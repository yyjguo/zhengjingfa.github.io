<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JavaScript简明教程（7） | Afanail</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="很高兴你能看到这里，希望对你学习JavaScript有帮助。这是最后一章节，主要讲有关JavaScript的设计模式。 函数属性缓存思路说明 01 函数是对象，因此可以在函数上面添加属性和方法 02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果 03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为">
<meta name="keywords" content="JavaScript,简明教程">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript简明教程（7）">
<meta property="og:url" content="http://www.afanail.com/2016/05/28/js-07/index.html">
<meta property="og:site_name" content="Afanail">
<meta property="og:description" content="很高兴你能看到这里，希望对你学习JavaScript有帮助。这是最后一章节，主要讲有关JavaScript的设计模式。 函数属性缓存思路说明 01 函数是对象，因此可以在函数上面添加属性和方法 02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果 03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为">
<meta property="og:updated_time" content="2017-07-22T03:52:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript简明教程（7）">
<meta name="twitter:description" content="很高兴你能看到这里，希望对你学习JavaScript有帮助。这是最后一章节，主要讲有关JavaScript的设计模式。 函数属性缓存思路说明 01 函数是对象，因此可以在函数上面添加属性和方法 02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果 03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为">
  
  
    <link rel="icon" href="/afanail.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.afanail.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/photos">相册</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Afanail</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-js-07" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JavaScript简明教程（7）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>很高兴你能看到这里，希望对你学习JavaScript有帮助。这是最后一章节，主要讲有关JavaScript的设计模式。</p>
<h1 id="函数属性缓存"><a href="#函数属性缓存" class="headerlink" title="函数属性缓存"></a>函数属性缓存</h1><p>思路说明</p>
<pre><code>01 函数是对象，因此可以在函数上面添加属性和方法
02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果
03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value）
04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。
</code></pre><a id="more"></a>
<p>代码示例(单个参数)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">param</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (func.cache[param] == <span class="literal">undefined</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">var</span> result = <span class="string">"字符串"</span>; <span class="comment">//初始化值</span></div><div class="line">        <span class="comment">//...对result做复杂的计算</span></div><div class="line">        func.cache[param] = result + param;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> func.cache[param];</div><div class="line">&#125;</div><div class="line">func.cache = &#123;&#125;;    <span class="comment">//空对象</span></div><div class="line"><span class="built_in">console</span>.log(func(<span class="string">"demo"</span>));  <span class="comment">//字符串demo</span></div><div class="line"><span class="built_in">console</span>.log(func(<span class="string">"test"</span>));  <span class="comment">//字符串test</span></div><div class="line"><span class="built_in">console</span>.log(func(<span class="string">"demo"</span>));  <span class="comment">//字符串demo 直接使用属性缓存中的数据,而不再进行复杂的计算(可以提升性能)</span></div></pre></td></tr></table></figure></p>
<p>代码示例（多个参数）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> key = <span class="built_in">JSON</span>.stringify(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</div><div class="line">    <span class="keyword">if</span> (func.cache[key] == <span class="literal">undefined</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">var</span> result = <span class="string">"字符串"</span>; <span class="comment">//初始化值</span></div><div class="line">        <span class="comment">//...对result做复杂的计算</span></div><div class="line">        func.cache[key] = result + key;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> func.cache[key];</div><div class="line">&#125;</div><div class="line">func.cache = &#123;&#125;;    <span class="comment">//空对象</span></div><div class="line">func(<span class="string">"123"</span>,<span class="string">"456"</span>);  <span class="comment">//</span></div><div class="line"><span class="comment">//说明:如果传入的参数数量超过1,则可以将传入的参数序列化为一个json字符串作为参数处理。</span></div></pre></td></tr></table></figure></p>
<p>代码说明：<br>slice:<code>返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素</code></p>
<h1 id="命名空间模式"><a href="#命名空间模式" class="headerlink" title="命名空间模式"></a>命名空间模式</h1><p>作用:<br>(1)有助于减少程序中所需要的全局变量的数量<br>(2)并且同时还有助于避免命名冲突或过长的名字前缀。<br> <strong>说明：JavaScript中并没有内置的命名空间</strong></p>
<h2 id="如何实现命名空间"><a href="#如何实现命名空间" class="headerlink" title="如何实现命名空间"></a>如何实现命名空间</h2><pre><code>可以为应用程序创建一个全局对象,然后将所有功能都添加到该全局对象中
从而在具有大量函数,对象和其他变量的情况下并不会污染全局范围。
</code></pre><p><strong>建议</strong></p>
<pre><code>全局命名空间的名称可以随便写,但建议使用项目的名称或者是APP的名称
按照习惯,通过程序员会约定以全部大写的方式来约定全局命名空间。
</code></pre><p><strong>命名空间模式的缺点</strong></p>
<pre><code>① 需要输入更多的字符,在每个变量和函数前面都需要附加上前缀,总体上增加了代码的体积。
② 仅有一个全局实例,意味着代码的任何部分都能够修改当前的实例。
③ 很长的前缀意味着需要花更长的时间来解析属性(变量|属性访问原则-就近原则)
</code></pre><p>代码示例（零散的代码）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line">    <span class="keyword">var</span> testDemo01 = <span class="string">"测试字符串01"</span>;</div><div class="line">    <span class="keyword">var</span> testDemo02 = <span class="string">"测试字符串02"</span>;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    obj.des = <span class="string">"描述信息"</span>;</div><div class="line">    obj.logDes = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(obj.des);</div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p>代码示例(命名空间模式)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个全局变量</span></div><div class="line">    <span class="keyword">var</span> MYAPP = &#123;&#125;;</div><div class="line">    <span class="comment">//02 处理构造函数</span></div><div class="line">    MYAPP.Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    MYAPP.Man = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    <span class="comment">//03 处理变量</span></div><div class="line">    MYAPP.array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line">    MYAPP.testDemo01 = <span class="string">"测试字符串01"</span>;</div><div class="line">    MYAPP.testDemo02 = <span class="string">"测试字符串02"</span>;</div><div class="line">    <span class="comment">//处理对象</span></div><div class="line">    MYAPP.obj = &#123;&#125;;</div><div class="line">    MYAPP.obj.des = <span class="string">"描述信息"</span>;</div><div class="line">    MYAPP.obj.logDes = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(obj.des);</div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<pre><code>01 在使用命名空间模式的时候,因为所有的变量和属性都添加到同一个全局对象下面,因此该全局对象下面可能有很多很多的属性。
02 而我们在添加属性的时候,很有可能该属性已经存在,这导致可能会覆盖掉之前的属性。
03 所以,在添加一个属性或者是创建一个命名空间之前,最好是先检查它是否已经存在。
04 但是如果每次添加属性都需要对属性进行检查则会产生代码冗余问题。
</code></pre><p>示例代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 不好的演示</span></div><div class="line"><span class="comment">//其他代码</span></div><div class="line"><span class="comment">//var MYAPP = &#123;&#125;;     //注意这是不安全的代码,因为有可能覆盖掉上下文中的代码</span></div><div class="line"><span class="comment">//02 在创建命名空间之前,先检查该命名空间是否存在</span></div><div class="line"><span class="comment">//    if (MYAPP == 'undefined')&#123;</span></div><div class="line"><span class="comment">//        var MYAPP = &#123;&#125;;</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line"><span class="comment">//03 更好的做法</span></div><div class="line"><span class="keyword">var</span> MYAPP = MYAPP || &#123;&#125;;        <span class="comment">//如果MYAPP为假,那么就返回&#123;&#125;并赋值给MYAPP</span></div><div class="line"><span class="comment">//04 添加属性时的检查问题</span></div><div class="line"><span class="comment">//假如现在需要添加一个name属性,那么在添加之前需要先检查该属性是否存在</span></div><div class="line"><span class="keyword">if</span> (MYAPP.name == <span class="string">'undefined'</span>)</div><div class="line">&#123;</div><div class="line">    MYAPP.name = <span class="string">"默认的名称"</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//假如要添加一个obJ属性</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> MYAPP.obj == <span class="string">'undefined'</span>)</div><div class="line">&#123;</div><div class="line">        MYAPP.obj = &#123;&#125;;</div><div class="line">&#125;</div><div class="line"><span class="comment">//假如要给MYAPP.obj添加属性,则</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> MYAPP.obj.des === <span class="string">"undefined"</span>)</div><div class="line">&#123;</div><div class="line">    MYAPP.obj.des = <span class="string">"对象的描述信息"</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(MYAPP.obj);</div></pre></td></tr></table></figure></p>
<p>代码说明：我们在添加属性或者是方法的时候,比较安全的做法是在添加之前先在当前环境中进行检查,以免覆盖但是我们的检查操作催生出了一个新的问题,就是重复代码过多,能否考虑把检查的过程抽取</p>
<p><strong>示例代码</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> MYAPP = MYAPP || &#123;&#125;;</div><div class="line">    MYAPP.namescape = <span class="function"><span class="keyword">function</span> (<span class="params">string</span>) </span>&#123;</div><div class="line">        <span class="comment">//split() 方法用于把一个字符串分割成字符串数组</span></div><div class="line">        <span class="keyword">var</span> parts = string.split(<span class="string">'.'</span>);</div><div class="line">        <span class="keyword">var</span> parent = MYAPP;</div><div class="line">        <span class="built_in">console</span>.log(parts);</div><div class="line">        <span class="comment">//先去掉最前面的冗余的全局变量</span></div><div class="line">        <span class="keyword">if</span>(parts[<span class="number">0</span>] == <span class="string">"MYAPP"</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//splice() 方法向/从数组中添加/删除项目,然后返回被删除的项目</span></div><div class="line">            <span class="comment">//parts.splice(0,1);</span></div><div class="line">            <span class="comment">//slice() 方法可从已有的数组中返回选定的元素</span></div><div class="line">            <span class="comment">//返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素</span></div><div class="line">            parts = parts.slice(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.log(parts,<span class="string">"处理之后的数组"</span>);</div><div class="line">        <span class="comment">//通过for循环来遍历结构</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; parts.length; i++) &#123;</div><div class="line">            <span class="comment">//检查属性,如果对应的属性不存在,那么就创建一个属性</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> parent[parts[i]] == <span class="string">'undefined'</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">//初始化为一个空的对象</span></div><div class="line">                parent[parts[i]] = &#123;&#125;;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//修正parent的值</span></div><div class="line">            parent = parent[parts[i]];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> parent;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//代码示例</span></div><div class="line">    <span class="keyword">var</span> testDemo01 = MYAPP.namescape(<span class="string">"MYAPP.test.testDemo01"</span>);</div><div class="line">    <span class="keyword">var</span> testDemo02 = MYAPP.namescape(<span class="string">"MYAPP.test.testDemo02"</span>);</div><div class="line">    <span class="built_in">console</span>.log(MYAPP);</div><div class="line">    <span class="comment">//忽略全面的前缀</span></div><div class="line">    MYAPP.namescape(<span class="string">"sadsa.sadjaldj.adada.test"</span>);</div><div class="line">    <span class="built_in">console</span>.log(MYAPP);</div><div class="line">    <span class="comment">//演示长命名空间的情况</span></div><div class="line">    MYAPP.namescape(<span class="string">"demo.testDemo.testDemos.ss.dd.qq.ddd.ffff.fff"</span>);</div><div class="line">    <span class="built_in">console</span>.log(MYAPP);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>补充说明<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">01</span> split() 方法用于把一个字符串分割成字符串数组</div><div class="line"><span class="number">02</span> splice() 方法向/从数组中添加/删除项目,然后返回被删除的项目</div><div class="line"><span class="number">03</span> slice() 方法可从已有的数组中返回选定的元素</div></pre></td></tr></table></figure></p>
<h1 id="设计模式简单说明"><a href="#设计模式简单说明" class="headerlink" title="设计模式简单说明"></a>设计模式简单说明</h1><pre><code>概念:设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案
    注意,设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案
起源:该属于源于建筑行业
历史:
    （1）由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学
    （2）四人帮著作《设计模式：可复用面向对象软件的基础》（Design Patterns - Elements of Reusable Object-Oriented Software）
    （3）Gang of Four:Erich Gamma + Richard Helm + Ralph Johnson +John Vlissides
优点:
    为了可重用代码、让代码更容易被他人理解、保证代码可靠性
</code></pre><h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><pre><code>创建型模式:工厂方法模式 + 抽象工厂模式 + 单例模式 + 建造者模式 + 原型模式
结构型模式:适配器模式 + 代理模式 + ...
行为型模式:观察者模式 + 命令模式 + ...
</code></pre><h2 id="单例模式的思想"><a href="#单例模式的思想" class="headerlink" title="单例模式的思想"></a>单例模式的思想</h2><pre><code>保证一个特定的类只有一个实例。
即当我们第二次创建新对象的时候,得到的应该是和第一次创建的对象一模一样的对象(同一个对象)
</code></pre><p><strong>其他语言中实现单例模式</strong></p>
<pre><code>在其它有Class的语言中,实现单例模式核心步骤是:
    01 在创建对象实例时候判断,该类的实例对象是否已经存在,如果已经存在,那么就直接返回
    02 如果不存在,那么就创建一个新的实例对象,并保存起来,下次创建实例对象的时候直接使用。
</code></pre><h2 id="JavaScript中的单例模式"><a href="#JavaScript中的单例模式" class="headerlink" title="JavaScript中的单例模式"></a>JavaScript中的单例模式</h2><pre><code>JavaScript是一门弱类型,动态,基于原型的语言,并没有类,只有对象。
在JavaScript中要实现单例模式有很多种方式。
最简单的方式:使用字面量的方式来创建对象,因为在JavaScript中对象之间永远不可能相等,除非他们是同一个对象。
</code></pre><p><strong>使用字面量方式创建的对象总是唯一的</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">script&gt;</div><div class="line">    <span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">"zhangsan"</span>&#125;;</div><div class="line">    <span class="keyword">var</span> obj2 = &#123;<span class="attr">name</span>:<span class="string">"zhangsan"</span>&#125;;</div><div class="line">    <span class="built_in">console</span>.log(obj1 == obj2);      <span class="comment">//false</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>使用new操作符创建对象实现单例</strong></p>
<pre><code>实现单例模式的几种途径
    ① 在代码中提供一个全局变量来存储创建出来的实例 缺点:该全局变量可能会被轻易的修改和覆盖
    ② 尝试在构造函数的静态成员中缓存实例属性。缺点:函数的静态属性在外部可以直接修改,容易导致实例对象的丢失。
    ③ 将实例对象包装在闭包中。优点是安全性较好,无法被轻易的修改,缺点是有额外闭包的开销。
</code></pre><p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">China</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">//创建对象</span></div><div class="line"><span class="keyword">var</span> china01 = <span class="keyword">new</span> China();</div><div class="line"><span class="keyword">var</span> china02 = <span class="keyword">new</span> China();</div><div class="line"><span class="comment">//思考:如果想要实现单例模式,那么最终的结果必要是china01 和china02是同一个对象,那么如何实现</span></div></pre></td></tr></table></figure></p>
<p><strong>实现方案(一)使用全局变量方式存储创建出来的实例对象</strong><br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个全局变量</span></div><div class="line">    <span class="keyword">var</span> instance;</div><div class="line">   <span class="comment">//02 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="literal">undefined</span>)</div><div class="line">        &#123;</div><div class="line">            instance = <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.name = <span class="string">"默认的名称"</span>;</div><div class="line">        <span class="keyword">this</span>.age = <span class="number">66</span>;</div><div class="line">        <span class="comment">//使用全局变量来接收内部创建出来的实例对象(this)</span></div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//03 使用构造函数创建对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p2);</div><div class="line">    <span class="built_in">console</span>.log(p1.name);</div><div class="line">    <span class="built_in">console</span>.log(p2.name);</div><div class="line">    p1.name = <span class="string">"修改之后的名称"</span>;</div><div class="line">    <span class="built_in">console</span>.log(p1.name);</div><div class="line">    <span class="built_in">console</span>.log(p2.name);</div><div class="line">    <span class="comment">//说明:在上面的方案中我们使用一个全局变量来接收实例对象的值,在构造函数内部也是通过判断这个全局变量来做一些其他的处理</span></div><div class="line">    instance = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> p3 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p3);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p><code>说明：</code>这种方法确实可以实现单例模式,但是并不安全,因为全局变量可能会被轻易的修改或者是覆盖,因此不推荐这种方式。</p>
<p><strong>实现方案(二)通过构造函数静态属性来缓存实例对象</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//02 在内部判断构造函数的静态属性中是否拥有实例对象</span></div><div class="line">        <span class="comment">//如果拥有实例对象,那么就直接返回,否则就设置实例对象,并赋值给构造函数的静态属性</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> Person.instance == <span class="string">"object"</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> Person.instance;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//设置实例对象的属性和方法</span></div><div class="line">        <span class="keyword">this</span>.name = <span class="string">"默认的名称"</span>;</div><div class="line">        <span class="keyword">this</span>.age = <span class="number">66</span>;</div><div class="line">        <span class="comment">//03 把内部创建的实例化对象赋值给构造函数的静态属性</span></div><div class="line">        Person.instance = <span class="keyword">this</span>;</div><div class="line">        <span class="comment">//显示返回</span></div><div class="line">        <span class="comment">//return Person.instance;</span></div><div class="line">        <span class="comment">//隐式返回</span></div><div class="line">        <span class="comment">//return this;</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//04 创建实例对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p2);</div><div class="line">    Person.instance = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> p3 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p3);      <span class="comment">//false</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><code>说明：</code>在构造函数外部可以直接访问其静态成员(属性和方法),可能会导致实例对象的丢失。</p>
<p><strong>实现方案(二)通过闭包-惰性函数定义来实现</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//02 在函数内部使用私有变量来缓存实例</span></div><div class="line">        <span class="keyword">var</span> instance = <span class="keyword">this</span>;</div><div class="line">        <span class="comment">//03 设置实例对象的属性和方法</span></div><div class="line">        <span class="keyword">this</span>.name = <span class="string">"默认的姓名"</span>;</div><div class="line">        <span class="keyword">this</span>.age = <span class="number">66</span>;</div><div class="line">        <span class="comment">//04 使用惰性函数定义来更新构造函数的实现</span></div><div class="line">        <span class="comment">//通过一个闭包来返回缓存的实例对象</span></div><div class="line">        Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> instance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//05 创建对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p2);</div><div class="line">    <span class="comment">//代码说明:第一次调用原始构造函数的时候,它会像往常一样返回this(指向内部新创建的实例对象)</span></div><div class="line">    <span class="comment">//再后面调用的时候,它会执行更新后的构造函数,在这个新的函数实现中,我们通过闭包来访问了私有变量,并简单的返回。</span></div><div class="line">    <span class="comment">//这个instance私有变量存储的是第一次调用构造函数时创建出来的实例对象</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>新的问题</strong><br>01 因为内部使用惰性函数定义(重写构造函数会导致之前添加在构造函数中的属性丢失),所以存在属性丢失问题<br>02 在上面的代码中,体现在于创建对象前后设置的构造函数的原型对象丢失问题</p>
<p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> instance = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">this</span>.name = <span class="string">"默认的姓名"</span>;</div><div class="line">        <span class="keyword">this</span>.age = <span class="number">66</span>;</div><div class="line">        Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> instance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//设置构造函数的原型对象</span></div><div class="line">    Person.prototype.des = <span class="string">"描述信息"</span>;</div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="comment">//在创建第一个对象之后,设置原型对象</span></div><div class="line">    Person.prototype.someThing = <span class="string">"something"</span>;</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p2);</div><div class="line">    <span class="built_in">console</span>.log(p1.des);        <span class="comment">//描述信息</span></div><div class="line">    <span class="built_in">console</span>.log(p2.des);        <span class="comment">//描述信息</span></div><div class="line">    <span class="built_in">console</span>.log(p1.someThing);  <span class="comment">//undefined</span></div><div class="line">    <span class="built_in">console</span>.log(p2.someThing);  <span class="comment">//undefined</span></div><div class="line">    <span class="comment">//打印对象的构造函数</span></div><div class="line">    <span class="built_in">console</span>.log(p1.constructor.name);       <span class="comment">//Person</span></div><div class="line">    <span class="built_in">console</span>.log(p2.constructor.name);       <span class="comment">//Person</span></div><div class="line">    <span class="comment">//判断对象的构造函数</span></div><div class="line">    <span class="built_in">console</span>.log(p1.constructor == Person);  <span class="comment">//false</span></div><div class="line">    <span class="built_in">console</span>.log(p1.constructor == p2.constructor,<span class="string">"构造函数是否一致"</span>);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p><strong>解决问题的核心过程</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">01</span> 提供一个构造函数</div><div class="line"><span class="number">02</span> 在构造函数内部提供一个私有变量instance</div><div class="line"><span class="number">03</span> 重写构造函数,返回私有变量instance</div><div class="line"><span class="number">04</span> 把原有的原型对象赋值给新Person构造函数的原型对象</div><div class="line"><span class="number">05</span> 调用<span class="keyword">new</span> 构造函数方法创建一个实例化对象赋值给instance</div><div class="line"><span class="number">06</span> 修正instance实例的构造器属性,指向新的构造函数(注意:虽</div><div class="line">然重写了构造函数,但是instance的构造函数仍然是以前的Person)</div><div class="line"><span class="number">07</span> 设置实例属性和方法</div><div class="line"><span class="number">08</span> 返回instance对象</div><div class="line">代码示例</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//01 提供一个私有变量</span></div><div class="line">        <span class="keyword">var</span> instance;</div><div class="line">        <span class="comment">//02 重写构造函数</span></div><div class="line">        Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(instance);</div><div class="line">            <span class="comment">//console.log(instance.constructor);</span></div><div class="line">            <span class="keyword">var</span> t = <span class="keyword">this</span>;</div><div class="line">            <span class="built_in">console</span>.log(t);</div><div class="line">            <span class="keyword">return</span> instance;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//03 保留原型属性</span></div><div class="line">        Person.prototype = <span class="keyword">this</span>.__proto__;    <span class="comment">//这是一个空的对象</span></div><div class="line">        Person.lal = <span class="string">"lala"</span>;</div><div class="line">        <span class="comment">//04 创建并使用私有变量来接收实例对象</span></div><div class="line">        instance = <span class="keyword">new</span> Person();</div><div class="line">        <span class="comment">//05 修正构造函数指针</span></div><div class="line">        instance.constructor = Person;</div><div class="line">        <span class="comment">//06 设置实例属性和方法</span></div><div class="line">        instance.name = <span class="string">"默认的名字"</span>;</div><div class="line">        instance.age = <span class="number">66</span>;</div><div class="line">        <span class="comment">//07 返回私有变量</span></div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">   Person.haha = <span class="string">"哈哈"</span>;</div><div class="line">    <span class="comment">//设置构造函数的原型对象</span></div><div class="line">    Person.prototype.des = <span class="string">"描述信息"</span>;</div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="comment">//在创建第一个对象之后,设置原型对象</span></div><div class="line">    Person.prototype.someThing = <span class="string">"something"</span>;</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p2);</div><div class="line">    <span class="built_in">console</span>.log(p1.des);        <span class="comment">//描述信息</span></div><div class="line">    <span class="built_in">console</span>.log(p2.des);        <span class="comment">//描述信息</span></div><div class="line">    <span class="built_in">console</span>.log(p1.someThing);  <span class="comment">//something</span></div><div class="line">    <span class="built_in">console</span>.log(p2.someThing);  <span class="comment">//something</span></div><div class="line">    <span class="comment">//打印构造器属性</span></div><div class="line">    <span class="built_in">console</span>.log(p1.constructor == Person,<span class="string">"验证构造器指向"</span>);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p><strong>全局变量方式实现单例-改进版</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> Person;</div><div class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//01 提供一个局部变量instance</span></div><div class="line">        <span class="keyword">var</span> instance;</div><div class="line">        Person = <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (instance)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">return</span> instance;</div><div class="line">            &#125;</div><div class="line">            instance = <span class="keyword">this</span>;</div><div class="line">            <span class="keyword">this</span>.name = <span class="string">"默认的名字"</span>;</div><div class="line">            <span class="keyword">this</span>.age = <span class="number">66</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;)();</div><div class="line">    <span class="comment">//创建对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p2);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>说明：<code>通过即时函数来限定作用域,外部无法修改内部instance的值(现在是一个局部变量)</code></p>
<h1 id="工厂模式简单说明"><a href="#工厂模式简单说明" class="headerlink" title="工厂模式简单说明"></a>工厂模式简单说明</h1><pre><code>工厂模式的目的是用于创建对象,通常在类或者是类的静态方法中实现。
</code></pre><p><strong>工厂模式的目标</strong></p>
<pre><code>01 用一套方法去创建相似的目标。
02 在编译时不知道具体类型的情况下,为用户提供创建对象的接口
</code></pre><p><strong>工厂模式实现过程</strong></p>
<pre><code>01 提供一个父构造函数
02 在父构造函数的原型上添加共享的方法
03 在父构造函数身上提供一个静态方法(静态工厂方法)
    001 先获取参数(产品类型)
    002 判断构造函数是否存在(容错性处理)
    003 设置原型链继承:设置子构造函数的原型对象为父构造函数的一个实例对象(目的是为了让子构造函数创建的对象拥有父构造函数上面实例属性和原型属性)
    004 使用子构造函数创建实例对象
    005 返回新创建的实例对象
04 定义特定的工厂客户(静态方法)
05 通过父构造函数的静态工厂方法来创建产品对象
</code></pre><p><strong>代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个父构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">PhoneMaker</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    <span class="comment">//02 在父构造函数的原型上添加共享的方法</span></div><div class="line">    PhoneMaker.prototype.callPhoneDes = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"手机的特点是:  "</span> + <span class="keyword">this</span>.des);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//03 在父构造函数身上提供一个静态方法(静态工厂方法)</span></div><div class="line">    PhoneMaker.factory = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">        <span class="comment">//001 先获取参数(产品类型)</span></div><div class="line">        <span class="keyword">var</span> typeStr = type;</div><div class="line">        <span class="comment">//002 判断构造函数是否存在(容错性处理)</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> PhoneMaker[typeStr] !== <span class="string">'function'</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="string">"Error 对应的构造函数不存在,不能生产该种类型的产品"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//003 设置原型链继承</span></div><div class="line">        PhoneMaker[typeStr].prototype = <span class="keyword">new</span> PhoneMaker();</div><div class="line">        <span class="comment">//004 使用子构造函数创建实例对象</span></div><div class="line">        <span class="keyword">var</span> newPhone = <span class="keyword">new</span>  PhoneMaker[typeStr]();</div><div class="line">        <span class="comment">//005 返回新创建的实例对象</span></div><div class="line">        <span class="keyword">return</span> newPhone;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//定义特定的工厂客户(静态方法)</span></div><div class="line">    PhoneMaker.iphone = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.des = <span class="string">"最安全稳定的系统"</span>;</div><div class="line">    &#125;</div><div class="line">    PhoneMaker.oppo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.des = <span class="string">"充当五分钟,通话两小时"</span>;</div><div class="line">    &#125;</div><div class="line">    PhoneMaker.vivo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.des = <span class="string">"vivo手机,你的音乐手机"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//通过父构造函数的静态工厂方法来创建产品对象</span></div><div class="line">    <span class="keyword">var</span> vivo = PhoneMaker.factory(<span class="string">'vivo'</span>);</div><div class="line">    <span class="keyword">var</span> iphone = PhoneMaker.factory(<span class="string">'iphone'</span>);</div><div class="line">    <span class="keyword">var</span> oppo = PhoneMaker.factory(<span class="string">'oppo'</span>);</div><div class="line">    vivo.callPhoneDes();</div><div class="line">    oppo.callPhoneDes();</div><div class="line">    iphone.callPhoneDes();</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p><strong>观察者模式</strong><br>观察者模式又名为发布-订阅者模式，它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。</p>
<p><strong>观察者模式的特点（优点）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">01 观察者模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案</div><div class="line">02 观察者模式可以取代对象之间硬性编码的通知机制，一个对象不再是显示的调用另外一个对象的接口，这种模式让两个对象松耦合的联系在一起，它们不需要清楚彼此的实现细节就能够相互通信。</div><div class="line">03 在这种设计模式中，不再是一个对象调用另外一个对象的方法，而是一个对象订阅另一个对象的特定活动并且在状态改变后获得通知</div></pre></td></tr></table></figure></p>
<p><strong>模型</strong><br>01 订阅者也称为<code>观察者</code><br>02 被观察的对象称为<code>发布者</code>或者是主题<br>03 当发生一个重要事件的时候，发布者将会通知所有订阅者并且经常以事件的形式来传递消息。<br>示例代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提取成公共的发行者对象</span></div><div class="line">    <span class="keyword">var</span> publisher = &#123;</div><div class="line">        <span class="attr">users</span>:&#123;</div><div class="line">            <span class="attr">default</span>:[]</div><div class="line">        &#125;,   <span class="comment">//所有的订阅者对象</span></div><div class="line">        addUser:<span class="function"><span class="keyword">function</span> (<span class="params">fn,type</span>) </span>&#123;</div><div class="line">            <span class="comment">//对订阅的类型进行判断</span></div><div class="line">            <span class="keyword">var</span> type = type || <span class="string">"default"</span>;</div><div class="line">            <span class="comment">//如果是新的订阅类型,那么我们需要做初始化的处理</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.users[type] == <span class="literal">undefined</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">this</span>.users[type] = [];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">this</span>.users[type].push(fn);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">removeUser</span>:<span class="function"><span class="keyword">function</span> (<span class="params">fn,type</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.tool(type,<span class="string">"removerUser"</span>,fn);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">publish</span>:<span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.tool(type,<span class="string">"publish"</span>);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">tool</span>:<span class="function"><span class="keyword">function</span> (<span class="params">type,funcType,fn</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> type = type || <span class="string">"default"</span>;</div><div class="line">            <span class="keyword">var</span> users = <span class="keyword">this</span>.users[type];</div><div class="line">            <span class="keyword">if</span> (users == <span class="literal">undefined</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"当前没有任何订阅者"</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; users.length; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (funcType == <span class="string">'publish'</span>)</div><div class="line">                &#123;</div><div class="line">                    users[i]()</div><div class="line">                &#125;<span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span> (users[i] == fn)</div><div class="line">                    &#123;</div><div class="line">                        users.splice(i, <span class="number">1</span>);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//02 提供一个工具函数,能够利用发行者对象的模板来快速创建新的发布者</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">makePaper</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> publisher) &#123;</div><div class="line">            <span class="keyword">if</span> (publisher.hasOwnProperty(i) &amp;&amp; <span class="keyword">typeof</span> publisher[i] == <span class="string">'function'</span>)</div><div class="line">            &#123;</div><div class="line">                o[i] = publisher[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        o.users = &#123;<span class="attr">default</span>:[]&#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//03 创建发布者</span></div><div class="line">    <span class="keyword">var</span> paper1 = &#123;</div><div class="line">        <span class="attr">day</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.publish();</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">month</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.publish(<span class="string">"month"</span>)</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">year</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.publish(<span class="string">"year"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//把某个对象编程一个发布者</span></div><div class="line">    makePaper(paper1);</div><div class="line">    <span class="comment">//04 创建订阅者(当发布者发布消息的时候,订阅者能够收到信息--自动调用订阅者的方法)</span></div><div class="line">    <span class="keyword">var</span> obj = &#123;</div><div class="line">        <span class="attr">lookDayNews</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"obj - 查看最新的日报信息"</span>);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">lookImageNews</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"obj - 查看图片信息"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//05 设置订阅</span></div><div class="line">    paper1.addUser(obj.lookDayNews);</div><div class="line">    paper1.addUser(obj.lookImageNews,<span class="string">'month'</span>);</div><div class="line">    paper1.day();</div><div class="line">    paper1.month();</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>

      
    </div>

  </div>
  
    
 <script src="/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2016/06/02/nav-Mac安装使用/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          nvm-Mac安装使用
        
      </div>
    </a>
  
  
    <a href="/2016/05/11/解决页面抖动/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">固定导航，不做抖man</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
           <div id="uyan_frame"></div>
    
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#函数属性缓存"><span class="toc-number">1.</span> <span class="toc-text">函数属性缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#命名空间模式"><span class="toc-number">2.</span> <span class="toc-text">命名空间模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如何实现命名空间"><span class="toc-number">2.1.</span> <span class="toc-text">如何实现命名空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#设计模式简单说明"><span class="toc-number">3.</span> <span class="toc-text">设计模式简单说明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#设计模式的分类"><span class="toc-number">3.1.</span> <span class="toc-text">设计模式的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单例模式的思想"><span class="toc-number">3.2.</span> <span class="toc-text">单例模式的思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript中的单例模式"><span class="toc-number">3.3.</span> <span class="toc-text">JavaScript中的单例模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#工厂模式简单说明"><span class="toc-number">4.</span> <span class="toc-text">工厂模式简单说明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#观察者模式"><span class="toc-number">5.</span> <span class="toc-text">观察者模式</span></a></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2016 - 2017 Afanail
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;zjfapk@163.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="undefined" class=" zoomIn">
        </a>
        <hgroup>
            <h1 class="header-author"><a href="/">Afanail</a></h1>
        </hgroup>

      

      


      

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                          
                            <li><a href="/">首页</a></li>
                          
                            <li><a href="/archives">归档</a></li>
                          
                            <li><a href="/photos">相册</a></li>
                          
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                          
                        </ul>
                    </nav>
                </section>

              

              

              
            </div>
        </div>
    </header>
</div>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      





 <script  type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2133352"></script>



<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>

<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>