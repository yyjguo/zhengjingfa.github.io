{"meta":{"title":"Afanail","subtitle":"Afanail,阿发奶酪","description":"前端,js,jquery,javascript,html5,开发者,程序猿","author":"Afanail","url":"http://www.1oveit.club"},"pages":[{"title":"啊喔~~~ 404鸡神奇显身","date":"2017-05-23T13:54:12.000Z","updated":"2017-05-23T13:54:12.000Z","comments":false,"path":"/404.html","permalink":"http://www.1oveit.club//404.html","excerpt":"","text":""},{"title":"","date":"2017-05-11T13:40:29.000Z","updated":"2017-05-11T13:40:29.000Z","comments":true,"path":"photos/ins.css","permalink":"http://www.1oveit.club/photos/ins.css","excerpt":"","text":"#post-instagram{ padding: 30px; } #post-instagram .article-entry{ padding-right: 0; } .instagram{ position: relative; min-height: 500px; } .instagram img { width: 100%; margin-top:0; } .instagram .year { font-size: 16px; } .instagram .open-ins{ padding: 10px 0; color: #cdcdcd; } .instagram .open-ins:hover{ color: #657b83; } .instagram .year{ display: inline; } .instagram .thumb { width: 25%; height: 0; padding-bottom: 25%; position: relative; display: inline-block; text-align: center; background: #ededed; outline: 1px solid #ddd; } .instagram .thumb a { position: relative; } .instagram .album h1 em{ font-style: normal; font-size: 14px; margin-left: 10px; } .instagram .album ul{ display: flex; flex-wrap: wrap; clear: both; width: 100%; text-align: left; } .instagram .album li{ list-style: none; display: inline-block; box-sizing: border-box; padding: 0 5px; margin-bottom: -10px; height: 0; width: 25%; position: relative; padding-bottom: 25%; } .instagram .album li:before{ display: none; } .instagram .album div.img-box{ position: absolute; width: 90%; height: 90%; -webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); -moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); } .instagram .album div.img-box img{ width: 100%; height: 100%; position: absolute; z-index: 2; } .instagram .album div.img-box .img-bg{ position: absolute; top: 0; left: 0; bottom: 0px; width: 100%; margin: -5px; padding: 5px; -webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -webkit-transition: all 0.15s ease-out 0.1s; -moz-transition: all 0.15s ease-out 0.1s; -o-transition: all 0.15s ease-out 0.1s; transition: all 0.15s ease-out 0.1s; opacity: 0.2; cursor: pointer; display: block; z-index: 3; } .instagram .album div.img-box .icon { font-size: 14px; position: absolute; left: 50%; top: 50%; margin-left: -7px; margin-top: -7px; color: #999; z-index: 1; } .instagram .album div.img-box .img-bg:hover{ opacity: 0; } .photos-btn-wrap { border-bottom: 1px solid #e5e5e5; margin-bottom: 20px; } .photos-btn { font-size: 16px; color: #333; margin-bottom: -4px; padding: 5px 8px 3px; } .photos-btn.active { color: #08c; border: 1px solid #e5e5e5; border-bottom: 5px solid #fff; } @media screen and (max-width:600px) { .instagram .thumb { width: 50%; padding-bottom: 50%; } .instagram .album li { width: 100%; position: relative; padding-bottom: 100%; text-align: center; } .instagram .album div.img-box{ margin: 0; width: 90%; height: 90%; } }"},{"title":"about me","date":"2017-05-11T09:21:56.000Z","updated":"2017-05-11T13:07:58.000Z","comments":true,"path":"about/index.html","permalink":"http://www.1oveit.club/about/index.html","excerpt":"","text":"Afanail:email:zjfapk@163.com专注于前端主球队：Manchester UnitedGolden State Warriors七月上我欲乘风破浪，踏遍黄沙海洋。与其误会一场，也要不负勇往。我愿你是个谎，从未出现南墙.我想你就站在，站在七月之上。"},{"title":"相册","slug":"photos","date":"2017-05-11T13:49:08.000Z","updated":"2017-05-11T13:49:08.000Z","comments":false,"path":"photos/index.html","permalink":"http://www.1oveit.club/photos/index.html","excerpt":"","text":"图片正在加载中… (function() { var loadScript = function(path) { var $script = document.createElement('script') document.getElementsByTagName('body')[0].appendChild($script) $script.setAttribute('src', path) } setTimeout(function() { loadScript('./ins.js') }, 0) })()"},{"title":"","date":"2017-05-12T01:42:59.000Z","updated":"2017-05-12T01:42:59.000Z","comments":true,"path":"photos/data.json","permalink":"http://www.1oveit.club/photos/data.json","excerpt":"","text":"{\"list\":[{\"date\":\"2016-08\",\"arr\":{\"year\":2016,\"month\":8,\"link\":[\"2016-08-07_求婚啦.jpg\"],\"text\":[\"求婚啦\"],\"type\":[\"image\"]}},{\"date\":\"2016-06\",\"arr\":{\"year\":2016,\"month\":6,\"link\":[\"2016-06-01_我们宿舍.JPG\",\"2016-06-01_我毕业啦啦.JPG\",\"2016-06-01_毕业那件小事.JPG\",\"2016-06-01_永远的12.JPG\",\"2016-06-01_班花来啦.JPG\",\"2016-06-01_老魏啊.JPG\"],\"text\":[\"我们宿舍\",\"我毕业啦啦\",\"毕业那件小事\",\"永远的12\",\"班花来啦\",\"老魏啊\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2016-05\",\"arr\":{\"year\":2016,\"month\":5,\"link\":[\"2016-05-29_我们这群人.JPG\",\"2016-05-29_抛帽子.JPG\"],\"text\":[\"我们这群人\",\"抛帽子\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2016-02\",\"arr\":{\"year\":2016,\"month\":2,\"link\":[\"2016-02-02_校记者团.jpg\",\"2016-02-02_班集体.jpg\",\"2016-02-06_心情低谷.jpg\"],\"text\":[\"校记者团\",\"班集体\",\"心情低谷\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2015-12\",\"arr\":{\"year\":2015,\"month\":12,\"link\":[\"2015-12-05_西安西安.jpg\"],\"text\":[\"西安西安\"],\"type\":[\"image\"]}},{\"date\":\"2015-05\",\"arr\":{\"year\":2015,\"month\":5,\"link\":[\"2015-05-01_充实的一天--七夕01.jpg\",\"2015-05-01_反正不是我贴的.jpg\",\"2015-05-01_抽奖中的——低调.jpg\"],\"text\":[\"充实的一天--七夕01\",\"反正不是我贴的\",\"抽奖中的——低调\"],\"type\":[\"image\",\"image\",\"image\"]}}]}"},{"title":"","date":"2017-05-05T12:07:38.000Z","updated":"2017-05-04T14:53:06.000Z","comments":true,"path":"photos/lazyload.min.js","permalink":"http://www.1oveit.club/photos/lazyload.min.js","excerpt":"","text":"/*! * An jQuery | zepto plugin for lazy loading images. * author -> jieyou * see https://github.com/jieyou/lazyload * use some tuupola's code https://github.com/tuupola/jquery_lazyload (BSD) * use component's throttle https://github.com/component/throttle (MIT) */ !function(a){\"function\"==typeof define&&define.amd?define([\"jquery\"],a):a(window.jQuery||window.Zepto)}(function(a){function g(){}function h(a,b){var e;return e=b._$container==d?(\"innerHeight\"in c?c.innerHeight:d.height())+d.scrollTop():b._$container.offset().top+b._$container.height(),e=a.offset().top+b.threshold+a.height()}function k(b,e){var f;return f=e._$container==d?a.fn.scrollLeft?d.scrollLeft():c.pageXOffset:e._$container.offset().left,f>=b.offset().left+e.threshold+b.width()}function l(a,b){var c=0;a.each(function(d){function g(){f.trigger(\"_lazyload_appear\"),c=0}var f=a.eq(d);if(!(f.width()b.failure_limit)return!1}else g()})}function m(a){return a.filter(function(b){return!a.eq(b)._lazyload_loadStarted})}function n(a,b){function h(){f=0,g=+new Date,e=a.apply(c,d),c=null,d=null}var c,d,e,f,g=0;return function(){c=this,d=arguments;var a=new Date-g;return f||(a>=b?h():f=setTimeout(h,b-a)),e}}var f,c=window,d=a(c),e={threshold:0,failure_limit:0,event:\"scroll\",effect:\"show\",effect_params:null,container:c,data_attribute:\"original\",data_srcset_attribute:\"original-srcset\",skip_invisible:!0,appear:g,load:g,vertical_only:!1,check_appear_throttle_time:300,url_rewriter_fn:g,no_fake_img_loader:!1,placeholder_data_img:\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\",placeholder_real_img:\"http://ditu.baidu.cn/yyfm/lazyload/0.0.1/img/placeholder.png\"};f=function(){var a=Object.prototype.toString;return function(b){return a.call(b).replace(\"[object \",\"\").replace(\"]\",\"\")}}(),a.fn.hasOwnProperty(\"lazyload\")||(a.fn.lazyload=function(b){var i,j,k,h=this;return a.isPlainObject(b)||(b={}),a.each(e,function(g,h){var i=f(b[g]);-1!=a.inArray(g,[\"threshold\",\"failure_limit\",\"check_appear_throttle_time\"])?\"String\"==i?b[g]=parseInt(b[g],10):\"Number\"!=i&&(b[g]=h):\"container\"==g?(b._$container=b.hasOwnProperty(g)?b[g]==c||b[g]==document?d:a(b[g]):d,delete b.container):!e.hasOwnProperty(g)||b.hasOwnProperty(g)&&i==f(e[g])||(b[g]=h)}),i=\"scroll\"==b.event,k=0==b.check_appear_throttle_time?l:n(l,b.check_appear_throttle_time),j=i||\"scrollstart\"==b.event||\"scrollstop\"==b.event,h.each(function(c){var e=this,f=h.eq(c),i=f.attr(\"src\"),k=f.attr(\"data-\"+b.data_attribute),l=b.url_rewriter_fn==g?k:b.url_rewriter_fn.call(e,f,k),n=f.attr(\"data-\"+b.data_srcset_attribute),o=f.is(\"img\");return 1==f._lazyload_loadStarted||i==l?(f._lazyload_loadStarted=!0,h=m(h),void 0):(f._lazyload_loadStarted=!1,o&&!i&&f.one(\"error\",function(){f.attr(\"src\",b.placeholder_real_img)}).attr(\"src\",b.placeholder_data_img),f.one(\"_lazyload_appear\",function(){function i(){d&&f.hide(),o?(n&&f.attr(\"srcset\",n),l&&f.attr(\"src\",l)):f.css(\"background-image\",'url(\"'+l+'\")'),d&&f[b.effect].apply(f,c?b.effect_params:[]),h=m(h)}var d,c=a.isArray(b.effect_params);f._lazyload_loadStarted||(d=\"show\"!=b.effect&&a.fn[b.effect]&&(!b.effect_params||c&&0==b.effect_params.length),b.appear!=g&&b.appear.call(e,f,h.length,b),f._lazyload_loadStarted=!0,b.no_fake_img_loader||n?(b.load!=g&&f.one(\"load\",function(){b.load.call(e,f,h.length,b)}),i()):a(\"\").one(\"load\",function(){i(),b.load!=g&&b.load.call(e,f,h.length,b)}).attr(\"src\",l))}),j||f.on(b.event,function(){f._lazyload_loadStarted||f.trigger(\"_lazyload_appear\")}),void 0)}),j&&b._$container.on(b.event,function(){k(h,b)}),d.on(\"resize load\",function(){k(h,b)}),a(function(){k(h,b)}),this})});"},{"title":"","date":"2017-05-11T13:47:15.000Z","updated":"2017-05-11T13:47:15.000Z","comments":true,"path":"photos/ins.js","permalink":"http://www.1oveit.club/photos/ins.js","excerpt":"","text":"/******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"/dist/\"; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(1); var _view = __webpack_require__(2); var _view2 = _interopRequireDefault(_view); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } /** * @name impush-client * @description 这个项目让我发家致富… * @date 2016-12-1 */ var _collection = []; var _count = 0; var searchData; function addMask(elem) { var rect = elem.getBoundingClientRect(); var style = getComputedStyle(elem, null); var mask = document.createElement('i'); mask.className = 'icon-film'; mask.style.color = '#fff'; mask.style.fontSize = '26px'; mask.style.position = 'absolute'; mask.style.right = '10px'; mask.style.bottom = '10px'; mask.style.zIndex = 1; elem.parentNode.appendChild(mask); } var createVideoIncon = function createVideoIncon() { var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]'); for (var i = 0, len = $videoImg.length; i < len; i++) { addMask($videoImg[i]); } }; var render = function render(res) { var ulTmpl = \"\"; for (var j = 0, len2 = res.list.length; j < len2; j++) { var data = res.list[j].arr; var liTmpl = \"\"; for (var i = 0, len = data.link.length; i < len; i++) { var minSrc = 'https://raw.githubusercontent.com/zhengjingfa/Blog-Back-Up/master/min_photos/' + data.link[i]; var src = 'https://raw.githubusercontent.com/zhengjingfa/Blog-Back-Up/master/photos/' + data.link[i]; var type = data.type[i]; var target = src + (type === 'video' ? '.mp4' : '.jpg'); src += ''; liTmpl += '\\ \\ \\ \\ ' + data.text[i] + '\\ '; } ulTmpl = ulTmpl + '' + data.year + '年' + data.month + '月\\ ' + liTmpl + '\\ '; } document.querySelector('.instagram').innerHTML = '' + ulTmpl + ''; createVideoIncon(); _view2.default.init(); }; var replacer = function replacer(str) { var arr = str.split(\"/\"); return \"/assets/ins/\" + arr[arr.length - 1]; }; var ctrler = function ctrler(data) { var imgObj = {}; for (var i = 0, len = data.length; i < len; i++) { var y = data[i].y; var m = data[i].m; var src = replacer(data[i].src); var text = data[i].text; var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m); if (imgObj[key]) { imgObj[key].srclist.push(src); imgObj[key].text.push(text); } else { imgObj[key] = { year: y, month: m, srclist: [src], text: [text] }; } } render(imgObj); }; function loadData(success) { if (!searchData) { var xhr = new XMLHttpRequest(); xhr.open('GET', './data.json?t=' + +new Date(), true); xhr.onload = function() { if (this.status >= 200 && this.status < 300) { var res = JSON.parse(this.response); searchData = res; success(searchData); } else { console.error(this.statusText); } }; xhr.onerror = function() { console.error(this.statusText); }; xhr.send(); } else { success(searchData); } } var Ins = { init: function init() { loadData(function(data) { render(data); }); } }; Ins.init(); // export default impush; /***/ }, /* 1 */ /***/ function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */ (function(global) { 'use strict'; var inViewport = __webpack_require__(3); var lazyAttrs = ['data-src']; global.lzld = lazyload(); // Provide libs using getAttribute early to get the good src // and not the fake data-src replaceGetAttribute('Image'); replaceGetAttribute('IFrame'); function registerLazyAttr(attr) { if (indexOf.call(lazyAttrs, attr) === -1) { lazyAttrs.push(attr); } } function lazyload(opts) { opts = merge({ 'offset': 333, 'src': 'data-src', 'container': false }, opts || {}); if (typeof opts.src === 'string') { registerLazyAttr(opts.src); } var elts = []; function show(elt) { var src = findRealSrc(elt); if (src) { elt.src = src; } elt.setAttribute('data-lzled', true); elts[indexOf.call(elts, elt)] = null; } function findRealSrc(elt) { if (typeof opts.src === 'function') { return opts.src(elt); } return elt.getAttribute(opts.src); } function register(elt) { elt.onload = null; elt.removeAttribute('onload'); elt.onerror = null; elt.removeAttribute('onerror'); if (indexOf.call(elts, elt) === -1) { inViewport(elt, opts, show); } } return register; } function replaceGetAttribute(elementName) { var fullname = 'HTML' + elementName + 'Element'; if (fullname in global === false) { return; } var original = global[fullname].prototype.getAttribute; global[fullname].prototype.getAttribute = function(name) { if (name === 'src') { var realSrc; for (var i = 0, max = lazyAttrs.length; i < max; i++) { realSrc = original.call(this, lazyAttrs[i]); if (realSrc) { break; } } return realSrc || original.call(this, name); } // our own lazyloader will go through theses lines // because we use getAttribute(opts.src) return original.call(this, name); }; } function merge(defaults, opts) { for (var name in defaults) { if (opts[name] === undefined) { opts[name] = defaults[name]; } } return opts; } // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html function indexOf(value) { for (var i = this.length; i-- && this[i] !== value;) {} return i; } module.exports = lazyload; // export default impush; /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ }, /* 2 */ /***/ function(module, exports) { 'use strict'; var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) { // parse slide data (url, title, size ...) from DOM elements // (children of gallerySelector) var parseThumbnailElements = function parseThumbnailElements(el) { el = el.parentNode.parentNode; var thumbElements = el.getElementsByClassName('thumb'), numNodes = thumbElements.length, items = [], figureEl, linkEl, size, type, // video or not target, item; for (var i = 0; i < numNodes; i++) { figureEl = thumbElements[i]; // // include only element nodes if (figureEl.nodeType !== 1) { continue; } linkEl = figureEl.children[0]; // size = linkEl.getAttribute('data-size').split('x'); type = linkEl.getAttribute('data-type'); target = linkEl.getAttribute('data-target'); // create slide object item = { src: linkEl.getAttribute('href'), w: parseInt(size[0], 10), h: parseInt(size[1], 10) }; if (figureEl.children.length > 1) { item.title = figureEl.children[1].innerHTML; } if (linkEl.children.length > 0) { item.msrc = linkEl.children[0].getAttribute('src'); item.type = type; item.target = target; item.html = ''; if (type === 'video') { //item.src = null; } } item.el = figureEl; // save link to element for getThumbBoundsFn items.push(item); } return items; }; // find nearest parent element var closest = function closest(el, fn) { return el && (fn(el) ? el : closest(el.parentNode, fn)); }; // triggers when user clicks on thumbnail var onThumbnailsClick = function onThumbnailsClick(e) { e = e || window.event; e.preventDefault ? e.preventDefault() : e.returnValue = false; var eTarget = e.target || e.srcElement; // find root element of slide var clickedListItem = closest(eTarget, function(el) { return el.tagName && el.tagName.toUpperCase() === 'FIGURE'; }); if (!clickedListItem) { return; } // find index of clicked item by looping through all child nodes // alternatively, you may define index via data- attribute var clickedGallery = clickedListItem.parentNode, // childNodes = clickedListItem.parentNode.childNodes, // numChildNodes = childNodes.length, childNodes = document.getElementsByClassName('thumb'), numChildNodes = childNodes.length, nodeIndex = 0, index; for (var i = 0; i < numChildNodes; i++) { if (childNodes[i].nodeType !== 1) { continue; } if (childNodes[i] === clickedListItem) { index = nodeIndex; break; } nodeIndex++; } if (index >= 0) { // open PhotoSwipe if valid index found openPhotoSwipe(index, clickedGallery); } return false; }; // parse picture index and gallery index from URL (#&pid=1&gid=2) var photoswipeParseHash = function photoswipeParseHash() { var hash = window.location.hash.substring(1), params = {}; if (hash.length < 5) { return params; } var vars = hash.split('&'); for (var i = 0; i < vars.length; i++) { if (!vars[i]) { continue; } var pair = vars[i].split('='); if (pair.length < 2) { continue; } params[pair[0]] = pair[1]; } if (params.gid) { params.gid = parseInt(params.gid, 10); } return params; }; var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) { var pswpElement = document.querySelectorAll('.pswp')[0], gallery, options, items; items = parseThumbnailElements(galleryElement); // define options (if needed) options = { // define gallery index (for URL) galleryUID: galleryElement.getAttribute('data-pswp-uid'), getThumbBoundsFn: function getThumbBoundsFn(index) { // See Options -> getThumbBoundsFn section of documentation for more info var thumbnail = items[index].el.getElementsByTagName('img')[0], // find thumbnail pageYScroll = window.pageYOffset || document.documentElement.scrollTop, rect = thumbnail.getBoundingClientRect(); return { x: rect.left, y: rect.top + pageYScroll, w: rect.width }; } }; // PhotoSwipe opened from URL if (fromURL) { if (options.galleryPIDs) { // parse real index when custom PIDs are used // http://photoswipe.com/documentation/faq.html#custom-pid-in-url for (var j = 0; j < items.length; j++) { if (items[j].pid == index) { options.index = j; break; } } } else { // in URL indexes start from 1 options.index = parseInt(index, 10) - 1; } } else { options.index = parseInt(index, 10); } // exit if index not found if (isNaN(options.index)) { return; } if (disableAnimation) { options.showAnimationDuration = 0; } // Pass data to PhotoSwipe and initialize it gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); var $tempVideo; var stopVideoHandle = function stopVideoHandle() { if ($tempVideo) { $tempVideo.remove(); $tempVideo = null; } }; var changeHandle = function changeHandle() { var item = gallery.currItem; stopVideoHandle(); if (item.type === 'video') { var $ctn = item.container; var style = $ctn.getElementsByClassName('pswp__img')[0].style; var $video = document.createElement('video'); $video.setAttribute('autoplay', 'autoplay'); $video.setAttribute('controls', 'controls'); $video.setAttribute('src', item.target); $video.style.width = style.width; $video.style.height = style.height; $video.style.position = 'absolute'; $video.style.zIndex = 2; $tempVideo = $video; $ctn.appendChild($video); } }; gallery.listen('initialZoomIn', changeHandle); gallery.listen('afterChange', changeHandle); gallery.listen('initialZoomOut', stopVideoHandle); }; // loop through all gallery elements and bind events var galleryElements = document.querySelectorAll(gallerySelector); for (var i = 0, l = galleryElements.length; i < l; i++) { galleryElements[i].setAttribute('data-pswp-uid', i + 1); galleryElements[i].onclick = onThumbnailsClick; } // Parse URL and open gallery if it contains #&pid=3&gid=1 var hashData = photoswipeParseHash(); if (hashData.pid && hashData.gid) { openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true); } }; var Viewer = function() { function init() { initPhotoSwipeFromDOM('.photos'); } return { init: init }; }(); module.exports = Viewer; /***/ }, /* 3 */ /***/ function(module, exports) { /* WEBPACK VAR INJECTION */ (function(global) { module.exports = inViewport; var instances = []; var supportsMutationObserver = typeof global.MutationObserver === 'function'; function inViewport(elt, params, cb) { var opts = { container: global.document.body, offset: 0 }; if (params === undefined || typeof params === 'function') { cb = params; params = {}; } var container = opts.container = params.container || opts.container; var offset = opts.offset = params.offset || opts.offset; for (var i = 0; i < instances.length; i++) { if (instances[i].container === container) { return instances[i].isInViewport(elt, offset, cb); } } return instances[ instances.push(createInViewport(container)) - 1 ].isInViewport(elt, offset, cb); } function addEvent(el, type, fn) { if (el.attachEvent) { el.attachEvent('on' + type, fn); } else { el.addEventListener(type, fn, false); } } function debounce(func, wait, immediate) { var timeout; return function() { var context = this, args = arguments; var callNow = immediate && !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); function later() { timeout = null; if (!immediate) func.apply(context, args); } }; } // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708 var contains = function() { if (!global.document) { return true; } return global.document.documentElement.compareDocumentPosition ? function(a, b) { return !!(a.compareDocumentPosition(b) & 16); } : global.document.documentElement.contains ? function(a, b) { return a !== b && (a.contains ? a.contains(b) : false); } : function(a, b) { while (b = b.parentNode) { if (b === a) { return true; } } return false; }; } function createInViewport(container) { var watches = createWatches(); var scrollContainer = container === global.document.body ? global : container; var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15); addEvent(scrollContainer, 'scroll', debouncedCheck); if (scrollContainer === global) { addEvent(global, 'resize', debouncedCheck); } if (supportsMutationObserver) { observeDOM(watches, container, debouncedCheck); } // failsafe check, every 200ms we check for visible images // usecase: a hidden parent containing eleements // when the parent becomes visible, we have no event that the children // became visible setInterval(debouncedCheck, 150); function isInViewport(elt, offset, cb) { if (!cb) { return isVisible(elt, offset); } var remote = createRemote(elt, offset, cb); remote.watch(); return remote; } function createRemote(elt, offset, cb) { function watch() { watches.add(elt, offset, cb); } function dispose() { watches.remove(elt); } return { watch: watch, dispose: dispose }; } function watchInViewport(elt, offset, cb) { if (isVisible(elt, offset)) { watches.remove(elt); cb(elt); } } function isVisible(elt, offset) { if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) { return false; } // Check if the element is visible // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js if (!elt.offsetWidth || !elt.offsetHeight) { return false; } var eltRect = elt.getBoundingClientRect(); var viewport = {}; if (container === global.document.body) { viewport = { top: -offset, left: -offset, right: global.document.documentElement.clientWidth + offset, bottom: global.document.documentElement.clientHeight + offset }; } else { var containerRect = container.getBoundingClientRect(); viewport = { top: containerRect.top - offset, left: containerRect.left - offset, right: containerRect.right + offset, bottom: containerRect.bottom + offset }; } // The element must overlap with the visible part of the viewport var visible = ( (eltRect.right > viewport.left) && (eltRect.left < viewport.right) && (eltRect.bottom > viewport.top) && (eltRect.top < viewport.bottom) ); return visible; } return { container: container, isInViewport: isInViewport }; } function createWatches() { var watches = []; function add(elt, offset, cb) { if (!isWatched(elt)) { watches.push([elt, offset, cb]); } } function remove(elt) { var pos = indexOf(elt); if (pos !== -1) { watches.splice(pos, 1); } } function indexOf(elt) { for (var i = watches.length - 1; i >= 0; i--) { if (watches[i][0] === elt) { return i; } } return -1; } function isWatched(elt) { return indexOf(elt) !== -1; } function checkAll(cb) { return function() { for (var i = watches.length - 1; i >= 0; i--) { cb.apply(this, watches[i]); } }; } return { add: add, remove: remove, isWatched: isWatched, checkAll: checkAll }; } function observeDOM(watches, container, cb) { var observer = new MutationObserver(watch); var filter = Array.prototype.filter; var concat = Array.prototype.concat; observer.observe(container, { childList: true, subtree: true, // changes like style/width/height/display will be catched attributes: true }); function watch(mutations) { // some new DOM nodes where previously watched // we should check their positions if (mutations.some(knownNodes) === true) { setTimeout(cb, 0); } } function knownNodes(mutation) { var nodes = concat.call([], Array.prototype.slice.call(mutation.addedNodes), mutation.target ); return filter.call(nodes, watches.isWatched).length > 0; } } /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ } /******/ ]);"},{"title":"tags","date":"2017-05-11T09:21:38.000Z","updated":"2017-05-11T09:21:38.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.1oveit.club/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"perl-learning","slug":"perl-learning","date":"2017-07-15T03:25:22.000Z","updated":"2017-07-15T03:59:38.000Z","comments":true,"path":"2017/07/15/perl-learning/","link":"","permalink":"http://www.1oveit.club/2017/07/15/perl-learning/","excerpt":"什么是perl？ perl 是一门编程语言。因为工作上的原因需要用到perl，这才对perl有了了解。相对JS而言，perl貌似更简单易用。同为脚本语言，perl风靡一时，当下肯定没有JS热门。perl更多的是用在生信等领域，而JS是随着web2.0的兴起而逐渐壮大，你看ES7都快出来了。先来看一下perl的最基本入门程序。","text":"什么是perl？ perl 是一门编程语言。因为工作上的原因需要用到perl，这才对perl有了了解。相对JS而言，perl貌似更简单易用。同为脚本语言，perl风靡一时，当下肯定没有JS热门。perl更多的是用在生信等领域，而JS是随着web2.0的兴起而逐渐壮大，你看ES7都快出来了。先来看一下perl的最基本入门程序。123456789#!/usr/bin/perlprint \"Hello,world!\\n\"=podlarry 推出了Perl 1 Itermediate Perl 2 Mastering Perl 3 Programming perl 额外练习 《Learning Perl Student Workbook》=cut 其中 #!/usr/bin/perl，意思为perl脚本的默认存放位置是“/usr/bin/perl”；比较新奇的是perl的多行注释： =pod、=cut只能在行首 以=开头，以cut结尾 =后面要紧接一个字符，=cut后面可以不用 关于perl的更多知识，入门推荐 Learning Perl,之后按书籍顺序： 1 Itermediate Perl 2 Mastering Perl 3 Programming perl 让我们再来看一个perl文件，一种叫做 `Here123456789101112131415161718192021222324252627282930313233#!/usr/bin/perl=pod Heredoc一种在命令行和程序语言里定义一个字串的方法。注意点： 1.必须后接分号；2.END可以用任何语言代替，必须保证开始结束标识一致；3.开始标识不带引号与带引号的作用一样，会解析转义；4.结束标识必须占一行。必须行首开始。5.当内容需要内嵌引号的时候，不需要加转义字符，本身对单双引号转义；=cut$a = 10;$var = &lt;&lt; \"eof\";这是一个Here文档实例，使用双引号。“可以输入双引号”，‘可以输入单引号’；可以在这里输入字符串和变量；例如： a = $a;eofprint \"$var\\n\";$var = &lt;&lt; 'dfc';这是一个单引号的例子；a = $a;dfcprint \"$var\\n\";# perl Heredoc变量可以重复,例如上面的$var;# perl 用反斜线来转义$res = \"zjf\";print \"$res\\n\";print '$res\\n';# perl标识符与其他编程语言一样； 这也是比较新奇的技巧。在我学习perl的过程，我会把学习代码放到仓库https://github.com/zhengjingfa/perl-learning，欢迎莅临指导。","categories":[],"tags":[{"name":"perl","slug":"perl","permalink":"http://www.1oveit.club/tags/perl/"}]},{"title":"教你如何巧妙解决网页乱码","slug":"教你如何巧妙解决网页乱码","date":"2017-06-28T11:34:04.000Z","updated":"2017-06-28T12:18:48.000Z","comments":true,"path":"2017/06/28/教你如何巧妙解决网页乱码/","link":"","permalink":"http://www.1oveit.club/2017/06/28/教你如何巧妙解决网页乱码/","excerpt":"约定俗成不是好的标准，却是近似好的标准。 我们编写好的html文件，在浏览器显示往往会乱码，这就是编码格式的问题。在约定情况下，通常默认utf-8编码格式。但是，有一些有一定历史的公司，比如网易，我们可以看到它的编码格式是简体中文，也就是国标编码2312,简称gb2312。","text":"约定俗成不是好的标准，却是近似好的标准。 我们编写好的html文件，在浏览器显示往往会乱码，这就是编码格式的问题。在约定情况下，通常默认utf-8编码格式。但是，有一些有一定历史的公司，比如网易，我们可以看到它的编码格式是简体中文，也就是国标编码2312,简称gb2312。 如果你这个时候把编码格式设置为其它的呢？相信你会看到一些似懂非懂的文字。我就比较好奇试了一下。 结果不出意料，果然乱码了。从这个小细节，我们引出了一个问题。当前后台没有约定编码格式（可能是新来的傻傻的认为编码格式都是utf-8），这时候编码格式就不一样了。就像上面出现的情况一样。可能你会像我一样去修改html文件的meta标签，设置chartset与后台一样的编码格式，然后再返回给后台，但是你会发现居然没有什么毛线效果，该乱码还是乱码。然后我们百度、谷歌的方法也不一定有用，这个时候你会怀疑是不是遇到了什么天大的难题了。 其实解决的方法很简单，简单到我们都没有想到。在webstrom下，右下角有个很明显的 utf-8 可选项，点击它，如下图所示。选择你们约定好的编码格式，这个问题也就到此为止了。 其实这只是一个很小的细节，但是引发出来的问题还是不少的，比如网页上的某个标签的编码格式与整体的页面不一致该如何设置，在IE6浏览器的环境下又该如何设置，这些可能都是我们会遇到的问题。你都知道怎么解决吗？ 诚然，好的规范需要共同约定，需要共同遵守！","categories":[],"tags":[{"name":"编码格式","slug":"编码格式","permalink":"http://www.1oveit.club/tags/编码格式/"}]},{"title":"抓住17年的尾巴","slug":"抓住17年的尾巴","date":"2017-06-17T15:44:23.000Z","updated":"2017-06-17T16:54:11.000Z","comments":true,"path":"2017/06/17/抓住17年的尾巴/","link":"","permalink":"http://www.1oveit.club/2017/06/17/抓住17年的尾巴/","excerpt":"17年也要结束了，一切来的那么快。年前的计划是否实现了,这显然没有那么重要了。还有半年的时间，切忌不要等到赶着时间去抓17年的尾巴。","text":"17年也要结束了，一切来的那么快。年前的计划是否实现了,这显然没有那么重要了。还有半年的时间，切忌不要等到赶着时间去抓17年的尾巴。 new Date 关于工作，就像标题一样，一切都是新的时间对象。跳槽来到了一家只有我一个前端的公司，所以一切几乎等同于从零开始。对一个东西有很深感情，很多不是因为一见钟情，很多不是因为互相喜欢，而是从一开始到结束，从浅到深，慢慢培养的感情。而我们似乎都急于求成，感情上如此，生活亦是。 once super 一个人的团队可以干些什么？这似乎是一道双向的数据绑定题。首先，赋予我们极大的自由，可以运用自己热衷并且擅长的技术，可以调动自己的创造性，极大可能的挖掘自己的潜能。从前端代码规范，前端工程自动化，前端技术选型，似乎可以任君胡作非为一番了。前人栽树，后人乘凉。还是要妥当才好。团队不可能永远一个人，你不是一个人在战斗。你只是暂时一个人代表一个团队在战斗。你会慢慢喜欢上你从无到有的团队的，请坚信这一点。单枪匹马与千军万马孰优孰劣一目了然。 make kludeg 然而，一切有想象中的那么自由吗？往往限制自己的就是我们自己。你似乎已经忘记团队的存在了，这才是多么可怕的事情。所以事情没有想的那么容易。但是也没有想象中的那么困难。这个流动性大的环境下，时刻做好准备才是硬道理。你看前端框架更新多快，就知道流动性有多大了。所以真的有必要去重构之前的一些代码吗？还是标注kludeg让接下来的开发者谨慎注意某些复杂的代码片段。有一些10几年的老项目，存在是有它的道理的。新的东西不一定好，旧的东西不一定会被淘汰。往往要看当权者如何折中了。不要为了前端而前端，好像就是这个理。 web browser 我曾经是一度的希望，会不会有个大神上的大神，出来一统前端，破解今日百家争艳的局面。更希望哪个web browser能够并购所有browser，IE也行，Chrome也罢。这样就不会有兼容性，就不会有纷呈复杂的前端技术了。现在想想，才知道自己那时候是多么幼稚。也正是因为如此，前端才变得更具挑战性，未来才更加不确定性，更加富有往各种方向发展的可能性。想想垄断，是多么可怕的词。如今的局面，可能都是最好的安排。 catch 17end 不管什么局面，都是时间的积累造就的，没有人能够一蹴而就。生活如此，感情亦是。太快了，反而更需要花时间沉淀。Because，one day, when you review your code and project, you would doubt that how stupid to gulp this. 本来今天想早点睡觉的，没想到又快到凌晨1点多了，黑眼圈也是需要时间积累的，大概我的黑眼圈就是这样来的吧。刚好今天是父亲节，好久没有给父亲打电话了。想一想，应该是从来没有给父亲打过真正意义上的电话。父亲实在太辛苦了，一个人要赚钱养8口人的大家庭。我们兄弟姐妹从来与父亲不来电，不谈心事，不谈生活，不谈其它，因为是母亲承担了这些孩子成长上琐碎的事情。我们心里都明白，父亲是知道孩子成长道路上琐碎的事情的，甚至比母亲还上心。可是生活造就了一切，有的人就是默默无闻的付出，得到的也不是掷地有声的回报。但是，这默默无闻付出的背后，你可曾知道这也是无时无刻幸福与满足交织涌向心头，胜过千倍万倍娇弱做作的我爱你！","categories":[],"tags":[{"name":"工作计划","slug":"工作计划","permalink":"http://www.1oveit.club/tags/工作计划/"}]},{"title":"less小技巧","slug":"less小技巧","date":"2017-06-16T14:23:03.000Z","updated":"2017-06-16T15:04:41.000Z","comments":true,"path":"2017/06/16/less小技巧/","link":"","permalink":"http://www.1oveit.club/2017/06/16/less小技巧/","excerpt":"后端转前端，或者UI转前端，往往会写不好css，有没有一种可以像写函数式编程那样对方法来编写css，答案是有的，比如less、sass、stylus等。 什么是less？ 这里不多说，请看中文网介绍less中文网。","text":"后端转前端，或者UI转前端，往往会写不好css，有没有一种可以像写函数式编程那样对方法来编写css，答案是有的，比如less、sass、stylus等。 什么是less？ 这里不多说，请看中文网介绍less中文网。 我个人对less、sass、stylus对理解，简单对概括为：让css更接近编程语言。 less是最容易上手对，如果你使用less一段时间，发现会爱不释手。因为它更接近编程思维，优点多多。 less技巧 就拿移动端来举例子，我们常用像素单位rem,可以很好的适配各种机型的屏幕。首先通过设置js让html元素的字体大小随着屏幕大小的改变而改变。 123var font = window.screen.width / 10 + 'px'; console.log(font); document.getElementsByTagName('html')[0].style.fontSize = font; 通过less的unit函数转化属性值的单位，定义函数.fs、.w… @px是一个变量也是一个参数,我们可以在调用它的时候给它传递实际参数。下面是移动开发时候经常使用的函数，仅供参考。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/*把像素转成rem 375/10 = 37.5 375 它是ipone6的屏幕宽度*///默认是20px.fs(@px:20px)&#123; font-size: unit(@px/37.5,rem);&#125;.w(@px)&#123; width: unit(@px/37.5,rem);&#125;.h(@px)&#123; height: unit(@px/37.5,rem);&#125;.lh(@px)&#123; line-height: unit(@px/37.5,rem);&#125;.pl(@px)&#123; padding-left: unit(@px/37.5,rem);&#125;.pr(@px)&#123; padding-right: unit(@px/37.5,rem);&#125;.pt(@px)&#123; padding-top: unit(@px/37.5,rem);&#125;.pb(@px)&#123; padding-bottom: unit(@px/37.5,rem);&#125;.mt(@px)&#123; margin-top:unit(@px/37.5,rem);;&#125;.mb(@px)&#123; margin-bottom:unit(@px/37.5,rem);&#125;.ml(@px)&#123; margin-left:unit(@px/37.5,rem);&#125;.mr(@px)&#123; margin-right:unit(@px/37.5,rem);&#125;.top(@px)&#123; top:unit(@px/37.5,rem);&#125;.bottom(@px)&#123; bottom:unit(@px/37.5,rem);&#125;.left(@px)&#123; left:unit(@px/37.5,rem);&#125;.right(@px)&#123; right:unit(@px/37.5,rem);&#125;.padding(@tb,@lr)&#123; padding: unit(@tb/37.5,rem) unit(@lr/37.5,rem);;&#125;.fl&#123; float: left;&#125;.fr&#123; float: right;&#125;.clearfix&#123; clear: both;&#125; 可复用属性提取重复属性，定义一个函数。可在内部和外部调用。1234567891011121314151617div&#123;//不会被编译btn () &#123;background: #000;color: #888;&#125;header &#123;//内部调用 btn; ...&#125;&#125;footer&#123;// 外部调用 div &gt; btn;&#125; 关于less的技巧还有很多很多，这里只是简单提了一下。孰能生巧，多用就会了。sass、stylus其实跟less都一样，语法也很相似。当你学会less，你就基本掌握了sass、stylus，何乐而不为呢？","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://www.1oveit.club/tags/css/"},{"name":"less","slug":"less","permalink":"http://www.1oveit.club/tags/less/"}]},{"title":"NBA总决赛G3","slug":"NBA总决赛G3","date":"2017-06-08T04:04:05.000Z","updated":"2017-06-08T04:48:55.000Z","comments":true,"path":"2017/06/08/NBA总决赛G3/","link":"","permalink":"http://www.1oveit.club/2017/06/08/NBA总决赛G3/","excerpt":"勇士（3） vs 骑士（0），这会是你想到的结果吗？ 今天的比赛可能是整个系列赛最精彩的一场了。双方教练斗智斗勇，场上球员各显神通。最终勇士队以118-113击败骑士队涉险过关。","text":"勇士（3） vs 骑士（0），这会是你想到的结果吗？ 今天的比赛可能是整个系列赛最精彩的一场了。双方教练斗智斗勇，场上球员各显神通。最终勇士队以118-113击败骑士队涉险过关。回到主场，这是骑士必须拿下的比赛，而勇士也是有备而来，双方球员必须使出浑身解数，争取拿下比赛。前俩场，库里和杜兰特发挥特别出色。克莱汤普森由于身担防守欧文的重责，进攻端发挥有所失常。依靠勇士强大的整体，勇士前俩场刀不血刃的拿下了比赛。 第三场比赛，骑士明显有了针对性的调整，从场上球员的站队以及跑位，可以看到库里明显被夹击了。骑士队的战术执行的很坚决，一方面三分线外夹击库里，一方面协防杜兰特，限制勇士俩大进攻点的发挥。克莱汤普森受益于骑士队的战术，当库里和杜兰特被对方狠狠的盯死的时候，汤普森多出了很多的空位，所以汤普森今天的爆发是意料之中的。 再说说今天骑士队的詹姆斯，上半场火力全开，得了27分，14投11中，4篮板3助攻。特别是第一节的詹姆斯，10投9中。几乎一个人对抗整支勇士队。真所谓吕布战群英，精彩绝伦。下半场勇士队立马就走出了调整，多次让杜兰特去防守詹姆斯，可是没想到，欧文这时候站了出来，各种不可思议的突破，各种鬼魅的神仙球。借助欧文神奇的发挥，第三节骑士队终于实现了比分的反超。 进入比赛关键的第四节，勇士队先排上替补阵容，保证主力队员的休息时间。这是骑士队必须拿下的比赛，主力球员是要战斗到最后时刻了。比分一直是骑士领先，勇士队替补阵容很好的完成的战术作用。比赛还剩下最后的6分钟左右的时间时候，科尔令旗一挥，勇士队熟悉的死亡五小上阵。最厉害的总是最后出场的，果不其然，勇士队慢慢的缩小了比分。 直到比赛还剩下48秒左右，勇士队111：113落后骑士队俩分，杜兰特控球从后场到前场，当所有人都以为勇士队会叫暂停布置一次成功的战术都时候。杜兰特做出了一个令人想不到的选择，顶着詹姆斯的防守，双眼紧紧盯着篮筐，无视詹姆斯，仿佛全世界只有篮球、篮筐，还有那投出篮球一刻在空中划过的闪耀全世界的弧线，当球坠入篮筐那一刻，杀神降临，杜兰特归位。在这历史的一刻，杜兰特用行动证明了他的价值，证明了他可能才是这个星球上打篮球最好的人。 最终比赛的数据：腾讯NBA数据库","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.1oveit.club/tags/随笔/"}]},{"title":"愿世间没有。。。","slug":"愿世间没有...","date":"2017-05-28T16:00:00.000Z","updated":"2017-05-30T00:18:44.000Z","comments":true,"path":"2017/05/29/愿世间没有.../","link":"","permalink":"http://www.1oveit.club/2017/05/29/愿世间没有.../","excerpt":"如果可以，你也可以！！！ 活了大概五分之一的人生以上，从来没有一天像今天这样的心情。如果可以，愿世间没有。。。","text":"如果可以，你也可以！！！ 活了大概五分之一的人生以上，从来没有一天像今天这样的心情。如果可以，愿世间没有。。。 我爷爷属牛。原谅我不知道今年多少岁，只是最接近百岁的那一只牛。很多人不理解为什么人会老，为什么人会死。就像人一样，为什么会是人。可能这就是一直以来的不可违背的伦理。这个世界千千万万人，如果有那么一个俩个人，不为人知的一直活在我们不知道的空间里。监视着我们，直到我们快老去，我们快不为人知。那个一直不为人知的一俩个人，会不会出来跟你说：“嘿！欢迎来到不为人知的世界！这个世界无比真挚的欢迎来自人间的你！“。如果存在这样的事情，那么不为人知就显得有一些廉价了。我们都相信这个世界的确有这么一俩个人，谁敢说不是呢？如果可以，愿世间没有这样不为人知的一俩个人！ 记得我在很小的时候，我是什么都不懂。每天跟着爷爷，有糖吃，特别喜欢粘着爷爷。农村的街道很宽很干净很少人，爷爷的自行车很高很稳很响亮。”玲玲玲“，那时候的车玲显得格外悦耳，格外动听。我就坐在车头，是那个白白胖胖的无所畏惧的无敌小小子。那时候的天空很蓝，白云很白，清风很轻，人也格外舒坦。爷爷骑着车，在乡间田园的路上，有小草野花，有流水小船，有深处人家。哼着歌，响着铃铛，喀拉拉，无比轻盈的轮滑，留下一道道岁月的痕迹，让我去追寻，去回忆。如果可以，愿世间没有追寻，没有回忆。 不知道我是从什么时候开始懂事，可能是体毛初长的时候，也可能是情窦初开的时候。一瞬间，也可能是所有瞬间堆积成的一瞬间，反正在不知不觉的某一刻，我们就开始懂事了。明白了爸妈为什么早出晚回，明白了爷爷奶奶为什么还下地干活。农村的五伏天，天天热辣，天天背朝黄天。没有空调，没有风扇，只有夏天的树，芭蕉做的扇。我喜欢芭蕉扇，喜欢夏天的树，一直一直。爷爷说，夏天是收割的季节，天气要热些好，稻谷才好晒些，最怕这个季节的风台了。咱们农民是靠天靠地吃饭，要感谢有现在的天和地。我有些懂事了，认为爷爷说的对。如果可以，愿世间没有天地，我们可以靠自己。 后来，我长大了。我也不知道什么时候长大的，可能是第一次失恋，可能是第一次初恋。无所谓了，反正你的年龄决定你长大了。我离开了家，上了高中，集体宿舍。都是农村的娃娃，显得特别好相处。这是我们镇最好的高中，也是我们镇最坏的高中，也是我们镇唯一的高中。我在这里度过了三年，改变了我许多。人都是慢慢变化的，我也是。在这里，有很多学生，我只认识我宿舍的，我班级的，还有一俩个我心底里默默喜欢的女生。我们读书不老好，打篮球却是十分热爱，逃课打篮球是经常的事情。更有甚者，有年级默认的联盟，有球队。这太影响我了，我默默长大了。高考了，为了高考而高考了。老师都说一本是好的，二本也是好的。但是专业呢？没有人敢和你说读那个专业是好的，敷衍一句兴趣吧。导致很多人读了十几年书，专业是最后一刻才确定的，也有乱写的，比如我。那么问题来了，这样往往会出事的，事实却是如此。我很茫。爷爷说，娃娃，没事的，抗日我也抗过了，去吧，河南并不老远！好好读就是了！如果可以，愿世间没有距离，没有远离。 再后来，我上了大学。但是我却没有好好读。或者说，好好读不如读好好。浪费了大把青春时光。想追回，不知谈何说起。我爱我的大学，虽然自知无力去爱。总会有人说重来一次怎样怎样，还是这样。你不是不相信科学，而是有一种力量叫做冥冥之中的注定。失去的就是失去的，也许会回来，也许回不来，而我们还执拗个啥，执拗个啥。放不下的，却是最远久的过。过去的，却是最降近的未来。最悲哀的是，在这最将近的未来，你不知道执拗个啥，执拗个啥！如果可以，愿世间没有失去，唯有珍惜！ 端午节，爷爷身体不好，百岁将近。人是不都有这么一刻，年轻的时候不知道为什么，年老的时候也不知道为什么，人就是会这样子！？我们拼搏，我们奋斗，我们努力，我们终究只是时间的产物，一刻一秒，若有若无，化作灰烬。如果可以，愿世间没有时间，只有永恒！ 我还是那个我，你也是。只不过我们多了一个理由，去拥有更美好的世界！那就是，如果可以，你也可以！！！","categories":[],"tags":[{"name":"-随笔","slug":"随笔","permalink":"http://www.1oveit.club/tags/随笔/"}]},{"title":"ES7--大势所趋","slug":"ES7-大势所趋","date":"2017-05-25T16:20:21.000Z","updated":"2017-05-25T17:04:43.000Z","comments":true,"path":"2017/05/26/ES7-大势所趋/","link":"","permalink":"http://www.1oveit.club/2017/05/26/ES7-大势所趋/","excerpt":"最快的是，技术的更新；最慢的是，更新的应用。 也许你已经厌烦JavaScript的回调，虽然快，但是异步。老司机可能会发现JavaScript貌似很在意一个问题，那就是如何解决异步。","text":"最快的是，技术的更新；最慢的是，更新的应用。 也许你已经厌烦JavaScript的回调，虽然快，但是异步。老司机可能会发现JavaScript貌似很在意一个问题，那就是如何解决异步。一开始我们写回调函数callback，总是深深的被包含在花括号中，无法自拔。这种嵌套的结构一来不易于代码的维护，二来容易出错。相信经历过的人都知道。12//伪代码&#123;&#123;&#123;&#123;callback()&#125;&#125;&#125;&#125; 直到有一天，承诺（promise）出现了，生成器（generator）出现了。这里的promise，让异步可以以同步的方式实现。教程有很多，这里不细讲了，总之写起来很麻烦。反正我是觉得写起来比生成器麻烦。 其实JavaScript的生成器很大程度上借鉴了Python的生成器，学过Python的人都知道。但是生成器不是用来解决异步的，但是生成器却能用来解决异步。生成器更像一种语法糖，把你返回的值存储起来，直到调用才暴露出来，这也是它能解决异步的原因之一。 现在，你去看很多源码的时候，好奇的发现async和await，这俩货究竟是什么东西啊？紧跟标题，大势所趋的ES7。借用koa中最常见的代码块来看1234567app.use(async (ctx, next) =&gt; &#123; if (ctx.request.path === '/error') &#123; ctx.response.body = 'ERROR page'; &#125; else &#123; await next(); &#125;&#125;) 这里的async相当于middleware，await的作用是调用下一个middleware。如果之前对回调了解不是很深刻，可能会比较蒙，await通过next（）调用回调，解决了异步。当然，我在这里解释的也不是很清楚，如果想深入了解，可上GitHub。","categories":[],"tags":[{"name":"ES7","slug":"ES7","permalink":"http://www.1oveit.club/tags/ES7/"}]},{"title":"Google I/O 2017 for front-end development","slug":"Google-I-O-2017-for-front-end-development","date":"2017-05-18T17:41:15.000Z","updated":"2017-05-19T01:37:45.000Z","comments":true,"path":"2017/05/19/Google-I-O-2017-for-front-end-development/","link":"","permalink":"http://www.1oveit.club/2017/05/19/Google-I-O-2017-for-front-end-development/","excerpt":"不知道下一年，世界又会是哪个科技引领潮流。 web componentTwitter和来自印度的Ola，现场展示了modern mobile webApp。虽然组件化的框架polymer从15年开始已经发布，但是polymer框架2.0现在才进入预发布状态。work box的出现很大程度上弥补了server work的不足。so will polymer be a competitor to react? 好吧，welcome back polymer! React is a JavaScript framwork for rendering HTML! React is not certainly not Web Components.","text":"不知道下一年，世界又会是哪个科技引领潮流。 web componentTwitter和来自印度的Ola，现场展示了modern mobile webApp。虽然组件化的框架polymer从15年开始已经发布，但是polymer框架2.0现在才进入预发布状态。work box的出现很大程度上弥补了server work的不足。so will polymer be a competitor to react? 好吧，welcome back polymer! React is a JavaScript framwork for rendering HTML! React is not certainly not Web Components.add webApp to home screen, 然后和native app做对比，从数据流量，媒介，手机流畅度等方面介绍webApp。progressive web app越来越受欢迎。未来web领域可能与VR结合，但是未来一起不可预料，又可以想象。 front-end developers 现在可以让自己的website试用谷歌的 AMP-bind and PWA接口。这无疑给front-end developer多一种新的选择去构建自己的progressive web app。 看完第一场演讲，深觉印度的IT行业发展之快。感触良多，未来不可预料，又可以想象！","categories":[],"tags":[{"name":"Google I/O 2017","slug":"Google-I-O-2017","permalink":"http://www.1oveit.club/tags/Google-I-O-2017/"},{"name":"随笔","slug":"随笔","permalink":"http://www.1oveit.club/tags/随笔/"}]},{"title":"Webpack2.x踩坑与总结","slug":"webpack-之路","date":"2017-02-12T11:13:12.000Z","updated":"2017-05-22T11:28:48.000Z","comments":true,"path":"2017/02/12/webpack-之路/","link":"","permalink":"http://www.1oveit.club/2017/02/12/webpack-之路/","excerpt":"本地安装npm包后如何在命令行运行 在npm安装包的时候，如果使用全局安装，即npm install -g，则在安装完成后可以在终端运行作为命令去运行，但是如果是本地安装的包npm install –save-dev ，则无法这样直接运行。那么如何运行本地安装的包呢？首先进入项目目录（即package.json所在目录），然后使用以下命令即可运行：1$ node_modules/.bin/&lt;packageName&gt;","text":"本地安装npm包后如何在命令行运行 在npm安装包的时候，如果使用全局安装，即npm install -g，则在安装完成后可以在终端运行作为命令去运行，但是如果是本地安装的包npm install –save-dev ，则无法这样直接运行。那么如何运行本地安装的包呢？首先进入项目目录（即package.json所在目录），然后使用以下命令即可运行：1$ node_modules/.bin/&lt;packageName&gt; 除了可以这样在命令行运行外，还可以在文件中运行123//index.jslet webpack = require('webpack');webpack(); 1$ node index.js webpack1.x升级2.x 1.module.loaders改成了module.rules旧的loaders被新的rules取代，后者允许配置loader以及其他更多项。123456789101112131415161718192021222324252627module: &#123; loaders: [ rules: [ &#123; test: /\\.css$/, loaders: [ use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\", query: &#123; options: &#123; modules: true &#125; ] &#125;, &#123; test: /\\.jsx$/, loader: \"babel-loader\", // Do not use \"use\" here options: &#123; // ... &#125; &#125; ]&#125; 以上写法中，Rule.loader是Rule.use: [ { loader } ]的简写。 2.链式调用loaders在webpack1.x中loaders可以链式调用，在2.x中依旧有该特性，使用rule.use配置项，use中设置一个loaders的数组而在1.x中使用!连接各个loader，旧版写法只有在使用旧的module.loaders时有效。123456789101112module: &#123; loaders: &#123; rules: &#123; test: /\\.less$/, loader: \"style-loader!css-loader!less-loader\" use: [ \"style-loader\", \"css-loader\", \"less-loader\" ] &#125;&#125; 3.取消在模块中自动添加-loader后缀webpack2.x中不再添加-loader1234567891011121314module: &#123; rules: [ &#123; use: [ \"style\", \"style-loader\", \"css\", \"css-loader\", \"less\", \"less-loader\", ] &#125; ]&#125; 根据官方说法，做出这样更改的原因是省略-loader会对新手造成误解，所以去掉这个功能，如果想打开这个旧的功能，可以配置resolveLoader.moduleExtensions，但是并不推荐这么做。123resolveLoader: &#123; moduleExtensions: [\"-loader\"] &#125; 4.使用options配置loader在webpack1.x中可以通过webpack.config.js的自定义属性来配置loader，这在webpack2.x中无法执行12345678910111213141516171819202122module.exports = &#123; ... module: &#123; use: [&#123; test: /\\.tsx?$/, loader: 'ts-loader' &#125;] &#125;, // does not work with webpack 2 ts: &#123; transpileOnly: false &#125; &#125;//webpack2 use optionsmodule.exports = &#123; ... module: &#123; use: [&#123; test: /\\.tsx?$/, loader: 'ts-loader' options: &#123; transpileOnly: false &#125; &#125;] &#125;&#125; webpack插件的使用 webpack-dev-server1.x升级2.x 1.在CLI使用的时候，–inline默认开启，无需在输入命令时添加 2.删除contentBase用proxy代替 3.减少控制台无用输出，在1.x中，当我们停掉服务器后，控制台会一直输出错误信息，但是在2.x中只会输出[WDS] Disconnected! extract-text-webpack-plugin 在使用webpack将vue_spa打包后，并不会出现css，因为css被打包入build.js，如果从vue组件中抽离出css，需要安装插件extract-text-webpack-plugin，在使用的时候需要配合v2版本的才可以使用（如果使用了webpack2，则对应的插件版本都需要用v2版本）。具体配置如下：1234567891011121314151617181920212223module:&#123; rules:[ &#123; test: /\\.vue$/, loader: 'vue', options: &#123; loaders:&#123; css: extractTextPlugin.extract(&#123; loader: 'css-loader', fallbackLoader: 'vue-style-loader' &#125;) &#125; &#125; &#125; ]&#125;,plugins: [ new webpack.HotModuleReplacementPlugin(), new extractTextPlugin(&#123; filename:'/style.css', allChunks:true &#125;)] 在options中：options.loader: string | object | loader[] (必填项) 这里的 loader(s) 用于将资源转换为css导出模块options.fallbackLoader: string | object | loader[] 当css没有被导出的时候这里的 loader(s) 会被使用 （即当在plugins模块中设置allChunks:false的时候）在plugins中：filename：可以设置被导出的css文件的路径以及名字allChunks：从所有附加块中提取（默认情况下，它只从初始块中提取）html-webpack-plugin12345plugins: [ new htmlWwebpackPlugin(&#123; filename: 'assets/admin.html' &#125;),] title：用于生成文档的documentfilename：要注入的html文件，默认为index.html。可以自定义（例如：assets/admin.html）inject：true | ‘head’ | ‘body’ | false将资源注入所给的template或templateContent，当设置为 true 或者 ‘body’，所有的资源会被注入到body底部。而head则会将js放到headelementfavicon: 在输出的html中添加faviconhash: true | false 如果为true，则将一个唯一的webpack编译散列附加到所有包含的脚本和CSS文件。这对缓存清除很有用。cache: true | false 如果为true（默认），尝试仅在更改后才发出文件。是否要更换preset？webpack2.x默认支持es6的模块，所以在编译时候没有必要将它们先转换为CommonJS模块再处理，所以在github中出现了babel-preset-es2015-webpack，但是这个模块我在使用的时候出现了Cannot remove ‘babel-plugin-transform-es2015-modules-commonjs’ from the plugin list.的问题，根据babel-preset-es2015-webpack中的叙述以及issues#14可知，babel-preset-es2015已经支持不转换模块中的import和export，只需要设置.babelrc12345678910&#123; \"presets\": [ [ \"es2015\", &#123; \"modules\": false &#125; ] ]&#125; 使用CommonsChunkPlugin将第三方库单独打包 很多情况下我们会引入第三方库，但是默认情况下，webpack会将第三方库与我们自己写的js一起打包进生成文件中，为了让第三方库与我们自己写的js分开，webpack2.x内置一个插件CommonsChunkPlugin，它可以让webpack在打包的时候将我们自己写的js与第三方库分开，具体用法如下：12345678910111213141516171819entry:&#123; app: './src/main.js', vendor: [ 'lodash', 'axios', 'vue', 'vue-router' ]&#125;,output: &#123; path: path.resolve(__dirname + '/dist'), publicPath: '/dist', filename: '[name].js'&#125;,plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name:'vendor' &#125;)] 这里需要注意一点，这里在在输出的时候需要使用filename: ‘[name].js’，否则会报错。 原文出处：Webpack2.x踩坑与总结","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://www.1oveit.club/tags/Webpack/"}]},{"title":"JavaScript简明教程（全）","slug":"javaScript简明教程（全）","date":"2016-12-29T05:37:19.000Z","updated":"2017-05-22T07:26:04.000Z","comments":true,"path":"2016/12/29/javaScript简明教程（全）/","link":"","permalink":"http://www.1oveit.club/2016/12/29/javaScript简明教程（全）/","excerpt":"JavaScript与Java没有半毛钱关系，网景公司员工Brendan Eich用了10天时间设计了JavaScript语言。 JavaScript的范围JavaScript的范围：BOM + DOM + ECMAScript BOM简单说明123456BOM即Browser Object Mode,浏览器对象模型。BOM提供了独立于内容而与浏览器窗口进行交互的对象。BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。因为BOM主要用于管理窗口与窗口之间的通信，因此其核心对象是window。BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C。BOM结构体系","text":"JavaScript与Java没有半毛钱关系，网景公司员工Brendan Eich用了10天时间设计了JavaScript语言。 JavaScript的范围JavaScript的范围：BOM + DOM + ECMAScript BOM简单说明123456BOM即Browser Object Mode,浏览器对象模型。BOM提供了独立于内容而与浏览器窗口进行交互的对象。BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。因为BOM主要用于管理窗口与窗口之间的通信，因此其核心对象是window。BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C。BOM结构体系 DOM简单说明12345DOM即Document Object Model，文档对象模型。当网页被加载时，浏览器会创建页面的文档对象模型，即DOM。DOM(文档对象模型)被构造为对象的树。DOM由一系列相关的对象构成，引申为Document对象。DOM的标准化组织是W3C。 ECMAScript简单说明123456789ECMAScript指代JavaScript的核心语法。JavaScript 由 Brendan Eich 发明。JavaScript于1995 年出现在 Netscape 中于 1997 年被 ECMA（一个标准协会）采纳。语法核心：变量基本数据类型对象类型结构(循环|条件|判断)面向对象 javascript语法javascript数据类型基本类型（简单数据类型） * string * number * boolean * undefined * null 复杂类型（复杂数据类型） * Object * Array * Date * RegExp * Function * String * Number * Boolean * null * Math javascript部分操作符的说明一元操作符只能够操作一个值的操作符叫做一元操作符。① 递增和递减操作符:12345678910[01] 前置型,递增和递减操作在包含他们的语句被求值之前就执行。[02] 后置型,递增和递减操作在包含他们的语句被求值之后才执行。var num1 = 2;var num2 = 20;var num3 = --num1 + num2; //21var num4 = num1 + num2; //21var num1 = 2;var num2 = 20;var num3 = num1-- + num2; //22var num4 = num1 + num2; //21 ② 一元加和减操作符:一元加操作符对结果不会有任何的影响。一元减操作符主要用于表示负数。 位操作符01 按位非(NOT):使用 ~ 表示，执行按位非的结果就是返回数值的反码。操作数的负值减去1。123var num1 = 25;var num2 = -num1 - 1; //-26consol.log(~num1) //-26 02 按位与(AND):使用&amp;表示，操作两个操作数。只要有0就为0。03 按位或(OR):使用|表示，操作两个操作数。只要有1就为1。04 按位异或(XOR):使用 ^ 表示，操作两个操作数。相同则为0，不同则为1。05 左移|右移(|有符号|无符号)。 布尔操作符 布尔操作符一共有三个，分别是：非、与、或。 01 逻辑非，符号：！ 说明：取反，可应用于任何值，！！相当于没有操作。02 逻辑与，符号：&amp;&amp; 说明：两个值都为真的时候，结果为真。属于短路操作，如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。03 逻辑或，符号：||说明：两个值只要有一个为真，那么结果为真。属于短路操作，如果第一个操作数为真，那么就不会再对第二个操作数求值了。技巧：可以利用逻辑或短路操作的特点来避免为变量赋null或undefined值。123var myObject = refObject || backupObject;//如果refObject的值不是null,那么它的值将被赋值给myObject//如果是null,那么就将backupObject的值赋值给myObject。 乘性操作符乘 *除 /模 % 加性操作符加 +减 - 说明：上述五种操作符在操作数为非数值的时候内部会执行自动的类型转换。 关系操作符大于 &gt;小于 &lt;小于等于 &lt;=大于等于 &gt;=说明：返回布尔类型的值，要么为false，要么为true。 相等操作符01 相等和不相等[先转换再比较]，符号是 == 和！=比较的规则:[01] 如果操作数中有布尔值，则先转换为数值再比较。[02] 如果是字符串和数值比较，则先将字符串转换为数值再比较。[03] 如果是对象和其他类型的值比较，则先调用对象的valueOf方法，然后用得到的基本类型值去比较。[04] null和undefined是相等的。[05] NaN和NaN不相等。[06] 如果两个操作符都是对象，则比较他们是不是同一个对象，如果指向的是同一个对象则返回true，否则返回false。02 全等和不全等[仅比较不转换],符号是===和!==比较的规则:[01] null和undefined是不全等的，因为它们是不同类型的值。[02] 类型相同，且值相等，则返回true，否则返回false。 条件操作符符号：表达式1 ? 字面量1 ：字面量2说明：如果表达式1的结果为true，则使用字面量1，否则使用字面量2。 赋值操作符符号：=、+=、-=、*=、&lt;&lt;=等等说明：使用赋值操作符对性能而言，没有任何的提升，只是简化了赋值操作而已。 值类型和引用类型01 值类型和引用类型简单说明值类型主要有：12345数值字符串布尔类型undefinednull 引用类型主要有：123对象（Object类型）数组（Array）函数 (Function) 值类型：保存为简单的数据值，赋值只是简单的数据值的复制引用类型:保存为对象，其本质是指向内存位置的引用(地址)，赋值是对地址的复制值类型代码示例1234567var num1 = 10;var num2 = num1; //把num1的值复制一份给num2,num1和num2的值相等,除此之外没有任何其他关系console.log(num1,num2); //10,10console.log(num1 == num2); //truenum2 = 20; //修改num2的值为20,不会对num1产生任何的影响console.log(num1,num2); //10,20console.log(num1 == num2); //false 引用类型代码示例12345678910111213var arr1 = [1,2,3];var arr2 = arr1;console.log(arr1,arr2); //[1,2,3],[1,2,3]console.log(arr1 == arr2); //truevar arr3 = [1,2,3];console.log(arr3); //[1,2,3]console.log(arr1 == arr3,arr2 == arr3); //false,false/** * 代码说明: * arr1和arr2在比较的时候,值相等(都是[1,2,3]),且引用相等(都指向堆中同一块数据),因此arr1和arr2相等 * arr3和arr1以及arr2比较的时候,值相等([1,2,3]),但是引用不相等(arr3指向的是堆中另外一块数据),因此不等 * 总结:引用类型在比较相等的时候,只有值和引用都相等才相等 * */ 02 值类型和引用类型的赋值赋值操作(=):把当前变量存储的值复制一份给接收的变量。值类型的赋值:把当前变量存储的值(具体的数据)复制一份给接收的变量。引用类型的赋值:把当前变量存储的值(具体数据的引用即地址)复制一份给接收的变量。12345678//引用类型使用注意 console.log(arr1,arr2); //[1,2,3],[1,2,3]; console.log(arr1 == arr2); //true arr1.push(4); console.log(arr1,arr2); //[1,2,3,4],[1,2,3,4] /** * 代码说明:因为arr1和arr2内部的引用指向的是同一块数据,所以修改了arr1会对arr2也产生影响 * */ 03 值类型和引用类型作为函数参数处理形参:占位用的参数,用来接收数据的参数而已。实参:实际传递的参数。函数的调用:在函数调用的时候,函数默认会把实参的值赋值给形参。值类型作为参数：在函数内部对形参变量进行修改不会影响到实参的值。引用类型作为参数：在函数内部对形参变量进行修改会影响到实参的值，因为他们的引用指向同一个对象。04 值类型和引用类型的相关图示基本类型的赋值12var str1 = \"hello zhangsan\";var str2 = str1; 引用类型的结构和赋值123456789var car = &#123; color:\"黑色\", number:\"B99\"&#125;;var p1 = &#123; name:\"王宝宝\", age:30, car:car&#125;; 12345var obj1 = &#123; name:\"lisi\", age:18 &#125;; var obj2 = obj1; 对象的动态特性在js中可以动态的对对象属性进行增加、修改和删除；代码示例12345678910111213141516171819//01 创建对象var obj = &#123; name:\"刘德华\", age:60&#125;;//02 动态的为对象添加属性obj.height = \"180cm\";console.log(obj.height);//03 动态的为对象添加方法obj.maiMeng = function () &#123; console.log(\"华仔会卖萌噢\");&#125;;obj.maiMeng();//04 修改属性的值:如果设置的属性以前不存在,那么就是添加,如果设置的属性已经存在了,那么就是修改obj.name = \"王宝强\";console.log(obj.name)//05 删除属性delete obj.name;console.log(obj.name); //undefined 访问对象的方法01 可以使用点语法访问02 可以使用[]语法访问，注意对象的属性必须是字符串 关键字in和delete的使用01 in关键字01 判断属性是否存在于对象中，注意所有的key都是字符串02 for in循环中 遍历对象的 键代码示例12345678910var obj = &#123; name:\"张三\", age:18&#125;;for(k in obj)&#123; console.log(k,obj[k]);&#125;//检测obj对象中是否存在name这个属性console.log(\"name\" in obj); 注意：in关键字操作数组的时候检测的是索引值并非数组元素02 delete关键字01 删除对象的属性02 删除未使用var声明的变量03 返回值为boolean类型，true则表示是否删除成功注意1201 删除的属性如果不存在，返回true02 删除的如果是原型中的属性，返回true 但是删除不成功 循环和分支循环结构1234forwhiledo...whilefor..in 分支结构12if...else..swith..case break和continue对比break:终止循环，循环中后面的代码不再执行continue:结束当前循环，循环后面的代码不再执行，继续下一次循环 调试工具的使用开启调试窗口 windows 平台: f12; Mac: option+command+i;调试窗口介绍 指针: 选择页面中的元素 手机: 使用移动端界面调试 Elements: 查看页面 DOM 树 Console: 控制台(注意, 控制台与该页面是一个整体, 在控制台中的任何操作, 会影响到页面) Source: 代码调试调试工具的使用 逐过程运行, 一次运行一个函数 单步运行(逐步运行), 一次运行一句, 如果是函数, 进入函数体内运行 继续运行. 从当前状态运行下去, 直到出现断点, 如果没有断点则运行结束设置断点技巧 逐步与逐过程混合 断点加继续运行 条件断点(右键添加 add contitional breakpoint)利用 watch 监视窗口可以查看对象成员 异常处理常见的异常分类运行环境的多样性导致的异常（浏览器）语法错误，代码错误异常的特征:一旦代码出现异常，后面的代码就不会再执行异常捕获使用try-catch语句捕获异常123456try&#123; //这里写可能出现异常的代码&#125;catch(e)&#123; //这里的e就是捕获的异常对象 //可以在这里写，出现异常后的处理代码&#125; 异常捕获语句执行的过程为：01 代码正常运行, 如果在try中出现了错误, try 里面出现错误的语句后面的代码都不再执行, 直接跳转到 catch 中02 在catch中处理错误信息03 继续执行后面的代码04 如果 try 中没有出现错误, 那么不走 catch 直接执行后面的代码捕获异常的优点：通过try-catch语句进行异常捕获之后，代码将会继续执行，而不会中断。注意：语法错误异常用try-catch语句无法捕获，因为在预解析阶段，语法错误会直接检测出来，而不会等到运行的时候才报错。try..catch使用示例1234567891011121314151617//01 try ... catch结构的使用//a(); 若直接调用则爆出:Uncaught ReferenceError: a is not defined错误//在开发中,我们对于可能会报错或者是发生异常的代码用try结构进行处理try&#123; a(); //如果发生异常,那么至少不会到正程序中断&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest();//结论:使用try...catch结构,如果发生了异常,那么不会影响后面代码的执行,且我们可以在发生异常信息之后做出具体的处理 手动抛出异常案例：自己写的一个函数，需要一个参数，如果用户不传参数，此时想直接给用户抛出异常，就需要了解如何抛出异常。抛出异常使用throw关键字，语法如下：手动抛出异常信息（字符串）:123456789101112131415try&#123; //a(); //如果发生异常,那么至少不会到正程序中断 //不使用系统默认的异常信息,尝试手动抛出 throw \"对不起,您调用了尚未定义的方法\";&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest(); 手动抛出异常信息（对象）:1234567891011121314151617181920212223try&#123; //a(); //如果发生异常,那么至少不会到正程序中断 //不使用系统默认的异常信息,尝试手动抛出 throw &#123; errMsg:\"具体的错误信息提示\", errCode:\"指定错误类型的代号,如1001等\" &#125;;&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e); //在try语句中抛出的错误信息是什么,那么得到的异常信息就是什么 //如果抛出的是字符串,那么得到的就是字符串 //如果抛出的是对象,那么此处得到的就是对象 console.log(e.errMsg); console.log(e.errCode);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest(); 异常捕获语句的完整模式异常捕获语句的完整模式为try-catch-finally123456789101112131415try&#123; //在执行的时候可能发生异常的代码 b();&#125;catch (e)&#123; //如果try代码块中的代码在执行中发生了异常,那么就会执行该代码块的代码 //通过打印e对象可以查看具体的异常信息 console.log(e); //打印异常信息&#125;finally &#123; //不论try语句中的代码是否会发生异常,都一定会执行此处的代码块 //一般在前端开发中很少使用,常用语后台开发的资源释放工作 console.log(\"无论如何总要执行的代码\");&#125; finally中的代码，不管是否发生异常，都会执行。一般用在后端语言中，用来释放资源，JavaScript中很少会用到。 DOM操作获取元素操作123getElementByIdgetElementsByTagNamegetElementsByClassName 元素节点操作1234567appendChildinsertBeforeremoveChildreplaceChildcloneNodecreateElementcreateTextNode（创建文本节点） 属性节点操作123getAttributesetAttributeremoveAttribute 常用DOM属性1234classNameinnerHTMLinnerText/textContent valuechildren 代码示例12345678910111213141516//0 获取页面中指定的标签,并设置其样式 var divID = document.getElementById(\"divId\"); divID.style.backgroundColor = \"pink\"; divID.style.height = \"40px\"; divID.style.width = \"200px\"; //01 创建新的标签 var div = document.createElement(\"div\"); //02 设置标签的样式 div.style.backgroundColor = \"red\"; div.style.height = \"100px\"; div.style.width = \"300px\"; div.style.fontSize = \"20\"; //03 设置标签的内容 div.innerText = \"这是一个自己创建的标签\"; //04 把标签插入到页面中 document.body.appendChild(div); 面向对象编程 面向对象方法被人谈论了二十多年了，直到今天，我们还一直在谈对象。 面向层过程和面向对象编程01 面向对象编程和面向过程编程是一种编程思想,和具体的语言关系不大。02 面向过程编程和面向对象编程的主要区别1234567891011121314151617181920面向过程编程: 关注点在于解决问题需要的每一个详细的步骤 示例: 自己洗衣服的过程 ① 收集需要洗的脏衣服 ② 准备洗衣粉、洗衣液等 ③ 把衣服放到一个盆里 ④ 接水 ⑤ 把洗衣粉放到盆里 ⑥ 摩擦,摩擦,不断的摩擦 ⑦ 把洗好的衣服用清水冲洗干净 ⑧ 尽量把把洗好的衣服的水分拧干 ⑨ 晾晒 面向对象编程: 关注点在于解决问题需要的对象身上 示例: 使用洗衣机洗衣服的过程 ① 收集需要洗的脏衣服 ② 找到合适的洗衣机 ③ 设定洗衣服和烘干的程序 03 面向过程和面向对象他们的区别就类似于自己洗衣服和使用洗衣机洗衣服|自己做饭吃和去餐馆吃饭 面向对象编程的相关概念01 对象 什么是对象? 所有的一切都是对象,在开发中有一项重要的工作就是对象的划分。一般来说,我们所指的对象是某个具体的事物,而非泛泛的类别。02 对象的特征(静态描述信息) 所谓特征就是一些特定的描述信息 如:学生(性别、年龄、班级、专业、籍贯、家庭住址) 如:汽车(颜色、车牌、品牌、价格等)03 对象的行为(动态特性) 如:人(吃饭、睡觉、玩游戏、奔跑、运动等) 如:狗(吃、睡、咬人、叫、流口水)04 js中的对象 键-值对(key-value)的集合。05 现实生活中的对象和js对象的对应关系 静态的描述信息 - js对象中的属性(属性就是定义在对象内部的变量) 动态的行为特征 - js对象中的方法(方法就是定义在对象内部的函数)06 代码示例：12345678910111213141516171819202122232425 var zhangsan = &#123; name:\"张三\", sex:\"男\", age:18, address:\"天上人间1号公馆\", eat:function () &#123; console.log('能吃'); &#125;, sleep:function () &#123; console.log(\"能睡\"); &#125;, say:function () &#123; console.log(\"能说话\"); &#125;, run:function () &#123; console.log(\"能运动\"); &#125;, song:function () &#123; console.log(\"能唱歌\"); &#125; &#125;; //打印对象的属性并调用相关的方法console.log(zhangsan.name,zhangsan.age,zhangsan.address); zhangsan.say(); zhangsan.sleep(); 面向对象的三大特性面向对象的三大特性:封装、继承、多态01 封装:复用|信息隐蔽代码示例123456789101112131415161718192021//01 封装的简单说明//001 观察以下杂乱无关的语句,它们仅仅只是一堆无意义的全局变量var name = \"乘风波浪会有时\";var actors = [\"彭于晏\",\"邓超\"];var showTime = \"2016-1-28 - 2016-2-28\";var director = \"韩寒\";var type = \"喜剧\";var play = function () &#123; //播放......&#125;;//002 把上面的变量封装到对象中(更具有意义)var film = &#123; name:\"乘风破浪会有时\", actors:[\"彭于晏\",\"邓超\"], showTime:\"2016-1-28 - 2016-2-28\", director:\"韩寒\", type:\"喜剧\", play:function () &#123; //播放...... &#125;&#125; 02 继承:获取已经存在的对象已有属性和方法的一种方式(获取他人已有财富和资源的一种方式)。代码示例123456789101112131415//继承的简单示例//001 创建一个空的对象var nullObj = &#123;&#125;;// 上面的对象film拥有了很多的属性和方法//002 设法让nullObj拥有film中所有的属性和方法//方法一:自己重新写一遍//方法二:通过某种方式来获得,比如遍历该对象,然后完成赋值for(var k in film)&#123; nullObj[k] = film[k];&#125;for(var k in nullObj)&#123; console.log(nullObj[k]);&#125; 03 多态(polymorphism) 多态:polymorphism = poly(复数) + morph(形态) + ism 多用于强类型语言中，JavaScript具备与生俱来的多态特性。 多态表现为: ① 同一操作,作用于不同的对象,会产生不同的解释和行为。 ② 隐藏不同。 创建对象的方法字面量方式创建对象基本写法123456789var book1 = &#123; name:\"声名狼藉者的生活\", price:42.00, author:\"福柯\", press:\"北京大学出版社\", read:function () &#123; console.log(\"我的书名为:声名狼藉者的的生活,作者为福柯....\"); &#125; &#125;; 存在的问题[01] 代码复用性差[02] 如果要创建大量的同类型对象，则需要些大量重复性代码 内置构造函数创建对象JS中的内置构造函数123456789StringNumberBoolean 注意：(区别于string number boolean)DateArrayFunctionObjectRegExp 基本写法12345678var book1 = new Object();book1.name = \"声名狼藉者的生活\";book1.price = 42.00;book1.author = \"福柯\";book1.press = \"北京大学出版社\";book1.read = function () &#123; console.log(\"我的书名为:声名狼藉者的的生活,作者为福柯....\");&#125;; 问题01 创建的对象无法复用,复用性差02 如果需要创建多个同类型的对象,如(书籍)则需要写大量重复的代码,代码的冗余度高 工厂函数创建对象基本写法12345678910111213141516171819202122function createBookNew (name,price,author,press) &#123; var book = new Object(); book.name = name; book.price = price; book.author = author; book.press = press; book.read = function () &#123; console.log(\"我的书名为:\"+book.name+\",作者为\"+book.author+\"....\"); &#125;; return book;&#125;//使用工厂函数来创建对象var book1 = createBookNew(\"声名狼藉者的的生活\",\"42.00\",\"福柯\",\"北京大学出版社\");var book2 = createBookNew(\"人性的枷锁\",\"49.00\",\"毛姆\",\"华东师范大学出版社\");var book3 = createBookNew(\"悟空传\",\"28.00\",\"今何在\",\"湖南文艺出版社\");//打印对象的属性,调用对象的方法console.log(book1.name);console.log(book2.name);console.log(book3.name);book1.read();book2.read();book3.read(); 工厂函数说明:001 工厂函数方式创建对象其本质是对内置构造函数创建对象的过程进行了封装002 适用于大规模“批量生产”同类型的对象1234567891011121314function createBook (name,price,author,press) &#123; //001 参数 = 原料 var book = new Object(); //002 创建对象并设置对象的属性和方法 = 对原料进行加工 book.name = name; book.price = price; book.author = author; book.press = press; book.read = function () &#123; console.log(\"我的书名为:\"+book.name+\",作者为\"+book.author+\"....\"); &#125;; //003 把处理好的对象返回给我们 == 产品出厂 return book;&#125; 封装思路:使用函数把固定不变的部分封装起来，变化的部分提取为函数的参数。工厂函数创建对象的实现过程:① 提供一个创建对象的函数（参数）② 在该函数内部使用new 关键字和Object构造器创建对象③ 设置对象的属性④ 设置对象的方法⑤ 返回对象 自定义构造函数创建对象基本写法123456789101112131415function 构造函数名(参数1,参数2,参数3...) &#123; //设置对象的属性 this.属性01 = 参数1; this.属性02 = 参数2; //设置对象的方法 this.方法01 = function () &#123; //..... &#125;; this.方法02 = function () &#123; //..... &#125;&#125;//自定义构造函数方式创建对象var 对象01 = new 构造函数名(实参01,实参02,实参03...);var 对象02 = new 构造函数名(实参01,实参02,实参03...); 代码示例12345678910111213141516171819function CreateBook (name,price,author,press) &#123; this.name = name; this.price = price; this.author = author; this.press = press; this.read = function () &#123; console.log(\"我的书名为:\"+this.name+\",作者为\"+this.author+\"....\"); &#125;;&#125;var b1 = new CreateBook(\"声名狼藉者的的生活\",\"42.00\",\"福柯\",\"北京大学出版社\");var b2 = new CreateBook(\"人性的枷锁\",\"49.00\",\"毛姆\",\"华东师范大学出版社\");var b3 = new CreateBook(\"悟空传\",\"28.00\",\"今何在\",\"湖南文艺出版社\");//打印对象的属性,并调用对象的方法测试console.log(b1.author);console.log(b2.author);console.log(b3.author);b1.read();b2.read();b3.read(); 构造函数与new关键字:new关键字的作用：用于创建对象（Object类型）。构造函数和普通函数的区别：函数的首字母大写。构造函数的作用:用于完成对象的初始化。 自定义构造函数和简单工厂函数的对比：1234① 函数的首字母大写(用于区别构造函数和普通函数)② 创建对象的过程是由new关键字实现③ 在构造函数内部会自动的创建新对象,并赋值给this指针④ 自动返回创建出来的对象 构造函数的执行过程① 使用new关键字创建对象② 把新创建出来的对象赋值给this③ 在构造函数内部,使用this为新创建出来的对象设置属性和方法④ 默认返回新创建的对象(普通函数如果不显示的return则默认返回undefined)。 构造函数的返回值01 如果在构造函数中没有显示的return,则默认返回的是新创建出来的对象02 如果在构造函数中显示的return,则依照具体的情况处理 [01] return 的是对象,则直接返回该对象,取而代之本该默认返回的新对象 [02] return 的是null或基本数据类型值,则返回新创建的对象 构造函数方式创建对象存在的问题每次创建对象,都会重新创建函数，那么如果创建的对象数量很多,而对象方法内部的实现一模一样,则造成了资源浪费。 构造函数的使用注意函数传值：可以把构造函数的对象方法抽取为参数。代码示例：1234567891011121314151617//001 创建一个构造函数function Person(name,age,toDoSomeThing) &#123; //002 在构造函数内部设置对象的属性和方法 this.name = name; this.age = age; this.sayName = function () &#123; console.log(this.name); &#125;; this.toDoSomeThing = toDoSomeThing;&#125;//003 使用构造函数创建对象var zhangsan = new Person(\"张三\",18,function () &#123; console.log(\"张三在读书\");&#125;);var lisi = new Person(\"李四\",20,function () &#123; console.log(\"李四在玩耍\");&#125;); 对象类型:01 检查对象的类型：instanceOf02 获取对象的类型：Object.prototype.toString.call(dog) 对象的构造器属性12345function Dog(name) &#123; this.name = name; this.color = \"黄色\"; &#125;console.log(dog.constructor); 属性的名称：constructor属性的作用：指向创建该对象的构造函数，类似于现实生活中所有的产品都标有生产厂家一样。 构造函数的调用01 构造函数可以像普通函数一样不通过new关键字直接调用02 在使用构造函数创建对象的时候，如果没有传递参数，则（）可以省略代码示例:1234567891011//01 创建构造函数function Person() &#123; this.name = \"张三\"; this.age = 20; this.sayName = function () &#123; console.log(this.name); &#125;&#125;//02 使用构造函数创建对象var p1 = new Person();var p2 = new Person; //说明:如果不需要传递参数,则在调用构造函数的时候()可以省略 this指向01 如果使用new 构造函数的方式调用，则this指向内部默认创建出来的空对象02 如果像调用普通函数一样调用构造函数，则this指向全局对象window(不要这样使用) 原型对象原型对象概念 在构造函数创建出来的时候,系统会默认帮构造函数创建并关联的一个新对象 自定义构造函数的原型对象默认是一个空对象。 原型对象的作用 构造函数中的原型对象中的属性和方法可以被使用该构造函数创建出来的对象使用。 即以自定义构造函数方式创建出来的所有对象,自动拥有和共享该构造函数的原型对象中的所有属性和方法。 如何访问构造函数的原型对象① 构造函数.protoType② 对象.__proto__（不推荐） 设置原型对象的属性和方法① 利用对象的动态特性来为构造函数的原型对象添加属性和方法② 替换原型对象 实例和实例化：实例化:通过构造函数创建具体对象的过程。实例:通过构造函数实例化出来的对象,我们称之为该构造函数的一个实例。注意:在说实例的时候,一定要指定是某个具体构造函数的实例。 原型的使用方法① 利用对象的动态特性给原型添加属性|方法，如果要添加的方法过多,则有大量重复代码。② 直接替换原型对象：01 替换前后创建的对象所指向的原型对象不一致02 替换原型对象会切断和之前的原型对象之间的关系 原型对象的使用注意1234567① 访问属性:构造函数创建出来的对象在访问属性的时候,会先在实例内查找,如果没有找到则进一步到对应的原型对象中查找。② 设置属性:在使用点语法进行赋值的时候,无法操作到对应的原型对象,如果该属性在对象中已经存在，则修改该属性的值。如果该属性在对象中尚未存在,则新增该属性。③ 设置原型对象的属性:[01] 设置原型对象的属性,只能通过构造函数.Prototype的方式替换原型对象的方式设置。[02] 如果原型对象的属性是值类型，那么只能通过Person.prototype.属性的方式修改其值。如果原型对象的属性是引用类型,那么可以通过对象名.引用对象.属性名的方式设置修改： (001) 使用构造函数创建出来的多个对象的原型对象中的该属性指向的是同一块数据。 (002) 某个对象对该原型对象属性进行了修改会影响到其他的对象。 __proto__属性说明：__proto__是一个非标准属性,即ECMAScript中并不包含该属性,这只是某些浏览器为了方便开发人员开发和调试而提供的一个属性,不具备通用性。建议:在调试的时候可以使用该属性,但不能出现在正式的代码中。 继承 关于继承，通俗说子继父业。在JavaScript中，Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。 相关方法在讲继承之前，我们必须先了解一些相关的方法。 hasOwnProperty和in属性操作in关键字作用：用来检查对象中是否存在某个属性(不区分实例属性和原型属性)。语法：“属性名” in 对象。代码示例:12345678910111213141516&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125; //03 创建对象 var p1 = new Person(); //04 使用in关键字判断对象中是否存在以下属性:name age sayHello console.log(\"age\" in p1); //false console.log(\"name\" in p1); //true console.log(\"sayHello\" in p1); //true&lt;/script&gt; 对象的hasOwnProperty方法作用：用来检查对象中是否存在指定的属性(只检查实例属性)语法：对象.hasOwnProperty(“属性名”)代码示例123456789101112131415161718&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125; Person.prototype.des = \"默认的描述信息\"; //03 创建对象 var p1 = new Person(); //04 使用hasOwnProperty方法判断该属性是否是对象的实例属性 console.log(p1.hasOwnProperty(\"age\")); //false console.log(p1.hasOwnProperty(\"name\")); //true console.log(p1.hasOwnProperty(\"sayHello\")); //false console.log(p1.hasOwnProperty(\"des\")); //false&lt;/script&gt; 判断某对象中存在且只存在某个原型属性123function isProperty(obj, property) &#123; return !obj.hasOwnProperty(property) &amp;&amp; (property in obj); &#125; constructor构造器属性说明 使用构造函数创建对象,则 原型对象中的constructor属性指向对应的构造函数 实例对象中的constructor指向对应的构造函数,其中这里的constructor就是从原型中获取的即constructor时实例对象中的原型属性,而非实例属性 代码验证123456789101112131415//01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125;; Person.prototype.des = \"默认的描述信息\"; //03 创建对象 var p1 = new Person(); function isProperty(obj, property) &#123; return !obj.hasOwnProperty(property) &amp;&amp; (property in obj); &#125; console.log(isProperty(p1, \"constructor\")); //true isprotoTypeOf和instanceisprotoTypeOf作用：判断是否是某个实例对象的原型对象语法:构造函数.protoType.isPrototypeOf(对象)用法示例123456789&lt;script&gt; function Person() &#123;&#125; function Dog() &#123;&#125; Person.prototype.name = \"嘿嘿\"; var p1 = new Person(); console.log(Person.prototype.isPrototypeOf(p1));//rue console.log(Object.prototype.isPrototypeOf(p1));//true console.log(Dog.prototype.isPrototypeOf(p1));//false&lt;/script&gt; instance作用：用于检查对象是否是某个构造函数(类型)的实例语法：对象 instance 构造函数注意：所有的对象都是Object构造函数（类型）的实例用法示例12345678&lt;script&gt; var arr = [1,2,3]; console.log(arr instanceof Array); //true console.log(Array instanceof Object); //true console.log(arr instanceof Object); //true //instanceOf在判断的时候,算上整条原型链 //arr 是Array 和Object 任何一个类的示例&lt;/script&gt; 继承继承基本概念继承：即通过一定的方式实现让某个类型A获取另外一个类型B的属性或方法。其中类型A称之为子类型，类型B称之为父类型或超类型。 javaScript中的继承Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。继承有两种方式：接口继承和实现继承，在js中只支持实现继承，实现继承主要依赖原型链来完成。JavaScript中实现继承的几种方式：说明:其他语言中继承通常通过类来实现，js中没有类的概念，js中的继承是某个对象继承另外一个对象，是基于对象的。123401 原型式继承02 原型链继承03 经典继承(借用构造函数)04 组合继承 原型式继承原型链继承的方式A1234567891011121314151617&lt;script&gt; //01 提供一个构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置原型对象的属性 Person.prototype.className = \"逍遥派1班\"; //03 使用构造函数来创建原型对象 var p1 = new Person(\"张三\",10); var p2 = new Person(\"李四\",20); //04 打印p1和p2对象中的className属性 console.log(p1.className); console.log(p2.className); //结论:对象p1和p2继承了构造函数原型对象中的属性className //但是这并不是严格意义上的继承&lt;/script&gt; 原型链继承的方式B1234567891011121314151617181920&lt;script&gt; //01 提供一个构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置原型对象的属性 Person.prototype = &#123; constructor:Person, className:\"逍遥派1班\" &#125;; //03 使用构造函数来创建原型对象 var p1 = new Person(\"张三\",10); var p2 = new Person(\"李四\",20); //04 打印p1和p2对象中的className属性 console.log(p1.className); console.log(p2.className); //结论:对象p1和p2继承了构造函数原型对象中的属性className //注意:使用原型替换的方式实现继承的时候,原有原型对象中的属性和方法会丢失&lt;/script&gt; 原型链继承的方式C1234567891011121314151617181920212223//01 提供超类型|父类型构造函数function SuperClass() &#123; this.name = 'SuperClass的名称'; this.showName = function () &#123; console.log(this.name); &#125;&#125;//02 设置父类型的原型属性和原型方法SuperClass.prototype.info = 'SuperClass的信息';SuperClass.prototype.showInfo = function () &#123; console.log(this.info);&#125;;//03 提供子类型function SubClass() &#123;&#125;//04 设置继承(原型对象继承)SubClass.prototype = SuperClass.prototype;SubClass.prototype.constructor = SubClass;var sub = new SubClass();console.log(sub.name); //undefinedconsole.log(sub.info); //SuperClass的信息sub.showInfo(); //SuperClass的信息sub.showName(); //sub.showName is not a function 点评：上面的方法可以可以继承超类型中的原型属性和原型方法，但是无法继承实例属性和实例方法 原型链继承实现思想：利用原型（链）让一个对象继承另一个对象的属性和方法实现本质：重写原型对象 原型链123456① 每个构造函数都有原型对象② 每个对象都有自己的构造函数③ 每个构造函数的原型都是一个对象④ 那么这个构造函数的原型对象也有自己的构造函数⑤ 那么这个构造函数的原型对象的构造函数也有自己的原型对象以上形成一个链式的结构,称之为原型链 原型链中的属性搜索原则12345当访问某个对象的成员的时候,会先在自身中查找,如果找到则直接使用如果在自身中没有找到,则去当前创建当前对象的构造函数的原型对象中查找,如果找到了则直接使用如果在该原型对象中没有找到,则继续查找原型对象的原型对象(创建该原型对象的构造函数所对应的原型对象),如果找到则直接使用如果在原型对象的原型对象中也没有找到,则继续向上搜索....直到Object的原型对象,若还是没有,则返回undefined(属性)或报错(方法)。 基本写法·代码示例1234567891011121314151617181920212223//01 提供超类型|父类型function SuperClass() &#123; this.name = 'SuperClass的名称'; this.showName = function () &#123; console.log(this.name); &#125;&#125;//02 设置父类型的原型属性和原型方法SuperClass.prototype.info = 'SuperClass的信息';SuperClass.prototype.showInfo = function () &#123; console.log(this.info);&#125;;//03 提供子类型function SubClass() &#123;&#125;//04 设置继承(原型对象继承)SubClass.prototype = new SuperClass();SubClass.prototype.constructor = SubClass;var sub = new SubClass();console.log(sub.name); //SuperClass的名称console.log(sub.info); //SuperClass的信息sub.showInfo(); //SuperClass的信息sub.showName(); //SuperClass的名称 点评：可以继承父类型中的原型属性|原型方法,以及实例属性和实例方法 注意点① 确定原型和实例的关系 instanceof + isPrototypeOf()② 注意重写原型对象的位置，必须先实现原型继承，然后再设置子对象的原型属性和原型方法③ 完成继承之后，不能使用字面量的方式来创建原型[因为会切断原型] 问题① 父对象的实例属性会转换为子类型原型的原型属性，而如果父类型是实例属性是引用类型则会存在共享问题② 在创建子类型的实例时，不能向父类型的构造函数中传递参数1234567891011121314151617//01 提供父对象的构造函数function SuperType() &#123; //02 在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈'];&#125;;//03 提供子对象的构造函数function SubType() &#123;&#125;;//04 设置原型继承SubType.prototype = new SuperType();//05 创建父对象构造函数的实例对象,并对内部的实例化属性进行修改var subDemo1 = new SubType();var subDemo2 = new SubType();alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈subDemo1.family.push('爷爷','奶奶');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶 经典继承（借用构造函数）经典继承又称为借用构造函数|伪造继承 基本思想在子类型构造函数的内部调用超类型|父类型构造函数说明：需要借助call|apply方法代码示例1234567891011121314151617181920212223242526//01 提供父类型(对象)的构造函数 function SuperType(name) &#123; //02 在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈']; //实例属性 this.name = name; &#125;; SuperType.prototype.info = '父类型的原型属性'; //03 提供子类型（对象）的构造函数 function SubType() &#123; //经典继承|借用构造函数|伪造对象继承 //SuperType.call(this); //构造参数传递参数 SuperType.call(this,'张老汉'); &#125;; //04 创建父类型的实例对象,并对内部的实例化属性进行修改 var subDemo1 = new SubType(); var subDemo2 = new SubType(); alert(subDemo1.info); //undefined alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈 alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈 subDemo1.family.push('爷爷','奶奶'); alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶 alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈 //测试构造函数传递参数 alert(subDemo1.name); 点评：能够继承父类型的实例属性,但是无法继承父类型的原型属性和原型方法 经典继承的优点① 解决实例对象共享问题，通过调用父对象的构造函数来实现每个子类型（对象）的实例对象均拥有一份父类型实例属性和方法的副本② 可以在调用call方法的时候向构造函数传递参数 经典继承的问题① 冒充继承的方法无法实现函数的重用② 无法继承父对象的原型属性和原型方法 组合继承组合继承|伪经典继承 基本思想① 使用原型链实现对原型属性和方法的继承② 通过伪造(冒充)构造函数来实现对实例属性的继承代码示例1234567891011121314151617181920212223242526272829//01 提供父类型的构造函数function SuperType(name) &#123; //在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈']; //实例属性 this.name = name;&#125;;//原型方法SuperType.prototype.showName = function () &#123; console.log(this.name);&#125;//02 提供子类型的构造函数function SubType(name) &#123; //冒充|伪造 构造参数传递参数 SuperType.call(this,name);&#125;;SubType.prototype = SuperType.prototype;//SubType.prototype = new SuperType();//02 创建父类型的实例对象,并对内部的实例化属性进行修改var subDemo1 = new SubType('张三');var subDemo2 = new SubType('张四');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈subDemo1.family.push('爷爷','奶奶');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈//测试构造函数传递参数subDemo1.showName(); //张三subDemo2.showName(); //张四 基本包装类型基本类型：字符串 + 数值 + null + undefined + 布尔值为了便于操作基本类型，ECMAScript提供了三个特殊的引用类型：Boolean + Number + String。上述类型和其他的引用类型类似，同时也具备与各自的基本类型相应的特殊行为，每当我们读取一个基本类型的值的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。123var str = '测试字符串';console.log(str.length); //5console.log(str.substring(2)); //字符串 思考：属性和方法本是对象的特征，字符串如何能够拥有length属性以及其他类似subString等方法，内部怎么实现的？基本类型值并不是对象，因此从逻辑上讨论他们不应该有属性和方法。 内部的具体处理:123（1）创建String类型的一个实例对象（2）在实例对象上面读取指定的属性（length）,调用指定的方法（subString）（3）销毁该对象 NumberNumber是与数字值相对应的引用类型。创建Number类型的对象：var num = new Number(10); String String是字符串的对象包装类型。创建字符串类型的对象：var str = new String(‘hello World’); BooleanBoolean是与布尔值对象的引用类型。可以通过调用Boolean构造函数传递参数来创建boolean类型的对象。var bool = new Boolean(true); 基本包装类型的代码示例1234567891011121314//001 Stringvar str = '测试字符串';console.log(str.length); //5console.log(str.substring(2)); //字符串//002 Numbervar num = new Number(10);console.log(num); //Number &#123;[[PrimitiveValue]]: 10&#125;console.log(typeof num); //objectconsole.log(typeof 10); //number//003 Booleanvar bool = new Boolean(true);console.log(bool); //Boolean &#123;[[PrimitiveValue]]: true&#125;console.log(typeof bool); //objectconsole.log(typeof true); //boolean 基本包装类型的注意点[1] 对象还是基本数据类型值？对象：通过new 调用构造函数创建出来的是对象基本数据类型值：直接通过字面量方式赋值|通过省略new关键字调用构造函数方式创建的是基本数据类型值。12345ex: var str1 = new String('hello'); var str2 = 'hello'; var str3 = String('hello'); 说明：以上代码中，str1是对象，而str2和str3是字符串（基本数据类型值） [2] 相等问题基本类型值判断相等=&gt;值相等引用类型值判断相等=&gt;值相等且引用相等对象是引用类型，因此在判断相等的时候有诸多的注意点和容易出错的地方123456789101112131415161718ex var str1 = '这是一个字符串'; //基本数据类型 var str2 = String('这是一个字符串'); //基本数据类型 console.log(str1 == str2); //true 相等 var str3 = new String('这是一个字符串'); //引用类型-对象 console.log(str1 == str3); //true //值相等 console.log(str2 == str3); //true //值相等 console.log(str1 === str3); //false //值相等,但是引用不相等 console.log(str2 === str3); //false //值相等,但是引用不相等 //判断下面的变量是否相等 var num1 = 10; //基本数据类型 var num2 = new Number(10); //对象 console.log(num1 == num2); //true console.log(num1 === num2); //false var bool1 = true; var bool2 = new Boolean(true); console.log(bool1 == bool2); //true console.log(bool1 === bool2); //false 原型链及相关属性方法简单说明原型链代码示例1234567891011121314151617&lt;script&gt; //01 提供Person构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置Person的原型对象 Person.prototype.showName = function () &#123; console.log(this.name); &#125; //03 创建Student构造函数 function Student(number) &#123; this.numer = number &#125; //04 设置Student的原型对象 Student.prototype = new Person();&lt;/script&gt; 原型链图示例 Object对象Object构造函数01 使用Object构造函数创建字符串对象12345678//01 创建字符串对象var str1 = new String(\"测试字符串\");var str2 = new Object(\"测试字符串\");var str3 = str1;//注意:对象比较相等(需要引用[地址]相等)console.log(str1 == str2); //falseconsole.log(str1 === str2); //falseconsole.log(str1 === str3); //true 02 使用Object构造函数创建数字对象12var num = new Object(10);console.log(typeof num); //object 03 使用Object构造函数创建布尔类型对象12var bool = new Object(true); console.log(typeof bool); //object js中所有的内置或自定义对象都继承自Object对象,几乎所有的对象都可以使用Object.prototype上面的属性和方法 Object.prototype01 因为js中所有的对象都继承自Obejct,都可以使用Object对象的原型属性和方法,因此不要轻易的扩展Object.prototype。02 Object.property中的属性和方法 ① constructor 指向原型相关联的构造函数，为Object ② hasOwnProperty 判断对象中是否拥有某个实例属性(不包括原型链上面的属性) ③ isPrototypeOf 校验某个对象是否是指定对象的原型对象(整条原型链) ④ propertyIsEnumerable 属性是否存在且可枚举(使用for循环可以遍历,即目标属性能否在for循环中显示出来) ⑤ toString() 返回一个描述目标对象的字符串,对象则返回[object object] toString(参数) 参数出可以传入一个用于进制数的参数,该参数的默认值为10(主要针对Number类型有效) ⑥ toLocaleString 同toString,但是会做一些本地化的处理。 ⑦ valueOf() 如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。 Date对象调用该方法会返回一个时间戳。 constructor说明：该属性指向创建该对象的构造函数，在这里为Object123456function Person() &#123; &#125; var p = new Person(); console.log(p.constructor); //function Person() &#123;&#125; console.log(Person.prototype.constructor); //function Person() &#123;&#125; console.log(Object.prototype.constructor); //function Object() &#123; [native code] &#125; hasOwnProperty说明：判断对象中是否拥有某个实例属性(不包括原型链上面的属性)12345678function Person() &#123; this.name = \"默认的姓名\"&#125;//检查对象中是否拥有指定的属性(实例属性)var p1 = new Person();p1.hasOwnProperty(\"name\"); //truep1.hasOwnProperty(\"age\"); //falsep1.hasOwnProperty(\"constructor\"); //对象的constructor是从原型对象上继承的 isPrototypeOf说明：校验某个对象是否是指定对象的原型对象(整条原型链);1234567891011121314&lt;script&gt; var obj = &#123; name:\"张三\", age:20, hello:function () &#123; console.log(\"hello\"); &#125;, showName:function () &#123; console.log(this.name); &#125; &#125; //属性是否存在且可以枚举 console.log(obj.propertyIsEnumerable(\"name\")); //true&lt;/script&gt; toString说明：返回一个描述目标对象的字符串,对象则返回[object object]12345678910111213&lt;script&gt; var obj = &#123;&#125;; console.log(obj.toString()); //打印[object Object] var arr = [1,2,3,4,5]; console.log(arr.toString()); //打印1,2,3,4,5 var num = 10; console.log(num.toString()); //10 var date = new Date(); console.log(date.toString()); //Mon Feb 13 2017 19:00:13 GMT+0800 (CST) //toString方法可以传入参数,在处理Number类型数据的时候,可以传入指定的进制 console.log(num.toString(2)); //1010 == 1*2*2*2+0*2*2+1*2+1*1 = 10 console.log(num.toString(3)); //101 == 1*3*3 + 0*3 + 1*1 = 10&lt;/script&gt; toLocaleString说明：作用同toString方法一致，但是会做一些本地化的处理. valueOf说明：① 如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。② 如果是Date类型，则返回时间戳。123456789&lt;script&gt; var obj = &#123;&#125;; console.log(obj + 1); //[object Object]1 //说明:如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。 var o = &#123;name:\"张三\"&#125;; console.log(o + 1); //[object Object]1 var date = new Date(); console.log(date.valueOf()); //1486984088998&lt;/script&gt; 静态成员和实例成员静态成员 定义在构造函数上面的成员(属性和方法) 实例成员 定义在实例对象上面的成员(属性和方法) 建议 ① 把工具类的方法写成静态方法 ② 把和对象相关的方法写成实例方法(成员) 代码示例12345678910111213141516&lt;script&gt; function Person() &#123; this.name = \"张三\"; //实例属性 this.showName = function () &#123; console.log(this.name); &#125;; &#125; //为Person构造函数添加静态成员 Person.des = \"描述信息\"; Person.add = function (msg) &#123; console.log(\"添加信息\" + msg); &#125;; Person.add(\"这是一个+操作\"); var p1 = new Person(); p1.showName();&lt;/script&gt; Function构造函数函数创建的几种方式 12301 函数声明02 字面量的方式创建03 使用new Function的形式创建 函数创建代码示例 12345678function func01() &#123; console.log(\"函数声明\"); &#125; var func02 = function () &#123; console.log(\"字面量方式创建\"); &#125; //使用Function构造函数创建 var func03 = new Function(); Function构造函数创建函数 参数说明:可以传入多个参数 最后一个参数:传入的最后一个参数为函数的函数体内容 其他参数:创建出来的函数的参数 如果只有一个参数,则表示这是该函数的函数体内容 传递参数的格式:以字符串的方式进行传参代码示例123456//需求01 使用Function构造函数创建一个函数对象,该函数执行一行打印操作var funcName01 = new Function(\"console.log('让我掉下眼泪的,不止昨夜的酒')\");funcName01();//需求02 使用Function构造函数创建一个函数对象,该函数需要接受两个参数,要求返回他们的和var funcName02 = new Function(\"a\",\"b\",\"return a + b;\");console.log(funcName02(10, 20)); //30 解决函数体代码过长的问题（1）使用转义字符，写在一行中（2）使用+操作符来拼接字符串（3）使用``操作符来管理字符串（4）使用模板先处理字符串，然后在js中获得模板中的内容 arguments、length和calleearguments参数说明：在js中的函数中，有两个隐藏的参数分别是this和arguments1234arguments 是一个类似数组的结构,可以通过下标来操作函数的参数,但并非数组类型的。在函数调用的时候,会将函数的所有参数都传入arguments对象中保存,因此我们可以通过操作arguments属性来操作参数形参的数量大于实参的数量,则依次传入,未传入的设置为undefined形参的数量小于实参的数量,则arguments中保存实际的值 length 函数内部的arguments数组拥有length属性,可以通过该属性获取用户调用时传入的实参的个数 函数本身有一个length属性,可以通过该属性来获取形式参数的个数 callee方法 函数内部的arguments对象中,有一个callee方法,该方法指向函数自身,常用于匿名函数的递归调用。 代码示例12345678910111213141516171819&lt;script&gt; function func() &#123; console.log(arguments); console.log(arguments.length); //调用函数时实际传入的参数数量 &#125; func(1,2,3,4,5); console.log(func.length); //预期的参数数量 —— 函数的形参数量 function func02(a,b) &#123; console.log(a, b); console.log(arguments); &#125; func02(1,2,3); //实参的数量 &gt; 形参的数量 则arguments保存实参的值 func02(1); //实参的数量 &lt; 形参的数量 则不足的补undefined //匿名函数调用 (function () &#123; //如果需要在该函数中调用自身,则可以使用arguments.callee方法 arguments.callee(); &#125;)();&lt;/script&gt; Function的应用01 数组去重123456789101112 var func = new Function(\"arr\",` var array = []; for(var i = 0 ; i&lt;arr.length; i++) &#123; if(array.indexOf(arr[i]) == -1) &#123; array.push(arr[i]); &#125; &#125; return array;`); console.log(func([1, 2, 3, 4, 5, 3, 4, 2]));; 02 返回传入函数中所有数据的最大值123456789101112var func = function () &#123; var maxNumber = arguments[0]; for(var i = 0;i&lt;arguments.length;i++) &#123; if (maxNumber &lt; arguments[i]) &#123; maxNumber = arguments[i]; &#125; &#125; return maxNumber;&#125;console.log(func(1, 2, 3, 45, 5, 6, 7, 8, 30, 21)); eval 简单说明eval 的基本使用eval函数用来讲字符串转换为JS的代码,并执行 eval 处理JSON数据代码示例123456&lt;script&gt; var jsonData = '&#123;\"name\":\"张三\",\"age\":18&#125;'; //把json的数据转换为对象 var obj = JSON.parse(jsonData); console.log(obj);&lt;/script&gt; 12345678910111213&lt;script&gt; var jsonData = '&#123;\"name\":\"张三\",\"age\":18&#125;'; //var obj = eval(jsonData); //注意:如果直接这样写代码则会报错 //正确的处理方式 //方式一 eval(\"var obj = \" + jsonData); console.log(obj); //方式二 //说明:使用eval来解析json格式字符串的时候,会将&#123;&#125;解析为代码块,而不是字面量 // 在使用的时候为了避免这种错误,需要在JSO的最外面加上(),如此则会把大括号当做一条语句来解析 var o = eval(\"(\"+jsonData+\")\"); console.log(o);&lt;/script&gt; eval 注意事项 ① eval函数本身功能强大,但它的特性也为程序带来了很大的不确定性,因此在开发中并不推荐使用。 ② eval函数是动态的执行代码,因此其效率不如直接执行静态脚本高。 eval和Function比较12相同点:都能够把字符串转换为Javascript的代码不同点:eval转换为js的代码之后马上就执行,而Function需要先创建函数,调用函数之后才会执行。 Function.prototype原型链关于Function和自定义构造函数的原型对象 Function.prototype 是一个空的函数 自定义构造函数的原型对象是一个空的对象 说明 Function也可以被当做是一个构造函数 通过new Function创建出来的函数,可以认为是Function的实例化对象。 Function的原型对象是一个空的函数,这个空的函数也是一个对象,它的原型对象是Object.prototype。 在JS中,Object的原型对象是所有对象的祖宗。 Function是构造函数,则其原型对象为空的函数 空的函数的原型对象为Object.prototype Function本身也是对象,则其构造函数为:function Function() { [native code] } 是自身 同Object类型 Object本身是构造函数,其原型对象是Object.prototype Object本身也是对象,其构造函数为:function Function() { [native code] 代码示例123456789101112131415//01 提供Person构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置Person的原型对象 Person.prototype.showName = function () &#123; console.log(this.name); &#125; //03 创建Student构造函数 function Student(number) &#123; this.numer = number &#125; //04 设置Student的原型对象 Student.prototype = new Person(); 完整的原型链示意图Object和Function的关系01 Object构造函数是通过Function构造函数实例化出来的02 Function构造函数也是通过Function构造函数实例化出来的 代码示例12345678&lt;script&gt; //检查对象是否是某个构造函数的实例 console.log(Function instanceof Function); console.log(Function instanceof Object); console.log(Object instanceof Object); console.log(Object instanceof Function); //注意:以上打印结果均为true&lt;/script&gt; 对象的拷贝操作浅拷贝如果对象中的属性是引用类型的值,那么存在数据共享问题,修改某个对象会对拷贝的对象产生影响代码示例123456789var o = &#123;name:\"张三\",car:&#123;number:\"2017\",type:\"火车\"&#125;&#125;;var obj = &#123;&#125;;//obj对象需要拷贝o对象中所有的属性for (var i in o )&#123; obj[i] = o[i];&#125;console.log(obj);o.car.type = \"飞船\";console.log(obj); 深拷贝 如果对象中的属性是值类型,那么就直接拷贝赋值 如果对象中的属性是引用类型,那么就再次调用拷贝方法,遍历对象 代码示例123456789101112131415161718192021222324252627 var o = &#123;name:\"张三\",car:&#123;number:\"2017\",type:\"火车\"&#125;&#125;; var obj = &#123;&#125;; function deepCopy(obj,tmp) &#123; tmp = tmp || &#123;&#125;; //如果没有传入,那么就创建一个空的对象 for(var i in obj) &#123; if (obj.hasOwnProperty(i)) //只拷贝实例属性 &#123; //判断是否是引用类型 if ((typeof obj[i]) == 'object') &#123; //重新调用拷贝方法 tmp[i] = Array.isArray(obj[i]) ? [] :&#123;&#125;; deepCopy(obj[i],tmp[i]); &#125;else &#123; //直接拷贝 tmp[i] = obj[i]; &#125; &#125; &#125; &#125;deepCopy(o,obj); console.log(obj); o.car.type = \"测试的类型\"; console.log(obj); console.log(o); 注意isArray的兼容性问题isArray是ECMA5中新推出的方法,需要处理兼容性问题123456if (Array.isArray != \"function\")&#123; Array.isArray = function (obj) &#123; return Object.prototype.toString.call(obj) == '[object Array]'; &#125;&#125; Number原型扩展小案例：在Number的原型对象上面定义一个新的方法add(),该方法接收一个参数,并将该参数与自身的值进行相加,然后进行返回。代码实现123456789Number.prototype.add = function (num) &#123; return this + num;&#125;var n = 10;console.log(n.add(3));//console.log(5.add(5)); 错误:解析器无法处理字面量的这种情况var num = new Number(50);console.log(num.add(20)); //70console.log((1).add(4)); //5 使用()把数字包起来 使用注意123（01）使用数字变量可以调用成功（02）使用数字表达式可以调用成功（03）直接使用数字字面量方式调用失败 js的语法解析器无法处理数字字面量这种情况。 With语句with语句简单介绍123with语句是js中一个强大但有争议的特性。with语句允许我们将一个对象的所有属性引用到当前的作用域允许我们无需使用拥有者对象的前缀，就可以直接对这些属性进行引用和赋值操作。 注意：ECMAScript5规范在严格模式下已经禁用了该语句，在开发中不推荐使用，但是要求能够看懂with的代码。 with语句内部细节说明： with语句会创建一个作用域，在该作用域内，在引用特定对象的属性时，可以不使用前缀。应用场景：对深层级对象的引用进行缩短。 在with作用域内部引用属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //[01] 测试with语句作用域内对对象属性的引用 //01 提供全局变量,名称为testValue var testValue = '测试使用的全局变量'; //02 提供对象,对象内部提供属性 var testObject = &#123; name:'对象的名称属性', testValue:'对象内部的属性' &#125;; //03 使用with语句引用 with(testObject) &#123; console.log(name); //对象的名称属性 console.log(testValue); //对象内部的属性 console.log(this); //window &#125; console.log(testValue); //测试使用的全局变量``` 总结：(1) 在with语句作用域内,对象属性的优先级绝对高于在更层级作用域内定义的同名变量(2) this(函数上下文)依然指向window,并不会收到with作用域的影响**在with作用域内进行赋值操作**```js //01 提供一个对象,在内部提供属性 var obj = &#123; name:'对象的内部属性', &#125; //02 with语句测试对对象属性的赋值操作 with(obj) &#123; name = '修正对象中name的值'; //在作用域内部添加变量(思考?该变量是添加为全局作用域还是当前obj对象的属性?) age = '25'; showName = function () &#123; console.log('name == ' + name); &#125;; &#125;; //测试修改对象属性操作 console.log(obj.name); //测试添加对象属性操作 console.log(obj.age); //undefined //obj.showName(); //obj.showName is not a function console.log('____________________'); console.log(this.name); //== name == window.name console.log(window.name); console.log(name); showName(); //==this.showName() ==window.showName() 总结：（1）在with作用域的内部我们可以使用无前缀引用对象的属性进行读取和赋值的操作 但是 不能使用无前缀的方式添加属性（2）如果使用无前缀的方式来添加属性[对不存在的属性进行赋值操作],那么属性将被添加到全局上下文[window|this]（3）可能产生的错误:意外的引入一个全局变量,而非为with作用域对象添加属性 with语句的问题（1）with作用域内操作优先级混乱（2）性能不好，会大大降低js代码的执行性能（3）ECMAScript5规定在严格模式下禁用with特性 with语句简化代码的替代方案使用即时调用函数来替代with语句，通过函数传参的方式使用更短的引用来替代冗长的引用前缀比使用with语句消除前缀的方式更好。123456789101112with(this.style)&#123; width = '200px'; height = '200px'; backgroundColor = '#ca3'; console.log(width); //要访问的本应该是外部的字符串变量 \"错误哈哈\",但是这里被解释为200px&#125;(function (s) &#123; s.width = '200px'; s.height = '200px'; s.backgroundColor = '#ca3';&#125;)(this.style); 使用面向过程的方式处理1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 bookList.push(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; console.log(obj); break; &#125; &#125; //修改操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; obj.author = \"泰戈尔-戈尔泰\" &#125; &#125; //删除操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; //删除该对象 bookList.splice(i, 1); &#125; &#125; console.log(bookList);&lt;/script&gt; 使用函数来封装图书管理操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 function addBook(bookObj) &#123; bookList.push(bookObj); &#125; addBook(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 function getBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125; console.log(getBook(\"什么是批判\")); //修改操作 function updateBookData(name,authorName)&#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; obj.author = authorName; &#125; &#125; &#125; updateBookData(\"飞鸟集\",\"泰戈尔斯坦\"); //删除操作 function removeBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; //删除该对象 bookList.splice(i, 1); &#125; &#125; &#125; console.log(bookList);&lt;/script&gt; 数封装-复用形式12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 function addBook(bookObj) &#123; bookList.push(bookObj); &#125; addBook(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 function getBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125; console.log(getBook(\"什么是批判\")); //修改操作 function updateBookData(name,authorName)&#123; var obj = getBook(name); obj.author = authorName; &#125; updateBookData(\"飞鸟集\",\"泰戈尔斯坦\"); //删除操作 function removeBook(name) &#123; var obj = getBook(name); var index = bookList.indexOf(obj); bookList.splice(index,1); &#125; addBook(&#123;name:\"东京人\",author:\"川端康成\"&#125;); console.log(bookList);&lt;/script&gt; 面向对象的方式管理图书123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;scrip&gt; var obj = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ];泰 function BookManager() &#123; this.bookList = null; &#125; BookManager.prototype = &#123; constructor:BookManager, init:function (arr) &#123; this.bookList = arr || []; &#125;, addBook:function (bookObj) &#123; this.bookList.push(bookObj) &#125;, getBook:function (name) &#123; for (var i = 0; i &lt; this.bookList.length; i++) &#123; var obj = this.bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125;, updateBookData:function (name,authorName)&#123; var obj = this.getBook(name); obj.author = authorName; &#125;, removeBook:function (name) &#123; var obj = this.getBook(name); var index = this.bookList.indexOf(obj); this.bookList.splice(index,1); &#125; &#125;; //01 创建对象 var YYManager = new BookManager(); YYManager.init(obj); console.log(YYManager.bookList); //02 演示添加操作 YYManager.addBook(&#123;name:\"花田半亩\",author:\"田维\"&#125;); console.log(YYManager.bookList); //03 演示查询操作 console.log(YYManager.getBook(\"花田半亩\")); //04 演示更新操作 YYManager.updateBookData(\"花田半亩\",\"甜田\"); console.log(YYManager.getBook(\"花田半亩\"));; //05 演示删除操作 YYManager.removeBook(\"什么是批判\"); console.log(YYManager.bookList); //02 创建第二个人的图书管理对象 var wulitaotaoMManager = new BookManager(); wulitaotaoMManager.init([&#123;name:\"装逼速成\",author:\"六扇门\"&#125;]); console.log(wulitaotaoMManager.bookList);&lt;/script&gt; 总结01 提供构造函数，在构造函数内部设置实例化属性02 把常用的操作提取成对象的实例方法，写在原型对象身上03 提供init方法，用于初始化数据04 注意：如果切断了原型对象那么需要修正内部的构造器属性指向 变量和函数 JavaScript中有严格模式和非严格模式两种运行环境,本章节主要讲严格模式及非严格模式下函数和变量的区别,最后简单讲诉了JavaScript作用域。 私有变量和函数 定义在构造函数内部而被this对象的变量,在外部无法访问到的变量和函数 公有变量和方法 对外暴露接口,可以通过构造函数对象创建的对象访问的属性和方法 代码示例1234567891011121314151617function Car(type,number) &#123; this.type = type; //公共的属性 this.number = number; var city = \"广州\"; //私有变量 var getNumber = function () &#123; //私有函数 return number; &#125;; var getType = function () &#123; return type; &#125;; //能够访问私有变量和函数的方法 --- 特权方法 this.getDescription = function () &#123; console.log(getNumber() + getType() + city); &#125; &#125; var car = new Car(\"汽车\",\"201718\"); car.getDescription(); 说明：能够访问构造函数内部私有变量|函数的方法称之为特权方法 构造函数的问题构造函数本身是一个函数，在调用的时候有多种调用方式。12① new 构造函数（）调用② 构造函数（）调用 以上，第二种调用方式存在作用域安全的问题 作用域安全的构造函数12345678910111213141516171819202122&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; //容错处理 if (this instanceof Person) &#123; //设置实例属性和方法 this.name = name; this.showName = function () &#123; console.log(this.name); &#125; &#125;else &#123; return new Person(name); &#125; &#125; //02 创建对象 var p1 = new Person(\"zhangsan\"); var p2 = new Person(\"lisi\"); p1.showName(); p2.showName();&lt;/script&gt; 新的问题说明:上面的代码在使用借用构造函数方式继承的时候存在问题，无法创建出的对象，原因在于通过call或者是apply函数调用的时候，内部的this绑定的子类型中的对象，因此在使用instanceOf 判断的时候，结果为假。解决：可以设置让子类型（构造函数）的原型对象为父类型的一个实例。代码示例123456789101112131415161718192021222324252627282930&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; //容错处理 if (this instanceof Person) &#123; //设置实例属性和方法 this.name = name; this.showName = function () &#123; console.log(this.name); &#125; &#125;else &#123; return new Person(name); &#125; &#125; //02 创建对象 var p1 = new Person(\"zhangsan\"); var p2 = new Person(\"lisi\"); p1.showName(); p2.showName(); // 使用借用构造函数来实现继承 function Boy(name)&#123; Person.call(this,name); &#125; //需要结合原型继承来解决 instanceOf 实例对象检测的问题 Boy.prototype = new Person(); var boy = new Boy(\"测试的名字\"); boy.showName();&lt;/script&gt; 严格模式关键字 “use strict”;实现严格模式:只需要在脚本代码中添加上上述关键字即可。 关键字具体说明12345(1) 注意区分大小写，必须全部都是小写的(2) 注意空格，整个字符串总共10个字符(3) 单引号和双引号无所谓，但是需要有双引号(4) 必须写在作用域的最顶部，注意其位置(5) 可以加分号，也可以不加，但是必须是一个字符串 注意：以下的关键字写法均是错误的123\"USE strict\";\" use strict \";\"(\"USE strict\").toLowerCase();\" 严格模式使用注意12345678910111 所有的变量必须使用var 关键字声明2 不能使用delete关键字删除全局变量 ,以前默认删除失败,严格模式下直接报错3 在对象中不允许有同名的属性4 函数的参数必须唯一(不能出现同名的参数)5 arguments对象的行为不同,在非严格模式下修改形参的值会反映到arguments中,而严格模式下则相对独立6 禁用了argument.callee和caller函数,他们一个引用函数本身,一个引用调用函数7 不能在if语句中声明函数8 禁止使用eval和arguments作为标识符9 修正this的值,在严格模式下,函数this的值始终是指定的值,无论指定的是什么值。10 禁用了with语句11 去掉了JavaScript中的八进制字面量(以0开头的八进制字面量是无效的语法) 1 所有的变量都必须使用var关键字声明12a = 10; //错误的演示console.log(10); ② 不能使用delete关键字删除全局变量1234//在非严格模式下,删除失败(静默失败) 失败了不吭声,严格模式下直接报错var a = 10;delete a;console.log(a); ③ 在对象中不允许有同名的属性1234567//在非严格模式下,会使用后面的属性赋值作为最终值,在严格模式下则直接报错var obj = &#123; name:\"张三\", name:\"李四\"&#125;console.log(obj); ④ 函数的参数必须唯一(不能出现同名的参数)123456789101112//在非严格模式下,如果函数在定义的时候,使用了多个同名的参数,则在函数内部形参的实际值为最后一个传入的实参值//在严格模式下,直接报错// function func(a,a,a) &#123;// console.log(a);// console.log(arguments);// &#125;function func(a,b,c) &#123; console.log(a); console.log(arguments);&#125;func(1,2,3); arguments对象的行为不同说明：（1）严格模式下,在函数内部修改了对象的指向,对arguments的值不会产生影响（2）在严格模式下,形参的值和arguments的值是相互独立的,在函数内部修改了形参的值对arguments不受影响（3）在非严格模式下，修改了形参的值，arguments中的数据会跟着改变123456789101112131415161718 //测试引用类型的值作为函数的参数function funcName(obj) &#123; console.log(obj); console.log(arguments[0]); //在函数内部修改形参的值 obj = &#123;age:20&#125;; console.log(obj); console.log(arguments[0]); &#125; funcName(&#123;name:\"张三\"&#125;); //测试基本类型数据作为函数的参数 function fun(str) &#123; console.log(str); console.log(arguments[0]); str = \"hello\"; console.log(arguments[0]); &#125; fun(\"hi\"); ⑥ 禁用了argument.callee和caller函数说明：argument.callee是对函数自身的引用argument.calller是对调用函数的引用12345678var num = (function (n) &#123; if (n ==1) &#123; return 1; &#125; return arguments.callee(n-1) + n; &#125;)(10); console.log(num); //55 ⑦ 不能在if语句中声明函数123456789//如果在if语句中声明函数，则会产生语法错误 if (true) &#123; console.log(\"________\"); function demo() &#123; console.log(\"呵呵呵呵\"); &#125; demo(); &#125; ⑧ 禁止使用eval和argument作为标识符1234var eval = \"测试的字符串\";console.log(eval);var arguments = \"参数列表\";console.log(arguments); ⑨ 修正this的值12345678在严格模式下,函数this的值始终是指定的值,无论指定的是什么值var name = \"测试的name\";function demoTest() &#123; //在非严格模式下,打印出来的this为全局的对象window console.log(this); //在严格模式下打印出来的this为undefined&#125;demoTest(); ⑩ 禁用了with语句1234567var o = &#123;name:\"暂时干\",age:20&#125;; with(o) &#123; name = \"lisi\"; age = 48 &#125; console.log(o); 禁用了八进制123//以0开头的数据常常引起混乱//var num = 023; //2*8 + 3 ==&gt; 19//console.log(num); //19 书写格式1234501 必须使用单引号或者是双引号括住字符串02 必须使用小写,不能出现大写字符03 必须是10个字符04 字符串后面的分号可以省略05 必须写在当前作用域的最顶上 代码示例123456789101112&lt;script&gt; //\"use strict\"; //正确写法 //\"use strict\" //正确写法 分号可以省略 //'use strict'; //正确写法 可以使用单引号 //\"use strict\"; //错误写法 必须是10个字符 //\"use Strict\"; //错误写法 所有的字符都必须小写 \"use strict\"; a = 10; // \"use strict\"; //错误写法 必须写在当前作用域的顶端 b = 20; console.log(a);&lt;/script&gt; 作用范围12① 函数的顶部(只对当前的函数有效)② script标签的顶部,只对当前的标签有效,对页面中其他的script无效 代码示例12345678910111213141516 //位置01 对func01和func02都有效 //\"use strict\"; function func01() &#123; //位置02 对func01有效,对func02无效 //\"use strict\"; a = 10; console.log(a); &#125; function func02() &#123; //位置03 对func02有效,但对func01无效 //\"use strict\"; b = 20; console.log(b); &#125;func01(); func02(); 函数的几种调用方式123401 普通函数调用 内部的this指向全局对象window02 构造函数调用 内部的this指向新创建的对象03 对象的方法调用 内部的this指向调用的对象本身04 通过call 或者是apply方式调用(函数上下文),this指向的是当前的上下文对象 this丢失demo演示123456789101112&lt;script&gt; var obj = &#123; name:\"张三\", getName:function () &#123; console.log(this.name); &#125; &#125;; //以对象的方法来进行调用 obj.getName(); //张三 var getName = obj.getName; getName(); //以普通函数的方式调用,此时内部的this指向的是window对象 打印的是window.name 为空值&lt;/script&gt; 代码示例0212345678910111213141516&lt;script&gt; //01 获取页面中id值为demo的标签 //var div = document.getElementById('demo');// var getId = document.getElementById;// var div = getId('demo'); //会报错?// console.log(div); //借用apply来修正this document.getElementById = (function (func) &#123; return function () &#123; return func.apply(document,arguments); &#125; &#125;)(document.getElementById); var getId = document.getElementById; var div = getId('demo'); //会报错? console.log(div);&lt;/script&gt; 代码说明：12301 因为document.getElementById方法的内部实现中需要使用到this,这个this本来期望指向的是document对象02 当我们以document.getElementById来调用的时候,内部的this指向document对象03 但是当我们以getId的方式调用的时候,内部的this指向的是window对象(因为我们以普通的方式进行调用) 作用域变量其作用的范围就是它的作用域 块级作用域说明：JavaScript中没有块级作用域123456for (var i = 0; i &lt; 10; i++) &#123; var num = i; &#125; console.log(i); console.log(num); //说明:如果有块级作用域,则i和num打印的结果应该为undefined 词法作用域123词法作用域:在代码写好的那一刻,变量的作用域就已经确定的动态作用域:变量的作用域由执行时的环境所决定说明:在js中不是动态作用域,当调用的时候,是往上查找的,不会到其他函数的作用域中去查找 在JavaScript中唯一能够产生作用域的东西是函数代码演示123456789101112131415161718192021222324&lt;script&gt; var a = \"这是第一个a\"; function func01() &#123; console.log(a); //先在当前作用域中查找,如果没有则访问全局的作用域 &#125; function func02() &#123; var a = \"这是第二个a\"; func01() &#125; func01(); //打印结果为:这是第一个a func02(); //打印结果为:这是第一个a&lt;/script&gt;&lt;script&gt; var a = \"这是第一个a\"; function func02() &#123; var a = \"这是第二个a\"; func01() &#125; function func01() &#123; console.log(a); //先在当前作用域中查找,如果没有则访问全局的作用域 &#125; func01(); //打印结果为:这是第一个a func02(); //打印结果为:这是第一个a&lt;/script&gt; 词法作用域的规则1234① 在函数内部允许访问外部的变量② 只有函数可以限定作用域③ 作用域规则首先使用提升规则分析④ 如果当前作用域中有该变量,则不考虑外部作用域的同名变量 变量和函数提升JS中的代码执行分为两个步骤① 预解析JavaScript在预解析阶段,会对使用var关键字声明的变量和function声明的代码块进行提升操作,提升到当前作用域的顶端② 执行 代码提升的几种情况 01 函数提升123456&lt;script&gt; func(); function func() &#123; console.log(\"测试的函数\"); &#125;&lt;/script&gt; 02 变量提升1234567&lt;script&gt; console.log(a); //打印出来的结果为undefined var a = 10; //var a; //注意:只会对变量的声明进行提升 //console.log(a); //a = 10&lt;/script&gt; 03 函数同名情况提升12345678910111213141516171819&lt;script&gt; func01(); //打印last function func01() &#123; console.log(\"first\"); &#125; func01(); //打印last function func01() &#123; console.log(\"last\"); &#125; //模拟提升后的情况 function func01() &#123; console.log(\"first\"); &#125; function func01() &#123; console.log(\"last\"); &#125; func01(); func01();&lt;/script&gt; 说明：预处理的时候，同名的函数都会进行提升，但是后面的会覆盖掉前面的 04 变量名和函数同名的情况12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; console.log(a); //打印function function a() &#123; console.log(\"我是一个函数\"); &#125; var a = 20; console.log(a); //打印20 //变量和函数提升后的结果 错误// function a() &#123;// console.log(\"我是一个函数\");// &#125;// var a ;// console.log(a);// a = 20;// console.log(a); //变量和函数提升后的结果 正确 function a() &#123; console.log(\"我是一个函数\"); &#125; console.log(a); var a = 20; console.log(a);&lt;/script&gt;```js总结:如果出现变量和函数同名的情况,则在进行提升的时候,只会提升函数到当前作用域顶端而忽略变量的提升操作**变量的提升是分作用域的**示例代码01```js&lt;script&gt; console.log(a); //undefined var a = 10; //模拟提升 var a; console.log(a); //undefined a = 10;&lt;/script&gt; 示例代码0212345678910111213141516171819&lt;script&gt; var num = 10; function func() &#123; var num = 20; console.log(num); &#125; console.log(num); //10 func(); //20 //模拟提升 var num; function func() &#123; var num; num = 20; console.log(num); &#125; num = 10; console.log(num); //10 func(); //20&lt;/script&gt; 示例代码031234567891011121314151617var num = 10;function func() &#123; console.log(num); var num = 20;&#125;console.log(num); //10func(); //undefiend//模拟提升var num;function func() &#123; var num; console.log(num); num = 20;&#125;num = 10;console.log(num); //10func(); //undefiend 示例代码041234567891011121314151617var num = 10;function func() &#123; console.log(num); num = 20;&#125;console.log(num); //10func(); //10//模拟变量提升var num;function func() &#123; console.log(num); num = 20;&#125;num= 10;console.log(num); //10func(); //10console.log(num); //20 函数表达式的提升说明：在使用函数表达式方式创建函数的时候,整个函数表达式并不会进行提升,只会对var声明的变量提升1234567891011func();var func = function () &#123; console.log(\"会不会被调用\");&#125;//以上如上代码将报错//模拟提升的过程var func;func(); //找不到这个函数func = function () &#123; console.log(\"会不会被调用\");&#125; 作用域链01 在js中函数可以创建作用域 02 函数中又可以创建函数(即又可以开辟新的作用域) 03 函数内部的作用域可以访问外部的作用域 04 如果有多个函数嵌套,那么就会构成一个链式的访问结构,也就是作用域链 05 注意:函数内部的作用域可以访问外部的作用域,但是外部的作用域却不能访问内部的作用域 代码示例1234567891011121314151617&lt;script&gt; function f1() &#123; //f1---&gt;全局作用域 function f4() &#123; //f4--&gt;f1---&gt;全局作用域 function f5() &#123; &#125; &#125; &#125; function f2() &#123; //f2--&gt;全局作用域 function f6() &#123; &#125; &#125; function f3() &#123; &#125;&lt;/script&gt; 作用域链绘图说明 ① 先画出全局作用域线条，然后在上面添加全局作用域中的函数和变量，作为0级作用域链 ② 画出全局作用域中的函数的作用域线条，，然后在上面添加当前作用域中的函数和变量，作为1级作用域链 ③ 以此类推，直至完成 示例代码01123456789function f1() &#123; function f2() &#123; &#125; &#125; var a = 20; function f3() &#123; function f4() &#123; &#125; &#125; 图示 示例代码021234567891011121314function f1() &#123; function f2() &#123; function f5() &#123; var b = \"demo\"; &#125; &#125; &#125; var a = 20; function f3() &#123; var c = \"啊哈哈\"; function f4() &#123; var d = \"test\"; &#125; &#125; 图示 作用域注意点和变量搜索原则注意点 01 在获取值和设置值的时候都是访问变量 02 并非在函数内部写了变量,这个变量就属于当前函数,而是必须使用var 关键字声明的变量才属于当前函数 03 函数在声明的时候,里面的代码并不会执行,只有在函数调用的时候才会执行 04 声明函数时候的函数名,其实也是一个变量名,可以通过这个变量名来进行设置和赋值 05 注意:在变量内部使用var 关键字声明一个变量并不会把同名的全局变量覆盖掉 1234567var a = 10;function f1() &#123; var a = 20; //注意:该行代码并不会覆盖掉全局变量中的变量a console.log(a);&#125;f1(); //20console.log(a); //10 代码点评：12在函数中使用var关键字声明变量a并不会覆盖全局作用域中的a。注意需要同时考虑变量在当前作用域的提升以及访问变量时的搜索原则。 1234567function f1() &#123; console.log(1);&#125;var f1 = \"demo字符串\"; //该行代码会把f1函数覆盖掉f1 = \"demoTest字符串\";console.log(f1);//f1(); 代码点评:函数的名称也是变量，如果在代码中出现同名的变量，那么函数的实现会被覆盖掉 变量搜索原则 01 在使用变量的时候,首先在自己的作用域中查找 02 如果找到了就直接使用,如果没有找到,那么就到上一级作用域中去查找 03 重复上面的步骤,直到0级作用域,如果还是找不到那么就返回undefined(报错) 闭包 闭包是学习JavaScript的难点之一，因JavaScript是单线程，故回调使用频繁，本章节主要讲了闭包以及回调。 闭包简单说明 闭:关闭,封闭 包:包住,包裹 闭包:通过某种方式实现的一个封闭的、包裹的对外不公开的结构|空间 闭包的原理:变量的访问原则(即上一级的作用域无法访问下一级的作用域),其实函数本身就是闭包。 闭包要解决的问题 提供一种间接的方式能够访问到函数内部的数据（变量） 实现思路 01 我们需要能够在函数外部访问函数内部的变量，正常情况无法访问； 02 在函数内部如果新创建函数，那么安装作用域链的原则，这个新创建的内部函数能够访问到函数中的这些变量。 03 我们如果能够操作函数中新创建的函数，那么就能够操作函数中的变量（如访问和设置等） 04 如果要能够操作函数中新创建的函数，那么需要在函数中把新创建的函数返回。 05 调用函数，接收并得到其返回值（是一个函数） 06 调用返回值（函数），通过函数传参的方式来设置函数中的变量。 07 调用返回值（函数），通过在函数内部再次return的方式来访问函数中的变量。 闭包的基本模式 在函数内部创建函数(内部函数),在这个内部函数中,可以操作外部函数中的变量 01 在函数(外部)中创建函数(内部函数),在该函数(内部函数)中操作外部函数中的变量 02 在外部函数中,把内部函数作为返回值返回 03 调用外部函数,并接收其返回值(是一个函数) 04 调用接收到的返回值(内部函数),来间接的操作外部函数中的变量 代码示例123456789function func() &#123; var num = 10; return function (n) &#123; num = n; console.log(num); &#125;&#125;var funcName = func();funcName(\"哗啦哗啦\"); 闭包获取数据获取单个数据（考虑赋值）123456789101112131415function func() &#123; var num = 123; return function (a) &#123; if (a !== undefined) &#123; num = a; &#125; return num; &#125;&#125;var f1 = func();var x = f1(456);var y = f1();console.log(x);console.log(y); 说明：上面的代码能够支持通过闭包对函数中的变量num进行访问（取值）或赋值的操作。 获取多个数据（数组）123456789101112131415function func() &#123; var name = \"张学友\"; var age = 40; return [ function getName() &#123; return name; &#125;, function getAge() &#123; return age; &#125; ]&#125;var foo = func();console.log(foo[0]()); //张学友console.log(foo[1]()); //40 说明：上面的代码能够满足返回多个变量值的需求，但是要数组操作的方式并不常见，且和使用习惯不符合。 利用对象返回并设置对个变量值1234567891011121314151617181920212223242526function foo() &#123; var name = \"张学友\"; var age = 45; return &#123; getName:function () &#123; return name; &#125;, getAge:function () &#123; return age; &#125;, setName:function (nameValue) &#123; name = nameValue; &#125;, setAge:function (ageValue) &#123; age = ageValue; &#125; &#125;&#125;var func = foo();console.log(func.getName()); //张学友console.log(func.getAge()); //45func.setName(\"张三\");func.setAge(30);console.log(func.getName()); //张三console.log(func.getAge()); //30 闭包的作用最基本的作用:闭包中的变量更安全,只能通过特定的接口来访问说明:12(1)创建一个私有的空间,保护数据,外界如果需要访问数据必须通过函数提供的指定方法(2)在这些指定的方法中,我们可以设置一些校验的逻辑,以保证对数据访问和设置的安全性 闭包的使用注意进程和线程 进程指的是系统中正在运行的一个应用程序。 线程:一个进程中可以有一个或多个线程,线程是CPU调度的最小单位,是真正执行任务的。 多线程:一个中可能有多条线程,多条线程之间并发的执行多个不同的任务。 单线程:一个进程中只有一条线程,即同一时间只能执行一个操作,只能干一件事情。 javascript是单线程的 js中的线程主要处理三块任务: 01 渲染任务 02 js的代码执行任务 03 js中的事件处理任务(如setTimeOut方法) javascript中代码的执行顺序 01 先把主任务执行完毕(代码任务)02 主任务执行完毕之后再执行次要的任务(包括setTimeOut方法等) 关于setTimeOut函数 函数的作用:一次性定时器(用于延迟执行任务) 参数: 第一个参数:要执行的任务 第二个参数:要延迟执行的时间,时间的单位是毫秒 函数说明： 01 至少在指定的时间后才能够执行回调函数 02 因为要等主任务中的代码执行完毕之后,才回去检查setTimeOut的回调函数。 通过闭包解决setTimeOut函数的问题12345678910111213&lt;script&gt; for (var i = 0; i &lt; 10; i++) &#123; setTimeout((function (j) &#123; return function () &#123; console.log(j); &#125; &#125;)(i),10); console.log(\"----\"); &#125;&lt;/script&gt; 函数的特殊之处函数的特殊之处在于,它本身是对象,且函数可以提供作用域。 (01) 函数可以在运行时动态的创建,还可以在程序执行过程中创建。 (02) 函数可以赋值给变量,可以被扩展,甚至是删除。 (03) 函数可以作为其他函数的参数和返回值。 (04) 函数可以拥有自己的属性和方法。 注意:{} 块在js中不会创建作用域,哪怕是if或者是while语句中使用var关键字声明的变量也并非局部变量。 函数是可以通过（）调用并执行的对象。 函数是第一型对象12301 函数可以像普通对象一样作为函数的参数02 函数可以像普通对象一样赋值给变量（函数表达式）03 函数可以像普通对象一个作为函数的返回值返回 代码示例123456789101112131415//函数作为参数传递 setTimeout(function () &#123; console.log(1); &#125;,100); //函数作为返回值 function func() &#123; return function () &#123; console.log(\"demo\"); &#125; &#125; var f = func(); f(); //demo //函数赋值给变量 var a = function()&#123;&#125; a(); //直接通过变量的名称调用函数 函数的两个特征1201 函数本质上是对象02 函数可以创建作用域 约定1234var add = function add(a,b)&#123;return a + b;&#125;; //命名函数表达式var add = function (a,b)&#123;return a + b;&#125;; //函数表达式,匿名函数 以上也称为使用字面量的方式来创建函数(或者是函数字面量)function add()&#123;&#125;; //函数声明 代码示例123456789101112131415&lt;script&gt; //01 函数声明 function demo01() &#123; &#125; //02 函数表达式(匿名函数) var demo02 = function () &#123; &#125;; //03 命名函数表达式 var demo03 = function demo03Test() &#123; &#125;; //04 打印name属性 console.log(demo01.name); //demo01 console.log(demo02.name); //demo02 (注意在火狐浏览器中打印出来的name属性为空) console.log(demo03.name); //demo03Test&lt;/script&gt; 函数回调回调函数(回调),当我们把某个函数作为参数传递给另一个函数的时候,这个函数就称为回调函数 函数回调的基本模式12345678910&lt;script&gt; function func(callBack) &#123; //处理其他的操作 callBack(); //调用回调函数 &#125; function demo() &#123; console.log(\"这是一个回调函数\"); &#125; func(demo); //注意调用函数的时候,参数是回调函数的引用(不要加括号);&lt;/script&gt; 函数回调解决this问题说明：如果回调函数是某个对象的方法,而该对象方法中使用了this指针那么该方法作为回调函数来使用的时候,需要注意this123456789101112131415161718192021222324252627//01 提供一个对象,该对象中永远showName方法var obj = &#123; name:\"默认的名字\", age:30, showName:function () &#123; console.log(this.name); &#125;, showAge:function () &#123; console.log(this.age); &#125;&#125;;//02 提供一个函数,该函数接受一个参数(函数引用)function demo(callBack,callBack_obj) &#123; //处理第一个参数传递对象方法字符串的形式 if(typeof callBack == 'string') &#123; callBack = callBack_obj[callBack]; &#125; if (typeof callBack == 'function') &#123; callBack.call(callBack_obj); &#125;&#125;//demo(obj.showName,obj);//demo(obj.showAge,obj);//传递字符串和对象来进行调用demo(\"showName\",obj); 代码说明：123（01）以上代码传入两个参数，分别为具体的回调函数，和该回调函数所属的对象（02）该函数的参数接受两种方式的回调传递（一种是直接传递函数引用，一种是直接以字符串的方式传递对象方法的字符串）（03）在函数内部对传入的回调参数做处理，修正this的问题 函数作为函数的返回值12① 使用闭包实现一个计数器(在该示例中setup函数的返回值为一个函数)② 通过调用返回值(一个函数),可以操作setup函数中的变量 123456789101112&lt;script&gt; var setup = function () &#123; var count = 0; return function () &#123; return count ++; &#125; &#125; var next = setup(); console.log(next()); //0 console.log(next()); //1 console.log(next()); //2&lt;/script&gt; 惰性函数定义说明：某个函数直到第一次使用的时候才被正确的定义,并且其具有向后惰性,执行更少的工作。应用场景:函数有一些初始化的准备工作要做,且只需要执行一次的情况。特点:能够更新自己(函数)的实现。缺点: 01 当重新定义自身的时候,已经添加到原始函数的任何属性都会丢失。 02 如何函数被赋值给了其他的变量或者是对象方法,那么在使用变量或者是对象方法调用时仍然会执行旧的函数体。代码示例123456789function foo() &#123; console.log(\"foo!\"); foo = function () &#123; console.log(\"new foo!\"); &#125;&#125;//函数的调用//foo(); //foo!//foo(); //new foo! 问题： ① 添加属性 ② 把函数赋值给新的变量 ③ 以对象的方法调用函数 当惰性函数定义在处理以上三种情况的时候，使用新的变量名调用或者是是以对象的方法来调用函数，那么该函数在执行的时候并不会更新自身，而是执行旧的函数体的内容 代码示例1234567891011121314151617181920212223242526272829&lt;script&gt; //01 声明函数foo function foo() &#123; console.log(\"foo!\"); foo = function () &#123; console.log(\"foo! foo!\"); &#125; &#125; //02 为foo函数对象添加属性 foo.description = \"foo函数的描述信息\"; //03 把foo函数赋值给其他的变量 var func = foo; //04 把foo函数赋值给对象中的方法 var obj = &#123; showFoo:foo &#125; //05 验证并演示输出 func(); //foo! func(); //foo! console.log(func.description); //foo函数的描述信息 //总结:01 如果把函数赋值给其他的变量,那么在以其他变量的方式调用时不会更新自身,还是执行旧的函数体 obj.showFoo(); //foo! obj.showFoo(); //foo! console.log(obj.showFoo.description); //foo函数的描述信息 //总结:02 如果把函数赋值给对象的方法,那么在以对象方法形式调用时不会更新自身,还是会执行旧的函数体。 foo(); //已经更新过foo函数 foo! foo! foo(); //已经更新过foo函数 foo! foo! console.log(foo.description); //undefined&lt;/script&gt; 即时函数 定义:在函数定义之后立即执行该函数。即时函数模式的组成: ① 使用函数表达式来定义函数(匿名函数,注意不能使用函数声明方式) ② 在函数表达式末尾添加一组(),表示立即执行当前函数。 ③ 将整个函数包装在()中,有两种方式` 即时函数的作用 01 用来将所有的代码包装到当前的作用域中,并且不会将任何的变量泄露到全局作用域中。 02 js中没有代码块作用域,而函数是js中唯一可以创建作用域的。 03 即时函数就是利用了函数创建作用域这一点,来实现对一些需要封装且不允许外部访问的操作。 即时函数的优点01 不会产生全局变量,在即时函数内部定义的所有变量都仅仅只是该函数的局部变量,不会造成全局变量污染问题。02 具有更好的封装性,外部无法访问到该函数内部的数据。 即时函数代码示例12345678//第一种写法(function () &#123; console.log(\"即时函数的第一种写法\");&#125;());//第二种写法(function () &#123; console.log(\"即时函数的第二种写法\");&#125;)(); 写法补充123456789(function (a) &#123; console.log(a); &#125;(20)); +function (b) &#123; console.log(b); &#125;(30); -function (b) &#123; console.log(b); &#125;(40); 即时函数的传参和返回值12345678910//01 接受参数 (function (str) &#123; console.log(str); //hello &#125;)(\"hello\"); //02 提供返回值并赋值给新的变量 var foo = (function () &#123; return 2 + 1; &#125;)(); console.log(foo); //3 即时对象初始化01 结构特征:12345① 提供一个对象,在该对象内部提供一个init初始化方法② 使用()把对象包装起来(让字面量变成表达式)③ 然后随即调用init方法,完成初始化操作。 02 基本结构({}).init(); 03 模式优点 在执行一次性的初始化任务时保护全局的命名空间。 代码示例1234567891011121314&lt;script&gt; (&#123; name:\"张三\", age:23, getDescript:function () &#123; console.log(\"名字:\" + this.name + \"年龄:\" + this.age); &#125;, //注意:在对象中访问对象的属性和方法都需要使用this.前缀 init:function () &#123; this.getDescript(); //其他的初始化处理 &#125; &#125;).init();&lt;/script&gt; 函数属性缓存思路说明 01 函数是对象，因此可以在函数上面添加属性和方法 02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果 03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value） 04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。 代码示例(单个参数)1234567891011121314var func = function (param) &#123; if (func.cache[param] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[param] = result + param; &#125; return func.cache[param];&#125;func.cache = &#123;&#125;; //空对象console.log(func(\"demo\")); //字符串democonsole.log(func(\"test\")); //字符串testconsole.log(func(\"demo\")); //字符串demo 直接使用属性缓存中的数据,而不再进行复杂的计算(可以提升性能) 代码示例（多个参数）12345678910111213var func = function () &#123; var key = JSON.stringify(Object.prototype.slice.call(arguments)); if (func.cache[key] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[key] = result + key; &#125; return func.cache[key];&#125;func.cache = &#123;&#125;; //空对象func(\"123\",\"456\"); ////说明:如果传入的参数数量超过1,则可以将传入的参数序列化为一个json字符串作为参数处理。 代码说明：slice:返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素 函数属性缓存 很高兴你能看到这里，希望对你学习JavaScript有帮助。这是最后一章节，主要讲有关JavaScript的设计模式。 思路说明 01 函数是对象，因此可以在函数上面添加属性和方法 02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果 03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value） 04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。 代码示例(单个参数)12345678910111213var func = function (param) &#123; if (func.cache[param] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[param] = result + param; &#125; return func.cache[param];&#125;func.cache = &#123;&#125;; //空对象console.log(func(\"demo\")); //字符串democonsole.log(func(\"test\")); //字符串testconsole.log(func(\"demo\")); //字符串demo 直接使用属性缓存中的数据,而不再进行复杂的计算(可以提升性能) 代码示例（多个参数）12345678910111213var func = function () &#123; var key = JSON.stringify(Array.prototype.slice.call(arguments)); if (func.cache[key] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[key] = result + key; &#125; return func.cache[key];&#125;func.cache = &#123;&#125;; //空对象func(\"123\",\"456\"); ////说明:如果传入的参数数量超过1,则可以将传入的参数序列化为一个json字符串作为参数处理。 代码说明：slice:返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素 命名空间模式作用:(1)有助于减少程序中所需要的全局变量的数量(2)并且同时还有助于避免命名冲突或过长的名字前缀。 说明：JavaScript中并没有内置的命名空间 如何实现命名空间可以为应用程序创建一个全局对象,然后将所有功能都添加到该全局对象中 从而在具有大量函数,对象和其他变量的情况下并不会污染全局范围。 建议 全局命名空间的名称可以随便写,但建议使用项目的名称或者是APP的名称 按照习惯,通过程序员会约定以全部大写的方式来约定全局命名空间。 命名空间模式的缺点 ① 需要输入更多的字符,在每个变量和函数前面都需要附加上前缀,总体上增加了代码的体积。 ② 仅有一个全局实例,意味着代码的任何部分都能够修改当前的实例。 ③ 很长的前缀意味着需要花更长的时间来解析属性(变量|属性访问原则-就近原则) 代码示例（零散的代码）123456789101112131415&lt;script&gt; //构造函数 function Person() &#123; &#125; function Man() &#123; &#125; var array = [1,2,3,4,5,6]; var testDemo01 = \"测试字符串01\"; var testDemo02 = \"测试字符串02\"; var obj = &#123;&#125;; obj.des = \"描述信息\"; obj.logDes = function () &#123; console.log(obj.des); &#125;&lt;/script&gt; 代码示例(命名空间模式) 1234567891011121314151617&lt;script&gt; //01 提供一个全局变量 var MYAPP = &#123;&#125;; //02 处理构造函数 MYAPP.Person = function () &#123;&#125;; MYAPP.Man = function () &#123;&#125;; //03 处理变量 MYAPP.array = [1,2,3,4,5,6]; MYAPP.testDemo01 = \"测试字符串01\"; MYAPP.testDemo02 = \"测试字符串02\"; //处理对象 MYAPP.obj = &#123;&#125;; MYAPP.obj.des = \"描述信息\"; MYAPP.obj.logDes = function () &#123; console.log(obj.des); &#125;&lt;/script&gt; 说明 01 在使用命名空间模式的时候,因为所有的变量和属性都添加到同一个全局对象下面,因此该全局对象下面可能有很多很多的属性。 02 而我们在添加属性的时候,很有可能该属性已经存在,这导致可能会覆盖掉之前的属性。 03 所以,在添加一个属性或者是创建一个命名空间之前,最好是先检查它是否已经存在。 04 但是如果每次添加属性都需要对属性进行检查则会产生代码冗余问题。 示例代码1234567891011121314151617181920212223242526//01 不好的演示//其他代码//var MYAPP = &#123;&#125;; //注意这是不安全的代码,因为有可能覆盖掉上下文中的代码//02 在创建命名空间之前,先检查该命名空间是否存在// if (MYAPP == 'undefined')&#123;// var MYAPP = &#123;&#125;;// &#125;//03 更好的做法var MYAPP = MYAPP || &#123;&#125;; //如果MYAPP为假,那么就返回&#123;&#125;并赋值给MYAPP//04 添加属性时的检查问题//假如现在需要添加一个name属性,那么在添加之前需要先检查该属性是否存在if (MYAPP.name == 'undefined')&#123; MYAPP.name = \"默认的名称\";&#125;//假如要添加一个obJ属性if (typeof MYAPP.obj == 'undefined')&#123; MYAPP.obj = &#123;&#125;;&#125;//假如要给MYAPP.obj添加属性,则if (typeof MYAPP.obj.des === \"undefined\")&#123; MYAPP.obj.des = \"对象的描述信息\"&#125;console.log(MYAPP.obj); 代码说明：我们在添加属性或者是方法的时候,比较安全的做法是在添加之前先在当前环境中进行检查,以免覆盖但是我们的检查操作催生出了一个新的问题,就是重复代码过多,能否考虑把检查的过程抽取 示例代码1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; var MYAPP = MYAPP || &#123;&#125;; MYAPP.namescape = function (string) &#123; //split() 方法用于把一个字符串分割成字符串数组 var parts = string.split('.'); var parent = MYAPP; console.log(parts); //先去掉最前面的冗余的全局变量 if(parts[0] == \"MYAPP\") &#123; //splice() 方法向/从数组中添加/删除项目,然后返回被删除的项目 //parts.splice(0,1); //slice() 方法可从已有的数组中返回选定的元素 //返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素 parts = parts.slice(1); &#125; console.log(parts,\"处理之后的数组\"); //通过for循环来遍历结构 for (var i = 0; i &lt; parts.length; i++) &#123; //检查属性,如果对应的属性不存在,那么就创建一个属性 if (typeof parent[parts[i]] == 'undefined') &#123; //初始化为一个空的对象 parent[parts[i]] = &#123;&#125;; &#125; //修正parent的值 parent = parent[parts[i]]; &#125; return parent; &#125; //代码示例 var testDemo01 = MYAPP.namescape(\"MYAPP.test.testDemo01\"); var testDemo02 = MYAPP.namescape(\"MYAPP.test.testDemo02\"); console.log(MYAPP); //忽略全面的前缀 MYAPP.namescape(\"sadsa.sadjaldj.adada.test\"); console.log(MYAPP); //演示长命名空间的情况 MYAPP.namescape(\"demo.testDemo.testDemos.ss.dd.qq.ddd.ffff.fff\"); console.log(MYAPP);&lt;/script&gt; 补充说明12301 split() 方法用于把一个字符串分割成字符串数组02 splice() 方法向/从数组中添加/删除项目,然后返回被删除的项目03 slice() 方法可从已有的数组中返回选定的元素 设计模式简单说明概念:设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案 注意,设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案 起源:该属于源于建筑行业 历史: （1）由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学 （2）四人帮著作《设计模式：可复用面向对象软件的基础》（Design Patterns - Elements of Reusable Object-Oriented Software） （3）Gang of Four:Erich Gamma + Richard Helm + Ralph Johnson +John Vlissides 优点: 为了可重用代码、让代码更容易被他人理解、保证代码可靠性 设计模式的分类创建型模式:工厂方法模式 + 抽象工厂模式 + 单例模式 + 建造者模式 + 原型模式 结构型模式:适配器模式 + 代理模式 + ... 行为型模式:观察者模式 + 命令模式 + ... 单例模式的思想保证一个特定的类只有一个实例。 即当我们第二次创建新对象的时候,得到的应该是和第一次创建的对象一模一样的对象(同一个对象) 其他语言中实现单例模式 在其它有Class的语言中,实现单例模式核心步骤是: 01 在创建对象实例时候判断,该类的实例对象是否已经存在,如果已经存在,那么就直接返回 02 如果不存在,那么就创建一个新的实例对象,并保存起来,下次创建实例对象的时候直接使用。 JavaScript中的单例模式JavaScript是一门弱类型,动态,基于原型的语言,并没有类,只有对象。 在JavaScript中要实现单例模式有很多种方式。 最简单的方式:使用字面量的方式来创建对象,因为在JavaScript中对象之间永远不可能相等,除非他们是同一个对象。 使用字面量方式创建的对象总是唯一的12345script&gt; var obj1 = &#123;name:\"zhangsan\"&#125;; var obj2 = &#123;name:\"zhangsan\"&#125;; console.log(obj1 == obj2); //false&lt;/script&gt; 使用new操作符创建对象实现单例 实现单例模式的几种途径 ① 在代码中提供一个全局变量来存储创建出来的实例 缺点:该全局变量可能会被轻易的修改和覆盖 ② 尝试在构造函数的静态成员中缓存实例属性。缺点:函数的静态属性在外部可以直接修改,容易导致实例对象的丢失。 ③ 将实例对象包装在闭包中。优点是安全性较好,无法被轻易的修改,缺点是有额外闭包的开销。 代码示例1234567function China() &#123;&#125;//创建对象var china01 = new China();var china02 = new China();//思考:如果想要实现单例模式,那么最终的结果必要是china01 和china02是同一个对象,那么如何实现 实现方案(一)使用全局变量方式存储创建出来的实例对象代码示例12345678910111213141516171819202122232425262728&lt;script&gt; //01 提供一个全局变量 var instance; //02 提供一个构造函数 function Person() &#123; if (instance == undefined) &#123; instance = this; &#125; this.name = \"默认的名称\"; this.age = 66; //使用全局变量来接收内部创建出来的实例对象(this) return instance; &#125; //03 使用构造函数创建对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2); console.log(p1.name); console.log(p2.name); p1.name = \"修改之后的名称\"; console.log(p1.name); console.log(p2.name); //说明:在上面的方案中我们使用一个全局变量来接收实例对象的值,在构造函数内部也是通过判断这个全局变量来做一些其他的处理 instance = &#123;&#125;; var p3 = new Person(); console.log(p1 == p3);&lt;/script&gt; 说明：这种方法确实可以实现单例模式,但是并不安全,因为全局变量可能会被轻易的修改或者是覆盖,因此不推荐这种方式。 实现方案(二)通过构造函数静态属性来缓存实例对象123456789101112131415161718192021222324252627&lt;script&gt; //01 提供一个构造函数 function Person() &#123; //02 在内部判断构造函数的静态属性中是否拥有实例对象 //如果拥有实例对象,那么就直接返回,否则就设置实例对象,并赋值给构造函数的静态属性 if (typeof Person.instance == \"object\") &#123; return Person.instance; &#125; //设置实例对象的属性和方法 this.name = \"默认的名称\"; this.age = 66; //03 把内部创建的实例化对象赋值给构造函数的静态属性 Person.instance = this; //显示返回 //return Person.instance; //隐式返回 //return this; &#125; //04 创建实例对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2); Person.instance = &#123;&#125;; var p3 = new Person(); console.log(p1 == p3); //false&lt;/script&gt; 说明：在构造函数外部可以直接访问其静态成员(属性和方法),可能会导致实例对象的丢失。 实现方案(二)通过闭包-惰性函数定义来实现12345678910111213141516171819202122&lt;script&gt; //01 提供一个构造函数 function Person() &#123; //02 在函数内部使用私有变量来缓存实例 var instance = this; //03 设置实例对象的属性和方法 this.name = \"默认的姓名\"; this.age = 66; //04 使用惰性函数定义来更新构造函数的实现 //通过一个闭包来返回缓存的实例对象 Person = function () &#123; return instance; &#125; &#125; //05 创建对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2); //代码说明:第一次调用原始构造函数的时候,它会像往常一样返回this(指向内部新创建的实例对象) //再后面调用的时候,它会执行更新后的构造函数,在这个新的函数实现中,我们通过闭包来访问了私有变量,并简单的返回。 //这个instance私有变量存储的是第一次调用构造函数时创建出来的实例对象&lt;/script&gt; 新的问题01 因为内部使用惰性函数定义(重写构造函数会导致之前添加在构造函数中的属性丢失),所以存在属性丢失问题02 在上面的代码中,体现在于创建对象前后设置的构造函数的原型对象丢失问题 代码示例123456789101112131415161718192021222324252627&lt;script&gt; function Person() &#123; var instance = this; this.name = \"默认的姓名\"; this.age = 66; Person = function () &#123; return instance; &#125; &#125; //设置构造函数的原型对象 Person.prototype.des = \"描述信息\"; var p1 = new Person(); //在创建第一个对象之后,设置原型对象 Person.prototype.someThing = \"something\"; var p2 = new Person(); console.log(p1 == p2); console.log(p1.des); //描述信息 console.log(p2.des); //描述信息 console.log(p1.someThing); //undefined console.log(p2.someThing); //undefined //打印对象的构造函数 console.log(p1.constructor.name); //Person console.log(p2.constructor.name); //Person //判断对象的构造函数 console.log(p1.constructor == Person); //false console.log(p1.constructor == p2.constructor,\"构造函数是否一致\");&lt;/script&gt; 解决问题的核心过程1234567891001 提供一个构造函数02 在构造函数内部提供一个私有变量instance03 重写构造函数,返回私有变量instance04 把原有的原型对象赋值给新Person构造函数的原型对象05 调用new 构造函数方法创建一个实例化对象赋值给instance06 修正instance实例的构造器属性,指向新的构造函数(注意:虽然重写了构造函数,但是instance的构造函数仍然是以前的Person)07 设置实例属性和方法08 返回instance对象代码示例 12345678910111213141516171819202122232425262728293031323334353637383940&lt;script&gt; function Person() &#123; //01 提供一个私有变量 var instance; //02 重写构造函数 Person = function () &#123; console.log(instance); //console.log(instance.constructor); var t = this; console.log(t); return instance; &#125;; //03 保留原型属性 Person.prototype = this.__proto__; //这是一个空的对象 Person.lal = \"lala\"; //04 创建并使用私有变量来接收实例对象 instance = new Person(); //05 修正构造函数指针 instance.constructor = Person; //06 设置实例属性和方法 instance.name = \"默认的名字\"; instance.age = 66; //07 返回私有变量 return instance; &#125; Person.haha = \"哈哈\"; //设置构造函数的原型对象 Person.prototype.des = \"描述信息\"; var p1 = new Person(); //在创建第一个对象之后,设置原型对象 Person.prototype.someThing = \"something\"; var p2 = new Person(); console.log(p1 == p2); console.log(p1.des); //描述信息 console.log(p2.des); //描述信息 console.log(p1.someThing); //something console.log(p2.someThing); //something //打印构造器属性 console.log(p1.constructor == Person,\"验证构造器指向\");&lt;/script&gt; 全局变量方式实现单例-改进版1234567891011121314151617181920&lt;script&gt; var Person; (function () &#123; //01 提供一个局部变量instance var instance; Person = function Person() &#123; if (instance) &#123; return instance; &#125; instance = this; this.name = \"默认的名字\"; this.age = 66; &#125; &#125;)(); //创建对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2);&lt;/script&gt; 说明：通过即时函数来限定作用域,外部无法修改内部instance的值(现在是一个局部变量) 工厂模式简单说明工厂模式的目的是用于创建对象,通常在类或者是类的静态方法中实现。 工厂模式的目标 01 用一套方法去创建相似的目标。 02 在编译时不知道具体类型的情况下,为用户提供创建对象的接口 工厂模式实现过程 01 提供一个父构造函数 02 在父构造函数的原型上添加共享的方法 03 在父构造函数身上提供一个静态方法(静态工厂方法) 001 先获取参数(产品类型) 002 判断构造函数是否存在(容错性处理) 003 设置原型链继承:设置子构造函数的原型对象为父构造函数的一个实例对象(目的是为了让子构造函数创建的对象拥有父构造函数上面实例属性和原型属性) 004 使用子构造函数创建实例对象 005 返回新创建的实例对象 04 定义特定的工厂客户(静态方法) 05 通过父构造函数的静态工厂方法来创建产品对象 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; //01 提供一个父构造函数 function PhoneMaker() &#123;&#125;; //02 在父构造函数的原型上添加共享的方法 PhoneMaker.prototype.callPhoneDes = function () &#123; console.log(\"手机的特点是: \" + this.des); &#125; //03 在父构造函数身上提供一个静态方法(静态工厂方法) PhoneMaker.factory = function (type) &#123; //001 先获取参数(产品类型) var typeStr = type; //002 判断构造函数是否存在(容错性处理) if (typeof PhoneMaker[typeStr] !== 'function') &#123; throw \"Error 对应的构造函数不存在,不能生产该种类型的产品\"; &#125; //003 设置原型链继承 PhoneMaker[typeStr].prototype = new PhoneMaker(); //004 使用子构造函数创建实例对象 var newPhone = new PhoneMaker[typeStr](); //005 返回新创建的实例对象 return newPhone; &#125;; //定义特定的工厂客户(静态方法) PhoneMaker.iphone = function () &#123; this.des = \"最安全稳定的系统\"; &#125; PhoneMaker.oppo = function () &#123; this.des = \"充当五分钟,通话两小时\"; &#125; PhoneMaker.vivo = function () &#123; this.des = \"vivo手机,你的音乐手机\"; &#125; //通过父构造函数的静态工厂方法来创建产品对象 var vivo = PhoneMaker.factory('vivo'); var iphone = PhoneMaker.factory('iphone'); var oppo = PhoneMaker.factory('oppo'); vivo.callPhoneDes(); oppo.callPhoneDes(); iphone.callPhoneDes();&lt;/script&gt; 观察者模式观察者模式观察者模式又名为发布-订阅者模式，它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。 观察者模式的特点（优点）12301 观察者模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案02 观察者模式可以取代对象之间硬性编码的通知机制，一个对象不再是显示的调用另外一个对象的接口，这种模式让两个对象松耦合的联系在一起，它们不需要清楚彼此的实现细节就能够相互通信。03 在这种设计模式中，不再是一个对象调用另外一个对象的方法，而是一个对象订阅另一个对象的特定活动并且在状态改变后获得通知 模型01 订阅者也称为观察者02 被观察的对象称为发布者或者是主题03 当发生一个重要事件的时候，发布者将会通知所有订阅者并且经常以事件的形式来传递消息。示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//01 提取成公共的发行者对象 var publisher = &#123; users:&#123; default:[] &#125;, //所有的订阅者对象 addUser:function (fn,type) &#123; //对订阅的类型进行判断 var type = type || \"default\"; //如果是新的订阅类型,那么我们需要做初始化的处理 if (this.users[type] == undefined) &#123; this.users[type] = []; &#125; this.users[type].push(fn); &#125;, removeUser:function (fn,type) &#123; this.tool(type,\"removerUser\",fn); &#125;, publish:function (type) &#123; this.tool(type,\"publish\"); &#125;, tool:function (type,funcType,fn) &#123; var type = type || \"default\"; var users = this.users[type]; if (users == undefined) &#123; console.log(\"当前没有任何订阅者\"); return; &#125; for (var i = 0; i &lt; users.length; i++) &#123; if (funcType == 'publish') &#123; users[i]() &#125;else &#123; if (users[i] == fn) &#123; users.splice(i, 1); break; &#125; &#125; &#125; &#125; &#125;; //02 提供一个工具函数,能够利用发行者对象的模板来快速创建新的发布者 function makePaper(o) &#123; for(var i in publisher) &#123; if (publisher.hasOwnProperty(i) &amp;&amp; typeof publisher[i] == 'function') &#123; o[i] = publisher[i]; &#125; &#125; o.users = &#123;default:[]&#125;; &#125; //03 创建发布者 var paper1 = &#123; day:function () &#123; this.publish(); &#125;, month:function () &#123; this.publish(\"month\") &#125;, year:function () &#123; this.publish(\"year\") &#125; &#125;; //把某个对象编程一个发布者 makePaper(paper1); //04 创建订阅者(当发布者发布消息的时候,订阅者能够收到信息--自动调用订阅者的方法) var obj = &#123; lookDayNews:function () &#123; console.log(\"obj - 查看最新的日报信息\"); &#125;, lookImageNews:function () &#123; console.log(\"obj - 查看图片信息\"); &#125; &#125;; //05 设置订阅 paper1.addUser(obj.lookDayNews); paper1.addUser(obj.lookImageNews,'month'); paper1.day(); paper1.month();&lt;/script&gt; 因本人能力有限，教程中难免出现疏忽，对此带来的不便敬请见谅。","categories":[{"name":"JavaScript简明教程","slug":"JavaScript简明教程","permalink":"http://www.1oveit.club/categories/JavaScript简明教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"有趣的Chrome DevTools","slug":"有趣的ChromeDevTools","date":"2016-11-11T13:46:45.000Z","updated":"2017-05-22T07:26:04.000Z","comments":true,"path":"2016/11/11/有趣的ChromeDevTools/","link":"","permalink":"http://www.1oveit.club/2016/11/11/有趣的ChromeDevTools/","excerpt":"Chrome 自带开发者工具很有趣，怎么个有趣法呢？Chrome的JS控制台有很多很多神奇而且有趣的功能。此文仅例举其中几个，一起来看看吧。 我们调试的时候控制台总会有一大堆密密麻麻的代码时，请试着输入 clear() 然后回车，清空所有，回到原始界面。","text":"Chrome 自带开发者工具很有趣，怎么个有趣法呢？Chrome的JS控制台有很多很多神奇而且有趣的功能。此文仅例举其中几个，一起来看看吧。 我们调试的时候控制台总会有一大堆密密麻麻的代码时，请试着输入 clear() 然后回车，清空所有，回到原始界面。 jq选择器第一个有趣的事情就是获取页面上的DOM元素啦！在控制台里通过jQuery选择器选取DOM元素. 如 $(&#39;tagName&#39;) $(&#39;.class&#39;) $(&#39;#id&#39;)等选择器。其实是通过document.querySelector(‘’)返回第一个匹配的DOM元素。通过 $$(&#39;tagName&#39;) $$(&#39;.className&#39;)两个$$符号来选择返回的一个相应的DOM数组。瞧： 获取DOM元素绑定事件其实也是一句代码搞定的事情，但是在调试的时候却非常有用。通过在控制台输入getEventListeners($(&#39;selector&#39;))返回数组对象的格式并且返回元素绑定的所有事件。然后通过getEventListeners($(&#39;selector&#39;)).click[0].listener获取元素绑定的click事件。 Chrome编辑器如果浏览器可以编辑，要记得导出喔。在控制台轻轻输入一句代码，然后试着编辑页面，接下来就是奇迹发生的时候！赶快试一下吧！ 监测事件通过输入monitorEvents($(&#39;selector&#39;)) 监测元素上绑定的所有事件，该元素某个事件被触发就会在控制台里显示出来。monitorEvents($(&#39;selector&#39;),&#39;eventName&#39;)监听元素上绑定的具体事件。第二个参数代表事件类型的名称。monitorEvents($(&#39;selector&#39;),[&#39;eventName1&#39;,&#39;eventName3&#39;,….])同时检测具体指定的多个事件类型。unmonitorEvents($(&#39;selector&#39;)) 用来停止对某个元素的事件监测。 表格形式输出数组先输入数组arr,然后通过输入console.table(variableName)以表格形式查看，如下图： 检查元素你可以直接在控制台里输入下面的方法来检查元素inspect($(&#39;selector&#39;)) 会检查所有匹配选择器的DOM元素，并返回所有选择器选择的DOM对象。inspect($(&#39;img&#39;)[1]) 检查并返回页面上第2个img元素。最后，Chrome DevTools是十分强大的调试工具，这只是冰上一角，深入了解请戳chrome-devtools","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.1oveit.club/tags/javascript/"},{"name":"Chrome DevTools","slug":"Chrome-DevTools","permalink":"http://www.1oveit.club/tags/Chrome-DevTools/"}]},{"title":"Css简明教程","slug":"css简明教程","date":"2016-11-05T13:26:03.000Z","updated":"2017-05-22T07:26:04.000Z","comments":true,"path":"2016/11/05/css简明教程/","link":"","permalink":"http://www.1oveit.club/2016/11/05/css简明教程/","excerpt":"Css简明教程，简洁明了。 CSS基础概念1.CSS的作用：修改样式","text":"Css简明教程，简洁明了。 CSS基础概念1.CSS的作用：修改样式格式：123456&lt;style type=”text/css”&gt; 选择器名称&#123;属性名称：属性对应的值；…&#125;&lt;/style&gt; 属性规定文字的属性 （1）规定文字的样式的属性： font-style:normal(正常的，默认) italic（倾斜） 快捷键：fsn→font-style:normal; （2）规定文字的粗线的属性： font-weight:lighter（细线，默认）bold（加粗） 取值：数字、单词 快捷键：fwb→font-weight:bold; （3）规定文字的大小的属性： font-size:30px; 取值：px（像素） 快捷键：fz30→font-size:30px; （4）规定文字的字体的属性： font-family:微软雅黑; 快捷键：ff→font-family:”微软雅黑”; 注意点：（1）如果取值是中文，需要用双引号或单引号括起来；（2）设置的字体必须是用户电脑里已经安装的字体；（3）如果设置的字体不存在，那么系统就会使用默认的字体来显示；（4）如果不想用默认的字体来显示，可以给字体设置备选方案 font-family: “微软雅黑”，“宋体”…;（5）如果想给中文和英文分别单独设置字体，但凡中文字体，里面都包含了英文；但凡英文字体，里面都不包含中文字体。补充：企业开发中常用的是字体有：中文：宋体 黑体 微软雅黑；英文：Times New Roman Arial；简写：font: style weight size family;注意点：style和weight可以调换位置也可以省略，size和family不可以调换位置也不可以省略，size必须放在family后面，size和family必须放在所有属性后面 规定文本的属性（1）文本装饰属性：text-decoration: ；取值：underline（下划线）/line-through（删除线）/overline（上划线）、none（什么都没有，常用于超链接去除下划线）（2）文本水平对齐属性：text-align: ；取值：right（右）/center（居中）/left（左，默认）（3）文本缩进属性：text-indent: ；取值：em 颜色控制属性color: ;取值：（1）英文（2）rgb（ , , ）：rgb其实就是三原色，其中r（red）g（green）b（blue），rgb（0,0,0）表示黑色，rgb（255,255,255）表示白色，rgb（255,0,0）表示红色，rgb（0,255,0）表示绿色，rgb（0,0,255）表示蓝色（3）rgba（ , , , ）：rgb其实就是三原色；a表示透明度，取值范围0-1，取值越小就越透明（4）十六进制#：本质就是rgb，每两位表示一个颜色（5）缩写十六进制：每个颜色的两位数都是一样的，那么就可以简写 规定背景属性（1）规定背景颜色属性：background-color:取值：英文单词 、rgb、rgba、十六进制、缩写十六进制注意点：同一个标签可以同时设置背景颜色和背景图片，如果颜色和图片同时存在，那么图片会覆盖颜色（2）规定背景图片属性：background-color: url(“”);注意点：图片地址必须放在url()中间，图片可以是本地地址也可以是网络上的地址如果图片的大小没有背景大，那么它会自动的在水平和垂直方向平铺和填充（3）规定背景图片平铺方式属性：background-repeat:取值：repeat:在水平和垂直方向上平铺，默认repeat-x:水平方向上平铺repeat-y:垂直方向上平铺（4）背景定位属性： background-position:水平方向 垂直方向；取值：1.具体的方位名词：水平方向：left right center;垂直方向：top bottom center;2.具体的像素： px注意点：数字可以为负数如何让一张很大的图片无论何时都居中显示?background-position:center top;（5）背景图片关联方式属性： background-attachment：取值：scroll 会随着滚动条而滚动，默认值 fixed 不会随着滚动条而滚动（6）背景尺寸属性：用于设置背景图片的大小 background-size： 取值：默认具体像素:background-size：px px;第一个值宽度，第二个值高度百分比：background-size：% %；宽度的等比拉伸：background-size：auto px;高度等比拉伸: background-size：px auto;cover:告诉系统图片需要等比拉伸到宽度和高度都填满元素contain：告诉系统图片需要等比拉伸到宽度或高度都填满元素 （7）规定背景图片的定位区域属性：告诉系统背景图片从哪个区域开始显示background-origin：取值：padding-box 默认，从padding区域开始显示 border-box从border区域开始显示 content-box从content区域开始显示（8）规定背景的绘制区域属性：用于指定从哪个区域开始绘制背景background-clip：取值：border-box默认，从border开始显示 padding-box 默认，从padding开始显示 content-box从content区域开始显示（9）多重背景图片：1234background:url(“”) no-repeat left top, url(“ ”) no-repeat right top, url(“”) no-repeat left bottom, url(“”) no-repeat right bottom; 注意点：多张图片之间用逗号隔开，先添加的图片会盖住后添加的图片编写多重背景图片时应分开来写123background-image:url(\"images/animal1.png\"),url(\"images/animal2.png\"),url(\"images/animal3.png\");background-repeat: no-repeat, no-repeat, no-repeat;background-position: left top, right top, left bottom; 简写：快捷键是bg+ background：背景颜色 背景图片 平铺方式 关联方式 定位方式；注意点：background的属性任何一个都可以省略 （10）Vertical-align:设置图片与盒子底部对齐 ：vertical-align: bottom;设置图片与盒子顶部对齐： vertical-align: top; 设置图片与文字基线对齐：vertical-align: baseline; 设置图片顶部与文字顶部对齐：vertical-align: text-top; 设置图片底部与文字底部对齐：vertical-align: text-bottom; 设置图片与文字中线对齐： vertical-align: middle; 规定边框的属性（1.1）连写格式一：同时设置四条边框的宽度、样式、颜色 border:边框的宽度 边框的样式 边框的颜色； （1.2）连写格式二：分别设置四条边框的宽度、样式、颜色border-top: 边框的宽度 边框的样式 边框的颜色；border-right:边框的宽度 边框的样式 边框的颜色；border- bottom:边框的宽度 边框的样式 边框的颜色；border- left:边框的宽度 边框的样式 边框的颜色；注意点：连写格式中颜色和宽度可以省略，但是样式不可以省略 （2.1）分开格式一：（1）规定边框的样式的属性： 格式：（同时设置四条边的样式）border-style:上 右 下 左 ；取值：dashed（虚线）solid（实线）注意点：设一个值（上下左右都是一样的） 设两个值（上下）（左右） 设三个值（上）（左右）（下） 设四个值（上）（右）（下）（左）（2）规定边框的宽度的属性：格式：（同时设置四条边的宽度）：border-width:上 右 下 左 ；（3）规定边框的颜色的属性： 格式：（同时设置四条边的颜色）border-color:上 右 下 左； （2.2）分开格式二：（1）规定边框的样式的属性：格式：（分别设置四条边的样式）border-top-style： ； border-light-style: ； border-bottom-style: ； border-left-style: ；（2）规定边框的宽度的属性：格式：（分别设置四条边的宽度）border-top-width： ； border-light-width: ； border-bottom-width: ； border-left-width: ；（3）规定边框的颜色的属性：格式：（分别设置四条边的颜色）border-top-color： ； border-light-color: ； border-bottom-color: ； border-left-color: ； border-radius：设置圆角属性四个参数:左上,右上, 右下 左下, 省略值和它的对角一样 分开写格式： border-top-left-radius: border-top-right-radius: border-bottom-left-radius: border-bottom-right-radius: 注意点：圆角的宽度=正方形的宽度一半就是圆圆角的宽度=长方形宽一半/高一半就是椭圆 圆角的宽度=长方形高就是半圆 圆角的宽度=正方形的边框宽度+宽度的一半就是圆环 4.border-image： 分开写格式： border-image-source: 边框的图片的路径border-image-slice: 设置裁剪的大小 如果是设置数字,则中间内容没有，想要中间也要有背景图片,则需要在最后添加一个参数为fillborder-image-width: 图片边框的宽度border-image-outset: 边框图像区域超出边框的量border-image-repeat: 图像边框是否应平铺(repeat)、自适应铺满(round)或拉伸(stretch)规定内边距的属性就是边框和内容之间的距离注意点：给标签设置内边距后，标签的宽度和高度会发生变化，内边距也会有背景颜色（1）连写格式：padding: 上 右 下 左; （2）分别设置格式： padding-top: ; padding-right: ; padding-bottom: ; padding-left: ; 规定外边距的属性就是标签和标签之间的距离注意点：外边距那一部分是没有背景颜色的 （1）连写格式：margin:上 右 下 左； （2）分别设置格式：margin-top: ; margin-right: ; margin-bottom: ; margin-left: ; 外边距合并的现象： 在默认布局的水平方向上，默认情况外边距是会叠加的 在默认布局的垂直方向上，默认情况外边距是会合并的，谁的外边距比较大就听谁的注意点：1.如果两个盒子是嵌套关系，那么设置了里面有个盒子的顶部的外边距，外面一个盒子也会被顶下来2.如果外面的盒子想保持不变，那么需要给外面的盒子添加一个边框属性3.在企业开发中，一般情况下如果需要控制嵌套关系盒子之间的距离，应该首先考虑padding,其次再考虑margin,因为它本质上是控制兄弟关系之间的间隙的4.在嵌套关系的盒子中，可以利用margin: 0 auto;方式让小盒子在大盒子中水平居中，并且margin: 0 auto;只对水平方向有效margin: 0 auto;和text-align:center;的区别：margin: 0 auto;让盒子中存储的文字和图片水平居中text-align:center;让盒子水平居中清除默认边距（外边距和内边距）：企业开发中为了更好的控制盒子的宽高和计算盒子的宽高，在编写代码前第一件事先清楚默认边距123*&#123;margin:0;padding:0;&#125; 注意点：通配符选择器会找到(遍历)当前界面中所有的标签，所以性能不好企业开发中可以从这个网址中拷贝：http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css 行高属性（行高可以撑起盒子的高度，有时可以省略盒子的高度） 格式： line-height: ； 要想一行文字在盒子中垂直居中那么只需要设置这行文字的行高等于盒子的高度即可 如果是多行文字那么只能通过设置padding来让文字居中 CSS盒子模型：什么是盒子模型CSS盒子模型只是一种形象的比喻，HTML中所有的标签都是盒子结论； （1）在HTML中所有标签都可以设置宽度和高度 宽度/高度 == 存放内容的区域 内边距 ==内容与边框的距离 边框 == 外边距 == （2）内容的宽度和高度：width/height 元素的宽度和高度： 宽度=左边框+左内边距+width+右内边距+右边框 高度同理可证 元素空间的宽度和高度： 宽度=左外边距+左边框+左内边距+width+右内边距+右边框+右外边距 高度同理可证 规律：1.增加了padding之后元素的宽高也会发生变化 2.如果增加了padding之后还想继续保持元素的宽高，那么就必须减去内容的宽高 1.增加了border之后元素的宽高也会发生变化 2.如果增加了border之后还想继续保持元素的宽高，那么就必须减去内容的宽高 盒子box-sizing属性 作用：保证盒子增加了padding和border后，盒子的宽度和高度不变 取值：content-box：默认值，元素的宽高=边距+内边距+内容宽高border-box；元素的宽高==width属性 选择器标签选择器 作用：根据指定的标签名称，在当前界面中找到所有该名称的标签，然后设置属性格式：123标签名称&#123;属性：值；&#125; 注意点：（1）标签选择器选中的是当前界面中的所有标签，而不能单独选中一个标签 （2）标签选择器无论标签藏得多深都能选中 （3）只要是HTML中是标签都可以做标签选择器 id选择器作用：根据指定的id名称找到对应的标签，然后设置属性格式：123#id名称&#123;属性：值；&#125; 注意点：（1）每个HTML都有一个属性叫做id，也就是说每个标签都可以设置id （2）在一个界面中id的名称是不可以重复的 （3）编写id选择器时一定要在id名称面前加上# （4）id的名称是由一定规范的：只能有字母/数字/下划线组成，并且不能以数字开头，企业开发过程中一般都是以字母开头的。Id名称不能是HTML标签的名称。 （5）如果仅仅是为了设置样式，企业开发中一般不会使用id，因为在前端开发中id 是留给js使用的 类选择器 作用：根据指定的类名称找到对应的标签，然后设置属性格式：123.类名&#123;属性：值；&#125; 注意点：（1）每个HTML都有一个属性叫做class，也就是说每个标签都可以设置类名 （2）在一个界面中class的名称是可以重复的 （3）编写class选择器时一定要在类名称面前加上. （4）类的名称是由一定规范的：只能有字母/数字/下划线组成，并且不能以数字开头，企业开发过程中一般都是以字母开头的，不能是HTML标签的名称 （5）类名是专门用来给某个特定的标签设置样式的 （6）在HTML中每个标签是可以同时绑定多个类名 格式：&lt;标签名称 class=”类名1 类名2 ……”&gt; id选择器与class选择器的区别： （1）id相当于人的身份证不可以重复，class相当于人的名称可以重复 （2）一个HTML标签名称只能绑定一个id名称，可以绑定多个class名称 （3）id选择器是以#开头，class是以.开头 （4）id一般是给js使用的，所有除非特殊情况，否则不要使用id去设置样式 后代选择器 作用：找到指定的标签的所有后代标签，然后设置属性格式：123标签名称1 标签名称2&#123;属性：值；&#125; 先找到名称叫做标签名称1的标签，再在这个标签下去查找所有名称叫做标签名称2的标签，然后设置属性 注意点： （1）后代选择器必须用空格隔开 （2）后代不仅是儿子，也包括孙子等等，只要最终是放在指定标签的都是后代 （3）后代选择器不仅仅可以使用标签名称，还可以使用其他选择器 子元素选择器 作用：找到指定标签中所有特定的直接子元素，然后设置属性格式：123标签名称1&gt;标签名称2&#123;属性：值；&#125; 先找到名称叫做标签名称1的标签，然后再在这个标签下去查找所有直接子元素名称叫做标签名称2的标签，然后设置属性 注意点： （1）子元素选择器之间需要用&gt;符号连接，并且不能有空格 （2）子元素选择器只会查找儿子，不会查找其他被嵌套的标签 （3）子元素选择器不仅仅可以使用标签名称，还可以使用其他选择器 后代选择器与子元素选择器的区别与联系： （1）后代选择器用空格作为连接符号，子元素选择器用&gt;作为连接符号 （2）后代选择器会选中指定标签中所有的特定后代标签，子元素选择器只会选中指定标签中的所有特定标签中的直接标签 （3）后代选择器和子元素选择器都可以使用标签名称/id名称/class名称作为选择器，都可以通过各自的连接符号一直延续下去 （4）在企业开发中如果想选中所有特定的标签，那么就使用后代选择器，如果只想选中指定标签中的所有特定儿子标签，那就使用子元素选择器 交集选择器 作用：给所有选择器选中的标签中，相交的那部分设置属性 格式：123 选择器1选择器2&#123;属性：值；&#125; 注意点：（1）选择器和选择器之间没有任何的连接符号 （2）选择器可以使用标签名称/id名称/class名称 （3）企业开发中用的比较少 并集选择器 作用：给所有选择器选中的标签设置属性 格式：123 选择器1，选择器2&#123;属性：值；&#125; 注意点：（1）选择器和选择器之间必须用，来连接 （2）选择器可以使用标签名称/id名称/class名称 兄弟选择器1.相邻兄弟选择器：（CSS2）作用：给指定选择器后面紧跟的那个选择器选中的标签设置属性 格式：123 选择器1+选择器2&#123;属性：值；&#125; 注意点：（1）选择器和选择器之间必须用+来连接 （2）选择器可以使用标签名称/id名称/class名称 （3）相邻兄弟选择器只能选中紧跟其后的那个标签，不能选中隔开的标签 2.通用兄弟选择器：（CSS3）作用：给指定选择器后面的所有选择器选中的所有标签设置属性 格式：123 选择器1~选择器2&#123;属性：值；&#125; 注意点：（1）选择器和选择器之间必须用~来连接 （2）选择器可以使用标签名称/id名称/class名称 （3）相邻兄弟选择器选中的是指定选择器后面某个选择器选中的所有标签，无论有没有隔开 序选择器1.同级别的第几个 （1）first-child:选中同级别的第一个标签 （2）last-child:选中同级别的最后一个标签 （3）nth-child（n）:选中同级别中的第n个标签 （4）nth-last-child（n）:选中同级别中的倒数第n个标签 （5）only-child：选中父元素中唯一的元素 （6）nth-child(odd):选中同级别中的奇数行 （7）nth-child(even):选中同级别中的偶数行 （8）nth-child(xn+y):x、y用户自定义，n是计数器，从0开始递增 注意点：不区别类型 2.同类型的第几个 （1）first-of-type:选中同级别中同类型的第一个标签 （2）first-of-type:选中同级别中同类型的最后一个标签 （3）nth-of-type（n）:选中同级别中同类型的第n个标签 （4）nth-last-of-type（n）:选中同级别中同类型的倒数第n个标签 （5）only-of-type：选中父元素中唯一类型的某个标签 属性选择器作用：根据指定的属性名称找到对应标签，然后设置属性（1）格式：[属性]（2）格式：[属性=value]（3）格式（属性的取值是以什么开头的）： [属性|=value] （CSS2） [属性^=value] （CSS3） 两者之间的区别：CSS2中的只能找到以value开头，并且value是被-和其他内容隔开的，CSS3中的只要是以value开头的都可以找到（4）格式（属性的取值是以什么结尾的）： [属性$=value] （CSS3）（5）格式（属性的取值是否包含某个特定的值）： [属性~=value] （CSS2） [属性*=value] （CSS3） 两者之间的区别：CSS2中的只能找到独立的单词，也就是包含value，并且是被空格隔开的，CSS3中的只要包含value就可以找到 通配符选择器作用：给当前界面上所有的标签设置属性 格式：*{ 属性：值；} 注意点：由于通配符选择器是给界面所有的标签设置属性，所以在设置之前会遍历所有的标签，如果标签比较多，那么性能就会比较差，所有一般在企业开发中不会使用它 CSS三大特性继承性作用：给父元素设置一些属性，子元素也可以使用 注意点：（1）并不是所有的属性都可以继承，只有以color/font-/text-/line开头的属性可以继承。 1.不仅是儿子可以继承，后代都可以继承。2.CSS继承性的特殊性：a标签的文字属性和下划线是不能继承的，h标签的文字大小是不能继承的 应用场景：在企业开发中，一般用于设置网页的一些共性信息，例如网页的文字颜色，字体，大小等 层叠性作用：层叠性是CSS处理冲突的一种能力 注意点：层叠性只有在多个选择器选中“同一个标签”，又设置的 “相同属性”，才会发生层叠性 优先级作用：当多个选择器选中同一个标签，并且给同一个标签设置相同的属性时，如何层叠就由优先级来确定 优先级的判断方式： （1）是否是直接选中（间接选中就是指继承）：如果是间接选中那么就是谁离目标标签比较近就听谁的 （2）相同选中器：如果都是直接选中并且是相同选中器那么谁写在后面就听谁的 （3）不同选择器：如果都是直接选中并且不是相同选中器，那么就按照选择器的优先级来层叠：id&gt;类&gt;标签&gt;通配符&gt;继承&gt;浏览器默认 !important属性作用：用于提升某个直接选中标签的选择器中的某个属性的优先级，可以将被指定的属性的优先级被提升为最高 注意点：（1）只能用于直接选中，不能用于间接选中 （2）只能提升被指定的属性的优先级，其他属性的优先级不变 （3）通配符选择器选中的标签也是直接选中 权重问题： 作用：当多个选择器混合在一起使用时，我们可以通过计算权重来判断谁的优先级最高 权重的计算规则：（1）首先先计算选择器中有多少个id，id多的选择器优先级最高 （2）如果id的个数一样，那么再看类名的个数，类名个数多的优先级最高 （3）如果类名的个数一样，那么再看标签名称的个数，标签个数多的优先级最高 （4）如果id个数一样，类名个数一样，标签名称个数一样，那么此时谁写在后面就听谁的，即优先级一样的时候，谁写在后面就听谁的 注意点：只有选择器直接选中标签才需要计算权重 CSS元素显示模式1.div和span 1.div 作用:一般配合CSS完成网页的基本布局 2.span 作用：一般配合CSS修改网页中的一些局部信息 两者区别：（1）div会单独占领一行，而span不会单独占领一行 （2）div是一个容器级的标签，而span是一个文本级的标签 容器级标签和文本级标签的区别： 容器级的标签中科院嵌套其他所有的吧，而文本级的标签只能嵌套文字/图片/超链接标签容器级的标签：div h u lol li dt dd…… 文本级的标签：span p buis e mind del…… 2.块级元素、行内元素、行内块级元素（1）块级元素：独占一行；如果没有设置宽度，那么默认和父元素一样宽；如果设置了宽度，就按照设置的宽度来显示p div h ul oi li dt dd……（2）行内元素：不会独占一行；如果没有设置宽度，那么默认和内容一样宽；行内元素是不可以设置宽度的span buis strong em ins del……（3）行内块级元素：为了能够让元素既能够不独占一行，又可以设置宽度和高度，那么就出现了块级行内元素 如何转换CSS元素的显示模式？设置元素的display属性取值：block 将元素转换为块级元素inline 将元素转换为行内元素inline-block 将元素转换为行内块级元素 网页布局方式网页元素排版网页的布局方式其实就是指浏览器是如何对网页的元素进行排版的 （1）标准流（文档流/普通流）排版方式浏览器的默认排版方式，有两种排版方式：垂直排版：如果元素是块级元素，那么就会垂直排版水平排版：如果元素是行内元素/行内块级元素，那么就会水平排版 （2）浮动流排版方式【1】浮动流是一种半脱离标准流的排版方式，只有水平排版方式，它只能设置某个元素向左对齐或向右对齐 注意点： （1）浮动流中是没有居中对齐的 （2）浮动流中是不可以使用margin:0 auto; 特点： （1）在浮动流中是不区分行内元素/块级元素/行内块级元素，无论是内元素/块级元素/行内块级元素都可以水平排版，都可以设置宽高 （2）浮动流中行内元素/块级元素/行内块级元素都可以设置宽高 【2】浮动元素脱标： 当某一个元素浮动之后，那么这个元素看上去就像被从标准流中删除一样 脱标后的影响：如果前面一个元素浮动了，而后面一个元素没有浮动，那么这个时候前一个元素就会盖住后面一个元素 【3】浮动元素排序规则： （1）相同方向上的浮动元素，先浮动的元素会显示在前面，后浮动的元素会显示在后面 （2）不同方向上的浮动元素，左浮动找左浮动，有浮动找右浮动 （3）浮动元素浮动后的位置由浮动元素浮动之前在标准流中的位置来决定 【4】浮动元素贴靠方式： （1） 当父元素足够放下所有浮动元素的时候，那么浮动元素就会并列显示 （2）当父元素不够放下所有浮动元素的时候，那么就会从最后一个元素开始向前一个元素贴靠，一直往前贴，直到贴到父元素的边框，这是不管父元素够不够都会贴靠在那里 【5】浮动元素字围现象：浮动元素不会挡住没有浮动元素中的文字, 没有浮动的文字会自动给浮动的元素让位置,这个就是浮动元素字围现象【6】浮动元素高度问题： （1）在标准流中内容的高度是可以撑起父元素的高度 （2）在浮动流中浮动元素是不可以撑起父元素的高度 【7】清除浮动： 《1》方式一：给前面一个元素设置高度 注意点：在企业开发中，我们能不写高度就不写高度，所以这种方式用的比较少 《2》方式二：给后面一个元素添加clear属性 取值：none:默认取值，按浮动元素的规则来排序(右浮动找右浮动,左浮动找左浮动) left:不要找前面的左浮动 right:不要找前面的右浮动 both: 不要找前面的左浮动和右浮动 注意点：当给某个元素添加clear属性之后，那么这个属性的margin属性就会失效 《3》方式三：隔墙法 （1）外墙法：在两个盒子之间添加一个额外的块级元素，并且给这个块级元素添加clear:both;属性 注意点：外墙法可以让第二个盒子使用margin-top属性，但不可以让第一个盒子使用margin-bottom属性。一般在企业开发中，是直接给额外添加的块级元素添加一个高度 （2）内墙法：在第一个盒子中所有子元素最后添加一个额外的块级元素，并且给这个块级元素添加clear:both;属性 注意点：内墙法可以让第二个盒子使用margin-top属性，也可以让第一个盒子使用margin-bottom属性。 （3）区别：外墙法不能撑起第一个盒子的高度，而内墙法可以撑起第一个盒子的高度 《4》方式四：伪元素选择器： 作用：给指定标签的内容前面添加一个子元素或者给指定标签的内容后面添加一个子元素 （1）格式一:给指定标签的内容前面添加一个子元素 标签名称：：before{ 属性名称：值； content: ； 给指定添加的子元素中存储的内容 width: ; height: ; 给指定添加的子元素的宽度和高度 display:block; 给指定添加的子元素的显示模式 visibility:hidden; 隐藏添加的子元素} （2）格式二：给指定标签的内容后面添加一个子元素 标签名称::after{ 属性名称：值； content: ； 设置添加的子元素的内容为空 height:0 ; 设置添加的子元素的高度为0 display:block; 设置添加的子元素为块级元素 visibility:hidden; 隐藏添加的子元素 clear:both; } 兼容IE6：给第一个盒子添加 .box1{*zoom:1;} 《5》 方式六：overflow:hidden; 作用：（1）可以将超出标签范围的内容裁剪掉 （2）可以清处浮动 （3）可以通过overflow:hidden;让里面的盒子设置margin-top之后，外面的盒子不被顶下来 注意点：可以让第二个盒子使用margin-top属性，也可以让第一个盒子使用margin-bottom属性 定位流排版方式《1》相对定位:相对于自己以前在标准流中的位置来移动格式：position:relative注意点：不会脱离标准流的，会继续在标准流占用一定的空间 需要配合 top right left bottom 来使用，但同一方向定位属性只能使用一个 由于相对定位是不脱离标准流的，所以是区分块级元素/行内元素/行内块级元素 由于相对定位是不脱离标准流的，并且相对定位的元素会占用标准流中的位置，所以当给相对定位元素设置margin/padding等属性会影响到标准流的布局应用场景：用于对元素进行微调（想让多个盒子对齐时可以使用【想让多个盒子顶部对齐也可以使用浮动定位】}）配合绝对定位来使用《2》绝对定位：相对于body来定位 格式：position：absolate 定位的参考点规律：默认情况下所有的绝对定位元素是相对于body来定位如果绝对定位的元素有祖先元素，并且祖先元素也是定位流，那么这个绝对定位元素就会以定位流（相对定位/绝对定位/固定定位）的那个祖先元素作为参考点如果绝对定位的元素有多个定位流的祖先元素，那么这个绝对定位流元素就会以离它最近的那个祖先元素作为参考点 注意点：绝对定位是脱离标准流的，不区分块级元素/行内元素/行内块级元素 需要配合 top right left bottom 来使用，但同一方向定位属性只能使用一个 如果一个绝对定位的元素是以body作为参考点，那么其实是以网页首屏的宽度和高度作为参考点，而不是整个网页的宽度和高度作为参考点的 一个绝对定位元素是会忽略祖先元素的padding应用场景：用于对元素的微调,配合相对定位来使用 子绝父相（子元素用绝对定位，父元素用相对定位）相对定位的弊端：不脱离标准流，会继续占用一定的空间，不利于布局界面绝对定位的弊端：默认情况下绝对定位是以body作为参考点，不会随着浏览器的宽度高度的变化而变化 应用场景：当某一个元素覆盖在另一个元素上面时，需要用到定位流绝对定位的水平居中问题： 只需设置绝对定位元素的left:50%; 然后在设置绝对定位元素的margin-left:-元素宽度的一半px 《3》固定定位：固定定位和背景关联方式很像，背景定位可以让背景图片不随着滚动条而滚动，而固定定位可以让某个元素不随着滚动条而滚动 格式：position:fixed; 注意点：固定定位的元素是脱离标准流的，不会占用标准流的空间 固定定位和绝对定位一样，不区分块级元素/行内元素/行内块级元素 应用场景：导航条在网页顶部的固定位置,网页两侧的广告,底部返回顶部的按钮《4》静态定位（默认状态） 格式：position:static定位流z-index:专门用于控制定位流的覆盖关系 规律：默认情况下所有的元素都有一个z-index属性，取值为0 默认情况下定位流元素覆盖标准流的元素 默认情况下定位流的元素后遍写的覆盖先编写的，如果定位流元素中设置了z-index属性，那么谁的z-index比较大，谁就显示在上面注意点：从父现象 （1）如果两个元素父元素都没有设置z-index属性，那么谁的z-index比较大，谁就显示在上面 （2）如果两个元素父元素都设置了z-index属性，那么子元素的z-index就会失效，谁的父元素z-index属性比较大，那么谁就会显示在上面 a标签伪类选择器 （1）作用：专门用来修改a标签不同状态的样式 （2）状态：从未被访问过（默认状态）、被访问过状态、鼠标长按状态、鼠标悬停在上面状态（3）格式：a:link{color： ;}修改从未被访问过状态下的样式 a:visited{color: ;}修改被访问过状态下的样式 a:active{color: ;}修改鼠标长按状态下的样式 a:hover{color: ;}修改鼠标悬停a标签上状态下的样式 （4）注意点： a标签伪类选择器可以单独初中，也可以同时出现。同时出现需要严格准守爱恨原则（love hatd）：a:link、a:visited、 a:hover、a:active 如果默认状态和被访问过状态是一样的，可以简写a{color:} 在企业开发中编写a标签伪类选择器最好写在标签选择器后面 在企业开发中和a标签盒子相关属性都写在标签选择器中（显示模式/宽度/高度/padding/margin） 在企业开发中和a标签文字/背景相关属性都写在伪类选择器中（5）悬停在链接上背景颜色的改变：http://localhost:63342/HTML5学习代码/A标签伪类选择器.html 过渡模块1.格式：1234567选择器&#123; transition-property:属性； transition-duration:时间&#125; 标签:hover&#123;属性：值；&#125; 2.过渡三要素：hover可以使用在任何标签上transition-property: 告诉系统哪个属性需要执行过渡效果 transition-duration:告诉系统过渡效果持续的时长注意点：当多个属性需要同时执行过渡效果，用逗号隔开即可3.其他属性； transition-delay:告诉系统延迟多久后再执行过渡动画 transition-timing-function:告诉系统过渡动画的运动速度 取值：linear匀速 ease逐渐慢下来 ease-in加速 ease-out减速 ease-in-out先加速再减速 4.连写：transition：property duration timing-function delay；注意点：如果多个属性需要同时执行过渡效果，用逗号隔开即可 连写的时候可以省略后面两个参数，因为只有编写了前面两个参数就已经满足了过渡三要素 如果多个属性运动的速度/延迟的时间/持续的时间都一样，那么可以简写为transition：all 值；5.编写过渡套路：先编写基本界面，再修改我们认为需要修改的属性，最后给被修改属性的那个元素添加过渡即可 2D转换模式1.格式：1选择器：hover&#123;transform: ；&#125; 取值：rotate(数字deg) 旋转多少度 translate（ px, px） 平移 第一个值代表水平方向，第二个值代表垂直方向 scale（ , ） 缩放第一个值代表水平方向，第二个值代表垂直方向，取值1代表不变，大于1 代表放大，小鱼1代表缩小。如果水平垂直方向缩放都一样，可以简写为一个参数注意点：如果父元素被缩放了，那么子元素也会被缩放2.综合效果： transform: rotate(数字deg) translate（ px） scale（ , ）；注意点：需要用空格隔开。2D的转换会修改元素坐标系，所以旋转后再平移就不是水平平移了3.形变中心点： 格式：1选择器&#123;：transform-origin： px px；&#125; 第一个参数代表水平方向，第二个参数代表垂直方向 取值：像素、百分比、单词 默认情况下所有的元素都是以自己的中心点作为参考来旋转4.旋转轴点：（1）默认情况下所有的元素都是围绕Z轴进行旋转：transform: rotateZ(数字deg)（2）围绕X轴进行旋转：transform: rotateX(数字deg)（3）围绕Y轴进行旋转：transform: rotateY(数字deg)注意点：屏幕的原点在左上角 左上角transform: rotate(0% 0%)中心点transform: rotate(50% 50%)5.透视属性：近大远小 perspective: px;注意点：想看到近大远小的效果越明显那么像素值就设置越大，想看到近大远小的效果越模糊那么就像素设置越大必须添加到需要呈现近大远小效果的元素的父元素上面 盒子阴影和文字阴影1.盒子阴影：box-shadow:h-shadow v-shadow blur spread color inset;h-shadow水平偏移v-shadow垂直偏移blur模糊度spread阴影扩展color阴影颜色inset内外阴影注意点：盒子阴影分内外阴影，默认是外阴影 快速添加盒子阴影：box-shadow:h-shadow v-shadow blur，阴影颜色由盒子内容颜色决定2.文字阴影：text-shadow:h-shadow v-shadow blur color注意点：快速添加文字阴影test-shadow:h-shadow v-shadow blur，阴影颜色由文字颜色决定3.翻转菜单http://localhost:63342/HTML5学习代码/翻转菜单.html 动画模块1.动画与过渡的异同： 不同点：过渡必须人为的触发才会执行动画 动画不需要人为的触发就会执行动画相同点：过渡与动画都是用来给元素添加动画的，都是系统新增的一些属性，都需要满足三要素才会有动画效果2.动画三要素： （1）告诉系统需要执行哪个动画 （2）告诉系统我们需要自己创建一个名称叫做xxx的动画 （3）告诉系统动画持续的时长3.格式一：（起始动画）12345678910111213141516171819202122232425262728293031 选择器&#123;animation-name: ； animation-duration: ； &#125; @keyframes 动画名称&#123;form&#123;&#125;to&#123;&#125;&#125;格式二：（百分比）选择器&#123;animation-name: ；animation-duration: ；&#125;@keyframes 动画名称&#123;0%&#123;&#125;25%&#123; &#125;50%&#123;&#125;75%&#123;&#125;100%&#123;&#125;&#125; 4.其他属性： animation-delay:告诉系统延迟多久后再执行动画 animation-timing-function:告诉系统动画的执行的速度 取值：linear匀速 ease逐渐慢下来 ease-in加速 ease-out减速 ease-in-out先加速再减速 animation-iteration-count:告诉系统动画被播放的次数 animation-direction:告诉系统是否需要执行往返动画 取值：normal:默认，执行完一次之后回到起点再执行下一次 alternate：执行完一次之后往回执行下一次 animation-play-state: : 告诉系统当前动画是否需要暂停 取值:running: 执行动画 paused: 暂停动画 动画的状态：等待状态 、开始状态 、结束状态 animation-fill-mode:指定动画的等待状态和结束状态的样式 取值：none:不做任何改变 forwords：让元素结束状态保持最后一帧的样式 backwordes：让元素等待状态时候显示动画的第一帧样式 both：让元素等待状态时候显示动画的第一帧样式，让元素结束状态保持最后一帧的样式5.注意点：（1）动画中如果有和默认样式中同名的属性，会覆盖覆盖默认样式中的同名属性 （2）在编写动画的时，固定不变的值写在前面，需要变化的值写在后面6.连写格式：animation：动画名称 动画时长 动画运动速度 延迟时间 执行次数 往返动画；简写模式：animation：动画名称 动画时长 动画运动速度； 3D转换模块1.2D和3D： 2D就是一个平面，只有看到和高度，没有厚度 3D就是一个立体，有宽度和高度，还有厚度 默认情况下，所有元素都呈现2D展现的2.如何让元素呈3D展现？ 和透视效果一样，想看到某个元素的3D效果，只需要给它的父元素添加一个transform-style属性，然后设置perspective-3d即可3.正方体 编写顺序：（先旋转再平移）上 后 下 前 左 右4.长方体：先编写正方体然后再对上后下前四个面进行拉伸 渐变1.线性渐变：直接设置渐变：background: linear-gradient(red,blue);添加渐变方向：background: linear-gradient(to right, red,blue); 可以根据角度设置渐变方向：background: linear-gradient(45deg,red,blue);设置渐变到下一颜色的位置：background: linear-gradient(to right,red 30%,green 80%,blue); 2.径向渐变：默认从中点开始扩散：background: radial-gradient(red,green,blue); 大小范围,位置,颜色：background: radial-gradient(100px at center center,red,blue);可以通过像素进行设置位置：background: radial-gradient(100px at 50px 50px,red,blue);3.重复渐变： 重复线性渐变：background: repeating-linear-gradient(to right,red 10%,blue 20%); 重复径向渐变：background: repeating-radial-gradient(red 10%, blue 20%, yellow公共的项目类写在第一个小范围调整时，使用相对定位；大范围调整使用绝对定位谷歌浏览最小字体是12px，如果想字体再小一些，可以使用缩放属性（inline-block）在一个盒子中，如果一个元素添加了浮动，那么其他元素也要进行浮动，为了页面的稳定性.webpictuer网页图片，谷歌独有图片，图片被压缩处理过，但图片清晰度不会改变，加载速度快 1.如果图片的宽度小于父元素的宽度, 那么可以使用text-align: center;来居中图片2.如果图片的宽度大于父元素的宽度, 但是图片的宽度是已知的, 那么可以使用定位流 left:50%; margin-left: -图片宽度的一半;3.如果图片的宽度大于父元素的宽度, 但是不知道图片的宽度, 那么可以使用给父元素添加text-align: center; 给图片添加margin: 0 -100%;","categories":[{"name":"Css简明教程","slug":"Css简明教程","permalink":"http://www.1oveit.club/categories/Css简明教程/"}],"tags":[{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"},{"name":"css","slug":"css","permalink":"http://www.1oveit.club/tags/css/"}]},{"title":"HTML简明教程","slug":"HTML简明教程","date":"2016-10-18T15:45:46.000Z","updated":"2017-05-22T07:26:04.000Z","comments":true,"path":"2016/10/18/HTML简明教程/","link":"","permalink":"http://www.1oveit.club/2016/10/18/HTML简明教程/","excerpt":"简单的概念，简洁明了。 常识1.什么是浏览器？功能：（1）将网页渲染出来让用户查看（2）并让用户与网页交互的一种软件主流浏览器：IE（内核：Trident） 火狐（内核：Gecko） 谷歌（内核：Webkit/Blink） Safari（内核：Webkit） 欧朋（内核：Presto）因为内核不同，所以渲染的网页有所不同","text":"简单的概念，简洁明了。 常识1.什么是浏览器？功能：（1）将网页渲染出来让用户查看（2）并让用户与网页交互的一种软件主流浏览器：IE（内核：Trident） 火狐（内核：Gecko） 谷歌（内核：Webkit/Blink） Safari（内核：Webkit） 欧朋（内核：Presto）因为内核不同，所以渲染的网页有所不同2.什么是服务器？超级计算机，24小时不断电不关机，专门用于存储数据 3.什么是URL?我们在浏览器的地址栏输入的就是URL，eg：http://127.0.0.1:80/index.htmlhttp:// URL协议类型127.0.0.1 服务器IP地址:80 服务器的端口号/index.html 需要访问的资源名称 HTML基础1.HTML（超文本标记语言）作用：专门用来描述文本语义的，也就是说告诉浏览器哪些是标题哪些是段落。注意事项：HTML作用只有一个专门给文本添加语义的，不是用来修改文本样式的。&lt;h1&gt;标签的作用是告诉浏览器哪些文字是标题，即给指定文字添加标题语义的.html是纯文本文件 2.乱码问题：（1）基本上都保存为UTF-8:&lt;meta charset=”UTF-8”&gt;（2）保存网页的字符集和网页中指定的字符集设置为一致 3.DTD文档声明：不是HTML标签，必须在第一行，不区分大小&lt;!DOCTYPE html&gt;：HTML5的DTD文档声明是上下兼容的 HTML标签1.标签分类：（1） 双标签1&lt;html&gt;&lt;/html&gt; &lt;title&gt;&lt;/title&gt; &lt;body&gt;&lt;/body&gt;…… 单标签 `&lt;meta&gt; &lt;br&gt;……` （2） 兄弟关系 &lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;嵌套关系 &lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt; 2.&lt;hn&gt;标签：&lt;h1&gt;~&lt;h6&gt; 注意点：（1）H标签是用来给文本添加标题语义的（2）被H系列标签包裹的内容会独占一行（3）在企业开发中一般情况下一个界面只能出现一个H1标签 3.&lt;p&gt;标签：作用：告诉浏览器哪些文字是一个段落注意点：在浏览器中会独占一行 4．&lt;hr&gt;标签：分割线 注意点：在浏览器中会独占一行 5.img标签 （1）格式：&lt;img src=””alt=””title=”” &gt; （2）注意点： 如果我们不指定img标签的宽度和高度，那么系统按照默认图片宽度和高度，如果我们手动指定了Img标签的宽度和高度，有可能导致图片变形。 如果想指定img标签的宽度和高度，又不想图片变形，我们只能只指定宽度或高度其中一个 （3）常用属性： src：用来显示图片的路径 title：用来告诉浏览器，当鼠标悬停在图片上时，需要弹出的描述框中显示什么内容 alt:当需要显示的图片找不到的时候显示什么内容 6.&lt;br&gt;：用于换行 注意点： 多个br标签可以同时使用由于HTML是用于给文本添加语义的，而br标签的语义不是另起一个段落，所以在企业开发中很少使用它 7.路径问题 给src属性赋值有两种方式： （1）相对路径:每次都是从.html文件所在的文件夹开始查找 同级：图片和.html文件存储在同一个文件夹中，格式：src=”xxx.xxx” 下级：存储图片的文件夹和.html文件在同一个文件夹中，格式：src=”xxx/xxx.xxx” 上级：存储图片的位置和存储代码的文件夹在同一个文件夹中，格式：src=”../xxx.xxx” （2）绝对路径:每次都是从指定的盘符开始查找 注意点： 企业开发中如果需要编写路径，统一使用反斜杠/ 企业开发中一般不使用绝对路径，因为可移植性不好 8.a标签：用于控制页面与页面之间的跳转 （1）格式：&lt;a href=””&gt;&lt;/a&gt; （2）注意点： a标签不仅可以让文字可以点击，也可以让图片能够被点击 a标签必须有一个href属性 如果通过a标签的href属性指定一个URL地址，那么必须在地址前加上http://或https:// a标签的href属性除了可以指定一个网址，还可以指定一个本地地址 （3）常用属性： target（跳转方式）：_self:在当前选项卡中跳转，默认。_blank:在新的选项卡中跳转 title：用来告诉浏览器，当鼠标悬停在链接上时，需要弹出的描述框中显示什么内容 （4）假链接：点击之后不会跳转，企业开发前期，其他页面都没有写出来，就用假链接来代替 格式：&lt;a href=”#”&gt;会自动回到网页顶部 &lt;a href=”javascript”&gt;不会自动回到网页顶部 9.base标签：专门用来统一的指定当前网页中所有的超链接需要如何打开 格式：&lt;base target=””&gt; 注意点：如果base和a标签同时指定了打开方式，网页的打开方式由a标签决定 10.锚点：(1)要想通过a标签跳转到当前界面的指定位置，那么必须告诉a标签一个独一无二的id，这样才能在当前界面找到需要跳转到的目标位置,格式： 1234&lt;a href=”zhongbu”&gt;&lt;h2&gt;我是顶部&lt;/h2&gt;&lt;/a&gt;&lt;h2 id=”zhongbu”&gt;我是中部&lt;/h2&gt;&lt;a href=”dibu”&gt; 跳转到底部&lt;/a&gt;&lt;h2 id=”dibu”&gt;我是底部&lt;/h2&gt; (2)想通过a标签跳转到其他界面的指定位置 格式：12&lt;a href=”新界面的网址#123”&gt;跳转到xxx&lt;/a&gt;&lt;h2 id=”123”&gt;欢迎来到这里&lt;/h2&gt; 11.列表标签（1）无需列表：ul 作用：给一堆数据添加列表语义，并且这一堆数据没有先后之分 格式：&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 应用场景：新闻列表 商品列表 导航条（2）有序列表：ol 作用：给一堆数据添加列表语义，并且这一堆数据有先后之分 格式：&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;（3）定义列表：dl 作用：给一堆数据添加列表语义，先通过dt标签定义列表中的所有标题，然后在通过dd标签给标题添加描述信息 格式：&lt;dl&gt;&lt;dt&gt;&lt;/dt&gt;&lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt;dt:定义列表的标题 dd:描述标题对应的含义 应用场景：网页的导航条 做网站尾部的相关信息 做图文混排 12.表格标签：&lt;table&gt;&lt;/table&gt; （1）作用：给一堆数据添加表格语义 （2）格式： &lt;table&gt;&lt;caption&gt;&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; tr：表示一行 td:表示一行的一个单元格 th：专门用来存储每一列的标题，内容会自动加粗居中 caption:专门用来指定表格标题 （3）注意点：表格边框属性border默认为0 常用属性：（1）宽度和高度（table、td） 表格默认宽高度是根据内容的尺寸调整的，也可以通过table标签设置width/height属性来手动设置； 如果给td标签设置width/height属性，只会改变单元格的宽度和高度，不会影响整个表格的宽度和高度 （2）水平对齐（table、td、tr） 给table标签设置align属性，可以控制表格在水平方向的对齐方式； 给tr标签设置align属性，可以控制当前行中的所有单元格的水平方向对齐方式； 给td标签设置align属性，可以控制当前行中的单元格内容的水平方向对齐方式； 注意点：如果同时给tr、td设置align属性，那么单元格中的内容会安照td的设置来对齐 （3）垂直对齐（td、tr） 给tr标签设置设置valign属性,可以控制当前行中的所有单元格的垂直方向对齐方式； 给td标签设置设置valign属性,可以控制当前行的单元格内容的垂直方向对齐方式 注意点：如果同时给tr、td设置valign属性，那么单元格中的内容会安照td的设置来对齐 （4）外边距：单元格与单元格之间的距离，默认情况下cellspacing=2px（5）内边距:单元格的边框与内容之间的间隙，默认情况下cellpadding=1px（6）水平方向上的单元格合并：（行上的单元格合并），给td标签设置一个colspan属性，来指定把一个单元格当作多个单元格（7）垂直方向上的单元格合并：（列上的单元格合并），给td标签设置一个rowspan属性,来指定把一个单元格当作多个单元格 细线表格制作方式：123456789&lt;table bgcolor=\"black\" cellspacing=\"1px\" &gt; &lt;tr bgcolor=\"white\" &gt; &lt;td&gt;1.1&lt;/td&gt; &lt;td&gt;1.2&lt;/td&gt; &lt;/tr&gt; &lt;tr bgcolor=\"white\" &gt; &lt;td&gt;2.1&lt;/td&gt; &lt;td&gt;2.2&lt;/td&gt; &lt;/tr&gt; 表格完整格式：（仅作了解）123456789101112131415161718&lt;table&gt; &lt;caption&gt;&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 13.表单标签：（1）作用：表单是专门用来收集用户信息的表单标签比较特殊，在浏览器中有自己默认的外观和功能。（2）格式： &lt;from&gt;&lt;表单元素&gt;&lt;/from&gt;（3）常见表单元素： input标签（默认有边框）：它有一个type属性，这个属性有很多类型的取值，取值的不同决定了input标签的功能和外观，除了按钮类型的input标签以外，其他标签都可以通过value属性来指定将来提交到服务器的值 《1》&lt;input type=”text”&gt;明文输入框 《2》&lt;input type=”password”&gt;暗文输入框 《3》&lt;input type=”radio”&gt;单选框注意点：默认单选框不会互斥，要想选框互斥，要给每个单选框标签设置一个name属性，并且属性值必须相同。要想让单选框默认选中其中一个，那么就给他添加一个checked属性 《4》&lt;input type=”checkbox”&gt;多选框注意点：默认可以选择多个，要想让单选框默认选中其中一个，那么就给他添加一个checked属性 《5》 按钮 普通按钮：&lt;input type=”button”value=”按钮”&gt;，通过value属性给按钮添加标题 图片按钮：&lt;input type=”img”src=””&gt;，作用与普通按钮一样 重置按钮：&lt;input type=”reset”&gt;，用于清空表单填写的内容 注意点：默认按钮标题是重置，可以通过value属性修改按钮标题 提交按钮：&lt;input type=”submit”&gt;，将表单中填写好的内容提交到远程服务器注意点：要想把表单中填写的内容提交给远程服务器中，需要做到以下两点：&lt;form action=”网址”&gt;&lt;/form&gt;；给需要提交的表单元素都添加name属性 《6》隐藏域：&lt;input type=”hidden”&gt;配合提交按钮将一些数据默默的提交到远程服务器 label标签：默认情况下，文字与输入框是没有关联关系的，也就是说点击文字输入框不会聚焦，如果想聚焦，需要这样：方法一：&lt;label for=”一样”&gt;文字:&lt;/label&gt;&lt;input type=”” id=”一样”&gt;方法二：&lt;labrl&gt;文字：&lt;input type=””&gt;&lt;/label&gt;局限性是不能交叉绑定 14.datalist标签：给输入框绑定待选项（了解）格式：123456&lt;input type=\"text\" list=\"cities\"&gt;&lt;datalist id=”cities”&gt;&lt;option&gt;待选项内容&lt;/option&gt;&lt;option&gt;待选项内容&lt;/option&gt;&lt;option&gt;待选项内容&lt;/option&gt;&lt;/datalist&gt; select标签：用于定义下拉列表格式：12345&lt;select&gt;&lt;option&gt;列表数据&lt;/option&gt;&lt;option&gt;列表数据&lt;/option&gt;&lt;option&gt;列表数据&lt;/option&gt;&lt;/select&gt; 注意点：下拉列表不能输入内容，但是可以选择内容。也可以设置默认值：&lt;option selected=&quot;selected&quot;&gt;列表数据&lt;/option&gt;给下拉列表分类：123&lt;optgroup label=\"分组名称\"&gt;&lt;option&gt;列表数据&lt;/option&gt;&lt;/optgroup&gt; textarea标签：默认情况下可以无限换行，有默认的宽度和高度，默认情况下输入框是可以手动拉伸的格式：&lt;textarea&gt;内容&lt;/textarea&gt;可以通过这样给文本添加列数和行数：&lt;textarea cols=”” rows=””&gt;内容&lt;/textarea&gt;fieldset标签：给表单添加边框legend标签：可以给边框指定一个标题 15.video标签：（1）作用： 播放视频（2）格式： 第一种格式：&lt;video src=””&gt;&lt;/video&gt;第二种格式：&lt;video&gt;&lt;source src=”” type=”video/webm/ogg/mp4”&gt;&lt;/suorce&gt;&lt;/video&gt;由于视频数据非常的重要，所以五大浏览器厂商都不愿意支持别人的视频格式，所以导致了没有一种视频格式是所有浏览器都支持的，这个时候w3c为了解决这个问题，所以有了第二种格式（3）常用属性：width/heightautoplay:用来告诉video标签是否需要自动播放视频 controls: 用来告诉video标签是否需要显示控制条 poster：用来告诉video标签视频没有播放之前显示的占用图片 loop：一般用于做广告视频，用于告诉video标签播放结束后是否需要循环播放preload：预加载视频，与autoplay相冲，如果设置了autoplay属性那么preload就会失效muted静音： 16.audio标签：（1）作用：播放音频（2）格式：第一种格式：&lt;audio src=””&gt;&lt;/audio&gt; 第二种格式：&lt;audio&gt;&lt;source src=”audio/mp3”&gt;&lt;/source&gt;&lt;/audio&gt;（3）常用属性：width/heightautoplay:用来告诉audio标签是否需要自动播放视频 controls: 用来告诉audio标签是否需要显示控制条 loop：用于告诉audio o标签播放结束后是否需要循环播放preload：加载音频，与autoplay相冲，如果设置了autoplay属性那么preload就会失效muted静音： 17.详情和概要标签：（1）作用：利用summary标签来描述概要信息，利用dateils标签描述详情信息，默认情况下是折叠显示，想看详情信息必须点击（2）格式：&lt;details&gt;&lt;summary&gt;概要信息&lt;/summary&gt;详情信息&lt;/details&gt;18.marquee标签：不是w3c推荐的标签，但各个浏览器对他的支持非常好 （1）作用：跑马灯效果，不仅可以让文字滚动也可以让图片滚动 （2）格式：&lt;marquee &gt;内容&lt;/marquee &gt; （3）常用属性： direction：滚动方向 left/right/up/down scrollamount:滚动速度 loop:滚动次数，默认是-1，无限次 behavior:滚动类型 slide滚动到边界就停止alternate滚动到边界就弹回来 19.字符实体&amp;nbsp;空格、&amp;lt;小于号、&amp;gt;大于号、&amp;copy;版权符号","categories":[{"name":"HTML简明教程","slug":"HTML简明教程","permalink":"http://www.1oveit.club/categories/HTML简明教程/"}],"tags":[{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"},{"name":"HTML","slug":"HTML","permalink":"http://www.1oveit.club/tags/HTML/"}]},{"title":"Top 10 ES6 Features","slug":"top10es","date":"2016-10-13T07:41:09.000Z","updated":"2017-05-22T07:26:04.000Z","comments":true,"path":"2016/10/13/top10es/","link":"","permalink":"http://www.1oveit.club/2016/10/13/top10es/","excerpt":"Top 10 ES6 Features Top 10 ES6 Features Every Busy JavaScript Developer Must KnowTop 10 ES6 Features Every Busy JavaScript Developer Must Know 10 ES6 Features Every Busy JavaScript Software Engineer Must Know38 Replies","text":"Top 10 ES6 Features Top 10 ES6 Features Every Busy JavaScript Developer Must KnowTop 10 ES6 Features Every Busy JavaScript Developer Must Know 10 ES6 Features Every Busy JavaScript Software Engineer Must Know38 RepliesThis essay will give you a quick introduction to ES6. If you don’t know what is ES6, it’s a new JavaScript implementation. If you’re a busy JavaScript software engineer (and who is not?), then proceed reading to learn the best 10 features of the new generation of the most popular programming language—JavaScript. Here’s the list of the top 10 best ES6 features for a busy software engineer (in no particular order):12345678910Default Parameters in ES6Template Literals in ES6Multi-line Strings in ES6Destructuring Assignment in ES6Enhanced Object Literals in ES6Arrow Functions in ES6Promises in ES6Block-Scoped Constructs Let and ConstClasses in ES6Modules in ES6 Disclaimer: the list if highly biased and subjective. It is in no way was intended to diminish usefulness of other ES6 features, which didn’t make it to the list simply because I had to limit the number to 10. Default Parameters in ES6Remember we had to do these statements to define default parameters:123456var link = function (height, color, url) &#123; var height = height || 50 var color = color || 'red' var url = url || 'http://azat.co' ...&#125; They were okay until the value was 0 and because 0 is falsy in JavaScript it would default to the hard-coded value instead of becoming the value itself. Of course, who needs 0 as a value (#sarcasmfont), so we just ignored this flaw and used the logic OR anyway… No more! In ES6, we can put the default values right in the signature of the functions:123var link = function(height = 50, color = 'red', url = 'http://azat.co') &#123; ...&#125; By the way, this syntax is similar to Ruby! Template Literals in ES6Template literals or interpolation in other languages is a way to output variables in the string. So in ES5 we had to break the string like this:123456var name = 'Your name is ' + first + ' ' + last + '.'var url = 'http://localhost:3000/api/messages/' + idLuckily, in ES6 we can use a new syntax $&#123;NAME&#125; inside of the back-ticked string:var name = `Your name is $&#123;first&#125; $&#123;last&#125;.`var url = `http://localhost:3000/api/messages/$&#123;id&#125;` Multi-line Strings in ES6Another yummy syntactic sugar is multi-line string. In ES5, we had to use one of these approaches: Sidenote: If you like this post and interested in a corporate on-site JavaScript, Node.js and React.js training to boost productivity of your team, then contact NodeProgram.com.12345var roadPoem = 'Then took the other, as just as fair,\\n\\t' + 'And having perhaps the better claim\\n\\t' + 'Because it was grassy and wanted wear,\\n\\t' + 'Though as for that the passing there\\n\\t' + 'Had worn them really about the same,\\n\\t' var fourAgreements = ‘You have the right to be you.\\n\\ You can only be you when you do your best.’While in ES6, simply utilize the backticks:12345678var roadPoem = `Then took the other, as just as fair, And having perhaps the better claim Because it was grassy and wanted wear, Though as for that the passing there Had worn them really about the same,`var fourAgreements = `You have the right to be you. You can only be you when you do your best.` Destructuring Assignment in ES6Destructuring can be a harder concept to grasp, because there’s some magic going on… let’s say you have simple assignments where keys house and mouse are variables house and mouse: [Sidenote] Reading blog posts is good, but watching video courses is even better because they are more engaging. A lot of developers complained that there is a lack of affordable quality video material on Node. It’s distracting to watch to YouTube videos and insane to pay $500 for a Node video course! Go check out Node University which has FREE video courses on Node: node.university. [End of sidenote]12345678910var data = $('body').data(), // data has properties house and mouse house = data.house, mouse = data.mouseOther examples of destructuring assignments (from Node.js):var jsonMiddleware = require('body-parser').jsonvar body = req.body, // body has username and password username = body.username, password = body.password In ES6, we can replace the ES5 code above with these statements:123456789var &#123; house, mouse&#125; = $('body').data() // we'll get house and mouse variablesvar &#123;jsonMiddleware&#125; = require('body-parser')var &#123;username, password&#125; = req.bodyThis also works with arrays. Crazy!var [col1, col2] = $('.column'), [line1, line2, line3, , line5] = file.split('\\n') It might take some time to get use to the destructuring assignment syntax, but it’s a sweet sugarcoating. Enhanced Object Literals in ES6What you can do with object literals now is mind blowing! We went from a glorified version of JSON in ES5 to something closely resembling classes in ES6. Here’s a typical ES5 object literal with some methods and attributes/properties:12345678910111213var serviceBase = &#123;port: 3000, url: 'azat.co'&#125;, getAccounts = function()&#123;return [1,2,3]&#125;var accountServiceES5 = &#123; port: serviceBase.port, url: serviceBase.url, getAccounts: getAccounts, toString: function() &#123; return JSON.stringify(this.valueOf()) &#125;, getUrl: function() &#123;return \"http://\" + this.url + ':' + this.port&#125;, valueOf_1_2_3: getAccounts()&#125; If we want to be fancy, we can inherit from serviceBase by making it the prototype with the Object.create method:123456789var accountServiceES5ObjectCreate = Object.create(serviceBase)var accountServiceES5ObjectCreate = &#123; getAccounts: getAccounts, toString: function() &#123; return JSON.stringify(this.valueOf()) &#125;, getUrl: function() &#123;return \"http://\" + this.url + ':' + this.port&#125;, valueOf_1_2_3: getAccounts()&#125; I know, accountServiceES5ObjectCreate and accountServiceES5 are NOT totally identical, because one object (accountServiceES5) will have the properties in the proto object as shown below: Enhanced Object Literals in ES6Enhanced Object Literals in ES6 But for the sake of the example, we’ll consider them similar. So in ES6 object literal, there are shorthands for assignment getAccounts: getAccounts, becomes just getAccounts,. Also, we set the prototype right there in the proto` property which makes sense (not‘proto’ though:12345678910111213141516var serviceBase = &#123;port: 3000, url: 'azat.co'&#125;, getAccounts = function()&#123;return [1,2,3]&#125;var accountService = &#123; __proto__: serviceBase, getAccounts,Also, we can invoke super and have dynamic keys (valueOf_1_2_3): toString() &#123; return JSON.stringify((super.valueOf())) &#125;, getUrl() &#123;return \"http://\" + this.url + ':' + this.port&#125;, [ 'valueOf_' + getAccounts().join('_') ]: getAccounts()&#125;;console.log(accountService)Enhanced Object Literals in ES6 IIEnhanced Object Literals in ES6 II This is a great enhancement to good old object literals! Arrow Functions in ES6This is probably one feature I waited the most. I love CoffeeScript for its fat arrows. Now we have them in ES6. The fat arrows are amazing because they would make your this behave properly, i.e., this will have the same value as in the context of the function—it won’t mutate. The mutation typically happens each time you create a closure. Using arrows functions in ES6 allows us to stop using that = this or self = this or _this = this or .bind(this). For example, this code in ES5 is ugly:12345678910var _this = this$('.btn').click(function(event)&#123; _this.sendData()&#125;)This is the ES6 code without _this = this:$('.btn').click((event) =&gt;&#123; this.sendData()&#125;) Sadly, the ES6 committee decided that having skinny arrows is too much of a good thing for us and they left us with a verbose old function instead. (Skinny arrow in CoffeeScript works like regular function in ES5 and ES6). Here’s another example in which we use call to pass the context to the logUpperCase() function in ES5:12345678var logUpperCase = function() &#123; var _this = this this.string = this.string.toUpperCase() return function () &#123; return console.log(_this.string) &#125;&#125; logUpperCase.call({ string: ‘es6 rocks’ })()While in ES6, we don’t need to mess around with _this:123456var logUpperCase = function() &#123; this.string = this.string.toUpperCase() return () =&gt; console.log(this.string)&#125;logUpperCase.call(&#123; string: 'es6 rocks' &#125;)() Note that you can mix and match old function with =&gt; in ES6 as you see fit. And when an arrow function is used with one line statement, it becomes an expression, i.e,. it will implicitly return the result of that single statement. If you have more than one line, then you’ll need to use return explicitly. This ES5 code is creating an array from the messages array:1234var ids = ['5632953c4e345e145fdf2df8','563295464e345e145fdf2df9']var messages = ids.map(function (value) &#123; return \"ID is \" + value // explicit return&#125;); Will become this in ES6:12var ids = ['5632953c4e345e145fdf2df8','563295464e345e145fdf2df9']var messages = ids.map(value =&gt; `ID is $&#123;value&#125;`) // implicit return Notice that I used the string templates? Another feature from CoffeeScript… I love them! The parenthesis () are optional for single params in an arrow function signature. You need them when you use more than one param. In ES5 the code has function with explicit return:1234var ids = ['5632953c4e345e145fdf2df8', '563295464e345e145fdf2df9'];var messages = ids.map(function (value, index, list) &#123; return 'ID of ' + index + ' element is ' + value + ' ' // explicit return&#125;); And more eloquent version of the code in ES6 with parenthesis around params and implicit return:12var ids = ['5632953c4e345e145fdf2df8','563295464e345e145fdf2df9']var messages = ids.map((value, index, list) =&gt; `ID of $&#123;index&#125; element is $&#123;value&#125; `) // implicit return Promises in ES6Promises have been a controversial topic. There were a lot of promise implementations with slightly different syntax. q, bluebird, deferred.js, vow, avow, jquery deferred to name just a few. Others said we don’t need promises and can just use async, generators, callbacks, etc. Gladly, there’s a standard Promise implementation in ES6 now! Let’s consider a rather trivial example of a delayed asynchronous execution with setTimeout():123setTimeout(function()&#123; console.log('Yay!')&#125;, 1000) We can re-write the code in ES6 with Promise:12345var wait1000 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 1000)&#125;).then(function() &#123; console.log('Yay!')&#125;) Or with ES6 arrow functions:12345var wait1000 = new Promise((resolve, reject)=&gt; &#123; setTimeout(resolve, 1000)&#125;).then(()=&gt; &#123; console.log('Yay!')&#125;) So far, we’ve increased the number of lines of code from three to five without any obvious benefit. That’s right. The benefit will come if we have more nested logic inside of the setTimeout() callback:123456setTimeout(function()&#123; console.log('Yay!') setTimeout(function()&#123; console.log('Wheeyee!') &#125;, 1000)&#125;, 1000) Can be re-written with ES6 promises:12345678910var wait1000 = ()=&gt; new Promise((resolve, reject)=&gt; &#123;setTimeout(resolve, 1000)&#125;)wait1000() .then(function() &#123; console.log('Yay!') return wait1000() &#125;) .then(function() &#123; console.log('Wheeyee!') &#125;); Still not convinced that Promises are better than regular callbacks? Me neither. I think once you got the idea of callbacks and wrap your head around them, then there’s no need for additional complexity of promises. Nevertheless, ES6 has Promises for those of you who adore them. Promises have a fail-and-catch-all callback as well which is a nice feature. Take a look at this post for more info on promises: Introduction to ES6 Promises. Block-Scoped Constructs Let and ConstYou might have already seen the weird sounding let in ES6 code. I remember the first time I was in London, I was confused by all those TO LET signs. The ES6 let has nothing to do with renting. This is not a sugarcoating feature. It’s more intricate. let is a new var which allows to scope the variable to the blocks. We define blocks by the curly braces. In ES5, the blocks did NOTHING to the vars:123456789101112131415function calculateTotalAmount (vip) &#123; var amount = 0 if (vip) &#123; var amount = 1 &#125; &#123; // more crazy blocks! var amount = 100 &#123; var amount = 1000 &#125; &#125; return amount&#125;console.log(calculateTotalAmount(true)) The result will be 1000. Wow! That’s a really bad bug. In ES6, we use let to restrict the scope to the blocks. Vars are function scoped.123456789101112131415function calculateTotalAmount (vip) &#123; var amount = 0 // probably should also be let, but you can mix var and let if (vip) &#123; let amount = 1 // first amount is still 0 &#125; &#123; // more crazy blocks! let amount = 100 // first amount is still 0 &#123; let amount = 1000 // first amount is still 0 &#125; &#125; return amount&#125;console.log(calculateTotalAmount(true)) The value is 0, because the if block also has let. If it had nothing (amount=1), then the expression would have been 1. When it comes to const, things are easier; it’s just an immutable, and it’s also block-scoped like let. Just to demonstrate, here are a bunch of constants and they all are okay because they belong to different blocks:123456789101112131415function calculateTotalAmount (vip) &#123; const amount = 0 if (vip) &#123; const amount = 1 &#125; &#123; // more crazy blocks! const amount = 100 &#123; const amount = 1000 &#125; &#125; return amount&#125;console.log(calculateTotalAmount(true)) In my humble opinion, let and const overcomplicate the language. Without them we had only one behavior, now there are multiple scenarios to consider. ;-( Classes in ES6If you love object-oriented programming (OOP), then you’ll love this feature. It makes writing classes and inheriting from them as easy as liking a comment on Facebook. Classes creation and usage in ES5 was a pain in the rear, because there wasn’t a keyword class (it was reserved but did nothing). In addition to that, lots of inheritance patterns like pseudo classical, classical, functional just added to the confusion, pouring gasoline on the fire of religious JavaScript wars. I won’t show you how to write a class (yes, yes, there are classes, objects inherit from objects) in ES5, because there are many flavors. Let’s take a look at the ES6 example right away. I can tell you that the ES6 class will use prototypes, not the function factory approach. We have a class baseModel in which we can define a constructor and a getName() method:123456789101112class baseModel &#123; constructor(options = &#123;&#125;, data = []) &#123; // class constructor this.name = 'Base' this.url = 'http://azat.co/api' this.data = data this.options = options &#125; getName() &#123; // class method console.log(`Class name: $&#123;this.name&#125;`) &#125;&#125; Notice that I’m using default parameter values for options and data. Also, method names don’t need to have the word function or the colon (:) anymore. The other big difference is that you can’t assign properties this.NAME the same way as methods, i.e., you can’t say name at the same indentation level as a method. To set the value of a property, simply assign a value in the constructor. The AccountModel inherits from baseModel with class NAME extends PARENT_NAME:12345678class AccountModel extends baseModel &#123; constructor(options, data) &#123;To call the parent constructor, effortlessly invoke super() with params: super(&#123;private: true&#125;, ['32113123123', '524214691']) //call the parent method with super this.name = 'Account Model' this.url +='/accounts/' &#125; If you want to be really fancy, you can set up a getter like this and accountsData will be a property:12345 get accountsData() &#123; //calculated attribute getter // ... make XHR return this.data &#125;&#125; So how do you actually use this abracadabra? It’s as easy as tricking a three-year old into thinking Santa Claus is real:123let accounts = new AccountModel(5)accounts.getName()console.log('Data is %s', accounts.accountsData) In case you’re wondering, the output is:12Class name: Account ModelData is %s 32113123123,524214691 Modules in ES6As you might now, there were no native modules support in JavaScript before ES6. People came up with AMD, RequireJS, CommonJS and other workarounds. Now there are modules with import and export operands. In ES5 you would use &lt;script&gt; tags with IIFE, or some library like AMD, while in ES6 you can expose your class with export. I am a Node.js guy, so I’ll use CommonJS which is also a Node.js syntax. It’s straightforward to use CommonJS on the browser with the Browserify bunder. Let’s say we have port variable and getAccounts method in ES5 module.js:123456module.exports = &#123; port: 3000, getAccounts: function() &#123; ... &#125;&#125; In ES5 main.js, we would require(‘module’) that dependency:12var service = require('module.js')console.log(service.port) // 3000 In ES6, we would use export and import. For example, this is our library in the ES6 module.js file:1234export var port = 3000export function getAccounts(url) &#123; ...&#125; In the importer ES6 file main.js, we use import {name} from ‘my-module’ syntax. For example,123456import &#123;port, getAccounts&#125; from 'module'console.log(port) // 3000Or we can import everything as a variable service in main.js:import * as service from 'module'console.log(service.port) // 3000 Personally, I find the ES6 modules confusing. Yes, they are more eloquent, but Node.js modules won’t change anytime soon. It’s better to have only one style for browser and server JavaScript, so I’ll stick with CommonJS/Node.js style for now. The support for ES6 modules in the browsers are not coming anytime soon (as of this writing), so you’ll need something like jspm to use ES6 modules. For more information and examples on ES6 modules, take a look at this text. No matter what, write modular JavaScript! How to Use ES6 Today (Babel) ES6 is finalized, but not fully supported by all browsers (e.g., ES6 Firefox support). To use ES6 today, get a compiler like Babel. You can run it as a standalone tool or use with your build system. There are Babel plugins for Grunt, Gulp and Webpack. How to Use ES6 Today (Babel)How to Use ES6 Today (Babel) Here’s a Gulp example. Install the plugin: $ npm install –save-dev gulp-babelIn gulpfile.js, define a task build that takes src/app.js and compiles it into the build folder:12345678var gulp = require('gulp'), babel = require('gulp-babel')gulp.task('build', function () &#123; return gulp.src('src/app.js') .pipe(babel()) .pipe(gulp.dest('build'))&#125;) Node.js and ES6 For Node.js, you can compile your Node.js files with a build tool or use a standalone Babel module babel-core. To install it, $ npm install –save-dev babel-coreThen in Node.js, you call this function: require(“babel-core”).transform(es5Code, options)Summary of ES6 Things There are many other noteworthy ES6 features which you probably won’t use (at least not right away). In no particular order: New Math, Number, String, Array and Object methodsBinary and octal number typesDefault rest spreadFor of comprehensions (hello again mighty CoffeeScript!)SymbolsTail callsGeneratorsNew data structures like Map and SetFor overachievers who can’t stop learning about ES6, like some people who can’t stop after the first potato chip (just one more!), here’s the list for further reading:Top 10 ES6 Features Every Busy JavaScript Developer Must Know","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://www.1oveit.club/tags/css/"},{"name":"js","slug":"js","permalink":"http://www.1oveit.club/tags/js/"}]},{"title":"gulp实现项目模板化","slug":"gulp实行项目模板化","date":"2016-08-13T03:55:22.000Z","updated":"2017-05-22T04:10:52.000Z","comments":true,"path":"2016/08/13/gulp实行项目模板化/","link":"","permalink":"http://www.1oveit.club/2016/08/13/gulp实行项目模板化/","excerpt":"使用gulp实现项目模板化gulpnodejs插件自动化WebFrontEnd当一个大项目逐渐成型，或者一个框架又或者一个开发方式逐渐成型的时候，总会有一个所谓的“套路”，我们在工作中往往遵循着这个套路走。所以更换一家公司或者一个部门团队的时候，上手项目并不难，你只需要掌握这个团队管用的“套路”就ok了，关键是：要想办法优化这个“套路”。","text":"使用gulp实现项目模板化gulpnodejs插件自动化WebFrontEnd当一个大项目逐渐成型，或者一个框架又或者一个开发方式逐渐成型的时候，总会有一个所谓的“套路”，我们在工作中往往遵循着这个套路走。所以更换一家公司或者一个部门团队的时候，上手项目并不难，你只需要掌握这个团队管用的“套路”就ok了，关键是：要想办法优化这个“套路”。之前一直在做内部框架的跨平台和自动化构建的事，加上开发业务逻辑的页面已经完成，就没去优化这个开发套路，什么套路呢？当项目中需要一个新的H5页面的时候，就需要手动去copy之前的一个页面代码，然后逐个修改，改成另外一个页面。去掉代码中的业务逻辑，会发现除了名称不同，其余的代码全部相同，秉承着“上级命令一定要完成”总宗旨，非也，是秉承着“我是一个程序员”的宗旨，就应该将一切需要手工完成的工作变成自动化的。所以……所以就不吹NB了，好好写……一个古老的思路是，你应该有一套模板，当有新的页面需要开发的时候，只需一条命令或者一个按钮就可以自动帮你基于这套模板创建一个可直接用于开发的环境。为了达成这个目的，我是用到了：1.gulpgulp的教程这里就不写了。2.该功能主要使用到的gulp插件gulp-load-plugins 加载gulp插件的插件gulp-file-include 文件包含插件gulp-data 提供数据，该数据可被其他gulp插件使用gulp-rename 重命名文件gulp-template 渲染模板上面的插件连接，点击进去就是文档。笔者认为最好的学习方式就是有一个能运行起来的项目，然后看着代码一步步走，所以我把模板化从公司的项目中抽离出来，并做了删减，提炼出一个完整的可运行的项目，并放在我的git仓库，可以运行一下命令查看效果，调试并学习： 下面是gulpfile.js文件和package.json文件gulpfile.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110var gulp = require('gulp');var gulpLoadPlugins = require(\"gulp-load-plugins\");var plugins = gulpLoadPlugins();var util = require(\"gulp-util\");var devPath = './html';var appData = &#123;&#125;;/* * @desc 组装模板 * @src devPath * @deps * @dest devPath + '/tmod/app/dest' */gulp.task('includeTpl',function () &#123; // 获取 gulp 命令的 --name参数的值 （gulp createapp --name=aaa） var appName = util.env.name || 'special'; // 首字母大写 var appNameBig = appName.replace((/\\w/), function(char)&#123; return char.toUpperCase(); &#125;); appData=&#123; app: appName, appapi: appNameBig, appDo: appName + \"Do\", title: appName &#125; return gulp.src([ devPath + '/tmod/app/app.tpl', devPath + '/tmod/app/appDo.tpl', devPath + '/tmod/app/app.html', devPath + '/tmod/app/appApi.tpl', devPath + '/tmod/app/appapiInterFace.tpl' ]) .pipe(plugins.fileInclude(&#123; prefix: '@@', basepath: '@file' &#125;)) .pipe(gulp.dest(devPath + '/tmod/app/dest'));&#125;);/* * @desc 解析模板 * @src devPath * @deps includeTpl * @dest devPath + '/tmod/app/dest' */gulp.task('resolveTpl',[\"includeTpl\"],function () &#123; return gulp.src([ devPath + '/tmod/app/dest/app.tpl', devPath + '/tmod/app/dest/appDo.tpl', devPath + '/tmod/app/dest/app.html', devPath + '/tmod/app/dest/appApi.tpl', devPath + '/tmod/app/dest/appapiInterFace.tpl' ]) .pipe(plugins.data(function () &#123; return &#123;app: appData.app, appDo:appData.appDo,title:appData.title, appapi : appData.appapi&#125;; &#125;)) .pipe(plugins.template()) .pipe(gulp.dest(devPath + '/tmod/app/dest'));&#125;);/* * @desc 创建部署 * @src devPath + '/tmod/app/dest * @deps resolveTpl * @dest devPath + '/modules/' */gulp.task('createapp', [\"resolveTpl\"], function () &#123; // 创建部署入口js文件，如 index.js gulp.src(devPath + '/tmod/app/dest/app.tpl') .pipe(plugins.rename(&#123; basename: appData.app, extname: \".js\" &#125;)) .pipe(gulp.dest(devPath + '/target/'+appData.app)); // 创建部署业务逻辑js文件，如 indexDo.js gulp.src(devPath + '/tmod/app/dest/appDo.tpl') .pipe(plugins.rename(&#123; basename: appData.appDo, extname: \".js\" &#125;)) .pipe(gulp.dest(devPath + '/target/'+appData.app)); // 创建部署html页面文件，如 index.html gulp.src([devPath + '/tmod/app/dest/*.html']) .pipe(plugins.rename(&#123; basename: appData.app, extname: \".html\" &#125;)) .pipe(gulp.dest(devPath + '/target/'+appData.app)); // 创建部署api接口js文件，如 indexApi.js gulp.src(devPath + '/tmod/app/dest/appApi.tpl') .pipe(plugins.rename(&#123; basename: appData.app + 'Api', extname: \".js\" &#125;)) .pipe(gulp.dest(devPath + '/target/clientApi')); // 创建部署跨平台接口js文件，如 indexapiInterFace.js gulp.src(devPath + '/tmod/app/dest/appapiInterFace.tpl') .pipe(plugins.rename(&#123; basename: appData.app + 'apiInterFace', extname: \".js\" &#125;)) .pipe(gulp.dest(devPath + '/target/clientApi'));&#125;); package.json12345678910111213141516&#123; \"name\": \"app\", \"project\": \"app\", \"version\": \"1.0.0\", \"host\": \"http://10.0.69.79\", \"path\": \"/home/huangjian/workstation/bridge/newssdk/bin\", \"devDependencies\": &#123; \"gulp\": \"^3.9.0\", \"gulp-data\": \"^1.2.0\", \"gulp-file-include\": \"^0.13.7\", \"gulp-load-plugins\": \"^0.10.0\", \"gulp-rename\": \"^1.2.0\", \"gulp-template\": \"^2.1.0\", \"gulp-util\": \"^3.0.6\" &#125;&#125; 大家重在研究代码的思路和各个组件的用法及配合，不要去研究代码的细节，比如这个构建出来的项目有什么用啊？当然对于你来说没什么用，因为这个是应用在公司项目中的，这个是为了给大家方便，抽离出来的，所以大家把握好重点。","categories":[],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://www.1oveit.club/tags/gulp/"}]},{"title":"jQuery 源码简单分析","slug":"jQuery-源码分析","date":"2016-08-04T16:33:34.000Z","updated":"2017-05-22T07:26:04.000Z","comments":true,"path":"2016/08/05/jQuery-源码分析/","link":"","permalink":"http://www.1oveit.club/2016/08/05/jQuery-源码分析/","excerpt":"jQuery时下非常流行，简单好用，工作必用。想更深入学习，可以通过研究其源代码。 jQuery是一个闭包（即时函数）(function( window, undefined ) {}) 让我们来看一看jQuery源代码的基本信息","text":"jQuery时下非常流行，简单好用，工作必用。想更深入学习，可以通过研究其源代码。 jQuery是一个闭包（即时函数）(function( window, undefined ) {}) 让我们来看一看jQuery源代码的基本信息12345678910111213 /*!* jQuery JavaScript Library v2.0.0 版本信息* http://jquery.com/ 官方网站** Includes Sizzle.js 复杂选择器文件名称* http://sizzlejs.com/ 复杂选择器文件网站** Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors 版权信息* Released under the MIT license 开源协议* http://jquery.org/license** Date: 2013-04-18 更新时间*/ 这说明jQuery有多个版本,现在我们分析的是2.0.0版本，在之前的版本版本需要兼容IE678,里面有大量的兼容性处理。从2.0.0版本入手开始研究,从上往下解读注释 包括: 01 官方网站 02 复杂选择器 03 版权信息和开源协议 04 #1335和bug管理系统 jQ本质就是一个闭包 使用闭包的好处： ① 为了避免和其他框架产生冲突(代码说明) ② 多个框架中如果出现了同名的变量或者是函数那么会存在覆盖或者是冲突,而使用闭包结构可以处理这个问题 ③ 其它 传递window参数的好处： ① 参数的区分:形式参数和实际参数 ② 函数作用域说明:函数内部的数据外界无法访问(引申闭包相关知识点) ③ 把内部的数据传递给外部使用 ④ 用于压缩代码(不是很理解) 传递window参数的好处： ① 方便代码的压缩 ② 使用undefined作为形参传入,为了防止代码的修改(在IE以前的版本中undefined可以被修改) jQuery被写成了一个工厂函数根据我们已经清楚的部分来开始初步的搭建框架结构,主要包括以下部分 001 该框架的最外层是一个立即调用函数(闭包),需要接受两个参数window和undefined 002 提供一个jQuery工厂函数 003 设置jQuery函数对象的原型对象(直接替换),并修正构造器属性,添加init方法 004 在jQuery工厂函数内部返回使用init方法创建的对象 005 设置原型对象赋值并讲解fn就是原型对象 03 讲解外界应该如何使用jQuery函数 001 依据我们使用jQuery框架的经验,在HTML文件中通过jQuery或者是$来访问 002 分析外部如何访问闭包内部的数据(在闭包中提供接口返回|把闭包中需要让外界访问的对象通过全局变量传递) 003 书写代码 window.$ = window.jQuery = jQuery; 004 注意说明:外界在调用的时候是通过jQuery()这种方式调用的,那么获取的就是一个jQuery.prototype.init类型的实例化对象 04 验证并说明调用jQuery得到的是jQuery.fn.init类型的实例化对象 代码示例：123456789101112131415161718192021222324252627包含功能: (1) 整体结构(立即调用函数) (2) jQuery工厂函数定义 (3) fn函数 (4) window.$ 和window.jQuery*/(function (window) &#123; //01 jQuery工厂函数 var jQuery = function () &#123; //02 返回一个jQuery.prototype.init类型的实例化对象 return new jQuery.fn.init(); &#125;; //03 替换jQuery工厂函数的原型对象 jQuery.prototype = &#123; //修正构造器属性 constructor:jQuery, init:function () &#123; //...init方法内部实现细节 &#125; &#125; //04 把jQuery工厂函数的原型对象赋值给jQuery.prototype.init的原型对象 jQuery.prototype.init.prototype = jQuery.prototype; //05 为jQuery工厂函数添加fn属性,该方法指向jQuery的原型对象 jQuery.fn = jQuery.prototype; //06 设置让外界能够拿到并使用jQuery工厂函数 window.$ = window.jQuery = jQuery;&#125;)(window); 上面分析的很简单，如果想要深入了解可以到GitHub网站等，希望对您有帮助","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://www.1oveit.club/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://www.1oveit.club/tags/jQuery/"},{"name":"源码分析","slug":"源码分析","permalink":"http://www.1oveit.club/tags/源码分析/"}]},{"title":"移动端开发技巧若干","slug":"移动端开发技巧若干","date":"2016-07-22T02:26:53.000Z","updated":"2017-05-22T03:53:08.000Z","comments":true,"path":"2016/07/22/移动端开发技巧若干/","link":"","permalink":"http://www.1oveit.club/2016/07/22/移动端开发技巧若干/","excerpt":"一些工作中的技巧。 viewport在做移动端时，要考虑各种各样的问题，这种情况下，如何优雅的设置meta标签，显得尤为重要。12345&lt;meta charset=\"utf-8\"&gt;&lt;meta content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" name=\"viewport\"&gt;&lt;meta name=\"viewport\" content=\"width=640,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" /&gt;&lt;meta content=\"telephone=no\" name=\"format-detection\"&gt;&lt;meta content=\"email=no\" name=\"format-detection\"&gt;","text":"一些工作中的技巧。 viewport在做移动端时，要考虑各种各样的问题，这种情况下，如何优雅的设置meta标签，显得尤为重要。12345&lt;meta charset=\"utf-8\"&gt;&lt;meta content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" name=\"viewport\"&gt;&lt;meta name=\"viewport\" content=\"width=640,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" /&gt;&lt;meta content=\"telephone=no\" name=\"format-detection\"&gt;&lt;meta content=\"email=no\" name=\"format-detection\"&gt; 1、&lt;meta charset=&quot;utf-8&quot;&gt;，设置编码格式为utf-8。 2、 设置视口模式，设备宽带等于视口宽带，初始缩放、最大缩放、最小缩放均为1.0,同时禁止用户缩放。1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" /&gt; 3、微信浏览器页面时，只需将宽度设置为640px。1&lt;meta name=\"viewport\" content=\"width=640,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" /&gt; 4、对格式进行保护，禁止将数字识别为电话号码。1&lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt; 5、同上，禁止Android平台中对邮箱地址的识别。1&lt;meta name=\"format-detection\" content=\"email=no\" /&gt; CSS样式CSS reset因为一些元素在不同对浏览器有不同对效果，所以我们需要重新设置。谨记”优雅降级、渐进增强”原则。12345678910111213141516@charset \"utf-8\";html&#123; -webkit-text-size-adjust:none; -webkit-user-select:none; -webkit-touch-callout: none; font-family: Arial;&#125;body&#123;font-size:16px;&#125;body,h1,h2,h3,h4,h5,h6,p,dl,dd,ul,ol,pre,form,input,textarea,th,td,select&#123;margin:0; padding:0; font-weight: normal;text-indent: 0;&#125;a,button,input,textarea,select&#123; background: none; -webkit-tap-highlight-color:rgba(255,0,0,0); outline:none; -webkit-appearance:none;&#125;em&#123;font-style:normal&#125;li&#123;list-style:none&#125;a&#123;text-decoration:none;&#125;img&#123;border:none; vertical-align:top;&#125;table&#123;border-collapse:collapse;&#125;textarea&#123; resize:none; overflow:auto;&#125; 公用 CSS style12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* 清除浮动 */.clear &#123; zoom:1; &#125;.clear:after &#123; content:''; display:block; clear:both; &#125;/* 定义盒模型（宽高不受边框影响） */.boxSz&#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; -o-box-sizing: border-box; box-sizing: border-box;&#125;/* 换行 */.forWrap&#123; word-break: break-all; /* 仅对英文起作用，以字母作为换行依据。 */ word-wrap: break-word; /* 仅对英文起作用，以单词作为换行依据。*/ white-space: pre-wrap; /* 仅对中文起作用，强制换行。*/&#125;/* 禁止换行 */.unWrap&#123; white-space:nowrap;&#125;/* 禁止换行,超出省略号 */.noWrapEllipsis&#123; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;&#125;/* 多行显示省略号，less写法，@line是行数 */.ellipsisLn(@line) &#123; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: @line;&#125;/* 1px 边框解决方案，示例中设置上边框，可以调整 top、right、bottom、left 的值分别设置上下左右边框 */#box2:after&#123; content: \" \"; position: absolute; left: 0; top: 0; right: 0; height: 1px; border-top: 1px solid #000; color: #C7C7C7; transform-origin: 0 0; transform: scaleY(0.5);&#125;/* 文字两端对齐 */.text-justify&#123; text-align:justify; text-justify:inter-ideograph;&#125;/* flex布局兼容写法并让内容水平垂直居中 */.flex-center&#123; display: -webkit-box; display: -moz-box; display: -ms-flexbox; display: -o-box; display: box; -webkit-box-pack: center; -moz-box-pack: center; -ms-flex-pack: center; -o-box-pack: center; box-pack: center; -webkit-box-align: center; -moz-box-align: center; -ms-flex-align: center; -o-box-align: center; box-align: center;&#125; Css小技巧1、去除android a button input被点击时边框的颜色1a,button,input&#123;-webkit-tap-highlight-color:rgba(255,0,0,0);&#125; 2、ios使用-webkit-text-size-adjust禁止调整字体大小1body&#123;-webkit-text-size-adjust: 100%!important;&#125; 3、android 上去掉语音输入按钮1input::-webkit-input-speech-button &#123;display: none&#125; 4、移动端无微软雅黑字体1body&#123;font-family:Helvetica;&#125; 5、禁用Webkit内核浏览器的文字大小调整功能。1-webkit-text-size-adjust: none; 6、禁止ios和android用户选中文字1.css&#123;-webkit-user-select:none&#125; 7、webkit去除表单元素的默认样式1.css&#123;-webkit-appearance:none;&#125; 8、修改webkit表单输入框placeholder的样式12input::-webkit-input-placeholder&#123;color:#AAAAAA;&#125;input:focus::-webkit-input-placeholder&#123;color:#EEEEEE;&#125; 其他技巧1、打电话和发短信12&lt;a href=\"tel:0755-10086\"&gt;打电话给:0755-10086&lt;/a&gt;&lt;a href=\"sms:10086\"&gt;发短信给: 10086&lt;/a&gt; 2、传图片视频12&lt;input type=file accept=\"image/*\"&gt;&lt;input type=file accept=\"video/*\"&gt; 3、在ios下，取消输入时首字母大写1&lt;input autocapitalize=\"off\" autocorrect=\"off\" /&gt;","categories":[],"tags":[{"name":"开发技巧","slug":"开发技巧","permalink":"http://www.1oveit.club/tags/开发技巧/"},{"name":"移动端","slug":"移动端","permalink":"http://www.1oveit.club/tags/移动端/"}]},{"title":"JSONP跨域","slug":"JSONP跨域","date":"2016-07-07T16:55:40.000Z","updated":"2017-05-22T07:26:04.000Z","comments":true,"path":"2016/07/08/JSONP跨域/","link":"","permalink":"http://www.1oveit.club/2016/07/08/JSONP跨域/","excerpt":"Asynchronous JavaScript and XML (Ajax) 是Web2.0的关键技术。AJAX与服务器交换数据刷新局部网页,不需重载。 因为浏览器及同源策略的限制，ajax不允许跨域通信。同源是指协议、域名和端口都一致的情况。同源策略保证一个源的动态脚本不能读取或操作其他源的http响应和cookie，使浏览器隔离不同源的内容之间互相操作。","text":"Asynchronous JavaScript and XML (Ajax) 是Web2.0的关键技术。AJAX与服务器交换数据刷新局部网页,不需重载。 因为浏览器及同源策略的限制，ajax不允许跨域通信。同源是指协议、域名和端口都一致的情况。同源策略保证一个源的动态脚本不能读取或操作其他源的http响应和cookie，使浏览器隔离不同源的内容之间互相操作。 Access-Control-Allow-Origin解决跨域问题可以在第三方网站开启HTTP的Access-Control-Allow-Origin参数，当目标页面的response包含Access-Control-Allow-Origin 这个header，而且还包含我们的域名时，浏览器就允许拿到它页面的数据：1Access-Control-Allow-Origin: http://www.1oveit.club 当值为 * 表示匹配所有，都能用：1Access-Control-Allow-Origin: * 但是此时的主动权不在我们手里。 JSONP解决跨域还可以使用更为主动的方法，使用JSONP解决跨域问题。分为以下几步：我们知道多个不同的script标签中的数据是可以相互访问的，而script的src的本质就是将导入文件中的内容拷贝到当前script标签中，我们拿到百度搜索URL地址：1https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=ab&amp;cb=jQuery11020672211218553074_1491468814655 搜索之后的结果：1jQuery11020672211218553074_1491468814655(&#123;q:&quot;ab&quot;,p:false,s:[&quot;abs&quot;,&quot;ab胶&quot;,&quot;abc&quot;,&quot;abac形式的成语&quot;,&quot;abcc形式的成语&quot;,&quot;abab式的词语&quot;,&quot;abo&quot;,&quot;abp&quot;,&quot;abstract&quot;,&quot;abs塑料&quot;]&#125;); 从而可以引出跨域(jsonP)原理：1.src可以拿到非当前域的数据。2.script的src的本质就是将导入文件中的内容拷贝到当前script标签中。3.如果src返回的数据符合 函数名称(参数); 格式, 那么就可以实现跨域。具体例子：在本地的文件的script准备回调函数say,123function say(obj) &#123; console.log(obj); &#125; 通过script的src属性拿到百度要搜索的URL并且拼接?wd=ab&amp;cb=say参数，如下：1&lt;script src=&quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=ab&amp;cb=say&quot;&gt;&lt;/script&gt; 最后，调用say方法，1say(&#123;q:&quot;ab&quot;,p:false,s:[&quot;abs&quot;,&quot;ab胶&quot;,&quot;abc&quot;,&quot;abac形式的成语&quot;,&quot;abcc形式的成语&quot;,&quot;abab式的词语&quot;,&quot;abo&quot;,&quot;abp&quot;,&quot;abstract&quot;,&quot;abs塑料&quot;]&#125;); 具体例子：12345678910111213141516 //1.使用src，请求数据 &lt;script src=\"http://datainfo.duapp.com/shopdata/getGoods.php?callback=callback\"&gt; //2.在本地声明一个方法 function callback(args) &#123; console.log(args); &#125; //3.要在服务端要处理跨域 $res = $_GET['callback']; echo $res.\"('我是服务的数据')\"; function callback(args) &#123; console.log(args); &#125;&lt;/script&gt;&lt;!-- 如果服务器返回的是js代码，那么浏览器就会直接执行js代码 借助浏览器的特性来实现跨域--&gt;&lt;script src=\"http://datainfo.duapp.com/shopdata/getGoods.php?call6‘back=callback\"&gt;&lt;/script&gt; 总体的流程大概就是这样子，不过实际开发中要与后台定好接口，希望能够帮到你。","categories":[],"tags":[{"name":"JSONP跨域","slug":"JSONP跨域","permalink":"http://www.1oveit.club/tags/JSONP跨域/"}]},{"title":"nvm-Mac安装使用","slug":"nav-Mac安装使用","date":"2016-06-02T04:49:10.000Z","updated":"2017-05-22T07:26:04.000Z","comments":true,"path":"2016/06/02/nav-Mac安装使用/","link":"","permalink":"http://www.1oveit.club/2016/06/02/nav-Mac安装使用/","excerpt":"node更新太快了，版本差异各异，这时候有必要安装node版本管理工具nvm了。 安装使用homebrew安装会出现莫名其妙的问题，这里推荐使用curl方式来安装：1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash","text":"node更新太快了，版本差异各异，这时候有必要安装node版本管理工具nvm了。 安装使用homebrew安装会出现莫名其妙的问题，这里推荐使用curl方式来安装：1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash 此时nvm安装在~/.nvm下，紧接着配置环境变量。 配置环境变量推荐大家使用zsh(终端神器)，打开~/.zshrc，在最后一行加上：12export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; 此时nvm都被添加到全局环境变量，紧接着输入source ~/.zshrc重新启动一下配置。输入nvm，会输出以下信息：1234567891011121314151617181920212223242526272829303132333435363738394041➜ ~ nvmNode Version ManagerNote: &lt;version&gt; refers to any version-like string nvm understands. This includes: - full or partial version numbers, starting with an optional &quot;v&quot; (0.10, v0.1.2, v1) - default (built-in) aliases: node, stable, unstable, iojs, system - custom aliases you define with `nvm alias foo`Usage: nvm help Show this message nvm --version Print out the latest released version of nvm nvm install [-s] &lt;version&gt; Download and install a &lt;version&gt;, [-s] from source. Uses .nvmrc if available --reinstall-packages-from=&lt;version&gt; When installing, reinstall packages installed in &lt;node|iojs|node version number&gt; nvm uninstall &lt;version&gt; Uninstall a version nvm use [--silent] &lt;version&gt; Modify PATH to use &lt;version&gt;. Uses .nvmrc if available nvm exec [--silent] &lt;version&gt; [&lt;command&gt;] Run &lt;command&gt; on &lt;version&gt;. Uses .nvmrc if available nvm run [--silent] &lt;version&gt; [&lt;args&gt;] Run `node` on &lt;version&gt; with &lt;args&gt; as arguments. Uses .nvmrc if available nvm current Display currently activated version nvm ls List installed versions nvm ls &lt;version&gt; List versions matching a given description nvm ls-remote List remote versions available for install nvm version &lt;version&gt; Resolve the given description to a single local version nvm version-remote &lt;version&gt; Resolve the given description to a single remote version nvm deactivate Undo effects of `nvm` on current shell nvm alias [&lt;pattern&gt;] Show all aliases beginning with &lt;pattern&gt; nvm alias &lt;name&gt; &lt;version&gt; Set an alias named &lt;name&gt; pointing to &lt;version&gt; nvm unalias &lt;name&gt; Deletes the alias named &lt;name&gt; nvm reinstall-packages &lt;version&gt; Reinstall global `npm` packages contained in &lt;version&gt; to current version nvm unload Unload `nvm` from shell nvm which [&lt;version&gt;] Display path to installed node version. Uses .nvmrc if availableExample: nvm install v0.10.32 Install a specific version number nvm use 0.10 Use the latest available 0.10.x release nvm run 0.10.32 app.js Run app.js using node v0.10.32 nvm exec 0.10.32 node app.js Run `node app.js` with the PATH pointing to node v0.10.32 nvm alias default 0.10.32 Set default node version on a shellNote: to remove, delete, or uninstall nvm - just remove the `$NVM_DIR` folder (usually `~/.nvm`) 使用nvm上面打印的内容已经告诉我们怎么使用了。首先输入nvm ls-remote查看node远程版本：12345➜ ~ nvm ls-remote v0.1.14 v0.1.15 v0.1.16 ... 然后输入nvm install &lt;版本号&gt;比如安装4.1.0版本nvm install v4.1.0紧接着使用，输入nvm use &lt;版本号&gt;比如使用4.1.0版本，输入nvm use v4.1.0 默认nvm当你新开一个bash，输入nvm current时显示为null。可以设置默认的nvm来解决问题，输入nvm alias default v4.1.0,可以看到12➜ ~ nvm alias default v4.1.0default -&gt; v4.1.0 指定v4.1.0作为默认版本 以后新开bash输入nvm current默认显示v4.1.0。","categories":[],"tags":[{"name":"nvm","slug":"nvm","permalink":"http://www.1oveit.club/tags/nvm/"},{"name":"node","slug":"node","permalink":"http://www.1oveit.club/tags/node/"},{"name":"版本管理工具","slug":"版本管理工具","permalink":"http://www.1oveit.club/tags/版本管理工具/"}]},{"title":"JavaScript简明教程（7）","slug":"js-07","date":"2016-05-28T01:05:25.000Z","updated":"2017-05-13T10:45:13.000Z","comments":true,"path":"2016/05/28/js-07/","link":"","permalink":"http://www.1oveit.club/2016/05/28/js-07/","excerpt":"很高兴你能看到这里，希望对你学习JavaScript有帮助。这是最后一章节，主要讲有关JavaScript的设计模式。 函数属性缓存思路说明 01 函数是对象，因此可以在函数上面添加属性和方法 02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果 03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value） 04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。","text":"很高兴你能看到这里，希望对你学习JavaScript有帮助。这是最后一章节，主要讲有关JavaScript的设计模式。 函数属性缓存思路说明 01 函数是对象，因此可以在函数上面添加属性和方法 02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果 03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value） 04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。 代码示例(单个参数)12345678910111213var func = function (param) &#123; if (func.cache[param] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[param] = result + param; &#125; return func.cache[param];&#125;func.cache = &#123;&#125;; //空对象console.log(func(\"demo\")); //字符串democonsole.log(func(\"test\")); //字符串testconsole.log(func(\"demo\")); //字符串demo 直接使用属性缓存中的数据,而不再进行复杂的计算(可以提升性能) 代码示例（多个参数）12345678910111213var func = function () &#123; var key = JSON.stringify(Array.prototype.slice.call(arguments)); if (func.cache[key] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[key] = result + key; &#125; return func.cache[key];&#125;func.cache = &#123;&#125;; //空对象func(\"123\",\"456\"); ////说明:如果传入的参数数量超过1,则可以将传入的参数序列化为一个json字符串作为参数处理。 代码说明：slice:返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素 命名空间模式作用:(1)有助于减少程序中所需要的全局变量的数量(2)并且同时还有助于避免命名冲突或过长的名字前缀。 说明：JavaScript中并没有内置的命名空间 如何实现命名空间可以为应用程序创建一个全局对象,然后将所有功能都添加到该全局对象中 从而在具有大量函数,对象和其他变量的情况下并不会污染全局范围。 建议 全局命名空间的名称可以随便写,但建议使用项目的名称或者是APP的名称 按照习惯,通过程序员会约定以全部大写的方式来约定全局命名空间。 命名空间模式的缺点 ① 需要输入更多的字符,在每个变量和函数前面都需要附加上前缀,总体上增加了代码的体积。 ② 仅有一个全局实例,意味着代码的任何部分都能够修改当前的实例。 ③ 很长的前缀意味着需要花更长的时间来解析属性(变量|属性访问原则-就近原则) 代码示例（零散的代码）123456789101112131415&lt;script&gt; //构造函数 function Person() &#123; &#125; function Man() &#123; &#125; var array = [1,2,3,4,5,6]; var testDemo01 = \"测试字符串01\"; var testDemo02 = \"测试字符串02\"; var obj = &#123;&#125;; obj.des = \"描述信息\"; obj.logDes = function () &#123; console.log(obj.des); &#125;&lt;/script&gt; 代码示例(命名空间模式) 1234567891011121314151617&lt;script&gt; //01 提供一个全局变量 var MYAPP = &#123;&#125;; //02 处理构造函数 MYAPP.Person = function () &#123;&#125;; MYAPP.Man = function () &#123;&#125;; //03 处理变量 MYAPP.array = [1,2,3,4,5,6]; MYAPP.testDemo01 = \"测试字符串01\"; MYAPP.testDemo02 = \"测试字符串02\"; //处理对象 MYAPP.obj = &#123;&#125;; MYAPP.obj.des = \"描述信息\"; MYAPP.obj.logDes = function () &#123; console.log(obj.des); &#125;&lt;/script&gt; 说明 01 在使用命名空间模式的时候,因为所有的变量和属性都添加到同一个全局对象下面,因此该全局对象下面可能有很多很多的属性。 02 而我们在添加属性的时候,很有可能该属性已经存在,这导致可能会覆盖掉之前的属性。 03 所以,在添加一个属性或者是创建一个命名空间之前,最好是先检查它是否已经存在。 04 但是如果每次添加属性都需要对属性进行检查则会产生代码冗余问题。 示例代码1234567891011121314151617181920212223242526//01 不好的演示//其他代码//var MYAPP = &#123;&#125;; //注意这是不安全的代码,因为有可能覆盖掉上下文中的代码//02 在创建命名空间之前,先检查该命名空间是否存在// if (MYAPP == 'undefined')&#123;// var MYAPP = &#123;&#125;;// &#125;//03 更好的做法var MYAPP = MYAPP || &#123;&#125;; //如果MYAPP为假,那么就返回&#123;&#125;并赋值给MYAPP//04 添加属性时的检查问题//假如现在需要添加一个name属性,那么在添加之前需要先检查该属性是否存在if (MYAPP.name == 'undefined')&#123; MYAPP.name = \"默认的名称\";&#125;//假如要添加一个obJ属性if (typeof MYAPP.obj == 'undefined')&#123; MYAPP.obj = &#123;&#125;;&#125;//假如要给MYAPP.obj添加属性,则if (typeof MYAPP.obj.des === \"undefined\")&#123; MYAPP.obj.des = \"对象的描述信息\"&#125;console.log(MYAPP.obj); 代码说明：我们在添加属性或者是方法的时候,比较安全的做法是在添加之前先在当前环境中进行检查,以免覆盖但是我们的检查操作催生出了一个新的问题,就是重复代码过多,能否考虑把检查的过程抽取 示例代码1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; var MYAPP = MYAPP || &#123;&#125;; MYAPP.namescape = function (string) &#123; //split() 方法用于把一个字符串分割成字符串数组 var parts = string.split('.'); var parent = MYAPP; console.log(parts); //先去掉最前面的冗余的全局变量 if(parts[0] == \"MYAPP\") &#123; //splice() 方法向/从数组中添加/删除项目,然后返回被删除的项目 //parts.splice(0,1); //slice() 方法可从已有的数组中返回选定的元素 //返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素 parts = parts.slice(1); &#125; console.log(parts,\"处理之后的数组\"); //通过for循环来遍历结构 for (var i = 0; i &lt; parts.length; i++) &#123; //检查属性,如果对应的属性不存在,那么就创建一个属性 if (typeof parent[parts[i]] == 'undefined') &#123; //初始化为一个空的对象 parent[parts[i]] = &#123;&#125;; &#125; //修正parent的值 parent = parent[parts[i]]; &#125; return parent; &#125; //代码示例 var testDemo01 = MYAPP.namescape(\"MYAPP.test.testDemo01\"); var testDemo02 = MYAPP.namescape(\"MYAPP.test.testDemo02\"); console.log(MYAPP); //忽略全面的前缀 MYAPP.namescape(\"sadsa.sadjaldj.adada.test\"); console.log(MYAPP); //演示长命名空间的情况 MYAPP.namescape(\"demo.testDemo.testDemos.ss.dd.qq.ddd.ffff.fff\"); console.log(MYAPP);&lt;/script&gt; 补充说明12301 split() 方法用于把一个字符串分割成字符串数组02 splice() 方法向/从数组中添加/删除项目,然后返回被删除的项目03 slice() 方法可从已有的数组中返回选定的元素 设计模式简单说明概念:设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案 注意,设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案 起源:该属于源于建筑行业 历史: （1）由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学 （2）四人帮著作《设计模式：可复用面向对象软件的基础》（Design Patterns - Elements of Reusable Object-Oriented Software） （3）Gang of Four:Erich Gamma + Richard Helm + Ralph Johnson +John Vlissides 优点: 为了可重用代码、让代码更容易被他人理解、保证代码可靠性 设计模式的分类创建型模式:工厂方法模式 + 抽象工厂模式 + 单例模式 + 建造者模式 + 原型模式 结构型模式:适配器模式 + 代理模式 + ... 行为型模式:观察者模式 + 命令模式 + ... 单例模式的思想保证一个特定的类只有一个实例。 即当我们第二次创建新对象的时候,得到的应该是和第一次创建的对象一模一样的对象(同一个对象) 其他语言中实现单例模式 在其它有Class的语言中,实现单例模式核心步骤是: 01 在创建对象实例时候判断,该类的实例对象是否已经存在,如果已经存在,那么就直接返回 02 如果不存在,那么就创建一个新的实例对象,并保存起来,下次创建实例对象的时候直接使用。 JavaScript中的单例模式JavaScript是一门弱类型,动态,基于原型的语言,并没有类,只有对象。 在JavaScript中要实现单例模式有很多种方式。 最简单的方式:使用字面量的方式来创建对象,因为在JavaScript中对象之间永远不可能相等,除非他们是同一个对象。 使用字面量方式创建的对象总是唯一的12345script&gt; var obj1 = &#123;name:\"zhangsan\"&#125;; var obj2 = &#123;name:\"zhangsan\"&#125;; console.log(obj1 == obj2); //false&lt;/script&gt; 使用new操作符创建对象实现单例 实现单例模式的几种途径 ① 在代码中提供一个全局变量来存储创建出来的实例 缺点:该全局变量可能会被轻易的修改和覆盖 ② 尝试在构造函数的静态成员中缓存实例属性。缺点:函数的静态属性在外部可以直接修改,容易导致实例对象的丢失。 ③ 将实例对象包装在闭包中。优点是安全性较好,无法被轻易的修改,缺点是有额外闭包的开销。 代码示例1234567function China() &#123;&#125;//创建对象var china01 = new China();var china02 = new China();//思考:如果想要实现单例模式,那么最终的结果必要是china01 和china02是同一个对象,那么如何实现 实现方案(一)使用全局变量方式存储创建出来的实例对象代码示例12345678910111213141516171819202122232425262728&lt;script&gt; //01 提供一个全局变量 var instance; //02 提供一个构造函数 function Person() &#123; if (instance == undefined) &#123; instance = this; &#125; this.name = \"默认的名称\"; this.age = 66; //使用全局变量来接收内部创建出来的实例对象(this) return instance; &#125; //03 使用构造函数创建对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2); console.log(p1.name); console.log(p2.name); p1.name = \"修改之后的名称\"; console.log(p1.name); console.log(p2.name); //说明:在上面的方案中我们使用一个全局变量来接收实例对象的值,在构造函数内部也是通过判断这个全局变量来做一些其他的处理 instance = &#123;&#125;; var p3 = new Person(); console.log(p1 == p3);&lt;/script&gt; 说明：这种方法确实可以实现单例模式,但是并不安全,因为全局变量可能会被轻易的修改或者是覆盖,因此不推荐这种方式。 实现方案(二)通过构造函数静态属性来缓存实例对象123456789101112131415161718192021222324252627&lt;script&gt; //01 提供一个构造函数 function Person() &#123; //02 在内部判断构造函数的静态属性中是否拥有实例对象 //如果拥有实例对象,那么就直接返回,否则就设置实例对象,并赋值给构造函数的静态属性 if (typeof Person.instance == \"object\") &#123; return Person.instance; &#125; //设置实例对象的属性和方法 this.name = \"默认的名称\"; this.age = 66; //03 把内部创建的实例化对象赋值给构造函数的静态属性 Person.instance = this; //显示返回 //return Person.instance; //隐式返回 //return this; &#125; //04 创建实例对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2); Person.instance = &#123;&#125;; var p3 = new Person(); console.log(p1 == p3); //false&lt;/script&gt; 说明：在构造函数外部可以直接访问其静态成员(属性和方法),可能会导致实例对象的丢失。 实现方案(二)通过闭包-惰性函数定义来实现12345678910111213141516171819202122&lt;script&gt; //01 提供一个构造函数 function Person() &#123; //02 在函数内部使用私有变量来缓存实例 var instance = this; //03 设置实例对象的属性和方法 this.name = \"默认的姓名\"; this.age = 66; //04 使用惰性函数定义来更新构造函数的实现 //通过一个闭包来返回缓存的实例对象 Person = function () &#123; return instance; &#125; &#125; //05 创建对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2); //代码说明:第一次调用原始构造函数的时候,它会像往常一样返回this(指向内部新创建的实例对象) //再后面调用的时候,它会执行更新后的构造函数,在这个新的函数实现中,我们通过闭包来访问了私有变量,并简单的返回。 //这个instance私有变量存储的是第一次调用构造函数时创建出来的实例对象&lt;/script&gt; 新的问题01 因为内部使用惰性函数定义(重写构造函数会导致之前添加在构造函数中的属性丢失),所以存在属性丢失问题02 在上面的代码中,体现在于创建对象前后设置的构造函数的原型对象丢失问题 代码示例123456789101112131415161718192021222324252627&lt;script&gt; function Person() &#123; var instance = this; this.name = \"默认的姓名\"; this.age = 66; Person = function () &#123; return instance; &#125; &#125; //设置构造函数的原型对象 Person.prototype.des = \"描述信息\"; var p1 = new Person(); //在创建第一个对象之后,设置原型对象 Person.prototype.someThing = \"something\"; var p2 = new Person(); console.log(p1 == p2); console.log(p1.des); //描述信息 console.log(p2.des); //描述信息 console.log(p1.someThing); //undefined console.log(p2.someThing); //undefined //打印对象的构造函数 console.log(p1.constructor.name); //Person console.log(p2.constructor.name); //Person //判断对象的构造函数 console.log(p1.constructor == Person); //false console.log(p1.constructor == p2.constructor,\"构造函数是否一致\");&lt;/script&gt; 解决问题的核心过程1234567891001 提供一个构造函数02 在构造函数内部提供一个私有变量instance03 重写构造函数,返回私有变量instance04 把原有的原型对象赋值给新Person构造函数的原型对象05 调用new 构造函数方法创建一个实例化对象赋值给instance06 修正instance实例的构造器属性,指向新的构造函数(注意:虽然重写了构造函数,但是instance的构造函数仍然是以前的Person)07 设置实例属性和方法08 返回instance对象代码示例 12345678910111213141516171819202122232425262728293031323334353637383940&lt;script&gt; function Person() &#123; //01 提供一个私有变量 var instance; //02 重写构造函数 Person = function () &#123; console.log(instance); //console.log(instance.constructor); var t = this; console.log(t); return instance; &#125;; //03 保留原型属性 Person.prototype = this.__proto__; //这是一个空的对象 Person.lal = \"lala\"; //04 创建并使用私有变量来接收实例对象 instance = new Person(); //05 修正构造函数指针 instance.constructor = Person; //06 设置实例属性和方法 instance.name = \"默认的名字\"; instance.age = 66; //07 返回私有变量 return instance; &#125; Person.haha = \"哈哈\"; //设置构造函数的原型对象 Person.prototype.des = \"描述信息\"; var p1 = new Person(); //在创建第一个对象之后,设置原型对象 Person.prototype.someThing = \"something\"; var p2 = new Person(); console.log(p1 == p2); console.log(p1.des); //描述信息 console.log(p2.des); //描述信息 console.log(p1.someThing); //something console.log(p2.someThing); //something //打印构造器属性 console.log(p1.constructor == Person,\"验证构造器指向\");&lt;/script&gt; 全局变量方式实现单例-改进版1234567891011121314151617181920&lt;script&gt; var Person; (function () &#123; //01 提供一个局部变量instance var instance; Person = function Person() &#123; if (instance) &#123; return instance; &#125; instance = this; this.name = \"默认的名字\"; this.age = 66; &#125; &#125;)(); //创建对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2);&lt;/script&gt; 说明：通过即时函数来限定作用域,外部无法修改内部instance的值(现在是一个局部变量) 工厂模式简单说明工厂模式的目的是用于创建对象,通常在类或者是类的静态方法中实现。 工厂模式的目标 01 用一套方法去创建相似的目标。 02 在编译时不知道具体类型的情况下,为用户提供创建对象的接口 工厂模式实现过程 01 提供一个父构造函数 02 在父构造函数的原型上添加共享的方法 03 在父构造函数身上提供一个静态方法(静态工厂方法) 001 先获取参数(产品类型) 002 判断构造函数是否存在(容错性处理) 003 设置原型链继承:设置子构造函数的原型对象为父构造函数的一个实例对象(目的是为了让子构造函数创建的对象拥有父构造函数上面实例属性和原型属性) 004 使用子构造函数创建实例对象 005 返回新创建的实例对象 04 定义特定的工厂客户(静态方法) 05 通过父构造函数的静态工厂方法来创建产品对象 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; //01 提供一个父构造函数 function PhoneMaker() &#123;&#125;; //02 在父构造函数的原型上添加共享的方法 PhoneMaker.prototype.callPhoneDes = function () &#123; console.log(\"手机的特点是: \" + this.des); &#125; //03 在父构造函数身上提供一个静态方法(静态工厂方法) PhoneMaker.factory = function (type) &#123; //001 先获取参数(产品类型) var typeStr = type; //002 判断构造函数是否存在(容错性处理) if (typeof PhoneMaker[typeStr] !== 'function') &#123; throw \"Error 对应的构造函数不存在,不能生产该种类型的产品\"; &#125; //003 设置原型链继承 PhoneMaker[typeStr].prototype = new PhoneMaker(); //004 使用子构造函数创建实例对象 var newPhone = new PhoneMaker[typeStr](); //005 返回新创建的实例对象 return newPhone; &#125;; //定义特定的工厂客户(静态方法) PhoneMaker.iphone = function () &#123; this.des = \"最安全稳定的系统\"; &#125; PhoneMaker.oppo = function () &#123; this.des = \"充当五分钟,通话两小时\"; &#125; PhoneMaker.vivo = function () &#123; this.des = \"vivo手机,你的音乐手机\"; &#125; //通过父构造函数的静态工厂方法来创建产品对象 var vivo = PhoneMaker.factory('vivo'); var iphone = PhoneMaker.factory('iphone'); var oppo = PhoneMaker.factory('oppo'); vivo.callPhoneDes(); oppo.callPhoneDes(); iphone.callPhoneDes();&lt;/script&gt; 观察者模式观察者模式观察者模式又名为发布-订阅者模式，它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。 观察者模式的特点（优点）12301 观察者模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案02 观察者模式可以取代对象之间硬性编码的通知机制，一个对象不再是显示的调用另外一个对象的接口，这种模式让两个对象松耦合的联系在一起，它们不需要清楚彼此的实现细节就能够相互通信。03 在这种设计模式中，不再是一个对象调用另外一个对象的方法，而是一个对象订阅另一个对象的特定活动并且在状态改变后获得通知 模型01 订阅者也称为观察者02 被观察的对象称为发布者或者是主题03 当发生一个重要事件的时候，发布者将会通知所有订阅者并且经常以事件的形式来传递消息。示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//01 提取成公共的发行者对象 var publisher = &#123; users:&#123; default:[] &#125;, //所有的订阅者对象 addUser:function (fn,type) &#123; //对订阅的类型进行判断 var type = type || \"default\"; //如果是新的订阅类型,那么我们需要做初始化的处理 if (this.users[type] == undefined) &#123; this.users[type] = []; &#125; this.users[type].push(fn); &#125;, removeUser:function (fn,type) &#123; this.tool(type,\"removerUser\",fn); &#125;, publish:function (type) &#123; this.tool(type,\"publish\"); &#125;, tool:function (type,funcType,fn) &#123; var type = type || \"default\"; var users = this.users[type]; if (users == undefined) &#123; console.log(\"当前没有任何订阅者\"); return; &#125; for (var i = 0; i &lt; users.length; i++) &#123; if (funcType == 'publish') &#123; users[i]() &#125;else &#123; if (users[i] == fn) &#123; users.splice(i, 1); break; &#125; &#125; &#125; &#125; &#125;; //02 提供一个工具函数,能够利用发行者对象的模板来快速创建新的发布者 function makePaper(o) &#123; for(var i in publisher) &#123; if (publisher.hasOwnProperty(i) &amp;&amp; typeof publisher[i] == 'function') &#123; o[i] = publisher[i]; &#125; &#125; o.users = &#123;default:[]&#125;; &#125; //03 创建发布者 var paper1 = &#123; day:function () &#123; this.publish(); &#125;, month:function () &#123; this.publish(\"month\") &#125;, year:function () &#123; this.publish(\"year\") &#125; &#125;; //把某个对象编程一个发布者 makePaper(paper1); //04 创建订阅者(当发布者发布消息的时候,订阅者能够收到信息--自动调用订阅者的方法) var obj = &#123; lookDayNews:function () &#123; console.log(\"obj - 查看最新的日报信息\"); &#125;, lookImageNews:function () &#123; console.log(\"obj - 查看图片信息\"); &#125; &#125;; //05 设置订阅 paper1.addUser(obj.lookDayNews); paper1.addUser(obj.lookImageNews,'month'); paper1.day(); paper1.month();&lt;/script&gt;","categories":[{"name":"JavaScript简明教程","slug":"JavaScript简明教程","permalink":"http://www.1oveit.club/categories/JavaScript简明教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"固定导航，不做抖man","slug":"解决页面抖动","date":"2016-05-10T16:17:25.000Z","updated":"2017-05-22T07:26:04.000Z","comments":true,"path":"2016/05/11/解决页面抖动/","link":"","permalink":"http://www.1oveit.club/2016/05/11/解决页面抖动/","excerpt":"如何hold住导航？ 页面结构假设一个网页由Header,Nav,Main三部分构成。","text":"如何hold住导航？ 页面结构假设一个网页由Header,Nav,Main三部分构成。1234567891011Header(Logo, other information)----------------------------------------------Nav(Nav,menu,links)----------------------------------------------Main(Container, Content)----------------------------------------------- 解决方法根据需求，当大于Header的高度时，固定住导航。当我们滚动滚轮时候，此时 Header 会被 Nav 所遮住，再往下面滚动时Nav会固定在顶部。最常规的解决方法,让Header固定定位，Nav上边距为Header的高度：123Header：position: fixedNav: margin-top: A.height 设置滚动事件：12345if (scrollTop &gt; Header.height) &#123; Nav: position: fixed&#125; else &#123; Nav: position: initial&#125; 这样做会所产生的问题： 当 Header fixed 后，页面高度由 Header + Nav + Main 变为 Header + Main，导致 Main 自动上移了 Nav.height，从而使 scrollTop 变小。这样根据滚动事件将执行 Nav: position: initial，用鼠标慢慢拖动时，Nav 会进行多次抖动（fixed-&gt;initial-&gt;fixed-&gt;initial-&gt;……）。 解决的方法如下： 使 Header fixed 后，页面高度依旧为 Header + Nav + Main。 Header: margin-top: A.height Nav-wrap： height: Nav.height 为了使用户产生 Header fixed 后的视觉动感，可设置 scrollTop &gt; Header.height + Nav.height / 3","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://www.1oveit.club/tags/css/"},{"name":"js","slug":"js","permalink":"http://www.1oveit.club/tags/js/"}]},{"title":"JavaScript简明教程（6）","slug":"js-06","date":"2016-04-25T03:19:14.000Z","updated":"2017-05-13T10:45:13.000Z","comments":true,"path":"2016/04/25/js-06/","link":"","permalink":"http://www.1oveit.club/2016/04/25/js-06/","excerpt":"闭包是学习JavaScript的难点之一，因JavaScript是单线程，故回调使用频繁，本章节主要讲了闭包以及回调。 闭包闭包简单说明 闭:关闭,封闭 包:包住,包裹 闭包:通过某种方式实现的一个封闭的、包裹的对外不公开的结构|空间 闭包的原理:变量的访问原则(即上一级的作用域无法访问下一级的作用域),其实函数本身就是闭包。","text":"闭包是学习JavaScript的难点之一，因JavaScript是单线程，故回调使用频繁，本章节主要讲了闭包以及回调。 闭包闭包简单说明 闭:关闭,封闭 包:包住,包裹 闭包:通过某种方式实现的一个封闭的、包裹的对外不公开的结构|空间 闭包的原理:变量的访问原则(即上一级的作用域无法访问下一级的作用域),其实函数本身就是闭包。 闭包要解决的问题 提供一种间接的方式能够访问到函数内部的数据（变量） 实现思路 01 我们需要能够在函数外部访问函数内部的变量，正常情况无法访问； 02 在函数内部如果新创建函数，那么安装作用域链的原则，这个新创建的内部函数能够访问到函数中的这些变量。 03 我们如果能够操作函数中新创建的函数，那么就能够操作函数中的变量（如访问和设置等） 04 如果要能够操作函数中新创建的函数，那么需要在函数中把新创建的函数返回。 05 调用函数，接收并得到其返回值（是一个函数） 06 调用返回值（函数），通过函数传参的方式来设置函数中的变量。 07 调用返回值（函数），通过在函数内部再次return的方式来访问函数中的变量。 闭包的基本模式 在函数内部创建函数(内部函数),在这个内部函数中,可以操作外部函数中的变量 01 在函数(外部)中创建函数(内部函数),在该函数(内部函数)中操作外部函数中的变量 02 在外部函数中,把内部函数作为返回值返回 03 调用外部函数,并接收其返回值(是一个函数) 04 调用接收到的返回值(内部函数),来间接的操作外部函数中的变量 代码示例123456789function func() &#123; var num = 10; return function (n) &#123; num = n; console.log(num); &#125;&#125;var funcName = func();funcName(\"哗啦哗啦\"); 闭包获取数据获取单个数据（考虑赋值）123456789101112131415function func() &#123; var num = 123; return function (a) &#123; if (a !== undefined) &#123; num = a; &#125; return num; &#125;&#125;var f1 = func();var x = f1(456);var y = f1();console.log(x);console.log(y); 说明：上面的代码能够支持通过闭包对函数中的变量num进行访问（取值）或赋值的操作。 获取多个数据（数组）123456789101112131415function func() &#123; var name = \"张学友\"; var age = 40; return [ function getName() &#123; return name; &#125;, function getAge() &#123; return age; &#125; ]&#125;var foo = func();console.log(foo[0]()); //张学友console.log(foo[1]()); //40 说明：上面的代码能够满足返回多个变量值的需求，但是要数组操作的方式并不常见，且和使用习惯不符合。 利用对象返回并设置对个变量值1234567891011121314151617181920212223242526function foo() &#123; var name = \"张学友\"; var age = 45; return &#123; getName:function () &#123; return name; &#125;, getAge:function () &#123; return age; &#125;, setName:function (nameValue) &#123; name = nameValue; &#125;, setAge:function (ageValue) &#123; age = ageValue; &#125; &#125;&#125;var func = foo();console.log(func.getName()); //张学友console.log(func.getAge()); //45func.setName(\"张三\");func.setAge(30);console.log(func.getName()); //张三console.log(func.getAge()); //30 闭包的作用最基本的作用:闭包中的变量更安全,只能通过特定的接口来访问说明:12(1)创建一个私有的空间,保护数据,外界如果需要访问数据必须通过函数提供的指定方法(2)在这些指定的方法中,我们可以设置一些校验的逻辑,以保证对数据访问和设置的安全性 闭包的使用注意进程和线程 进程指的是系统中正在运行的一个应用程序。 线程:一个进程中可以有一个或多个线程,线程是CPU调度的最小单位,是真正执行任务的。 多线程:一个中可能有多条线程,多条线程之间并发的执行多个不同的任务。 单线程:一个进程中只有一条线程,即同一时间只能执行一个操作,只能干一件事情。 javascript是单线程的 js中的线程主要处理三块任务: 01 渲染任务 02 js的代码执行任务 03 js中的事件处理任务(如setTimeOut方法) javascript中代码的执行顺序 01 先把主任务执行完毕(代码任务)02 主任务执行完毕之后再执行次要的任务(包括setTimeOut方法等) 关于setTimeOut函数 函数的作用:一次性定时器(用于延迟执行任务) 参数: 第一个参数:要执行的任务 第二个参数:要延迟执行的时间,时间的单位是毫秒 函数说明： 01 至少在指定的时间后才能够执行回调函数 02 因为要等主任务中的代码执行完毕之后,才回去检查setTimeOut的回调函数。 通过闭包解决setTimeOut函数的问题12345678910111213&lt;script&gt; for (var i = 0; i &lt; 10; i++) &#123; setTimeout((function (j) &#123; return function () &#123; console.log(j); &#125; &#125;)(i),10); console.log(\"----\"); &#125;&lt;/script&gt; 函数的特殊之处函数的特殊之处在于,它本身是对象,且函数可以提供作用域。 (01) 函数可以在运行时动态的创建,还可以在程序执行过程中创建。 (02) 函数可以赋值给变量,可以被扩展,甚至是删除。 (03) 函数可以作为其他函数的参数和返回值。 (04) 函数可以拥有自己的属性和方法。 注意:{} 块在js中不会创建作用域,哪怕是if或者是while语句中使用var关键字声明的变量也并非局部变量。 函数是可以通过（）调用并执行的对象。 函数是第一型对象12301 函数可以像普通对象一样作为函数的参数02 函数可以像普通对象一样赋值给变量（函数表达式）03 函数可以像普通对象一个作为函数的返回值返回 代码示例123456789101112131415//函数作为参数传递 setTimeout(function () &#123; console.log(1); &#125;,100); //函数作为返回值 function func() &#123; return function () &#123; console.log(\"demo\"); &#125; &#125; var f = func(); f(); //demo //函数赋值给变量 var a = function()&#123;&#125; a(); //直接通过变量的名称调用函数 函数的两个特征1201 函数本质上是对象02 函数可以创建作用域 约定1234var add = function add(a,b)&#123;return a + b;&#125;; //命名函数表达式var add = function (a,b)&#123;return a + b;&#125;; //函数表达式,匿名函数 以上也称为使用字面量的方式来创建函数(或者是函数字面量)function add()&#123;&#125;; //函数声明 代码示例123456789101112131415&lt;script&gt; //01 函数声明 function demo01() &#123; &#125; //02 函数表达式(匿名函数) var demo02 = function () &#123; &#125;; //03 命名函数表达式 var demo03 = function demo03Test() &#123; &#125;; //04 打印name属性 console.log(demo01.name); //demo01 console.log(demo02.name); //demo02 (注意在火狐浏览器中打印出来的name属性为空) console.log(demo03.name); //demo03Test&lt;/script&gt; 函数回调回调函数(回调),当我们把某个函数作为参数传递给另一个函数的时候,这个函数就称为回调函数 函数回调的基本模式12345678910&lt;script&gt; function func(callBack) &#123; //处理其他的操作 callBack(); //调用回调函数 &#125; function demo() &#123; console.log(\"这是一个回调函数\"); &#125; func(demo); //注意调用函数的时候,参数是回调函数的引用(不要加括号);&lt;/script&gt; 函数回调解决this问题说明：如果回调函数是某个对象的方法,而该对象方法中使用了this指针那么该方法作为回调函数来使用的时候,需要注意this123456789101112131415161718192021222324252627//01 提供一个对象,该对象中永远showName方法var obj = &#123; name:\"默认的名字\", age:30, showName:function () &#123; console.log(this.name); &#125;, showAge:function () &#123; console.log(this.age); &#125;&#125;;//02 提供一个函数,该函数接受一个参数(函数引用)function demo(callBack,callBack_obj) &#123; //处理第一个参数传递对象方法字符串的形式 if(typeof callBack == 'string') &#123; callBack = callBack_obj[callBack]; &#125; if (typeof callBack == 'function') &#123; callBack.call(callBack_obj); &#125;&#125;//demo(obj.showName,obj);//demo(obj.showAge,obj);//传递字符串和对象来进行调用demo(\"showName\",obj); 代码说明：123（01）以上代码传入两个参数，分别为具体的回调函数，和该回调函数所属的对象（02）该函数的参数接受两种方式的回调传递（一种是直接传递函数引用，一种是直接以字符串的方式传递对象方法的字符串）（03）在函数内部对传入的回调参数做处理，修正this的问题 函数作为函数的返回值12① 使用闭包实现一个计数器(在该示例中setup函数的返回值为一个函数)② 通过调用返回值(一个函数),可以操作setup函数中的变量 123456789101112&lt;script&gt; var setup = function () &#123; var count = 0; return function () &#123; return count ++; &#125; &#125; var next = setup(); console.log(next()); //0 console.log(next()); //1 console.log(next()); //2&lt;/script&gt; 惰性函数定义说明：某个函数直到第一次使用的时候才被正确的定义,并且其具有向后惰性,执行更少的工作。应用场景:函数有一些初始化的准备工作要做,且只需要执行一次的情况。特点:能够更新自己(函数)的实现。缺点: 01 当重新定义自身的时候,已经添加到原始函数的任何属性都会丢失。 02 如何函数被赋值给了其他的变量或者是对象方法,那么在使用变量或者是对象方法调用时仍然会执行旧的函数体。代码示例123456789function foo() &#123; console.log(\"foo!\"); foo = function () &#123; console.log(\"new foo!\"); &#125;&#125;//函数的调用//foo(); //foo!//foo(); //new foo! 问题： ① 添加属性 ② 把函数赋值给新的变量 ③ 以对象的方法调用函数 当惰性函数定义在处理以上三种情况的时候，使用新的变量名调用或者是是以对象的方法来调用函数，那么该函数在执行的时候并不会更新自身，而是执行旧的函数体的内容 代码示例1234567891011121314151617181920212223242526272829&lt;script&gt; //01 声明函数foo function foo() &#123; console.log(\"foo!\"); foo = function () &#123; console.log(\"foo! foo!\"); &#125; &#125; //02 为foo函数对象添加属性 foo.description = \"foo函数的描述信息\"; //03 把foo函数赋值给其他的变量 var func = foo; //04 把foo函数赋值给对象中的方法 var obj = &#123; showFoo:foo &#125; //05 验证并演示输出 func(); //foo! func(); //foo! console.log(func.description); //foo函数的描述信息 //总结:01 如果把函数赋值给其他的变量,那么在以其他变量的方式调用时不会更新自身,还是执行旧的函数体 obj.showFoo(); //foo! obj.showFoo(); //foo! console.log(obj.showFoo.description); //foo函数的描述信息 //总结:02 如果把函数赋值给对象的方法,那么在以对象方法形式调用时不会更新自身,还是会执行旧的函数体。 foo(); //已经更新过foo函数 foo! foo! foo(); //已经更新过foo函数 foo! foo! console.log(foo.description); //undefined&lt;/script&gt; 即时函数 定义:在函数定义之后立即执行该函数。即时函数模式的组成: ① 使用函数表达式来定义函数(匿名函数,注意不能使用函数声明方式) ② 在函数表达式末尾添加一组(),表示立即执行当前函数。 ③ 将整个函数包装在()中,有两种方式` 即时函数的作用 01 用来将所有的代码包装到当前的作用域中,并且不会将任何的变量泄露到全局作用域中。 02 js中没有代码块作用域,而函数是js中唯一可以创建作用域的。 03 即时函数就是利用了函数创建作用域这一点,来实现对一些需要封装且不允许外部访问的操作。 即时函数的优点01 不会产生全局变量,在即时函数内部定义的所有变量都仅仅只是该函数的局部变量,不会造成全局变量污染问题。02 具有更好的封装性,外部无法访问到该函数内部的数据。 即时函数代码示例12345678//第一种写法(function () &#123; console.log(\"即时函数的第一种写法\");&#125;());//第二种写法(function () &#123; console.log(\"即时函数的第二种写法\");&#125;)(); 写法补充123456789(function (a) &#123; console.log(a); &#125;(20)); +function (b) &#123; console.log(b); &#125;(30); -function (b) &#123; console.log(b); &#125;(40); 即时函数的传参和返回值12345678910//01 接受参数 (function (str) &#123; console.log(str); //hello &#125;)(\"hello\"); //02 提供返回值并赋值给新的变量 var foo = (function () &#123; return 2 + 1; &#125;)(); console.log(foo); //3 即时对象初始化01 结构特征:12345① 提供一个对象,在该对象内部提供一个init初始化方法② 使用()把对象包装起来(让字面量变成表达式)③ 然后随即调用init方法,完成初始化操作。 02 基本结构({}).init(); 03 模式优点 在执行一次性的初始化任务时保护全局的命名空间。 代码示例1234567891011121314&lt;script&gt; (&#123; name:\"张三\", age:23, getDescript:function () &#123; console.log(\"名字:\" + this.name + \"年龄:\" + this.age); &#125;, //注意:在对象中访问对象的属性和方法都需要使用this.前缀 init:function () &#123; this.getDescript(); //其他的初始化处理 &#125; &#125;).init();&lt;/script&gt; 函数属性缓存思路说明 01 函数是对象，因此可以在函数上面添加属性和方法 02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果 03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value） 04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。 代码示例(单个参数)1234567891011121314var func = function (param) &#123; if (func.cache[param] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[param] = result + param; &#125; return func.cache[param];&#125;func.cache = &#123;&#125;; //空对象console.log(func(\"demo\")); //字符串democonsole.log(func(\"test\")); //字符串testconsole.log(func(\"demo\")); //字符串demo 直接使用属性缓存中的数据,而不再进行复杂的计算(可以提升性能) 代码示例（多个参数）12345678910111213var func = function () &#123; var key = JSON.stringify(Object.prototype.slice.call(arguments)); if (func.cache[key] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[key] = result + key; &#125; return func.cache[key];&#125;func.cache = &#123;&#125;; //空对象func(\"123\",\"456\"); ////说明:如果传入的参数数量超过1,则可以将传入的参数序列化为一个json字符串作为参数处理。 代码说明：slice:返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素","categories":[{"name":"JavaScript简明教程","slug":"JavaScript简明教程","permalink":"http://www.1oveit.club/categories/JavaScript简明教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"JavaScript简明教程（5）","slug":"js-05","date":"2016-03-17T17:09:24.000Z","updated":"2017-05-13T10:45:13.000Z","comments":true,"path":"2016/03/18/js-05/","link":"","permalink":"http://www.1oveit.club/2016/03/18/js-05/","excerpt":"JavaScript中有严格模式和非严格模式两种运行环境,本章节主要讲严格模式及非严格模式下函数和变量的区别,最后简单讲诉了JavaScript作用域。 变量和函数私有变量和函数 定义在构造函数内部而被this对象的变量,在外部无法访问到的变量和函数","text":"JavaScript中有严格模式和非严格模式两种运行环境,本章节主要讲严格模式及非严格模式下函数和变量的区别,最后简单讲诉了JavaScript作用域。 变量和函数私有变量和函数 定义在构造函数内部而被this对象的变量,在外部无法访问到的变量和函数 公有变量和方法 对外暴露接口,可以通过构造函数对象创建的对象访问的属性和方法 代码示例1234567891011121314151617function Car(type,number) &#123; this.type = type; //公共的属性 this.number = number; var city = \"广州\"; //私有变量 var getNumber = function () &#123; //私有函数 return number; &#125;; var getType = function () &#123; return type; &#125;; //能够访问私有变量和函数的方法 --- 特权方法 this.getDescription = function () &#123; console.log(getNumber() + getType() + city); &#125; &#125; var car = new Car(\"汽车\",\"201718\"); car.getDescription(); 说明：能够访问构造函数内部私有变量|函数的方法称之为特权方法 构造函数的问题构造函数本身是一个函数，在调用的时候有多种调用方式。12① new 构造函数（）调用② 构造函数（）调用 以上，第二种调用方式存在作用域安全的问题 作用域安全的构造函数12345678910111213141516171819202122&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; //容错处理 if (this instanceof Person) &#123; //设置实例属性和方法 this.name = name; this.showName = function () &#123; console.log(this.name); &#125; &#125;else &#123; return new Person(name); &#125; &#125; //02 创建对象 var p1 = new Person(\"zhangsan\"); var p2 = new Person(\"lisi\"); p1.showName(); p2.showName();&lt;/script&gt; 新的问题说明:上面的代码在使用借用构造函数方式继承的时候存在问题，无法创建出的对象，原因在于通过call或者是apply函数调用的时候，内部的this绑定的子类型中的对象，因此在使用instanceOf 判断的时候，结果为假。解决：可以设置让子类型（构造函数）的原型对象为父类型的一个实例。代码示例123456789101112131415161718192021222324252627282930&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; //容错处理 if (this instanceof Person) &#123; //设置实例属性和方法 this.name = name; this.showName = function () &#123; console.log(this.name); &#125; &#125;else &#123; return new Person(name); &#125; &#125; //02 创建对象 var p1 = new Person(\"zhangsan\"); var p2 = new Person(\"lisi\"); p1.showName(); p2.showName(); // 使用借用构造函数来实现继承 function Boy(name)&#123; Person.call(this,name); &#125; //需要结合原型继承来解决 instanceOf 实例对象检测的问题 Boy.prototype = new Person(); var boy = new Boy(\"测试的名字\"); boy.showName();&lt;/script&gt; 严格模式关键字 “use strict”;实现严格模式:只需要在脚本代码中添加上上述关键字即可。 关键字具体说明12345(1) 注意区分大小写，必须全部都是小写的(2) 注意空格，整个字符串总共10个字符(3) 单引号和双引号无所谓，但是需要有双引号(4) 必须写在作用域的最顶部，注意其位置(5) 可以加分号，也可以不加，但是必须是一个字符串 注意：以下的关键字写法均是错误的123\"USE strict\";\" use strict \";\"(\"USE strict\").toLowerCase();\" 严格模式使用注意12345678910111 所有的变量必须使用var 关键字声明2 不能使用delete关键字删除全局变量 ,以前默认删除失败,严格模式下直接报错3 在对象中不允许有同名的属性4 函数的参数必须唯一(不能出现同名的参数)5 arguments对象的行为不同,在非严格模式下修改形参的值会反映到arguments中,而严格模式下则相对独立6 禁用了argument.callee和caller函数,他们一个引用函数本身,一个引用调用函数7 不能在if语句中声明函数8 禁止使用eval和arguments作为标识符9 修正this的值,在严格模式下,函数this的值始终是指定的值,无论指定的是什么值。10 禁用了with语句11 去掉了JavaScript中的八进制字面量(以0开头的八进制字面量是无效的语法) 1 所有的变量都必须使用var关键字声明12a = 10; //错误的演示console.log(10); ② 不能使用delete关键字删除全局变量1234//在非严格模式下,删除失败(静默失败) 失败了不吭声,严格模式下直接报错var a = 10;delete a;console.log(a); ③ 在对象中不允许有同名的属性1234567//在非严格模式下,会使用后面的属性赋值作为最终值,在严格模式下则直接报错var obj = &#123; name:\"张三\", name:\"李四\"&#125;console.log(obj); ④ 函数的参数必须唯一(不能出现同名的参数)123456789101112//在非严格模式下,如果函数在定义的时候,使用了多个同名的参数,则在函数内部形参的实际值为最后一个传入的实参值//在严格模式下,直接报错// function func(a,a,a) &#123;// console.log(a);// console.log(arguments);// &#125;function func(a,b,c) &#123; console.log(a); console.log(arguments);&#125;func(1,2,3); arguments对象的行为不同说明：（1）严格模式下,在函数内部修改了对象的指向,对arguments的值不会产生影响（2）在严格模式下,形参的值和arguments的值是相互独立的,在函数内部修改了形参的值对arguments不受影响（3）在非严格模式下，修改了形参的值，arguments中的数据会跟着改变123456789101112131415161718 //测试引用类型的值作为函数的参数function funcName(obj) &#123; console.log(obj); console.log(arguments[0]); //在函数内部修改形参的值 obj = &#123;age:20&#125;; console.log(obj); console.log(arguments[0]); &#125; funcName(&#123;name:\"张三\"&#125;); //测试基本类型数据作为函数的参数 function fun(str) &#123; console.log(str); console.log(arguments[0]); str = \"hello\"; console.log(arguments[0]); &#125; fun(\"hi\"); ⑥ 禁用了argument.callee和caller函数说明：argument.callee是对函数自身的引用argument.calller是对调用函数的引用12345678var num = (function (n) &#123; if (n ==1) &#123; return 1; &#125; return arguments.callee(n-1) + n; &#125;)(10); console.log(num); //55 ⑦ 不能在if语句中声明函数123456789//如果在if语句中声明函数，则会产生语法错误 if (true) &#123; console.log(\"________\"); function demo() &#123; console.log(\"呵呵呵呵\"); &#125; demo(); &#125; ⑧ 禁止使用eval和argument作为标识符1234var eval = \"测试的字符串\";console.log(eval);var arguments = \"参数列表\";console.log(arguments); ⑨ 修正this的值12345678在严格模式下,函数this的值始终是指定的值,无论指定的是什么值var name = \"测试的name\";function demoTest() &#123; //在非严格模式下,打印出来的this为全局的对象window console.log(this); //在严格模式下打印出来的this为undefined&#125;demoTest(); ⑩ 禁用了with语句1234567var o = &#123;name:\"暂时干\",age:20&#125;; with(o) &#123; name = \"lisi\"; age = 48 &#125; console.log(o); 禁用了八进制123//以0开头的数据常常引起混乱//var num = 023; //2*8 + 3 ==&gt; 19//console.log(num); //19 书写格式1234501 必须使用单引号或者是双引号括住字符串02 必须使用小写,不能出现大写字符03 必须是10个字符04 字符串后面的分号可以省略05 必须写在当前作用域的最顶上 代码示例123456789101112&lt;script&gt; //\"use strict\"; //正确写法 //\"use strict\" //正确写法 分号可以省略 //'use strict'; //正确写法 可以使用单引号 //\"use strict\"; //错误写法 必须是10个字符 //\"use Strict\"; //错误写法 所有的字符都必须小写 \"use strict\"; a = 10; // \"use strict\"; //错误写法 必须写在当前作用域的顶端 b = 20; console.log(a);&lt;/script&gt; 作用范围12① 函数的顶部(只对当前的函数有效)② script标签的顶部,只对当前的标签有效,对页面中其他的script无效 代码示例12345678910111213141516 //位置01 对func01和func02都有效 //\"use strict\"; function func01() &#123; //位置02 对func01有效,对func02无效 //\"use strict\"; a = 10; console.log(a); &#125; function func02() &#123; //位置03 对func02有效,但对func01无效 //\"use strict\"; b = 20; console.log(b); &#125;func01(); func02(); 函数的几种调用方式123401 普通函数调用 内部的this指向全局对象window02 构造函数调用 内部的this指向新创建的对象03 对象的方法调用 内部的this指向调用的对象本身04 通过call 或者是apply方式调用(函数上下文),this指向的是当前的上下文对象 this丢失demo演示123456789101112&lt;script&gt; var obj = &#123; name:\"张三\", getName:function () &#123; console.log(this.name); &#125; &#125;; //以对象的方法来进行调用 obj.getName(); //张三 var getName = obj.getName; getName(); //以普通函数的方式调用,此时内部的this指向的是window对象 打印的是window.name 为空值&lt;/script&gt; 代码示例0212345678910111213141516&lt;script&gt; //01 获取页面中id值为demo的标签 //var div = document.getElementById('demo');// var getId = document.getElementById;// var div = getId('demo'); //会报错?// console.log(div); //借用apply来修正this document.getElementById = (function (func) &#123; return function () &#123; return func.apply(document,arguments); &#125; &#125;)(document.getElementById); var getId = document.getElementById; var div = getId('demo'); //会报错? console.log(div);&lt;/script&gt; 代码说明：12301 因为document.getElementById方法的内部实现中需要使用到this,这个this本来期望指向的是document对象02 当我们以document.getElementById来调用的时候,内部的this指向document对象03 但是当我们以getId的方式调用的时候,内部的this指向的是window对象(因为我们以普通的方式进行调用) 作用域变量其作用的范围就是它的作用域 块级作用域说明：JavaScript中没有块级作用域123456for (var i = 0; i &lt; 10; i++) &#123; var num = i; &#125; console.log(i); console.log(num); //说明:如果有块级作用域,则i和num打印的结果应该为undefined 词法作用域123词法作用域:在代码写好的那一刻,变量的作用域就已经确定的动态作用域:变量的作用域由执行时的环境所决定说明:在js中不是动态作用域,当调用的时候,是往上查找的,不会到其他函数的作用域中去查找 在JavaScript中唯一能够产生作用域的东西是函数代码演示123456789101112131415161718192021222324&lt;script&gt; var a = \"这是第一个a\"; function func01() &#123; console.log(a); //先在当前作用域中查找,如果没有则访问全局的作用域 &#125; function func02() &#123; var a = \"这是第二个a\"; func01() &#125; func01(); //打印结果为:这是第一个a func02(); //打印结果为:这是第一个a&lt;/script&gt;&lt;script&gt; var a = \"这是第一个a\"; function func02() &#123; var a = \"这是第二个a\"; func01() &#125; function func01() &#123; console.log(a); //先在当前作用域中查找,如果没有则访问全局的作用域 &#125; func01(); //打印结果为:这是第一个a func02(); //打印结果为:这是第一个a&lt;/script&gt; 词法作用域的规则1234① 在函数内部允许访问外部的变量② 只有函数可以限定作用域③ 作用域规则首先使用提升规则分析④ 如果当前作用域中有该变量,则不考虑外部作用域的同名变量 变量和函数提升JS中的代码执行分为两个步骤① 预解析JavaScript在预解析阶段,会对使用var关键字声明的变量和function声明的代码块进行提升操作,提升到当前作用域的顶端② 执行 代码提升的几种情况 01 函数提升123456&lt;script&gt; func(); function func() &#123; console.log(\"测试的函数\"); &#125;&lt;/script&gt; 02 变量提升1234567&lt;script&gt; console.log(a); //打印出来的结果为undefined var a = 10; //var a; //注意:只会对变量的声明进行提升 //console.log(a); //a = 10&lt;/script&gt; 03 函数同名情况提升12345678910111213141516171819&lt;script&gt; func01(); //打印last function func01() &#123; console.log(\"first\"); &#125; func01(); //打印last function func01() &#123; console.log(\"last\"); &#125; //模拟提升后的情况 function func01() &#123; console.log(\"first\"); &#125; function func01() &#123; console.log(\"last\"); &#125; func01(); func01();&lt;/script&gt; 说明：预处理的时候，同名的函数都会进行提升，但是后面的会覆盖掉前面的 04 变量名和函数同名的情况12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; console.log(a); //打印function function a() &#123; console.log(\"我是一个函数\"); &#125; var a = 20; console.log(a); //打印20 //变量和函数提升后的结果 错误// function a() &#123;// console.log(\"我是一个函数\");// &#125;// var a ;// console.log(a);// a = 20;// console.log(a); //变量和函数提升后的结果 正确 function a() &#123; console.log(\"我是一个函数\"); &#125; console.log(a); var a = 20; console.log(a);&lt;/script&gt;```js总结:如果出现变量和函数同名的情况,则在进行提升的时候,只会提升函数到当前作用域顶端而忽略变量的提升操作**变量的提升是分作用域的**示例代码01```js&lt;script&gt; console.log(a); //undefined var a = 10; //模拟提升 var a; console.log(a); //undefined a = 10;&lt;/script&gt; 示例代码0212345678910111213141516171819&lt;script&gt; var num = 10; function func() &#123; var num = 20; console.log(num); &#125; console.log(num); //10 func(); //20 //模拟提升 var num; function func() &#123; var num; num = 20; console.log(num); &#125; num = 10; console.log(num); //10 func(); //20&lt;/script&gt; 示例代码031234567891011121314151617var num = 10;function func() &#123; console.log(num); var num = 20;&#125;console.log(num); //10func(); //undefiend//模拟提升var num;function func() &#123; var num; console.log(num); num = 20;&#125;num = 10;console.log(num); //10func(); //undefiend 示例代码041234567891011121314151617var num = 10;function func() &#123; console.log(num); num = 20;&#125;console.log(num); //10func(); //10//模拟变量提升var num;function func() &#123; console.log(num); num = 20;&#125;num= 10;console.log(num); //10func(); //10console.log(num); //20 函数表达式的提升说明：在使用函数表达式方式创建函数的时候,整个函数表达式并不会进行提升,只会对var声明的变量提升1234567891011func();var func = function () &#123; console.log(\"会不会被调用\");&#125;//以上如上代码将报错//模拟提升的过程var func;func(); //找不到这个函数func = function () &#123; console.log(\"会不会被调用\");&#125; 作用域链01 在js中函数可以创建作用域 02 函数中又可以创建函数(即又可以开辟新的作用域) 03 函数内部的作用域可以访问外部的作用域 04 如果有多个函数嵌套,那么就会构成一个链式的访问结构,也就是作用域链 05 注意:函数内部的作用域可以访问外部的作用域,但是外部的作用域却不能访问内部的作用域 代码示例1234567891011121314151617&lt;script&gt; function f1() &#123; //f1---&gt;全局作用域 function f4() &#123; //f4--&gt;f1---&gt;全局作用域 function f5() &#123; &#125; &#125; &#125; function f2() &#123; //f2--&gt;全局作用域 function f6() &#123; &#125; &#125; function f3() &#123; &#125;&lt;/script&gt; 作用域链绘图说明 ① 先画出全局作用域线条，然后在上面添加全局作用域中的函数和变量，作为0级作用域链 ② 画出全局作用域中的函数的作用域线条，，然后在上面添加当前作用域中的函数和变量，作为1级作用域链 ③ 以此类推，直至完成 示例代码01123456789function f1() &#123; function f2() &#123; &#125; &#125; var a = 20; function f3() &#123; function f4() &#123; &#125; &#125; 图示 示例代码021234567891011121314function f1() &#123; function f2() &#123; function f5() &#123; var b = \"demo\"; &#125; &#125; &#125; var a = 20; function f3() &#123; var c = \"啊哈哈\"; function f4() &#123; var d = \"test\"; &#125; &#125; 图示 作用域注意点和变量搜索原则注意点 01 在获取值和设置值的时候都是访问变量 02 并非在函数内部写了变量,这个变量就属于当前函数,而是必须使用var 关键字声明的变量才属于当前函数 03 函数在声明的时候,里面的代码并不会执行,只有在函数调用的时候才会执行 04 声明函数时候的函数名,其实也是一个变量名,可以通过这个变量名来进行设置和赋值 05 注意:在变量内部使用var 关键字声明一个变量并不会把同名的全局变量覆盖掉 1234567var a = 10;function f1() &#123; var a = 20; //注意:该行代码并不会覆盖掉全局变量中的变量a console.log(a);&#125;f1(); //20console.log(a); //10 代码点评：12在函数中使用var关键字声明变量a并不会覆盖全局作用域中的a。注意需要同时考虑变量在当前作用域的提升以及访问变量时的搜索原则。 1234567function f1() &#123; console.log(1);&#125;var f1 = \"demo字符串\"; //该行代码会把f1函数覆盖掉f1 = \"demoTest字符串\";console.log(f1);//f1(); 代码点评:函数的名称也是变量，如果在代码中出现同名的变量，那么函数的实现会被覆盖掉 变量搜索原则 01 在使用变量的时候,首先在自己的作用域中查找 02 如果找到了就直接使用,如果没有找到,那么就到上一级作用域中去查找 03 重复上面的步骤,直到0级作用域,如果还是找不到那么就返回undefined(报错)","categories":[{"name":"JavaScript简明教程","slug":"JavaScript简明教程","permalink":"http://www.1oveit.club/categories/JavaScript简明教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"JavaScript简明教程（4）","slug":"js-04","date":"2016-03-05T05:26:28.000Z","updated":"2017-05-13T10:45:13.000Z","comments":true,"path":"2016/03/05/js-04/","link":"","permalink":"http://www.1oveit.club/2016/03/05/js-04/","excerpt":"本章节主要讲解了原型链及相关方法。 原型链及相关属性方法简单说明原型链代码示例","text":"本章节主要讲解了原型链及相关方法。 原型链及相关属性方法简单说明原型链代码示例1234567891011121314151617&lt;script&gt; //01 提供Person构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置Person的原型对象 Person.prototype.showName = function () &#123; console.log(this.name); &#125; //03 创建Student构造函数 function Student(number) &#123; this.numer = number &#125; //04 设置Student的原型对象 Student.prototype = new Person();&lt;/script&gt; 原型链图示例 Object对象Object构造函数01 使用Object构造函数创建字符串对象12345678//01 创建字符串对象var str1 = new String(\"测试字符串\");var str2 = new Object(\"测试字符串\");var str3 = str1;//注意:对象比较相等(需要引用[地址]相等)console.log(str1 == str2); //falseconsole.log(str1 === str2); //falseconsole.log(str1 === str3); //true 02 使用Object构造函数创建数字对象12var num = new Object(10);console.log(typeof num); //object 03 使用Object构造函数创建布尔类型对象12var bool = new Object(true); console.log(typeof bool); //object js中所有的内置或自定义对象都继承自Object对象,几乎所有的对象都可以使用Object.prototype上面的属性和方法 Object.prototype01 因为js中所有的对象都继承自Obejct,都可以使用Object对象的原型属性和方法,因此不要轻易的扩展Object.prototype。02 Object.property中的属性和方法 ① constructor 指向原型相关联的构造函数，为Object ② hasOwnProperty 判断对象中是否拥有某个实例属性(不包括原型链上面的属性) ③ isPrototypeOf 校验某个对象是否是指定对象的原型对象(整条原型链) ④ propertyIsEnumerable 属性是否存在且可枚举(使用for循环可以遍历,即目标属性能否在for循环中显示出来) ⑤ toString() 返回一个描述目标对象的字符串,对象则返回[object object] toString(参数) 参数出可以传入一个用于进制数的参数,该参数的默认值为10(主要针对Number类型有效) ⑥ toLocaleString 同toString,但是会做一些本地化的处理。 ⑦ valueOf() 如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。 Date对象调用该方法会返回一个时间戳。 constructor说明：该属性指向创建该对象的构造函数，在这里为Object123456function Person() &#123; &#125; var p = new Person(); console.log(p.constructor); //function Person() &#123;&#125; console.log(Person.prototype.constructor); //function Person() &#123;&#125; console.log(Object.prototype.constructor); //function Object() &#123; [native code] &#125; hasOwnProperty说明：判断对象中是否拥有某个实例属性(不包括原型链上面的属性)12345678function Person() &#123; this.name = \"默认的姓名\"&#125;//检查对象中是否拥有指定的属性(实例属性)var p1 = new Person();p1.hasOwnProperty(\"name\"); //truep1.hasOwnProperty(\"age\"); //falsep1.hasOwnProperty(\"constructor\"); //对象的constructor是从原型对象上继承的 isPrototypeOf说明：校验某个对象是否是指定对象的原型对象(整条原型链);1234567891011121314&lt;script&gt; var obj = &#123; name:\"张三\", age:20, hello:function () &#123; console.log(\"hello\"); &#125;, showName:function () &#123; console.log(this.name); &#125; &#125; //属性是否存在且可以枚举 console.log(obj.propertyIsEnumerable(\"name\")); //true&lt;/script&gt; toString说明：返回一个描述目标对象的字符串,对象则返回[object object]12345678910111213&lt;script&gt; var obj = &#123;&#125;; console.log(obj.toString()); //打印[object Object] var arr = [1,2,3,4,5]; console.log(arr.toString()); //打印1,2,3,4,5 var num = 10; console.log(num.toString()); //10 var date = new Date(); console.log(date.toString()); //Mon Feb 13 2017 19:00:13 GMT+0800 (CST) //toString方法可以传入参数,在处理Number类型数据的时候,可以传入指定的进制 console.log(num.toString(2)); //1010 == 1*2*2*2+0*2*2+1*2+1*1 = 10 console.log(num.toString(3)); //101 == 1*3*3 + 0*3 + 1*1 = 10&lt;/script&gt; toLocaleString说明：作用同toString方法一致，但是会做一些本地化的处理. valueOf说明：① 如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。② 如果是Date类型，则返回时间戳。123456789&lt;script&gt; var obj = &#123;&#125;; console.log(obj + 1); //[object Object]1 //说明:如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。 var o = &#123;name:\"张三\"&#125;; console.log(o + 1); //[object Object]1 var date = new Date(); console.log(date.valueOf()); //1486984088998&lt;/script&gt; 静态成员和实例成员静态成员 定义在构造函数上面的成员(属性和方法) 实例成员 定义在实例对象上面的成员(属性和方法) 建议 ① 把工具类的方法写成静态方法 ② 把和对象相关的方法写成实例方法(成员) 代码示例12345678910111213141516&lt;script&gt; function Person() &#123; this.name = \"张三\"; //实例属性 this.showName = function () &#123; console.log(this.name); &#125;; &#125; //为Person构造函数添加静态成员 Person.des = \"描述信息\"; Person.add = function (msg) &#123; console.log(\"添加信息\" + msg); &#125;; Person.add(\"这是一个+操作\"); var p1 = new Person(); p1.showName();&lt;/script&gt; Function构造函数函数创建的几种方式 12301 函数声明02 字面量的方式创建03 使用new Function的形式创建 函数创建代码示例 12345678function func01() &#123; console.log(\"函数声明\"); &#125; var func02 = function () &#123; console.log(\"字面量方式创建\"); &#125; //使用Function构造函数创建 var func03 = new Function(); Function构造函数创建函数 参数说明:可以传入多个参数 最后一个参数:传入的最后一个参数为函数的函数体内容 其他参数:创建出来的函数的参数 如果只有一个参数,则表示这是该函数的函数体内容 传递参数的格式:以字符串的方式进行传参代码示例123456//需求01 使用Function构造函数创建一个函数对象,该函数执行一行打印操作var funcName01 = new Function(\"console.log('让我掉下眼泪的,不止昨夜的酒')\");funcName01();//需求02 使用Function构造函数创建一个函数对象,该函数需要接受两个参数,要求返回他们的和var funcName02 = new Function(\"a\",\"b\",\"return a + b;\");console.log(funcName02(10, 20)); //30 解决函数体代码过长的问题（1）使用转义字符，写在一行中（2）使用+操作符来拼接字符串（3）使用``操作符来管理字符串（4）使用模板先处理字符串，然后在js中获得模板中的内容 arguments、length和calleearguments参数说明：在js中的函数中，有两个隐藏的参数分别是this和arguments1234arguments 是一个类似数组的结构,可以通过下标来操作函数的参数,但并非数组类型的。在函数调用的时候,会将函数的所有参数都传入arguments对象中保存,因此我们可以通过操作arguments属性来操作参数形参的数量大于实参的数量,则依次传入,未传入的设置为undefined形参的数量小于实参的数量,则arguments中保存实际的值 length 函数内部的arguments数组拥有length属性,可以通过该属性获取用户调用时传入的实参的个数 函数本身有一个length属性,可以通过该属性来获取形式参数的个数 callee方法 函数内部的arguments对象中,有一个callee方法,该方法指向函数自身,常用于匿名函数的递归调用。 代码示例12345678910111213141516171819&lt;script&gt; function func() &#123; console.log(arguments); console.log(arguments.length); //调用函数时实际传入的参数数量 &#125; func(1,2,3,4,5); console.log(func.length); //预期的参数数量 —— 函数的形参数量 function func02(a,b) &#123; console.log(a, b); console.log(arguments); &#125; func02(1,2,3); //实参的数量 &gt; 形参的数量 则arguments保存实参的值 func02(1); //实参的数量 &lt; 形参的数量 则不足的补undefined //匿名函数调用 (function () &#123; //如果需要在该函数中调用自身,则可以使用arguments.callee方法 arguments.callee(); &#125;)();&lt;/script&gt; Function的应用01 数组去重123456789101112 var func = new Function(\"arr\",` var array = []; for(var i = 0 ; i&lt;arr.length; i++) &#123; if(array.indexOf(arr[i]) == -1) &#123; array.push(arr[i]); &#125; &#125; return array;`); console.log(func([1, 2, 3, 4, 5, 3, 4, 2]));; 02 返回传入函数中所有数据的最大值123456789101112var func = function () &#123; var maxNumber = arguments[0]; for(var i = 0;i&lt;arguments.length;i++) &#123; if (maxNumber &lt; arguments[i]) &#123; maxNumber = arguments[i]; &#125; &#125; return maxNumber;&#125;console.log(func(1, 2, 3, 45, 5, 6, 7, 8, 30, 21)); eval 简单说明eval 的基本使用eval函数用来讲字符串转换为JS的代码,并执行 eval 处理JSON数据代码示例123456&lt;script&gt; var jsonData = '&#123;\"name\":\"张三\",\"age\":18&#125;'; //把json的数据转换为对象 var obj = JSON.parse(jsonData); console.log(obj);&lt;/script&gt; 12345678910111213&lt;script&gt; var jsonData = '&#123;\"name\":\"张三\",\"age\":18&#125;'; //var obj = eval(jsonData); //注意:如果直接这样写代码则会报错 //正确的处理方式 //方式一 eval(\"var obj = \" + jsonData); console.log(obj); //方式二 //说明:使用eval来解析json格式字符串的时候,会将&#123;&#125;解析为代码块,而不是字面量 // 在使用的时候为了避免这种错误,需要在JSO的最外面加上(),如此则会把大括号当做一条语句来解析 var o = eval(\"(\"+jsonData+\")\"); console.log(o);&lt;/script&gt; eval 注意事项 ① eval函数本身功能强大,但它的特性也为程序带来了很大的不确定性,因此在开发中并不推荐使用。 ② eval函数是动态的执行代码,因此其效率不如直接执行静态脚本高。 eval和Function比较12相同点:都能够把字符串转换为Javascript的代码不同点:eval转换为js的代码之后马上就执行,而Function需要先创建函数,调用函数之后才会执行。 Function.prototype原型链关于Function和自定义构造函数的原型对象 Function.prototype 是一个空的函数 自定义构造函数的原型对象是一个空的对象 说明 Function也可以被当做是一个构造函数 通过new Function创建出来的函数,可以认为是Function的实例化对象。 Function的原型对象是一个空的函数,这个空的函数也是一个对象,它的原型对象是Object.prototype。 在JS中,Object的原型对象是所有对象的祖宗。 Function是构造函数,则其原型对象为空的函数 空的函数的原型对象为Object.prototype Function本身也是对象,则其构造函数为:function Function() { [native code] } 是自身 同Object类型 Object本身是构造函数,其原型对象是Object.prototype Object本身也是对象,其构造函数为:function Function() { [native code] 代码示例123456789101112131415//01 提供Person构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置Person的原型对象 Person.prototype.showName = function () &#123; console.log(this.name); &#125; //03 创建Student构造函数 function Student(number) &#123; this.numer = number &#125; //04 设置Student的原型对象 Student.prototype = new Person(); 完整的原型链示意图Object和Function的关系01 Object构造函数是通过Function构造函数实例化出来的02 Function构造函数也是通过Function构造函数实例化出来的 代码示例12345678&lt;script&gt; //检查对象是否是某个构造函数的实例 console.log(Function instanceof Function); console.log(Function instanceof Object); console.log(Object instanceof Object); console.log(Object instanceof Function); //注意:以上打印结果均为true&lt;/script&gt; 对象的拷贝操作浅拷贝如果对象中的属性是引用类型的值,那么存在数据共享问题,修改某个对象会对拷贝的对象产生影响代码示例123456789var o = &#123;name:\"张三\",car:&#123;number:\"2017\",type:\"火车\"&#125;&#125;;var obj = &#123;&#125;;//obj对象需要拷贝o对象中所有的属性for (var i in o )&#123; obj[i] = o[i];&#125;console.log(obj);o.car.type = \"飞船\";console.log(obj); 深拷贝 如果对象中的属性是值类型,那么就直接拷贝赋值 如果对象中的属性是引用类型,那么就再次调用拷贝方法,遍历对象 代码示例123456789101112131415161718192021222324252627 var o = &#123;name:\"张三\",car:&#123;number:\"2017\",type:\"火车\"&#125;&#125;; var obj = &#123;&#125;; function deepCopy(obj,tmp) &#123; tmp = tmp || &#123;&#125;; //如果没有传入,那么就创建一个空的对象 for(var i in obj) &#123; if (obj.hasOwnProperty(i)) //只拷贝实例属性 &#123; //判断是否是引用类型 if ((typeof obj[i]) == 'object') &#123; //重新调用拷贝方法 tmp[i] = Array.isArray(obj[i]) ? [] :&#123;&#125;; deepCopy(obj[i],tmp[i]); &#125;else &#123; //直接拷贝 tmp[i] = obj[i]; &#125; &#125; &#125; &#125;deepCopy(o,obj); console.log(obj); o.car.type = \"测试的类型\"; console.log(obj); console.log(o); 注意isArray的兼容性问题isArray是ECMA5中新推出的方法,需要处理兼容性问题123456if (Array.isArray != \"function\")&#123; Array.isArray = function (obj) &#123; return Object.prototype.toString.call(obj) == '[object Array]'; &#125;&#125; Number原型扩展小案例：在Number的原型对象上面定义一个新的方法add(),该方法接收一个参数,并将该参数与自身的值进行相加,然后进行返回。代码实现123456789Number.prototype.add = function (num) &#123; return this + num;&#125;var n = 10;console.log(n.add(3));//console.log(5.add(5)); 错误:解析器无法处理字面量的这种情况var num = new Number(50);console.log(num.add(20)); //70console.log((1).add(4)); //5 使用()把数字包起来 使用注意123（01）使用数字变量可以调用成功（02）使用数字表达式可以调用成功（03）直接使用数字字面量方式调用失败 js的语法解析器无法处理数字字面量这种情况。 With语句with语句简单介绍123with语句是js中一个强大但有争议的特性。with语句允许我们将一个对象的所有属性引用到当前的作用域允许我们无需使用拥有者对象的前缀，就可以直接对这些属性进行引用和赋值操作。 注意：ECMAScript5规范在严格模式下已经禁用了该语句，在开发中不推荐使用，但是要求能够看懂with的代码。 with语句内部细节说明： with语句会创建一个作用域，在该作用域内，在引用特定对象的属性时，可以不使用前缀。应用场景：对深层级对象的引用进行缩短。 在with作用域内部引用属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //[01] 测试with语句作用域内对对象属性的引用 //01 提供全局变量,名称为testValue var testValue = '测试使用的全局变量'; //02 提供对象,对象内部提供属性 var testObject = &#123; name:'对象的名称属性', testValue:'对象内部的属性' &#125;; //03 使用with语句引用 with(testObject) &#123; console.log(name); //对象的名称属性 console.log(testValue); //对象内部的属性 console.log(this); //window &#125; console.log(testValue); //测试使用的全局变量``` 总结：(1) 在with语句作用域内,对象属性的优先级绝对高于在更层级作用域内定义的同名变量(2) this(函数上下文)依然指向window,并不会收到with作用域的影响**在with作用域内进行赋值操作**```js //01 提供一个对象,在内部提供属性 var obj = &#123; name:'对象的内部属性', &#125; //02 with语句测试对对象属性的赋值操作 with(obj) &#123; name = '修正对象中name的值'; //在作用域内部添加变量(思考?该变量是添加为全局作用域还是当前obj对象的属性?) age = '25'; showName = function () &#123; console.log('name == ' + name); &#125;; &#125;; //测试修改对象属性操作 console.log(obj.name); //测试添加对象属性操作 console.log(obj.age); //undefined //obj.showName(); //obj.showName is not a function console.log('____________________'); console.log(this.name); //== name == window.name console.log(window.name); console.log(name); showName(); //==this.showName() ==window.showName() 总结：（1）在with作用域的内部我们可以使用无前缀引用对象的属性进行读取和赋值的操作 但是 不能使用无前缀的方式添加属性（2）如果使用无前缀的方式来添加属性[对不存在的属性进行赋值操作],那么属性将被添加到全局上下文[window|this]（3）可能产生的错误:意外的引入一个全局变量,而非为with作用域对象添加属性 with语句的问题（1）with作用域内操作优先级混乱（2）性能不好，会大大降低js代码的执行性能（3）ECMAScript5规定在严格模式下禁用with特性 with语句简化代码的替代方案使用即时调用函数来替代with语句，通过函数传参的方式使用更短的引用来替代冗长的引用前缀比使用with语句消除前缀的方式更好。123456789101112with(this.style)&#123; width = '200px'; height = '200px'; backgroundColor = '#ca3'; console.log(width); //要访问的本应该是外部的字符串变量 \"错误哈哈\",但是这里被解释为200px&#125;(function (s) &#123; s.width = '200px'; s.height = '200px'; s.backgroundColor = '#ca3';&#125;)(this.style); 使用面向过程的方式处理1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 bookList.push(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; console.log(obj); break; &#125; &#125; //修改操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; obj.author = \"泰戈尔-戈尔泰\" &#125; &#125; //删除操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; //删除该对象 bookList.splice(i, 1); &#125; &#125; console.log(bookList);&lt;/script&gt; 使用函数来封装图书管理操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 function addBook(bookObj) &#123; bookList.push(bookObj); &#125; addBook(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 function getBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125; console.log(getBook(\"什么是批判\")); //修改操作 function updateBookData(name,authorName)&#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; obj.author = authorName; &#125; &#125; &#125; updateBookData(\"飞鸟集\",\"泰戈尔斯坦\"); //删除操作 function removeBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; //删除该对象 bookList.splice(i, 1); &#125; &#125; &#125; console.log(bookList);&lt;/script&gt; 数封装-复用形式12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 function addBook(bookObj) &#123; bookList.push(bookObj); &#125; addBook(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 function getBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125; console.log(getBook(\"什么是批判\")); //修改操作 function updateBookData(name,authorName)&#123; var obj = getBook(name); obj.author = authorName; &#125; updateBookData(\"飞鸟集\",\"泰戈尔斯坦\"); //删除操作 function removeBook(name) &#123; var obj = getBook(name); var index = bookList.indexOf(obj); bookList.splice(index,1); &#125; addBook(&#123;name:\"东京人\",author:\"川端康成\"&#125;); console.log(bookList);&lt;/script&gt; 面向对象的方式管理图书123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;scrip&gt; var obj = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ];泰 function BookManager() &#123; this.bookList = null; &#125; BookManager.prototype = &#123; constructor:BookManager, init:function (arr) &#123; this.bookList = arr || []; &#125;, addBook:function (bookObj) &#123; this.bookList.push(bookObj) &#125;, getBook:function (name) &#123; for (var i = 0; i &lt; this.bookList.length; i++) &#123; var obj = this.bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125;, updateBookData:function (name,authorName)&#123; var obj = this.getBook(name); obj.author = authorName; &#125;, removeBook:function (name) &#123; var obj = this.getBook(name); var index = this.bookList.indexOf(obj); this.bookList.splice(index,1); &#125; &#125;; //01 创建对象 var YYManager = new BookManager(); YYManager.init(obj); console.log(YYManager.bookList); //02 演示添加操作 YYManager.addBook(&#123;name:\"花田半亩\",author:\"田维\"&#125;); console.log(YYManager.bookList); //03 演示查询操作 console.log(YYManager.getBook(\"花田半亩\")); //04 演示更新操作 YYManager.updateBookData(\"花田半亩\",\"甜田\"); console.log(YYManager.getBook(\"花田半亩\"));; //05 演示删除操作 YYManager.removeBook(\"什么是批判\"); console.log(YYManager.bookList); //02 创建第二个人的图书管理对象 var wulitaotaoMManager = new BookManager(); wulitaotaoMManager.init([&#123;name:\"装逼速成\",author:\"六扇门\"&#125;]); console.log(wulitaotaoMManager.bookList);&lt;/script&gt; 总结01 提供构造函数，在构造函数内部设置实例化属性02 把常用的操作提取成对象的实例方法，写在原型对象身上03 提供init方法，用于初始化数据04 注意：如果切断了原型对象那么需要修正内部的构造器属性指向","categories":[{"name":"JavaScript简明教程","slug":"JavaScript简明教程","permalink":"http://www.1oveit.club/categories/JavaScript简明教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"JavaScript简明教程（3）","slug":"js-3","date":"2016-02-18T03:55:29.000Z","updated":"2017-05-13T10:45:13.000Z","comments":true,"path":"2016/02/18/js-3/","link":"","permalink":"http://www.1oveit.club/2016/02/18/js-3/","excerpt":"关于继承，通俗说子继父业。在JavaScript中，Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。 继承相关方法在讲继承之前，我们必须先了解一些相关的方法。 hasOwnProperty和in属性操作in关键字作用：用来检查对象中是否存在某个属性(不区分实例属性和原型属性)。语法：“属性名” in 对象。代码示例:","text":"关于继承，通俗说子继父业。在JavaScript中，Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。 继承相关方法在讲继承之前，我们必须先了解一些相关的方法。 hasOwnProperty和in属性操作in关键字作用：用来检查对象中是否存在某个属性(不区分实例属性和原型属性)。语法：“属性名” in 对象。代码示例:12345678910111213141516&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125; //03 创建对象 var p1 = new Person(); //04 使用in关键字判断对象中是否存在以下属性:name age sayHello console.log(\"age\" in p1); //false console.log(\"name\" in p1); //true console.log(\"sayHello\" in p1); //true&lt;/script&gt; 对象的hasOwnProperty方法作用：用来检查对象中是否存在指定的属性(只检查实例属性)语法：对象.hasOwnProperty(“属性名”)代码示例123456789101112131415161718&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125; Person.prototype.des = \"默认的描述信息\"; //03 创建对象 var p1 = new Person(); //04 使用hasOwnProperty方法判断该属性是否是对象的实例属性 console.log(p1.hasOwnProperty(\"age\")); //false console.log(p1.hasOwnProperty(\"name\")); //true console.log(p1.hasOwnProperty(\"sayHello\")); //false console.log(p1.hasOwnProperty(\"des\")); //false&lt;/script&gt; 判断某对象中存在且只存在某个原型属性123function isProperty(obj, property) &#123; return !obj.hasOwnProperty(property) &amp;&amp; (property in obj); &#125; constructor构造器属性说明 使用构造函数创建对象,则 原型对象中的constructor属性指向对应的构造函数 实例对象中的constructor指向对应的构造函数,其中这里的constructor就是从原型中获取的即constructor时实例对象中的原型属性,而非实例属性 代码验证123456789101112131415//01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125;; Person.prototype.des = \"默认的描述信息\"; //03 创建对象 var p1 = new Person(); function isProperty(obj, property) &#123; return !obj.hasOwnProperty(property) &amp;&amp; (property in obj); &#125; console.log(isProperty(p1, \"constructor\")); //true isprotoTypeOf和instanceisprotoTypeOf作用：判断是否是某个实例对象的原型对象语法:构造函数.protoType.isPrototypeOf(对象)用法示例123456789&lt;script&gt; function Person() &#123;&#125; function Dog() &#123;&#125; Person.prototype.name = \"嘿嘿\"; var p1 = new Person(); console.log(Person.prototype.isPrototypeOf(p1));//rue console.log(Object.prototype.isPrototypeOf(p1));//true console.log(Dog.prototype.isPrototypeOf(p1));//false&lt;/script&gt; instance作用：用于检查对象是否是某个构造函数(类型)的实例语法：对象 instance 构造函数注意：所有的对象都是Object构造函数（类型）的实例用法示例12345678&lt;script&gt; var arr = [1,2,3]; console.log(arr instanceof Array); //true console.log(Array instanceof Object); //true console.log(arr instanceof Object); //true //instanceOf在判断的时候,算上整条原型链 //arr 是Array 和Object 任何一个类的示例&lt;/script&gt; 继承继承基本概念继承：即通过一定的方式实现让某个类型A获取另外一个类型B的属性或方法。其中类型A称之为子类型，类型B称之为父类型或超类型。 javaScript中的继承Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。继承有两种方式：接口继承和实现继承，在js中只支持实现继承，实现继承主要依赖原型链来完成。JavaScript中实现继承的几种方式：说明:其他语言中继承通常通过类来实现，js中没有类的概念，js中的继承是某个对象继承另外一个对象，是基于对象的。123401 原型式继承02 原型链继承03 经典继承(借用构造函数)04 组合继承 原型式继承原型链继承的方式A1234567891011121314151617&lt;script&gt; //01 提供一个构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置原型对象的属性 Person.prototype.className = \"逍遥派1班\"; //03 使用构造函数来创建原型对象 var p1 = new Person(\"张三\",10); var p2 = new Person(\"李四\",20); //04 打印p1和p2对象中的className属性 console.log(p1.className); console.log(p2.className); //结论:对象p1和p2继承了构造函数原型对象中的属性className //但是这并不是严格意义上的继承&lt;/script&gt; 原型链继承的方式B1234567891011121314151617181920&lt;script&gt; //01 提供一个构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置原型对象的属性 Person.prototype = &#123; constructor:Person, className:\"逍遥派1班\" &#125;; //03 使用构造函数来创建原型对象 var p1 = new Person(\"张三\",10); var p2 = new Person(\"李四\",20); //04 打印p1和p2对象中的className属性 console.log(p1.className); console.log(p2.className); //结论:对象p1和p2继承了构造函数原型对象中的属性className //注意:使用原型替换的方式实现继承的时候,原有原型对象中的属性和方法会丢失&lt;/script&gt; 原型链继承的方式C1234567891011121314151617181920212223//01 提供超类型|父类型构造函数function SuperClass() &#123; this.name = 'SuperClass的名称'; this.showName = function () &#123; console.log(this.name); &#125;&#125;//02 设置父类型的原型属性和原型方法SuperClass.prototype.info = 'SuperClass的信息';SuperClass.prototype.showInfo = function () &#123; console.log(this.info);&#125;;//03 提供子类型function SubClass() &#123;&#125;//04 设置继承(原型对象继承)SubClass.prototype = SuperClass.prototype;SubClass.prototype.constructor = SubClass;var sub = new SubClass();console.log(sub.name); //undefinedconsole.log(sub.info); //SuperClass的信息sub.showInfo(); //SuperClass的信息sub.showName(); //sub.showName is not a function 点评：上面的方法可以可以继承超类型中的原型属性和原型方法，但是无法继承实例属性和实例方法 原型链继承实现思想：利用原型（链）让一个对象继承另一个对象的属性和方法实现本质：重写原型对象 原型链123456① 每个构造函数都有原型对象② 每个对象都有自己的构造函数③ 每个构造函数的原型都是一个对象④ 那么这个构造函数的原型对象也有自己的构造函数⑤ 那么这个构造函数的原型对象的构造函数也有自己的原型对象以上形成一个链式的结构,称之为原型链 原型链中的属性搜索原则12345当访问某个对象的成员的时候,会先在自身中查找,如果找到则直接使用如果在自身中没有找到,则去当前创建当前对象的构造函数的原型对象中查找,如果找到了则直接使用如果在该原型对象中没有找到,则继续查找原型对象的原型对象(创建该原型对象的构造函数所对应的原型对象),如果找到则直接使用如果在原型对象的原型对象中也没有找到,则继续向上搜索....直到Object的原型对象,若还是没有,则返回undefined(属性)或报错(方法)。 基本写法·代码示例1234567891011121314151617181920212223//01 提供超类型|父类型function SuperClass() &#123; this.name = 'SuperClass的名称'; this.showName = function () &#123; console.log(this.name); &#125;&#125;//02 设置父类型的原型属性和原型方法SuperClass.prototype.info = 'SuperClass的信息';SuperClass.prototype.showInfo = function () &#123; console.log(this.info);&#125;;//03 提供子类型function SubClass() &#123;&#125;//04 设置继承(原型对象继承)SubClass.prototype = new SuperClass();SubClass.prototype.constructor = SubClass;var sub = new SubClass();console.log(sub.name); //SuperClass的名称console.log(sub.info); //SuperClass的信息sub.showInfo(); //SuperClass的信息sub.showName(); //SuperClass的名称 点评：可以继承父类型中的原型属性|原型方法,以及实例属性和实例方法 注意点① 确定原型和实例的关系 instanceof + isPrototypeOf()② 注意重写原型对象的位置，必须先实现原型继承，然后再设置子对象的原型属性和原型方法③ 完成继承之后，不能使用字面量的方式来创建原型[因为会切断原型] 问题① 父对象的实例属性会转换为子类型原型的原型属性，而如果父类型是实例属性是引用类型则会存在共享问题② 在创建子类型的实例时，不能向父类型的构造函数中传递参数1234567891011121314151617//01 提供父对象的构造函数function SuperType() &#123; //02 在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈'];&#125;;//03 提供子对象的构造函数function SubType() &#123;&#125;;//04 设置原型继承SubType.prototype = new SuperType();//05 创建父对象构造函数的实例对象,并对内部的实例化属性进行修改var subDemo1 = new SubType();var subDemo2 = new SubType();alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈subDemo1.family.push('爷爷','奶奶');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶 经典继承（借用构造函数）经典继承又称为借用构造函数|伪造继承 基本思想在子类型构造函数的内部调用超类型|父类型构造函数说明：需要借助call|apply方法代码示例1234567891011121314151617181920212223242526//01 提供父类型(对象)的构造函数 function SuperType(name) &#123; //02 在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈']; //实例属性 this.name = name; &#125;; SuperType.prototype.info = '父类型的原型属性'; //03 提供子类型（对象）的构造函数 function SubType() &#123; //经典继承|借用构造函数|伪造对象继承 //SuperType.call(this); //构造参数传递参数 SuperType.call(this,'张老汉'); &#125;; //04 创建父类型的实例对象,并对内部的实例化属性进行修改 var subDemo1 = new SubType(); var subDemo2 = new SubType(); alert(subDemo1.info); //undefined alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈 alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈 subDemo1.family.push('爷爷','奶奶'); alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶 alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈 //测试构造函数传递参数 alert(subDemo1.name); 点评：能够继承父类型的实例属性,但是无法继承父类型的原型属性和原型方法 经典继承的优点① 解决实例对象共享问题，通过调用父对象的构造函数来实现每个子类型（对象）的实例对象均拥有一份父类型实例属性和方法的副本② 可以在调用call方法的时候向构造函数传递参数 经典继承的问题① 冒充继承的方法无法实现函数的重用② 无法继承父对象的原型属性和原型方法 组合继承组合继承|伪经典继承 基本思想① 使用原型链实现对原型属性和方法的继承② 通过伪造(冒充)构造函数来实现对实例属性的继承代码示例1234567891011121314151617181920212223242526272829//01 提供父类型的构造函数function SuperType(name) &#123; //在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈']; //实例属性 this.name = name;&#125;;//原型方法SuperType.prototype.showName = function () &#123; console.log(this.name);&#125;//02 提供子类型的构造函数function SubType(name) &#123; //冒充|伪造 构造参数传递参数 SuperType.call(this,name);&#125;;SubType.prototype = SuperType.prototype;//SubType.prototype = new SuperType();//02 创建父类型的实例对象,并对内部的实例化属性进行修改var subDemo1 = new SubType('张三');var subDemo2 = new SubType('张四');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈subDemo1.family.push('爷爷','奶奶');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈//测试构造函数传递参数subDemo1.showName(); //张三subDemo2.showName(); //张四 基本包装类型基本类型：字符串 + 数值 + null + undefined + 布尔值为了便于操作基本类型，ECMAScript提供了三个特殊的引用类型：Boolean + Number + String。上述类型和其他的引用类型类似，同时也具备与各自的基本类型相应的特殊行为，每当我们读取一个基本类型的值的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。123var str = '测试字符串';console.log(str.length); //5console.log(str.substring(2)); //字符串 思考：属性和方法本是对象的特征，字符串如何能够拥有length属性以及其他类似subString等方法，内部怎么实现的？基本类型值并不是对象，因此从逻辑上讨论他们不应该有属性和方法。 内部的具体处理:123（1）创建String类型的一个实例对象（2）在实例对象上面读取指定的属性（length）,调用指定的方法（subString）（3）销毁该对象 NumberNumber是与数字值相对应的引用类型。创建Number类型的对象：var num = new Number(10); String String是字符串的对象包装类型。创建字符串类型的对象：var str = new String(‘hello World’); BooleanBoolean是与布尔值对象的引用类型。可以通过调用Boolean构造函数传递参数来创建boolean类型的对象。var bool = new Boolean(true); 基本包装类型的代码示例1234567891011121314//001 Stringvar str = '测试字符串';console.log(str.length); //5console.log(str.substring(2)); //字符串//002 Numbervar num = new Number(10);console.log(num); //Number &#123;[[PrimitiveValue]]: 10&#125;console.log(typeof num); //objectconsole.log(typeof 10); //number//003 Booleanvar bool = new Boolean(true);console.log(bool); //Boolean &#123;[[PrimitiveValue]]: true&#125;console.log(typeof bool); //objectconsole.log(typeof true); //boolean 基本包装类型的注意点[1] 对象还是基本数据类型值？对象：通过new 调用构造函数创建出来的是对象基本数据类型值：直接通过字面量方式赋值|通过省略new关键字调用构造函数方式创建的是基本数据类型值。12345ex: var str1 = new String('hello'); var str2 = 'hello'; var str3 = String('hello'); 说明：以上代码中，str1是对象，而str2和str3是字符串（基本数据类型值） [2] 相等问题基本类型值判断相等=&gt;值相等引用类型值判断相等=&gt;值相等且引用相等对象是引用类型，因此在判断相等的时候有诸多的注意点和容易出错的地方123456789101112131415161718ex var str1 = '这是一个字符串'; //基本数据类型 var str2 = String('这是一个字符串'); //基本数据类型 console.log(str1 == str2); //true 相等 var str3 = new String('这是一个字符串'); //引用类型-对象 console.log(str1 == str3); //true //值相等 console.log(str2 == str3); //true //值相等 console.log(str1 === str3); //false //值相等,但是引用不相等 console.log(str2 === str3); //false //值相等,但是引用不相等 //判断下面的变量是否相等 var num1 = 10; //基本数据类型 var num2 = new Number(10); //对象 console.log(num1 == num2); //true console.log(num1 === num2); //false var bool1 = true; var bool2 = new Boolean(true); console.log(bool1 == bool2); //true console.log(bool1 === bool2); //false","categories":[{"name":"JavaScript简明教程","slug":"JavaScript简明教程","permalink":"http://www.1oveit.club/categories/JavaScript简明教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"可能是最简单的js原型继承","slug":"js原型继承","date":"2016-02-08T07:35:45.000Z","updated":"2017-05-22T07:26:04.000Z","comments":true,"path":"2016/02/08/js原型继承/","link":"","permalink":"http://www.1oveit.club/2016/02/08/js原型继承/","excerpt":"JavaScript是一门奇妙的弱类型语言，原型继承与其它语言的类继承有所区别，下面通过一个简单的例子展示js的原型继承。 你有对象吗？你有对象吗？没有，赶紧就new一个吧！首先，创建构造函数Parent然后，new出一个Parent的实例对象child此时，构造函数Parent拥有以下属性aString、aNumber、anObject,构造函数Parent的原型对象有aFunction方法。","text":"JavaScript是一门奇妙的弱类型语言，原型继承与其它语言的类继承有所区别，下面通过一个简单的例子展示js的原型继承。 你有对象吗？你有对象吗？没有，赶紧就new一个吧！首先，创建构造函数Parent然后，new出一个Parent的实例对象child此时，构造函数Parent拥有以下属性aString、aNumber、anObject,构造函数Parent的原型对象有aFunction方法。12345678910function Parent() &#123; this.aString = 'string'; this.aNumber = 'number'; this.anObject = 'object'&#125;Parent.prototype = &#123; constructor: Parent, aFunction: function()&#123; alert('i am function'); &#125; 然后，new出一个Parent的实例对象child1var child = new Parent(); 简单的原型继承图如下： #~~~~# 实现继承实例对象默认拥有构造函数本身的属性和方法。但是，要知道构造函数荷构造函数的原型对象是俩个不同的函数（对象），原型对象拥有的属性和方法可以被实例化对象所共享。也就是说实例对象child此时拥有属性aString、aNumber、anObject，this指向实例对象。child本身并没有aFunction方法。但是你调用此方法时，却发现能调用，这是怎么回事呢？1child.aFunction(); 这就是我们所说的原型对象原拥有的属性和方法可以被实例化对象所共享的原因。通过简单的例子，希望能帮到你，如果想深入学习javascript，请深戳MDZ开发者","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.1oveit.club/tags/javascript/"},{"name":"原型继承机制","slug":"原型继承机制","permalink":"http://www.1oveit.club/tags/原型继承机制/"}]},{"title":"JavaScript简明教程（2）","slug":"js-02","date":"2016-02-01T05:15:15.000Z","updated":"2017-05-13T10:45:13.000Z","comments":true,"path":"2016/02/01/js-02/","link":"","permalink":"http://www.1oveit.club/2016/02/01/js-02/","excerpt":"面向对象方法被人谈论了二十多年了，直到今天，我们还一直在谈对象。 面向对象编程面向层过程和面向对象编程01 面向对象编程和面向过程编程是一种编程思想,和具体的语言关系不大。02 面向过程编程和面向对象编程的主要区别","text":"面向对象方法被人谈论了二十多年了，直到今天，我们还一直在谈对象。 面向对象编程面向层过程和面向对象编程01 面向对象编程和面向过程编程是一种编程思想,和具体的语言关系不大。02 面向过程编程和面向对象编程的主要区别1234567891011121314151617181920面向过程编程: 关注点在于解决问题需要的每一个详细的步骤 示例: 自己洗衣服的过程 ① 收集需要洗的脏衣服 ② 准备洗衣粉、洗衣液等 ③ 把衣服放到一个盆里 ④ 接水 ⑤ 把洗衣粉放到盆里 ⑥ 摩擦,摩擦,不断的摩擦 ⑦ 把洗好的衣服用清水冲洗干净 ⑧ 尽量把把洗好的衣服的水分拧干 ⑨ 晾晒 面向对象编程: 关注点在于解决问题需要的对象身上 示例: 使用洗衣机洗衣服的过程 ① 收集需要洗的脏衣服 ② 找到合适的洗衣机 ③ 设定洗衣服和烘干的程序 03 面向过程和面向对象他们的区别就类似于自己洗衣服和使用洗衣机洗衣服|自己做饭吃和去餐馆吃饭 面向对象编程的相关概念01 对象 什么是对象? 所有的一切都是对象,在开发中有一项重要的工作就是对象的划分。一般来说,我们所指的对象是某个具体的事物,而非泛泛的类别。02 对象的特征(静态描述信息) 所谓特征就是一些特定的描述信息 如:学生(性别、年龄、班级、专业、籍贯、家庭住址) 如:汽车(颜色、车牌、品牌、价格等)03 对象的行为(动态特性) 如:人(吃饭、睡觉、玩游戏、奔跑、运动等) 如:狗(吃、睡、咬人、叫、流口水)04 js中的对象 键-值对(key-value)的集合。05 现实生活中的对象和js对象的对应关系 静态的描述信息 - js对象中的属性(属性就是定义在对象内部的变量) 动态的行为特征 - js对象中的方法(方法就是定义在对象内部的函数)06 代码示例：12345678910111213141516171819202122232425 var zhangsan = &#123; name:\"张三\", sex:\"男\", age:18, address:\"天上人间1号公馆\", eat:function () &#123; console.log('能吃'); &#125;, sleep:function () &#123; console.log(\"能睡\"); &#125;, say:function () &#123; console.log(\"能说话\"); &#125;, run:function () &#123; console.log(\"能运动\"); &#125;, song:function () &#123; console.log(\"能唱歌\"); &#125; &#125;; //打印对象的属性并调用相关的方法console.log(zhangsan.name,zhangsan.age,zhangsan.address); zhangsan.say(); zhangsan.sleep(); 面向对象的三大特性面向对象的三大特性:封装、继承、多态01 封装:复用|信息隐蔽代码示例123456789101112131415161718192021//01 封装的简单说明//001 观察以下杂乱无关的语句,它们仅仅只是一堆无意义的全局变量var name = \"乘风波浪会有时\";var actors = [\"彭于晏\",\"邓超\"];var showTime = \"2016-1-28 - 2016-2-28\";var director = \"韩寒\";var type = \"喜剧\";var play = function () &#123; //播放......&#125;;//002 把上面的变量封装到对象中(更具有意义)var film = &#123; name:\"乘风破浪会有时\", actors:[\"彭于晏\",\"邓超\"], showTime:\"2016-1-28 - 2016-2-28\", director:\"韩寒\", type:\"喜剧\", play:function () &#123; //播放...... &#125;&#125; 02 继承:获取已经存在的对象已有属性和方法的一种方式(获取他人已有财富和资源的一种方式)。代码示例123456789101112131415//继承的简单示例//001 创建一个空的对象var nullObj = &#123;&#125;;// 上面的对象film拥有了很多的属性和方法//002 设法让nullObj拥有film中所有的属性和方法//方法一:自己重新写一遍//方法二:通过某种方式来获得,比如遍历该对象,然后完成赋值for(var k in film)&#123; nullObj[k] = film[k];&#125;for(var k in nullObj)&#123; console.log(nullObj[k]);&#125; 03 多态(polymorphism) 多态:polymorphism = poly(复数) + morph(形态) + ism 多用于强类型语言中，JavaScript具备与生俱来的多态特性。 多态表现为: ① 同一操作,作用于不同的对象,会产生不同的解释和行为。 ② 隐藏不同。 创建对象的方法字面量方式创建对象基本写法123456789var book1 = &#123; name:\"声名狼藉者的生活\", price:42.00, author:\"福柯\", press:\"北京大学出版社\", read:function () &#123; console.log(\"我的书名为:声名狼藉者的的生活,作者为福柯....\"); &#125; &#125;; 存在的问题[01] 代码复用性差[02] 如果要创建大量的同类型对象，则需要些大量重复性代码 内置构造函数创建对象JS中的内置构造函数123456789StringNumberBoolean 注意：(区别于string number boolean)DateArrayFunctionObjectRegExp 基本写法12345678var book1 = new Object();book1.name = \"声名狼藉者的生活\";book1.price = 42.00;book1.author = \"福柯\";book1.press = \"北京大学出版社\";book1.read = function () &#123; console.log(\"我的书名为:声名狼藉者的的生活,作者为福柯....\");&#125;; 问题01 创建的对象无法复用,复用性差02 如果需要创建多个同类型的对象,如(书籍)则需要写大量重复的代码,代码的冗余度高 工厂函数创建对象基本写法12345678910111213141516171819202122function createBookNew (name,price,author,press) &#123; var book = new Object(); book.name = name; book.price = price; book.author = author; book.press = press; book.read = function () &#123; console.log(\"我的书名为:\"+book.name+\",作者为\"+book.author+\"....\"); &#125;; return book;&#125;//使用工厂函数来创建对象var book1 = createBookNew(\"声名狼藉者的的生活\",\"42.00\",\"福柯\",\"北京大学出版社\");var book2 = createBookNew(\"人性的枷锁\",\"49.00\",\"毛姆\",\"华东师范大学出版社\");var book3 = createBookNew(\"悟空传\",\"28.00\",\"今何在\",\"湖南文艺出版社\");//打印对象的属性,调用对象的方法console.log(book1.name);console.log(book2.name);console.log(book3.name);book1.read();book2.read();book3.read(); 工厂函数说明:001 工厂函数方式创建对象其本质是对内置构造函数创建对象的过程进行了封装002 适用于大规模“批量生产”同类型的对象1234567891011121314function createBook (name,price,author,press) &#123; //001 参数 = 原料 var book = new Object(); //002 创建对象并设置对象的属性和方法 = 对原料进行加工 book.name = name; book.price = price; book.author = author; book.press = press; book.read = function () &#123; console.log(\"我的书名为:\"+book.name+\",作者为\"+book.author+\"....\"); &#125;; //003 把处理好的对象返回给我们 == 产品出厂 return book;&#125; 封装思路:使用函数把固定不变的部分封装起来，变化的部分提取为函数的参数。工厂函数创建对象的实现过程:① 提供一个创建对象的函数（参数）② 在该函数内部使用new 关键字和Object构造器创建对象③ 设置对象的属性④ 设置对象的方法⑤ 返回对象 自定义构造函数创建对象基本写法123456789101112131415function 构造函数名(参数1,参数2,参数3...) &#123; //设置对象的属性 this.属性01 = 参数1; this.属性02 = 参数2; //设置对象的方法 this.方法01 = function () &#123; //..... &#125;; this.方法02 = function () &#123; //..... &#125;&#125;//自定义构造函数方式创建对象var 对象01 = new 构造函数名(实参01,实参02,实参03...);var 对象02 = new 构造函数名(实参01,实参02,实参03...); 代码示例12345678910111213141516171819function CreateBook (name,price,author,press) &#123; this.name = name; this.price = price; this.author = author; this.press = press; this.read = function () &#123; console.log(\"我的书名为:\"+this.name+\",作者为\"+this.author+\"....\"); &#125;;&#125;var b1 = new CreateBook(\"声名狼藉者的的生活\",\"42.00\",\"福柯\",\"北京大学出版社\");var b2 = new CreateBook(\"人性的枷锁\",\"49.00\",\"毛姆\",\"华东师范大学出版社\");var b3 = new CreateBook(\"悟空传\",\"28.00\",\"今何在\",\"湖南文艺出版社\");//打印对象的属性,并调用对象的方法测试console.log(b1.author);console.log(b2.author);console.log(b3.author);b1.read();b2.read();b3.read(); 构造函数与new关键字:new关键字的作用：用于创建对象（Object类型）。构造函数和普通函数的区别：函数的首字母大写。构造函数的作用:用于完成对象的初始化。 自定义构造函数和简单工厂函数的对比：1234① 函数的首字母大写(用于区别构造函数和普通函数)② 创建对象的过程是由new关键字实现③ 在构造函数内部会自动的创建新对象,并赋值给this指针④ 自动返回创建出来的对象 构造函数的执行过程① 使用new关键字创建对象② 把新创建出来的对象赋值给this③ 在构造函数内部,使用this为新创建出来的对象设置属性和方法④ 默认返回新创建的对象(普通函数如果不显示的return则默认返回undefined)。 构造函数的返回值01 如果在构造函数中没有显示的return,则默认返回的是新创建出来的对象02 如果在构造函数中显示的return,则依照具体的情况处理 [01] return 的是对象,则直接返回该对象,取而代之本该默认返回的新对象 [02] return 的是null或基本数据类型值,则返回新创建的对象 构造函数方式创建对象存在的问题每次创建对象,都会重新创建函数，那么如果创建的对象数量很多,而对象方法内部的实现一模一样,则造成了资源浪费。 构造函数的使用注意函数传值：可以把构造函数的对象方法抽取为参数。代码示例：1234567891011121314151617//001 创建一个构造函数function Person(name,age,toDoSomeThing) &#123; //002 在构造函数内部设置对象的属性和方法 this.name = name; this.age = age; this.sayName = function () &#123; console.log(this.name); &#125;; this.toDoSomeThing = toDoSomeThing;&#125;//003 使用构造函数创建对象var zhangsan = new Person(\"张三\",18,function () &#123; console.log(\"张三在读书\");&#125;);var lisi = new Person(\"李四\",20,function () &#123; console.log(\"李四在玩耍\");&#125;); 对象类型:01 检查对象的类型：instanceOf02 获取对象的类型：Object.prototype.toString.call(dog) 对象的构造器属性12345function Dog(name) &#123; this.name = name; this.color = \"黄色\"; &#125;console.log(dog.constructor); 属性的名称：constructor属性的作用：指向创建该对象的构造函数，类似于现实生活中所有的产品都标有生产厂家一样。 构造函数的调用01 构造函数可以像普通函数一样不通过new关键字直接调用02 在使用构造函数创建对象的时候，如果没有传递参数，则（）可以省略代码示例:1234567891011//01 创建构造函数function Person() &#123; this.name = \"张三\"; this.age = 20; this.sayName = function () &#123; console.log(this.name); &#125;&#125;//02 使用构造函数创建对象var p1 = new Person();var p2 = new Person; //说明:如果不需要传递参数,则在调用构造函数的时候()可以省略 this指向01 如果使用new 构造函数的方式调用，则this指向内部默认创建出来的空对象02 如果像调用普通函数一样调用构造函数，则this指向全局对象window(不要这样使用) 原型对象原型对象概念 在构造函数创建出来的时候,系统会默认帮构造函数创建并关联的一个新对象 自定义构造函数的原型对象默认是一个空对象。 原型对象的作用 构造函数中的原型对象中的属性和方法可以被使用该构造函数创建出来的对象使用。 即以自定义构造函数方式创建出来的所有对象,自动拥有和共享该构造函数的原型对象中的所有属性和方法。 如何访问构造函数的原型对象① 构造函数.protoType② 对象.__proto__（不推荐） 设置原型对象的属性和方法① 利用对象的动态特性来为构造函数的原型对象添加属性和方法② 替换原型对象 实例和实例化：实例化:通过构造函数创建具体对象的过程。实例:通过构造函数实例化出来的对象,我们称之为该构造函数的一个实例。注意:在说实例的时候,一定要指定是某个具体构造函数的实例。 原型的使用方法① 利用对象的动态特性给原型添加属性|方法，如果要添加的方法过多,则有大量重复代码。② 直接替换原型对象：01 替换前后创建的对象所指向的原型对象不一致02 替换原型对象会切断和之前的原型对象之间的关系 原型对象的使用注意1234567① 访问属性:构造函数创建出来的对象在访问属性的时候,会先在实例内查找,如果没有找到则进一步到对应的原型对象中查找。② 设置属性:在使用点语法进行赋值的时候,无法操作到对应的原型对象,如果该属性在对象中已经存在，则修改该属性的值。如果该属性在对象中尚未存在,则新增该属性。③ 设置原型对象的属性:[01] 设置原型对象的属性,只能通过构造函数.Prototype的方式替换原型对象的方式设置。[02] 如果原型对象的属性是值类型，那么只能通过Person.prototype.属性的方式修改其值。如果原型对象的属性是引用类型,那么可以通过对象名.引用对象.属性名的方式设置修改： (001) 使用构造函数创建出来的多个对象的原型对象中的该属性指向的是同一块数据。 (002) 某个对象对该原型对象属性进行了修改会影响到其他的对象。 __proto__属性说明：__proto__是一个非标准属性,即ECMAScript中并不包含该属性,这只是某些浏览器为了方便开发人员开发和调试而提供的一个属性,不具备通用性。建议:在调试的时候可以使用该属性,但不能出现在正式的代码中。","categories":[{"name":"JavaScript简明教程","slug":"JavaScript简明教程","permalink":"http://www.1oveit.club/categories/JavaScript简明教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"JavaScript简明教程（1）","slug":"01","date":"2016-01-15T08:36:35.000Z","updated":"2017-05-13T10:45:13.000Z","comments":true,"path":"2016/01/15/01/","link":"","permalink":"http://www.1oveit.club/2016/01/15/01/","excerpt":"JavaScript与Java没有半毛钱关系，网景公司员工Brendan Eich用了10天时间设计了JavaScript语言。 JavaScript的范围JavaScript的范围：BOM + DOM + ECMAScript BOM简单说明123456BOM即Browser Object Mode,浏览器对象模型。BOM提供了独立于内容而与浏览器窗口进行交互的对象。BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。因为BOM主要用于管理窗口与窗口之间的通信，因此其核心对象是window。BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C。BOM结构体系","text":"JavaScript与Java没有半毛钱关系，网景公司员工Brendan Eich用了10天时间设计了JavaScript语言。 JavaScript的范围JavaScript的范围：BOM + DOM + ECMAScript BOM简单说明123456BOM即Browser Object Mode,浏览器对象模型。BOM提供了独立于内容而与浏览器窗口进行交互的对象。BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。因为BOM主要用于管理窗口与窗口之间的通信，因此其核心对象是window。BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C。BOM结构体系 DOM简单说明12345DOM即Document Object Model，文档对象模型。当网页被加载时，浏览器会创建页面的文档对象模型，即DOM。DOM(文档对象模型)被构造为对象的树。DOM由一系列相关的对象构成，引申为Document对象。DOM的标准化组织是W3C。 ECMAScript简单说明123456789ECMAScript指代JavaScript的核心语法。JavaScript 由 Brendan Eich 发明。JavaScript于1995 年出现在 Netscape 中于 1997 年被 ECMA（一个标准协会）采纳。语法核心：变量基本数据类型对象类型结构(循环|条件|判断)面向对象 javascript语法javascript数据类型基本类型（简单数据类型） * string * number * boolean * undefined * null 复杂类型（复杂数据类型） * Object * Array * Date * RegExp * Function * String * Number * Boolean * null * Math javascript部分操作符的说明一元操作符只能够操作一个值的操作符叫做一元操作符。① 递增和递减操作符:12345678910[01] 前置型,递增和递减操作在包含他们的语句被求值之前就执行。[02] 后置型,递增和递减操作在包含他们的语句被求值之后才执行。var num1 = 2;var num2 = 20;var num3 = --num1 + num2; //21var num4 = num1 + num2; //21var num1 = 2;var num2 = 20;var num3 = num1-- + num2; //22var num4 = num1 + num2; //21 ② 一元加和减操作符:一元加操作符对结果不会有任何的影响。一元减操作符主要用于表示负数。 位操作符01 按位非(NOT):使用 ~ 表示，执行按位非的结果就是返回数值的反码。操作数的负值减去1。123var num1 = 25;var num2 = -num1 - 1; //-26consol.log(~num1) //-26 02 按位与(AND):使用&amp;表示，操作两个操作数。只要有0就为0。03 按位或(OR):使用|表示，操作两个操作数。只要有1就为1。04 按位异或(XOR):使用 ^ 表示，操作两个操作数。相同则为0，不同则为1。05 左移|右移(|有符号|无符号)。 布尔操作符 布尔操作符一共有三个，分别是：非、与、或。 01 逻辑非，符号：！ 说明：取反，可应用于任何值，！！相当于没有操作。02 逻辑与，符号：&amp;&amp; 说明：两个值都为真的时候，结果为真。属于短路操作，如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。03 逻辑或，符号：||说明：两个值只要有一个为真，那么结果为真。属于短路操作，如果第一个操作数为真，那么就不会再对第二个操作数求值了。技巧：可以利用逻辑或短路操作的特点来避免为变量赋null或undefined值。123var myObject = refObject || backupObject;//如果refObject的值不是null,那么它的值将被赋值给myObject//如果是null,那么就将backupObject的值赋值给myObject。 乘性操作符乘 *除 /模 % 加性操作符加 +减 - 说明：上述五种操作符在操作数为非数值的时候内部会执行自动的类型转换。 关系操作符大于 &gt;小于 &lt;小于等于 &lt;=大于等于 &gt;=说明：返回布尔类型的值，要么为false，要么为true。 相等操作符01 相等和不相等[先转换再比较]，符号是 == 和！=比较的规则:[01] 如果操作数中有布尔值，则先转换为数值再比较。[02] 如果是字符串和数值比较，则先将字符串转换为数值再比较。[03] 如果是对象和其他类型的值比较，则先调用对象的valueOf方法，然后用得到的基本类型值去比较。[04] null和undefined是相等的。[05] NaN和NaN不相等。[06] 如果两个操作符都是对象，则比较他们是不是同一个对象，如果指向的是同一个对象则返回true，否则返回false。02 全等和不全等[仅比较不转换],符号是===和!==比较的规则:[01] null和undefined是不全等的，因为它们是不同类型的值。[02] 类型相同，且值相等，则返回true，否则返回false。 条件操作符符号：表达式1 ? 字面量1 ：字面量2说明：如果表达式1的结果为true，则使用字面量1，否则使用字面量2。 赋值操作符符号：=、+=、-=、*=、&lt;&lt;=等等说明：使用赋值操作符对性能而言，没有任何的提升，只是简化了赋值操作而已。 值类型和引用类型01 值类型和引用类型简单说明值类型主要有：12345数值字符串布尔类型undefinednull 引用类型主要有：123对象（Object类型）数组（Array）函数 (Function) 值类型：保存为简单的数据值，赋值只是简单的数据值的复制引用类型:保存为对象，其本质是指向内存位置的引用(地址)，赋值是对地址的复制值类型代码示例1234567var num1 = 10;var num2 = num1; //把num1的值复制一份给num2,num1和num2的值相等,除此之外没有任何其他关系console.log(num1,num2); //10,10console.log(num1 == num2); //truenum2 = 20; //修改num2的值为20,不会对num1产生任何的影响console.log(num1,num2); //10,20console.log(num1 == num2); //false 引用类型代码示例12345678910111213var arr1 = [1,2,3];var arr2 = arr1;console.log(arr1,arr2); //[1,2,3],[1,2,3]console.log(arr1 == arr2); //truevar arr3 = [1,2,3];console.log(arr3); //[1,2,3]console.log(arr1 == arr3,arr2 == arr3); //false,false/** * 代码说明: * arr1和arr2在比较的时候,值相等(都是[1,2,3]),且引用相等(都指向堆中同一块数据),因此arr1和arr2相等 * arr3和arr1以及arr2比较的时候,值相等([1,2,3]),但是引用不相等(arr3指向的是堆中另外一块数据),因此不等 * 总结:引用类型在比较相等的时候,只有值和引用都相等才相等 * */ 02 值类型和引用类型的赋值赋值操作(=):把当前变量存储的值复制一份给接收的变量。值类型的赋值:把当前变量存储的值(具体的数据)复制一份给接收的变量。引用类型的赋值:把当前变量存储的值(具体数据的引用即地址)复制一份给接收的变量。12345678//引用类型使用注意 console.log(arr1,arr2); //[1,2,3],[1,2,3]; console.log(arr1 == arr2); //true arr1.push(4); console.log(arr1,arr2); //[1,2,3,4],[1,2,3,4] /** * 代码说明:因为arr1和arr2内部的引用指向的是同一块数据,所以修改了arr1会对arr2也产生影响 * */ 03 值类型和引用类型作为函数参数处理形参:占位用的参数,用来接收数据的参数而已。实参:实际传递的参数。函数的调用:在函数调用的时候,函数默认会把实参的值赋值给形参。值类型作为参数：在函数内部对形参变量进行修改不会影响到实参的值。引用类型作为参数：在函数内部对形参变量进行修改会影响到实参的值，因为他们的引用指向同一个对象。04 值类型和引用类型的相关图示基本类型的赋值12var str1 = \"hello zhangsan\";var str2 = str1; 引用类型的结构和赋值123456789var car = &#123; color:\"黑色\", number:\"B99\"&#125;;var p1 = &#123; name:\"王宝宝\", age:30, car:car&#125;; 12345var obj1 = &#123; name:\"lisi\", age:18 &#125;; var obj2 = obj1; 对象的动态特性在js中可以动态的对对象属性进行增加、修改和删除；代码示例12345678910111213141516171819//01 创建对象var obj = &#123; name:\"刘德华\", age:60&#125;;//02 动态的为对象添加属性obj.height = \"180cm\";console.log(obj.height);//03 动态的为对象添加方法obj.maiMeng = function () &#123; console.log(\"华仔会卖萌噢\");&#125;;obj.maiMeng();//04 修改属性的值:如果设置的属性以前不存在,那么就是添加,如果设置的属性已经存在了,那么就是修改obj.name = \"王宝强\";console.log(obj.name)//05 删除属性delete obj.name;console.log(obj.name); //undefined 访问对象的方法01 可以使用点语法访问02 可以使用[]语法访问，注意对象的属性必须是字符串 关键字in和delete的使用01 in关键字01 判断属性是否存在于对象中，注意所有的key都是字符串02 for in循环中 遍历对象的 键代码示例12345678910var obj = &#123; name:\"张三\", age:18&#125;;for(k in obj)&#123; console.log(k,obj[k]);&#125;//检测obj对象中是否存在name这个属性console.log(\"name\" in obj); 注意：in关键字操作数组的时候检测的是索引值并非数组元素02 delete关键字01 删除对象的属性02 删除未使用var声明的变量03 返回值为boolean类型，true则表示是否删除成功注意1201 删除的属性如果不存在，返回true02 删除的如果是原型中的属性，返回true 但是删除不成功 循环和分支循环结构1234forwhiledo...whilefor..in 分支结构12if...else..swith..case break和continue对比break:终止循环，循环中后面的代码不再执行continue:结束当前循环，循环后面的代码不再执行，继续下一次循环 调试工具的使用开启调试窗口 windows 平台: f12; Mac: option+command+i;调试窗口介绍 指针: 选择页面中的元素 手机: 使用移动端界面调试 Elements: 查看页面 DOM 树 Console: 控制台(注意, 控制台与该页面是一个整体, 在控制台中的任何操作, 会影响到页面) Source: 代码调试调试工具的使用 逐过程运行, 一次运行一个函数 单步运行(逐步运行), 一次运行一句, 如果是函数, 进入函数体内运行 继续运行. 从当前状态运行下去, 直到出现断点, 如果没有断点则运行结束设置断点技巧 逐步与逐过程混合 断点加继续运行 条件断点(右键添加 add contitional breakpoint)利用 watch 监视窗口可以查看对象成员 异常处理常见的异常分类运行环境的多样性导致的异常（浏览器）语法错误，代码错误异常的特征:一旦代码出现异常，后面的代码就不会再执行异常捕获使用try-catch语句捕获异常123456try&#123; //这里写可能出现异常的代码&#125;catch(e)&#123; //这里的e就是捕获的异常对象 //可以在这里写，出现异常后的处理代码&#125; 异常捕获语句执行的过程为：01 代码正常运行, 如果在try中出现了错误, try 里面出现错误的语句后面的代码都不再执行, 直接跳转到 catch 中02 在catch中处理错误信息03 继续执行后面的代码04 如果 try 中没有出现错误, 那么不走 catch 直接执行后面的代码捕获异常的优点：通过try-catch语句进行异常捕获之后，代码将会继续执行，而不会中断。注意：语法错误异常用try-catch语句无法捕获，因为在预解析阶段，语法错误会直接检测出来，而不会等到运行的时候才报错。try..catch使用示例1234567891011121314151617//01 try ... catch结构的使用//a(); 若直接调用则爆出:Uncaught ReferenceError: a is not defined错误//在开发中,我们对于可能会报错或者是发生异常的代码用try结构进行处理try&#123; a(); //如果发生异常,那么至少不会到正程序中断&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest();//结论:使用try...catch结构,如果发生了异常,那么不会影响后面代码的执行,且我们可以在发生异常信息之后做出具体的处理 手动抛出异常案例：自己写的一个函数，需要一个参数，如果用户不传参数，此时想直接给用户抛出异常，就需要了解如何抛出异常。抛出异常使用throw关键字，语法如下：手动抛出异常信息（字符串）:123456789101112131415try&#123; //a(); //如果发生异常,那么至少不会到正程序中断 //不使用系统默认的异常信息,尝试手动抛出 throw \"对不起,您调用了尚未定义的方法\";&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest(); 手动抛出异常信息（对象）:1234567891011121314151617181920212223try&#123; //a(); //如果发生异常,那么至少不会到正程序中断 //不使用系统默认的异常信息,尝试手动抛出 throw &#123; errMsg:\"具体的错误信息提示\", errCode:\"指定错误类型的代号,如1001等\" &#125;;&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e); //在try语句中抛出的错误信息是什么,那么得到的异常信息就是什么 //如果抛出的是字符串,那么得到的就是字符串 //如果抛出的是对象,那么此处得到的就是对象 console.log(e.errMsg); console.log(e.errCode);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest(); 异常捕获语句的完整模式异常捕获语句的完整模式为try-catch-finally123456789101112131415try&#123; //在执行的时候可能发生异常的代码 b();&#125;catch (e)&#123; //如果try代码块中的代码在执行中发生了异常,那么就会执行该代码块的代码 //通过打印e对象可以查看具体的异常信息 console.log(e); //打印异常信息&#125;finally &#123; //不论try语句中的代码是否会发生异常,都一定会执行此处的代码块 //一般在前端开发中很少使用,常用语后台开发的资源释放工作 console.log(\"无论如何总要执行的代码\");&#125; finally中的代码，不管是否发生异常，都会执行。一般用在后端语言中，用来释放资源，JavaScript中很少会用到。 DOM操作获取元素操作123getElementByIdgetElementsByTagNamegetElementsByClassName 元素节点操作1234567appendChildinsertBeforeremoveChildreplaceChildcloneNodecreateElementcreateTextNode（创建文本节点） 属性节点操作123getAttributesetAttributeremoveAttribute 常用DOM属性1234classNameinnerHTMLinnerText/textContent valuechildren 代码示例12345678910111213141516//0 获取页面中指定的标签,并设置其样式 var divID = document.getElementById(\"divId\"); divID.style.backgroundColor = \"pink\"; divID.style.height = \"40px\"; divID.style.width = \"200px\"; //01 创建新的标签 var div = document.createElement(\"div\"); //02 设置标签的样式 div.style.backgroundColor = \"red\"; div.style.height = \"100px\"; div.style.width = \"300px\"; div.style.fontSize = \"20\"; //03 设置标签的内容 div.innerText = \"这是一个自己创建的标签\"; //04 把标签插入到页面中 document.body.appendChild(div);","categories":[{"name":"JavaScript简明教程","slug":"JavaScript简明教程","permalink":"http://www.1oveit.club/categories/JavaScript简明教程/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.1oveit.club/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.1oveit.club/tags/简明教程/"}]},{"title":"12年逗比如我","slug":"12年怀旧","date":"2016-01-08T13:27:45.000Z","updated":"2017-05-22T07:26:04.000Z","comments":true,"path":"2016/01/08/12年怀旧/","link":"","permalink":"http://www.1oveit.club/2016/01/08/12年怀旧/","excerpt":"12年写的乱七八遭，拿出来怀旧，权当笑话，笑笑更开心！ 一周大一秀欢迎收听一周大一秀，观众朋友们大家好。好学生就是我，我就是曾大贤。欢迎收听本节目，请大家用热烈的掌声欢迎我们今天的主角出场。他就是人见人爱，花见花开，俗称一朵海棠压梨花的帅哥。没错，你猜对了，好学生就是我，我就是曾大贤。接下来请大家千万把耳屎勾干净了，洗耳恭听嘛，哈哈。","text":"12年写的乱七八遭，拿出来怀旧，权当笑话，笑笑更开心！ 一周大一秀欢迎收听一周大一秀，观众朋友们大家好。好学生就是我，我就是曾大贤。欢迎收听本节目，请大家用热烈的掌声欢迎我们今天的主角出场。他就是人见人爱，花见花开，俗称一朵海棠压梨花的帅哥。没错，你猜对了，好学生就是我，我就是曾大贤。接下来请大家千万把耳屎勾干净了，洗耳恭听嘛，哈哈。大学就是围墙啊，在外面的人都想跳进来，在里面的人都想跳出去。曾哥我真的是深深的有感触啊！此事从五百年前说起，曾哥在一个夜黑风高的晚上，血腥的风放肆嘲笑满街的横尸遍野。曾哥右持AK_47，左携一篮子地雷，嘴叼雪茄【此音乐响起上海滩】，在千军万马中杀了出来。就这样，千军万马来相见，曾哥突破了大学这道围墙，杀进了大学【此时音乐响起天空之城】。进了大学这道墙，曾哥欣喜若狂，因为按照传说，就可以不费吹灰之力拥有一切，以后开宝马，住洋房，娶洋妞都不用愁了。以为到了世外桃源，曾哥很高兴地把AK_47丢进了河里，把一篮子地雷也扔了进去【此时音乐响起乌鸦的惨叫声】，只留下嘴刁着的那根雪茄，用来扮酷讨女孩子欢心。 故事到这里，相信大家都能猜到后果了，很遗憾广告时间到了，请大家不要走开，广告之后更精彩【好敌真好，广州好敌】。欢迎大家继续收听一周大一秀，好学生就是我，我就是曾大贤。曾大贤接下来何去何从，精彩不容错过。曾大贤被传说给传说了，接下来的日子里，他就只能做这些事了，哎【MUSIC阿里路亚】 摸黑起床，叫兽整队，准备抗战。有的时候还没来得及刷牙洗脸，就匆匆忙忙赶去与英语口语决一死战。战罢方休，一个馒头一个大饼是战利品。军纪如律令，又赶忙去找营地，生怕触犯律令，有时不得不一边啃着个窝窝头一边找赶上军队去扎营。糊糊涂涂的坐在营里，听叫兽讲那些讲那些似懂非懂的军事理论知识，时间很快到了中午。战友总在催，不走快点，就要吃剩饭，呜呜，排队打饭订餐，弄得曾哥连吃饭的心情都没有了。好不容易吃完了午饭，曾哥本想舒舒服服睡上一觉，怎知社团活动来风急。曾哥可怜的午休时间那，就这么被无情的摧残了。 俗话说，中午不睡，下午崩溃。果不其然，曾哥整个下午都崩溃掉了【音乐伤不起啊伤不起】。顶着乏意，毫无生机。曾哥恹恹欲睡，却又不敢入睡。闭着眼睛也能跟着叫兽打军体拳，曾哥实在是太强大了！ 时间一晃而过，本来打算美美的洗个澡的，可是时间急迫啊。七点就要站岗放哨，又是军纪如律令，所以洗澡这事给挂了。一来省些水资源，二来嘛省钱，你懂的，哈哈。终于曾哥下岗了，夜生活真正开始了。手机上网畅无线，莺歌电影嗨翻天十一二点不算晚，就看你的肾好不好，额滴肾啊，哈哈。 大学生活就是沙场点兵，而曾哥却总还能打怪兽。一部手机可以有几多个怪兽，曾哥说菲尔普斯专用山寨机，就是牛。曾哥追师姐也真是牛，来一个杀一个，来两个杀一双。可是你懂的，曾哥最终还是情伤了【音乐响起我是个容易受伤的男人】，因为长得太帅了没办法，不知道选那一个啊。【音乐响起请你不要迷恋哥，嫂子会打你的】 曾哥受伤了，曾哥想家了。【音乐响起常回家看看】曾哥哭了【音乐男人哭吧哭吧不是罪】，曾哥想到了AK_47，想到了地雷，但只剩嘴里那根烟了，杀不回去了。 还好，周末给了曾哥继续下去的理由。叫兽说，睡觉是对周末的最起码的尊重。曾哥一向是守法的孩子，所以周末有事没事要找曾哥的孩子，请留言，曾哥已睡死，哈哈。 当然这是不可能的事，因为叫兽还说过，来到洛阳，你不去外面转转，就可惜了。河山大好，洛阳正好。老师说到曾哥就做到，所以周末成了曾哥的旅游时间。一个地方总会有一个地方的好，洛阳正是个好地方。大学你所在的城市，你对他有了解多少呢？嘿嘿，趁周末完，像曾哥一样，出去转转吧，别待在宿舍当懒虫。音乐响起许嵩的【河山大好：电脑看太久了脖子也会酸，数字时代貌似把生活节奏加快，也让人变得行动迟缓起来。忙忙忙，忙不出个所以然，地球就算累了它照样会公转自转。叹叹叹，弹指一挥人生苦短，终点不明沿途风景要好好看。你可以隐隐的期待，途中佳缘的带来，保持一个浪漫的心态，活着就不算坏】。 感谢大家一路相伴，本期节目到此结束。曾哥究竟会在大学有何作为呢？","categories":[],"tags":[{"name":"娱乐","slug":"娱乐","permalink":"http://www.1oveit.club/tags/娱乐/"},{"name":"怀旧","slug":"怀旧","permalink":"http://www.1oveit.club/tags/怀旧/"}]},{"title":"五分钟学会简单使用git","slug":"五分钟学会简单使用git","date":"2016-01-02T16:00:00.000Z","updated":"2017-05-22T07:26:04.000Z","comments":true,"path":"2016/01/03/五分钟学会简单使用git/","link":"","permalink":"http://www.1oveit.club/2016/01/03/五分钟学会简单使用git/","excerpt":"五分钟，简单入门。学会之后可以愉快的管理你的文件啦。 简单使用git 其实很简单，有多简单呢？ 1. git init 初始化一个仓库； 2. git add . 添加文件到暂存区； 3. git commit -m&apos;messeage&apos; 提交至版本库； 4. git push origin master 推送至远程仓库；","text":"五分钟，简单入门。学会之后可以愉快的管理你的文件啦。 简单使用git 其实很简单，有多简单呢？ 1. git init 初始化一个仓库； 2. git add . 添加文件到暂存区； 3. git commit -m&apos;messeage&apos; 提交至版本库； 4. git push origin master 推送至远程仓库； 分支管理什么是平衡分支？实际工作中一般新建平衡分支用于开发调试等，然后再合并到主分支。 1.git checkout -b dev 新建dev分支并切换到dev分支。 相当于：git branch dev 创建dev分支； git checkout dev 切换到dev分支； 2. 开发或者调试结束后 git add * 添加所有文件到暂存区； git commit -m&apos;messeage&apos; 提交至版本库； 3.git checkout master 切换到主分支； git merge dev 合并分支； git branch -d dev 删除分支； 解决冲突什么是冲突？同一份文件同一个地方被不同的协作者修改了，最后一个推送至远程的会产生冲突。 解决冲突：git pull 更新本地仓库 打开冲突文件，找到冲突部分，协调修改。 1 TODO 2 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 3 我修改的 4 ======= 5 协作者修改的 6 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 经过协调，修改为 1 TODO 2 经过协调修改的 到这里，你已经基本上掌握了git的使用了，想再深入了解，请点击git Pro中文","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://www.1oveit.club/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"http://www.1oveit.club/tags/版本控制/"}]},{"title":"我的世界，如果少了一个你","slug":"你好，世界","date":"2016-01-01T10:23:07.000Z","updated":"2017-06-22T05:06:00.000Z","comments":true,"path":"2016/01/01/你好，世界/","link":"","permalink":"http://www.1oveit.club/2016/01/01/你好，世界/","excerpt":"如果说人的一生都有规律可以追寻，那是不是可以按照规律活下去，我的世界从此也就不会少一个你。 这一天生日在遥远的海洋上，夕阳无限好。摇摇曳曳，余光随着波浪，尽情摇摆。海面像往常一样平静。这是这座小城第824年历史的纪念日，历史悠久，耐人探索。吃完晚饭六点多，一家人来到海边散步。女儿已经5岁了，扎着小尾辫子。一手牵着妈妈，一手牵着爸爸，唱着上课老师教的歌曲。忽然，不知道那里逃出来的狗，灰棕灰，气势汹汹.这可不得了，这冲着人去咬。猝不及防，小女孩被狗咬伤了。没想到，意外总是这么意外。今天是小女孩的五岁生日。","text":"如果说人的一生都有规律可以追寻，那是不是可以按照规律活下去，我的世界从此也就不会少一个你。 这一天生日在遥远的海洋上，夕阳无限好。摇摇曳曳，余光随着波浪，尽情摇摆。海面像往常一样平静。这是这座小城第824年历史的纪念日，历史悠久，耐人探索。吃完晚饭六点多，一家人来到海边散步。女儿已经5岁了，扎着小尾辫子。一手牵着妈妈，一手牵着爸爸，唱着上课老师教的歌曲。忽然，不知道那里逃出来的狗，灰棕灰，气势汹汹.这可不得了，这冲着人去咬。猝不及防，小女孩被狗咬伤了。没想到，意外总是这么意外。今天是小女孩的五岁生日。 恶狗来袭就这样，小女孩的生日那天是在医院度过的。小女孩的爸爸–冯孔，在一家国企上班，刚到而立之年。小女孩的妈妈–翁玲，是一名教师。而这个小女孩，叫冯孔玲。刚才那狗，明显是冲着小女孩去的。冯孔和翁玲明显疏忽了。只见那狗一个纵身飞跃，咬着小女孩的大腿不放。这可得了，冯孔先是一愣，眼眉一紧，使出吃奶力气撩开那狗。可是那狗也是凶残，一个转身，又一个飞跃，獠牙再现，冯孔也中招了。在医院，翁玲余惊未去。要不是刚才在路上恰巧有消防队路过，恐怕今天是在劫难逃。翁玲陷入了深深的沉思，想起了7年前发生的事情。 时光回到十年前。 那时候冯孔还在上大学，而翁玲刚考上大学。翁玲认识冯孔是汉语言学院的迎新晚会上。在那时候发生了很多事，翁玲和冯孔能够走到一起，很多事情就显得不可思议。往事历历在目，宛如昨日。那时候的天还很蓝，水也比较清澈。人们都过着自认为比较舒服的日子。翁玲是独生女，从小比较娇惯些。如果能够回到十年前，翁玲恐怕做梦都想改变这一切吧！可是如果改变这一切，可能她就再也见不到她的先生了。也许生活就是这么安排的，让人苦笑不得。回到迎新晚回上，翁玲是女子舞蹈团体的领队，那时候在男生多，女生少的学校，不知道有多少人在追求着翁玲。为了这一场迎新晚回的表演，翁玲已经连续排练了一个多月。队里的一个女生，叫秦岚。是河南驻马店的一个小村庄，能够得到这个机会，一方面是翁琳的帮助，一方面是自己确实热爱舞蹈。没有人知道为什么这次晚回为什么学校这么看重，按照以前的规矩，提取一个星期排练就可以说是相当重视了。可是这一次不同，在老早的时候，就提取预知舞蹈队选拔，准备晚回演出。可以看出，这是晚回最重要的节目，没有之一。那个时候能当上舞蹈队队长，与翁琳队爸爸不无关系，论实际能力，队里大三的魏若筠才是不二人选。说起翁玲的老爸，是这学校的教学主任，当初选拔队长的时候，魏若筠可是持主流声音。毕竟在队里是最有资历的，也是最有实力的。而且在社团的历史上，还没有出现大一就当选队长团长这样的先例。为什么翁玲在大一的时候就能够当选舞蹈队的队长呢？其实说来也是巧，当初在竞选的时候，由于都知道魏若筠会当选，所有基本上没有人去竞选，因为大家打从心底里佩服魏若筠。舞蹈队的事情她可是无论细巨，都很上心很负责。所以，最后竞选的名单只有翁琳和魏若筠。为什么翁玲会去竞选这个舞蹈队的队长呢？这个说来也巧。在她刚入学的那一天，各大社团都有迎接新生的活动，因为翁玲的爸爸是这个学校的教学主任，所以对这个学校的一切，一切貌似都了如指掌。当初会报名舞蹈队，完全是她老爸的安排。管社团的团委老师与翁玲老爸是校友，所以就算翁玲没有报名加入舞蹈队，她也是队里的一名队员了。翁玲是十分不愿意被安排的，从小到大，都是这样，每一次父母都没有征询过自己的意见，每一次都像个乖乖女。 正所谓初生牛犊不怕虎， “您好，请问事13号病人的家属吗？”一旁的护士小姐端着记录板，轻声细语般：“请跟我到这边来办理相关手续，谢谢！”。翁玲收回思绪，赶紧随着护士去处理相关事宜。","categories":[],"tags":[{"name":"sad story","slug":"sad-story","permalink":"http://www.1oveit.club/tags/sad-story/"},{"name":"updating","slug":"updating","permalink":"http://www.1oveit.club/tags/updating/"}]}]}