{"meta":{"title":"Afanail","subtitle":"","description":"前端,js,jquery,javascript,html5,开发者,程序猿","author":"Afanail","url":"http://www.afanail.com"},"pages":[{"title":"","date":"2017-07-22T03:06:47.000Z","updated":"2017-07-22T03:06:47.000Z","comments":true,"path":"photos/ins.css","permalink":"http://www.afanail.com/photos/ins.css","excerpt":"","text":""},{"title":"啊喔~~~ 404鸡神奇显身","date":"2017-05-23T13:54:12.000Z","updated":"2017-05-23T13:54:12.000Z","comments":false,"path":"/404.html","permalink":"http://www.afanail.com//404.html","excerpt":"","text":""},{"title":"about me","date":"2017-05-11T09:21:56.000Z","updated":"2017-08-07T15:12:15.000Z","comments":true,"path":"about/index.html","permalink":"http://www.afanail.com/about/index.html","excerpt":"","text":"Afanail:email:zjfapk@163.com软件工程师主球队：Manchester UnitedGolden State Warriors七月上我欲乘风破浪，踏遍黄沙海洋。与其误会一场，也要不负勇往。我愿你是个谎，从未出现南墙.我想你就站在，站在七月之上。"},{"title":"","date":"2017-07-22T04:07:18.000Z","updated":"2017-07-22T04:07:18.000Z","comments":true,"path":"photos/data.json","permalink":"http://www.afanail.com/photos/data.json","excerpt":"","text":"{\"list\":[{\"date\":\"2016-08\",\"arr\":{\"year\":2016,\"month\":8,\"link\":[\"2016-08-07_求婚啦.jpg\"],\"text\":[\"求婚啦\"],\"type\":[\"image\"]}},{\"date\":\"2016-06\",\"arr\":{\"year\":2016,\"month\":6,\"link\":[\"2016-06-01_我们宿舍.JPG\",\"2016-06-01_我毕业啦啦.JPG\",\"2016-06-01_毕业那件小事.JPG\",\"2016-06-01_永远的12.JPG\",\"2016-06-01_班花来啦.JPG\",\"2016-06-01_老魏啊.JPG\"],\"text\":[\"我们宿舍\",\"我毕业啦啦\",\"毕业那件小事\",\"永远的12\",\"班花来啦\",\"老魏啊\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2016-05\",\"arr\":{\"year\":2016,\"month\":5,\"link\":[\"2016-05-29_我们这群人.JPG\",\"2016-05-29_抛帽子.JPG\"],\"text\":[\"我们这群人\",\"抛帽子\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2015-12\",\"arr\":{\"year\":2015,\"month\":12,\"link\":[\"2015-12-05_西安西安.jpg\"],\"text\":[\"西安西安\"],\"type\":[\"image\"]}},{\"date\":\"2015-05\",\"arr\":{\"year\":2015,\"month\":5,\"link\":[\"2015-05-01_充实的一天--七夕01.jpg\",\"2015-05-01_反正不是我贴的.jpg\",\"2015-05-01_抽奖中的——低调.jpg\"],\"text\":[\"充实的一天--七夕01\",\"反正不是我贴的\",\"抽奖中的——低调\"],\"type\":[\"image\",\"image\",\"image\"]}}]}"},{"title":"","date":"2017-07-22T02:56:11.000Z","updated":"2017-07-22T02:56:11.000Z","comments":true,"path":"photos/index.html","permalink":"http://www.afanail.com/photos/index.html","excerpt":"","text":"图片正在加载中… (function() { var loadScript = function(path) { var $script = document.createElement('script') document.getElementsByTagName('body')[0].appendChild($script) $script.setAttribute('src', path) } setTimeout(function() { loadScript('./ins.js') }, 0) })()"},{"title":"","date":"2017-05-11T13:47:15.000Z","updated":"2017-05-11T13:47:15.000Z","comments":true,"path":"photos/ins.js","permalink":"http://www.afanail.com/photos/ins.js","excerpt":"","text":"/******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"/dist/\"; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(1); var _view = __webpack_require__(2); var _view2 = _interopRequireDefault(_view); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } /** * @name impush-client * @description 这个项目让我发家致富… * @date 2016-12-1 */ var _collection = []; var _count = 0; var searchData; function addMask(elem) { var rect = elem.getBoundingClientRect(); var style = getComputedStyle(elem, null); var mask = document.createElement('i'); mask.className = 'icon-film'; mask.style.color = '#fff'; mask.style.fontSize = '26px'; mask.style.position = 'absolute'; mask.style.right = '10px'; mask.style.bottom = '10px'; mask.style.zIndex = 1; elem.parentNode.appendChild(mask); } var createVideoIncon = function createVideoIncon() { var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]'); for (var i = 0, len = $videoImg.length; i < len; i++) { addMask($videoImg[i]); } }; var render = function render(res) { var ulTmpl = \"\"; for (var j = 0, len2 = res.list.length; j < len2; j++) { var data = res.list[j].arr; var liTmpl = \"\"; for (var i = 0, len = data.link.length; i < len; i++) { var minSrc = 'https://raw.githubusercontent.com/zhengjingfa/Blog-Back-Up/master/min_photos/' + data.link[i]; var src = 'https://raw.githubusercontent.com/zhengjingfa/Blog-Back-Up/master/photos/' + data.link[i]; var type = data.type[i]; var target = src + (type === 'video' ? '.mp4' : '.jpg'); src += ''; liTmpl += '\\ \\ \\ \\ ' + data.text[i] + '\\ '; } ulTmpl = ulTmpl + '' + data.year + '年' + data.month + '月\\ ' + liTmpl + '\\ '; } document.querySelector('.instagram').innerHTML = '' + ulTmpl + ''; createVideoIncon(); _view2.default.init(); }; var replacer = function replacer(str) { var arr = str.split(\"/\"); return \"/assets/ins/\" + arr[arr.length - 1]; }; var ctrler = function ctrler(data) { var imgObj = {}; for (var i = 0, len = data.length; i < len; i++) { var y = data[i].y; var m = data[i].m; var src = replacer(data[i].src); var text = data[i].text; var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m); if (imgObj[key]) { imgObj[key].srclist.push(src); imgObj[key].text.push(text); } else { imgObj[key] = { year: y, month: m, srclist: [src], text: [text] }; } } render(imgObj); }; function loadData(success) { if (!searchData) { var xhr = new XMLHttpRequest(); xhr.open('GET', './data.json?t=' + +new Date(), true); xhr.onload = function() { if (this.status >= 200 && this.status < 300) { var res = JSON.parse(this.response); searchData = res; success(searchData); } else { console.error(this.statusText); } }; xhr.onerror = function() { console.error(this.statusText); }; xhr.send(); } else { success(searchData); } } var Ins = { init: function init() { loadData(function(data) { render(data); }); } }; Ins.init(); // export default impush; /***/ }, /* 1 */ /***/ function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */ (function(global) { 'use strict'; var inViewport = __webpack_require__(3); var lazyAttrs = ['data-src']; global.lzld = lazyload(); // Provide libs using getAttribute early to get the good src // and not the fake data-src replaceGetAttribute('Image'); replaceGetAttribute('IFrame'); function registerLazyAttr(attr) { if (indexOf.call(lazyAttrs, attr) === -1) { lazyAttrs.push(attr); } } function lazyload(opts) { opts = merge({ 'offset': 333, 'src': 'data-src', 'container': false }, opts || {}); if (typeof opts.src === 'string') { registerLazyAttr(opts.src); } var elts = []; function show(elt) { var src = findRealSrc(elt); if (src) { elt.src = src; } elt.setAttribute('data-lzled', true); elts[indexOf.call(elts, elt)] = null; } function findRealSrc(elt) { if (typeof opts.src === 'function') { return opts.src(elt); } return elt.getAttribute(opts.src); } function register(elt) { elt.onload = null; elt.removeAttribute('onload'); elt.onerror = null; elt.removeAttribute('onerror'); if (indexOf.call(elts, elt) === -1) { inViewport(elt, opts, show); } } return register; } function replaceGetAttribute(elementName) { var fullname = 'HTML' + elementName + 'Element'; if (fullname in global === false) { return; } var original = global[fullname].prototype.getAttribute; global[fullname].prototype.getAttribute = function(name) { if (name === 'src') { var realSrc; for (var i = 0, max = lazyAttrs.length; i < max; i++) { realSrc = original.call(this, lazyAttrs[i]); if (realSrc) { break; } } return realSrc || original.call(this, name); } // our own lazyloader will go through theses lines // because we use getAttribute(opts.src) return original.call(this, name); }; } function merge(defaults, opts) { for (var name in defaults) { if (opts[name] === undefined) { opts[name] = defaults[name]; } } return opts; } // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html function indexOf(value) { for (var i = this.length; i-- && this[i] !== value;) {} return i; } module.exports = lazyload; // export default impush; /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ }, /* 2 */ /***/ function(module, exports) { 'use strict'; var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) { // parse slide data (url, title, size ...) from DOM elements // (children of gallerySelector) var parseThumbnailElements = function parseThumbnailElements(el) { el = el.parentNode.parentNode; var thumbElements = el.getElementsByClassName('thumb'), numNodes = thumbElements.length, items = [], figureEl, linkEl, size, type, // video or not target, item; for (var i = 0; i < numNodes; i++) { figureEl = thumbElements[i]; // // include only element nodes if (figureEl.nodeType !== 1) { continue; } linkEl = figureEl.children[0]; // size = linkEl.getAttribute('data-size').split('x'); type = linkEl.getAttribute('data-type'); target = linkEl.getAttribute('data-target'); // create slide object item = { src: linkEl.getAttribute('href'), w: parseInt(size[0], 10), h: parseInt(size[1], 10) }; if (figureEl.children.length > 1) { item.title = figureEl.children[1].innerHTML; } if (linkEl.children.length > 0) { item.msrc = linkEl.children[0].getAttribute('src'); item.type = type; item.target = target; item.html = ''; if (type === 'video') { //item.src = null; } } item.el = figureEl; // save link to element for getThumbBoundsFn items.push(item); } return items; }; // find nearest parent element var closest = function closest(el, fn) { return el && (fn(el) ? el : closest(el.parentNode, fn)); }; // triggers when user clicks on thumbnail var onThumbnailsClick = function onThumbnailsClick(e) { e = e || window.event; e.preventDefault ? e.preventDefault() : e.returnValue = false; var eTarget = e.target || e.srcElement; // find root element of slide var clickedListItem = closest(eTarget, function(el) { return el.tagName && el.tagName.toUpperCase() === 'FIGURE'; }); if (!clickedListItem) { return; } // find index of clicked item by looping through all child nodes // alternatively, you may define index via data- attribute var clickedGallery = clickedListItem.parentNode, // childNodes = clickedListItem.parentNode.childNodes, // numChildNodes = childNodes.length, childNodes = document.getElementsByClassName('thumb'), numChildNodes = childNodes.length, nodeIndex = 0, index; for (var i = 0; i < numChildNodes; i++) { if (childNodes[i].nodeType !== 1) { continue; } if (childNodes[i] === clickedListItem) { index = nodeIndex; break; } nodeIndex++; } if (index >= 0) { // open PhotoSwipe if valid index found openPhotoSwipe(index, clickedGallery); } return false; }; // parse picture index and gallery index from URL (#&pid=1&gid=2) var photoswipeParseHash = function photoswipeParseHash() { var hash = window.location.hash.substring(1), params = {}; if (hash.length < 5) { return params; } var vars = hash.split('&'); for (var i = 0; i < vars.length; i++) { if (!vars[i]) { continue; } var pair = vars[i].split('='); if (pair.length < 2) { continue; } params[pair[0]] = pair[1]; } if (params.gid) { params.gid = parseInt(params.gid, 10); } return params; }; var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) { var pswpElement = document.querySelectorAll('.pswp')[0], gallery, options, items; items = parseThumbnailElements(galleryElement); // define options (if needed) options = { // define gallery index (for URL) galleryUID: galleryElement.getAttribute('data-pswp-uid'), getThumbBoundsFn: function getThumbBoundsFn(index) { // See Options -> getThumbBoundsFn section of documentation for more info var thumbnail = items[index].el.getElementsByTagName('img')[0], // find thumbnail pageYScroll = window.pageYOffset || document.documentElement.scrollTop, rect = thumbnail.getBoundingClientRect(); return { x: rect.left, y: rect.top + pageYScroll, w: rect.width }; } }; // PhotoSwipe opened from URL if (fromURL) { if (options.galleryPIDs) { // parse real index when custom PIDs are used // http://photoswipe.com/documentation/faq.html#custom-pid-in-url for (var j = 0; j < items.length; j++) { if (items[j].pid == index) { options.index = j; break; } } } else { // in URL indexes start from 1 options.index = parseInt(index, 10) - 1; } } else { options.index = parseInt(index, 10); } // exit if index not found if (isNaN(options.index)) { return; } if (disableAnimation) { options.showAnimationDuration = 0; } // Pass data to PhotoSwipe and initialize it gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); var $tempVideo; var stopVideoHandle = function stopVideoHandle() { if ($tempVideo) { $tempVideo.remove(); $tempVideo = null; } }; var changeHandle = function changeHandle() { var item = gallery.currItem; stopVideoHandle(); if (item.type === 'video') { var $ctn = item.container; var style = $ctn.getElementsByClassName('pswp__img')[0].style; var $video = document.createElement('video'); $video.setAttribute('autoplay', 'autoplay'); $video.setAttribute('controls', 'controls'); $video.setAttribute('src', item.target); $video.style.width = style.width; $video.style.height = style.height; $video.style.position = 'absolute'; $video.style.zIndex = 2; $tempVideo = $video; $ctn.appendChild($video); } }; gallery.listen('initialZoomIn', changeHandle); gallery.listen('afterChange', changeHandle); gallery.listen('initialZoomOut', stopVideoHandle); }; // loop through all gallery elements and bind events var galleryElements = document.querySelectorAll(gallerySelector); for (var i = 0, l = galleryElements.length; i < l; i++) { galleryElements[i].setAttribute('data-pswp-uid', i + 1); galleryElements[i].onclick = onThumbnailsClick; } // Parse URL and open gallery if it contains #&pid=3&gid=1 var hashData = photoswipeParseHash(); if (hashData.pid && hashData.gid) { openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true); } }; var Viewer = function() { function init() { initPhotoSwipeFromDOM('.photos'); } return { init: init }; }(); module.exports = Viewer; /***/ }, /* 3 */ /***/ function(module, exports) { /* WEBPACK VAR INJECTION */ (function(global) { module.exports = inViewport; var instances = []; var supportsMutationObserver = typeof global.MutationObserver === 'function'; function inViewport(elt, params, cb) { var opts = { container: global.document.body, offset: 0 }; if (params === undefined || typeof params === 'function') { cb = params; params = {}; } var container = opts.container = params.container || opts.container; var offset = opts.offset = params.offset || opts.offset; for (var i = 0; i < instances.length; i++) { if (instances[i].container === container) { return instances[i].isInViewport(elt, offset, cb); } } return instances[ instances.push(createInViewport(container)) - 1 ].isInViewport(elt, offset, cb); } function addEvent(el, type, fn) { if (el.attachEvent) { el.attachEvent('on' + type, fn); } else { el.addEventListener(type, fn, false); } } function debounce(func, wait, immediate) { var timeout; return function() { var context = this, args = arguments; var callNow = immediate && !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); function later() { timeout = null; if (!immediate) func.apply(context, args); } }; } // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708 var contains = function() { if (!global.document) { return true; } return global.document.documentElement.compareDocumentPosition ? function(a, b) { return !!(a.compareDocumentPosition(b) & 16); } : global.document.documentElement.contains ? function(a, b) { return a !== b && (a.contains ? a.contains(b) : false); } : function(a, b) { while (b = b.parentNode) { if (b === a) { return true; } } return false; }; } function createInViewport(container) { var watches = createWatches(); var scrollContainer = container === global.document.body ? global : container; var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15); addEvent(scrollContainer, 'scroll', debouncedCheck); if (scrollContainer === global) { addEvent(global, 'resize', debouncedCheck); } if (supportsMutationObserver) { observeDOM(watches, container, debouncedCheck); } // failsafe check, every 200ms we check for visible images // usecase: a hidden parent containing eleements // when the parent becomes visible, we have no event that the children // became visible setInterval(debouncedCheck, 150); function isInViewport(elt, offset, cb) { if (!cb) { return isVisible(elt, offset); } var remote = createRemote(elt, offset, cb); remote.watch(); return remote; } function createRemote(elt, offset, cb) { function watch() { watches.add(elt, offset, cb); } function dispose() { watches.remove(elt); } return { watch: watch, dispose: dispose }; } function watchInViewport(elt, offset, cb) { if (isVisible(elt, offset)) { watches.remove(elt); cb(elt); } } function isVisible(elt, offset) { if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) { return false; } // Check if the element is visible // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js if (!elt.offsetWidth || !elt.offsetHeight) { return false; } var eltRect = elt.getBoundingClientRect(); var viewport = {}; if (container === global.document.body) { viewport = { top: -offset, left: -offset, right: global.document.documentElement.clientWidth + offset, bottom: global.document.documentElement.clientHeight + offset }; } else { var containerRect = container.getBoundingClientRect(); viewport = { top: containerRect.top - offset, left: containerRect.left - offset, right: containerRect.right + offset, bottom: containerRect.bottom + offset }; } // The element must overlap with the visible part of the viewport var visible = ( (eltRect.right > viewport.left) && (eltRect.left < viewport.right) && (eltRect.bottom > viewport.top) && (eltRect.top < viewport.bottom) ); return visible; } return { container: container, isInViewport: isInViewport }; } function createWatches() { var watches = []; function add(elt, offset, cb) { if (!isWatched(elt)) { watches.push([elt, offset, cb]); } } function remove(elt) { var pos = indexOf(elt); if (pos !== -1) { watches.splice(pos, 1); } } function indexOf(elt) { for (var i = watches.length - 1; i >= 0; i--) { if (watches[i][0] === elt) { return i; } } return -1; } function isWatched(elt) { return indexOf(elt) !== -1; } function checkAll(cb) { return function() { for (var i = watches.length - 1; i >= 0; i--) { cb.apply(this, watches[i]); } }; } return { add: add, remove: remove, isWatched: isWatched, checkAll: checkAll }; } function observeDOM(watches, container, cb) { var observer = new MutationObserver(watch); var filter = Array.prototype.filter; var concat = Array.prototype.concat; observer.observe(container, { childList: true, subtree: true, // changes like style/width/height/display will be catched attributes: true }); function watch(mutations) { // some new DOM nodes where previously watched // we should check their positions if (mutations.some(knownNodes) === true) { setTimeout(cb, 0); } } function knownNodes(mutation) { var nodes = concat.call([], Array.prototype.slice.call(mutation.addedNodes), mutation.target ); return filter.call(nodes, watches.isWatched).length > 0; } } /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ } /******/ ]);"},{"title":"","date":"2017-05-05T12:07:38.000Z","updated":"2017-05-04T14:53:06.000Z","comments":true,"path":"photos/lazyload.min.js","permalink":"http://www.afanail.com/photos/lazyload.min.js","excerpt":"","text":"/*! * An jQuery | zepto plugin for lazy loading images. * author -> jieyou * see https://github.com/jieyou/lazyload * use some tuupola's code https://github.com/tuupola/jquery_lazyload (BSD) * use component's throttle https://github.com/component/throttle (MIT) */ !function(a){\"function\"==typeof define&&define.amd?define([\"jquery\"],a):a(window.jQuery||window.Zepto)}(function(a){function g(){}function h(a,b){var e;return e=b._$container==d?(\"innerHeight\"in c?c.innerHeight:d.height())+d.scrollTop():b._$container.offset().top+b._$container.height(),e=a.offset().top+b.threshold+a.height()}function k(b,e){var f;return f=e._$container==d?a.fn.scrollLeft?d.scrollLeft():c.pageXOffset:e._$container.offset().left,f>=b.offset().left+e.threshold+b.width()}function l(a,b){var c=0;a.each(function(d){function g(){f.trigger(\"_lazyload_appear\"),c=0}var f=a.eq(d);if(!(f.width()b.failure_limit)return!1}else g()})}function m(a){return a.filter(function(b){return!a.eq(b)._lazyload_loadStarted})}function n(a,b){function h(){f=0,g=+new Date,e=a.apply(c,d),c=null,d=null}var c,d,e,f,g=0;return function(){c=this,d=arguments;var a=new Date-g;return f||(a>=b?h():f=setTimeout(h,b-a)),e}}var f,c=window,d=a(c),e={threshold:0,failure_limit:0,event:\"scroll\",effect:\"show\",effect_params:null,container:c,data_attribute:\"original\",data_srcset_attribute:\"original-srcset\",skip_invisible:!0,appear:g,load:g,vertical_only:!1,check_appear_throttle_time:300,url_rewriter_fn:g,no_fake_img_loader:!1,placeholder_data_img:\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\",placeholder_real_img:\"http://ditu.baidu.cn/yyfm/lazyload/0.0.1/img/placeholder.png\"};f=function(){var a=Object.prototype.toString;return function(b){return a.call(b).replace(\"[object \",\"\").replace(\"]\",\"\")}}(),a.fn.hasOwnProperty(\"lazyload\")||(a.fn.lazyload=function(b){var i,j,k,h=this;return a.isPlainObject(b)||(b={}),a.each(e,function(g,h){var i=f(b[g]);-1!=a.inArray(g,[\"threshold\",\"failure_limit\",\"check_appear_throttle_time\"])?\"String\"==i?b[g]=parseInt(b[g],10):\"Number\"!=i&&(b[g]=h):\"container\"==g?(b._$container=b.hasOwnProperty(g)?b[g]==c||b[g]==document?d:a(b[g]):d,delete b.container):!e.hasOwnProperty(g)||b.hasOwnProperty(g)&&i==f(e[g])||(b[g]=h)}),i=\"scroll\"==b.event,k=0==b.check_appear_throttle_time?l:n(l,b.check_appear_throttle_time),j=i||\"scrollstart\"==b.event||\"scrollstop\"==b.event,h.each(function(c){var e=this,f=h.eq(c),i=f.attr(\"src\"),k=f.attr(\"data-\"+b.data_attribute),l=b.url_rewriter_fn==g?k:b.url_rewriter_fn.call(e,f,k),n=f.attr(\"data-\"+b.data_srcset_attribute),o=f.is(\"img\");return 1==f._lazyload_loadStarted||i==l?(f._lazyload_loadStarted=!0,h=m(h),void 0):(f._lazyload_loadStarted=!1,o&&!i&&f.one(\"error\",function(){f.attr(\"src\",b.placeholder_real_img)}).attr(\"src\",b.placeholder_data_img),f.one(\"_lazyload_appear\",function(){function i(){d&&f.hide(),o?(n&&f.attr(\"srcset\",n),l&&f.attr(\"src\",l)):f.css(\"background-image\",'url(\"'+l+'\")'),d&&f[b.effect].apply(f,c?b.effect_params:[]),h=m(h)}var d,c=a.isArray(b.effect_params);f._lazyload_loadStarted||(d=\"show\"!=b.effect&&a.fn[b.effect]&&(!b.effect_params||c&&0==b.effect_params.length),b.appear!=g&&b.appear.call(e,f,h.length,b),f._lazyload_loadStarted=!0,b.no_fake_img_loader||n?(b.load!=g&&f.one(\"load\",function(){b.load.call(e,f,h.length,b)}),i()):a(\"\").one(\"load\",function(){i(),b.load!=g&&b.load.call(e,f,h.length,b)}).attr(\"src\",l))}),j||f.on(b.event,function(){f._lazyload_loadStarted||f.trigger(\"_lazyload_appear\")}),void 0)}),j&&b._$container.on(b.event,function(){k(h,b)}),d.on(\"resize load\",function(){k(h,b)}),a(function(){k(h,b)}),this})});"},{"title":"tags","date":"2017-05-11T09:21:38.000Z","updated":"2017-05-11T09:21:38.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.afanail.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"my resume","slug":"my-resume","date":"2018-06-11T12:33:47.000Z","updated":"2018-06-11T12:38:20.473Z","comments":true,"path":"2018/06/11/my-resume/","link":"","permalink":"http://www.afanail.com/2018/06/11/my-resume/","excerpt":"","text":"郑敬发软件工程师河南科技大学/本科/自动化zjfapk@163.com15626495472广东广州项目经历一 项目名称： 航票一体化系统（中国航信广州航旅天空） PC端 项目简介： 服务商务旅游业，面向民航机票代理公司、旅行社等。以机票（机票查询预订、机票报表等）为主业务，酒店旅游等为辅业务的产品。技术上前后端没有分离，兼容IE7+浏览器。 [测试服务器]( http://58.67.199.150/ ) 账号: wangj 密码: edcwsxqaz 应用技术： 后端：主要以Perl+CGI为主，Java（新模块）为辅 数据库：Sybasee 前端：jQuery、HTML、CSS、JS、Ajax、XML等 工具：Editplus、VS Code、Conerstone(SVN)、PowerBuilder（Sybase）、Sybase central、FTP、Beyond Compare等 [Perl技术个人总结简介]（） 担任角色： 开发组副组长 工作内容： 主要负责维护开发Perl模块。设计发布新需求，代码重审。 负责系统前端代码重构升级以兼容更高级浏览器。 负责具体业务功能的开发。 负责对新同事进行技术培训。 收获： 掌握SQL事务，精通Perl，掌握Java，精通JS、CSS、HTML。 对前后端不分离的劣势与优势有了一定的了解。 能快速排查解决浏览器兼容性问题。 协助开发经理带领技术团队 二 项目名称： 菠萝贷（广州小迈科技） 移动端 项目简介： 快速贷款以及信用卡代还服务，个人用户贷款平台。 应用技术： 前端：node、webpack、React、Sass等 工具：WebStorm、VS Code、Git、PS、Fiddler、Postman、Chrome浏览器、Everything、Ditto等 [个人对整个前端项目技术总结简介](http://afanail.com/2018/01/11/React%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/#more) 担任角色： 前端开发工程师 工作内容： 开发React组件，封装冗余代码提取最小组件。 独立完成页面开发并精准还原设计稿。 负责与产品、UI和后端做良好的沟通，对产品能够提供持续的体验优化。 收获： 对前端性能、可访问性、可维护性有较深的理解。 对前端工程化和模块化有了进一步的理解,熟练掌握React。 熟悉前端调试及排错方法。 三 项目名称： 微航保（中国航信广州航旅天空） 移动端 项目简介： 线上航旅保险平台，为航空延误、航空意外等多个场景提供保险产品。 应用技术： 前端：node、gulp、artTemplate、hammer等 工具：WebStorm、VS Code、Git、PS、Fiddler、Postman、Chrome浏览器、Everything、Ditto等 [个人对整个前端项目技术总结简介](http://afanail.com/2018/06/11/%E5%BE%AE%E8%88%AA%E4%BF%9D%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/#more) 担任角色： 前端开发工程师 工作内容： 负责项目从零到一的开发，编写相关技术文档。 独立完成页面开发并精准还原设计稿。 负责与产品、UI和后端做良好的沟通，对产品能够提供持续的体验优化。 收获： 对前端性能、可访问性、可维护性有较深的理解。 对前端工程化和模块化有了进一步的理解,熟练掌握React。 熟悉前端调试及排错方法。 自我评价喜欢技术带来的成就感，热爱编程。 爱好特长写代码，打篮球。喜欢看书，喜欢看美剧，最近在看《Java编程思想》，重温《JavaScript权威指南》。","categories":[],"tags":[]},{"title":"Perl简介","slug":"Perl简介","date":"2018-04-11T12:00:00.000Z","updated":"2018-06-11T12:28:08.637Z","comments":true,"path":"2018/04/11/Perl简介/","link":"","permalink":"http://www.afanail.com/2018/04/11/Perl简介/","excerpt":"零、好习惯use diagnostics;输出详细的警告信息，不常用 可这样交换两个变量($a, $b) = ($b, $a) 使用 use bignum 保证数值运算不会丢失精度，此声明可在局部使用，不常用 Orcish Maneuver 标记 ||= 在判断数字0时有问题，多用unless defined... 例如$opt{i} ||= 1 这行命令，会在设置$opt{i}为0时，仍然设置$opt{i}为1，因为||操作符的原因 使用qq来标记字符串，用qw来标记字符串列表，避免将双引号转义 使用三个参数的open文件打开操作，更安全且允许文件名中出现空格 在同时有输入和输出的程序中，可在完成输入文件的操作后，进行unlink输出文件，再对输出文件进行操作，这样便能支持输入和输出为同一个文件的情况 $CR $LF $CRLF三个常量表示各个操作系统内的文件行分隔符 windows下最好不要安装perl在包含空格路径的目录下","text":"零、好习惯use diagnostics;输出详细的警告信息，不常用 可这样交换两个变量($a, $b) = ($b, $a) 使用 use bignum 保证数值运算不会丢失精度，此声明可在局部使用，不常用 Orcish Maneuver 标记 ||= 在判断数字0时有问题，多用unless defined... 例如$opt{i} ||= 1 这行命令，会在设置$opt{i}为0时，仍然设置$opt{i}为1，因为||操作符的原因 使用qq来标记字符串，用qw来标记字符串列表，避免将双引号转义 使用三个参数的open文件打开操作，更安全且允许文件名中出现空格 在同时有输入和输出的程序中，可在完成输入文件的操作后，进行unlink输出文件，再对输出文件进行操作，这样便能支持输入和输出为同一个文件的情况 $CR $LF $CRLF三个常量表示各个操作系统内的文件行分隔符 windows下最好不要安装perl在包含空格路径的目录下 一、备注\\b为退格键，在字符串中&quot;abc\\b&quot;会输出abc，实际上光标位置定位在b后面，但是&quot;abc\\bd&quot;会输出abd，因为退格了一次，用d替代了c。 index rindex 前向、后向搜索，提取字符串中指定的字符位置，也可以指定在字符串中查找的起始位置，基本可以代替循环匹配 substr放在赋值操作符左侧，可以将右侧的字符与substr所找到的字符进行替换，将右侧全部的字符串放入左侧指定的位置，替代选中的字符串 数字中插入下划线_表示分割 0b开头表示二进制 乘幂操作符** 单引号内\\n表示换行 字符串&apos;0&apos;是会被当成“假”值的唯一非空字符串 chomp 删除的是 $/, 可以使用 chomp @lines 删除多行中换行符 die 输出字符串结尾加上\\n即可不输出报错的文件名以及行号 使用select改变print 默认的文件句柄，可以控制错误输出地方 使用$^I = &quot;.bak&quot;来进行统一备份，使用不带参数的 &lt;&gt; unlink glob &quot;*.out&quot;; glob操作符展开具有通配符的文件名 可以使用sprintf将格式化的字符串输入到某个变量中去 &lt;=&gt; cmp 比较操作符，返回-1 0 1 $a&lt;=&gt;$b 按照增序排序 perl 安装模块，使用PREFIX=/*/参数来安装到自己指定的目录下 eval 设置$@为返回的错误信息，若eval代码块内有执行错误，则返回undefine或者空列表 perldoc -f ... 查看帮助 __DATA__结构内的数据，可由&lt;DATA&gt;句柄读入 BEGIN{} END{} 两个块内的内容无论在程序中出现的次序，总是最先，最后执行。而且若定义了函数，END里可以调用代码段里的函数，BEGIN不行，其是在编译文件其他部分之前就执行。 变量在双引号之间时，可以使用花括号将其包含，以区别变量名和一般字符串 使用&lt;&lt;来快速输入大量文本的方法叫做 here doc do语句块，返回的值为最后一个表达式的值，do-while也是do语句的一种特殊形式，可用do简化程序结构 模块的卸载，简单的删除所有的模块文件即可，可用perl -V 查看模块可能的位置 locate 可以用于查找 linux perl pm 位置， 即使该包不在 $PERL5LIB 中 while ($line=&lt;&gt;)隐含的使用了defined，实际上是在执行while(defined $line=&lt;&gt;) no strict &apos;refs&apos; perl 不会释放内存 即使 delete undef，perl 保留undef delete 的内存，用于减少后续可能的内存申请 crypt(key, init) 采用DES的加密算法，没有对应的解密算法，算法不安全，只能用来对用户密码进行基本的验证。 print &quot;FILE: &quot;, __FILE__, &quot; Line: &quot;, __LINE__, &quot;\\n&quot;; 输出文件名和行号 双触发开关..和...，会对符号两边的表达式求值. 在一个由条件式或者循环所构成的上下文中，一个flip-flop由两个通过..操作符相连的布尔表达式构成。除非其左侧表达式为true，否则一个flip-flop表达式就位false，而且在左侧表达式为true之前，它的值都会是false。一旦该表达式为true那么它就会“flips”到一个持久的true状态。它会保持该状态，而且对其后续的求值也返回true，直到其右侧的表达式为true为止。如果右侧表达式为 true了那么该flip-flop就会“flops”回一个持久的false状态，对其后续的求值也返回false，直到其左侧表达式再次成为true为止。 select(undef, undef, undef, 0.25) 可实现暂停0.25秒 split的第三个参数为正整数，可以限制切割的个数，为0或者没有指定时忽略最后的空字段，为负数时相当于不限制切割个数 行定向： # line 1000 将会把行定向为1000行 ?:操作符可为左值 二、加速keys (%hash) = 100; 预先为哈希分配个数，相比动态更改哈希大小，可以提高效率约15%，这是谬论! 避免在正则中使用 | 来判断多选，替代的可多次使用匹配 在量词后添加+避免使用回朔增加效率 用my而不用local，对特殊变量则只能使用local 循环中使用foreach，而不是for跟踪下标变化 删除哈希表，使用直接赋空值，而不是一个一个delete，虽然二者运行时间差距不大 ?:三元操作符的速度比if...else...要快一些 循环中重复用my声明变量不会对速度造成太大的影响 切分字符串，substr比split有绝对的速度优势 给子函数传递参数时，传引用速度快 使用子函数时，加不加&amp;符号对速度没什么太大影响 正则匹配中懒惰比贪婪省时间 正则匹配中，多余的定位符号，比如$^之类，会降低速度 正则中，使用o编译正则表达式，适用于匹配量不变的情况，预编译会拖慢速度，但是仅编译一次会及其微量地加速 三、列表、数组、哈希[]是操作符，会将里面的东西转成列表；()不是操作符，不能将里面的东西转成数组。 控制标量上下文 scale，prnit scale @a; 区分数组和列表，列表是若干个标量的集合，数组是陈放列表的容器。 将一个数组放在标量上下文中，获得的数组的元素个数；将列表放在标量上下文中赋值，赋的是最右边的元素。 标量上下文环境中的列表&quot;赋值&quot;操作，会返回赋值操作符右边元素的个数，注意这种用法：$a = () = split &quot;&quot;, $_; $a = $_ =~ {\\}g; 针对数组还有一种特殊的操作：切片slice 若@a是数组，则$#a表示数组最后一个元素的下标，其值加一是数组长度 合并两个哈希：%h3 = (%h1, %h2)效率最高 使用while(($key,$value) = each %HASH)替代原始的foreach循环，但是不能排序 while循环提供的是标量上下文，foreach循环里提供的是列表上下文 匿名数组：$a = [1..3] 返回的是数组的引用 匿名哈希：$a = {a=&gt;1} 返回的是哈希的引用 可以使用@HASH{a,b}同时访问一个哈希里的多个键值 指向匿名子程序的引用：$a = sub{...} splice 提取数组成分 $#a *= 0.9 快速修改数组大小 push，unshift 可以接收多于1个的参数 perl的哈希和python的字典，读入500M的文本时，占用的内容差不多也为500M 四、中文处理将中文转换成16进制字符：unpack(&quot;H*&quot;,$key)，转换回来：pack(&quot;H*&quot;,$key) 用以下方法使正则可以匹配中文，也就是PERL内部处理用UTF-8 use encoding &apos;utf8&apos;; 用以下方法避免输出时报wide character警 binmode OUT, &quot;:encoding(utf-8)&quot;; 用以下方法读取其他编码格式的输入 open HD,&quot;&lt;:encoding(GBK)&quot;,&quot;abc.txt&quot; or die $!; use encoding &quot;utf8&quot;, STDOUT =&gt; &apos;utf-8&apos;; decode encode函数 创建中文文件夹 my $name = &quot;你去吧&quot;; $name = encode(&quot;gbk&quot;, $name); mkdir $name or die; 匹配所有非汉字：\\p{Han} 匹配所有汉字： \\P{Han} 五、正则表达式正则匹配IP地址：\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5] \\Q \\E 把其中的非文字字符加上反斜线，正则匹配时可对变量进行扩展 正则匹配时，使用m{}符号，不用//，特别是在多行匹配中 x可添加注释，但是需要匹配的空白就要另行处理，比如用\\转义空格或者用\\s 断言: ?=expr ?&lt;=expr ?!expr ?&lt;!expr &lt;?&lt;=re&gt;.*&lt;?=ing&gt; 匹配reading时匹配到ad ?&lt;LABEL&gt;给匹配的括号添加标签，这样就可使用$+{LABEL}访问匹配的括号内的内容，不用去记忆匹配的标号顺序 ?:不记录括号的序数 (?#comment) 注释 断言的括号不占用$1 $2 $3的符号 匹配变量 /($var)/ 括号可要可不要 默认的.符号不匹配换行符，使用/s来使其匹配 \\Z 和 $ 类似，匹配串尾 \\L...\\E 小写化中间字符 \\U...\\E 大写化中间字符 \\G 断言离开之处，多在while(//g)中，继续匹配/g中匹配到的位置后面的信息 =~ m## 改变匹配符号 =~ m?? 在循环中，这种改变匹配符号的方式，只匹配第一次有效的结果，忽略后续的有效结果 @a = $b =~ //g 匹配后赋值给列表 s//.../e 可嵌入计算表达式在替换的内容中 /i /m /s /x 修饰词可以放在正则表达式的中间，像这样：/...(?i:s) (?&gt;)是非回溯子模式，其会加快某些模式的匹配失败，加快程序速度 (?:)是回溯子模式 /(??{})/ 匹配时的模式内插，可在{}内写入代码实现根据不同的情况进行匹配 /?(COND)IFture | IFfalse/ 条件内插，COND为一个整数时，其为反向引用的编号 像这样的匹配 if (/^(?:this|(you)).*(?(1)(special.)|(fun.))/) 反向引用的顺序是： 1 you 2 specila 3 fun 由于第一对括号内部有?:，故其不计入 且虽然用到了条件内插，其引用还是按照出现顺序来 my ($p1, $p2) = $tmp =~ /(\\S+)\\s*(\\S+)/; 六、守护进程(daemon)其一般为其他程序提供服务，运行时进入后台，直到被杀死或系统关闭，其应当做如下事情： 1、改变其工作目录为根目录 2、修改创建文件的掩码为一个已知值 3、规范PATH环境变量 可以使用POSIX模块提供的setsid()来创建。 七、信号Perl 提供了%SIG 这个特殊的默认HASH。调用需要使用到系统保留全局HASH数组%SIG，即使用&apos;$SIG{信号名}&apos;截取信号,相当于，在perl程序中出现这个信号时，执行我们自己定义某段代码(子函数)的地址值(定义信号响应函数)，这代码就是截取这个信息后要执行的结果了。 可直接使用如下方式处理由Ctrl+C产生的终端信号： $SIG{INT} = sub{...}; 信号名 值 标注 解释 HUP 1 A 检测到挂起 INT 2 A 来自键盘的中断 QUIT 3 A 来自键盘的停止 ILL 4 A 非法指令 ABRT 6 C 失败 FPE 8 C 浮点异常 KILL 9 AF 终端信号 USR1 10 A 用户定义的信号1 SEGV 11 C 非法内存访问 USR2 12 A 用户定义的信号2 PIPE 13 A 写往没有读取者的管道 ALRM 14 A 来自闹钟的定时器信号 TERM 15 A 终端信号 CHLD 17 B 子进程终止 CONT 18 E 如果被停止则继续 STOP 19 DF 停止进程 TSTP 20 D tty键入的停止命令 TTIN 21 D 对后台进程的tty输入 TTOU 22 D 对后台进程的tty输出 八、聊天工具RiveScript-1.20包可创建基于简单检索数据库的机器人对话程序，需要自己输入聊天内容作为数据，目前仅确定支持英文。 Chatbot-Eliza-1.04包是经典的心理医生程序，其巧妙的转换用户的输入获得输出，和用户进行交互性扯皮。 九、多进程使用fork函数产生子进程，其返回值大于0的为父进程，等于0的为子进程。 system函数也可产生新的进程，并等待其完成，并返回调用的地方。 exec函数用指定的命令进程替换当前进程，命令执行结束后，当前进程就结束。 子进程若没有恰当的收割，会产生僵尸进程。 一般配合CHLD信号执行收割子进程。 子进程的退出信号SIG-CHLD会唤醒休眠的父进程。 当Perl执行系统调用时，信号可能产生。大多数情况下，Perl自动重启并严密监控调用。 少数系统调用不适用此规则。 sleep() 就是其中之一，它根据指示数暂停脚本执行对应秒数。 如果一个信号中断 sleep()，比如ALARM，它将过早地结束，返回它完成休眠前的秒数。 sleep() 的这个属性很有用，因为它可以让脚本一直暂停，直到有预期的事件发生。 123456789POSIX = Portable Operating System Interfaceuse POSIX 'WNOHANG';$SIG&#123;CHLD&#125; = sub&#123; while((my $kid = waitpid(-1, WNOHANG)) &gt; 0) &#123; print \"reaped child...\\n\"; &#125;&#125;; 子进程退出时可以使用`exit 0`; 使用`pipe(READER, WRITER) or die;`创建双工管道实现父进程和子进程之间的通信。 十、多线程不建议在Perl5中使用多线程，但试一试后发现还行，能方便地进行数据共享，主要函数罗列如下： `asyn Thread-&gt;new();` 线程可进行join等待结束 或者进行detach放置不管 变量要share之后才能在线程间共享使用 匿名散列必须进行 `$hash{test} = &amp;share({});`才能共享使用，或者使用shared_clone的方法，如下： 123456789101112my $hash_ref = shared_clone( &#123; '100班' =&gt; &#123; '男' =&gt; [\"张三\",\"李四\", \"王五\"], '女' =&gt; ['A','B'] &#125;, '101班' =&gt; &#123; '男' =&gt; [\"张三\",\"李四\", \"王五\"], &#125;, ' 103班' =&gt; &#123; '男' =&gt; [\"张三\",\"李四\", \"王五\"], &#125;&#125;); 十一、套接字编程Perl内的套接字和C中的用法类似。 使用UNIX域的套接字，服务器程序使用举例： 123456789101112use IO::Handle;use Socket;socket(SOCK,AF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));my $addr=sockaddr_in(3000,INADDR_ANY);bind(SOCK,$addr);listen(SOCK,SOMAXCONN);while(1)&#123; next unless my $addr1=accept(S,SOCK); S-&gt;autoflush(1); # do something close S;&#125;; 客户端程序举例： 12345678910111213141516171819202122232425262728293031323334use Socket;use Encode;use IO::Handle;use strict;my $addr = \"\";my $buff = \"\";my $cont = 0;$addr = sockaddr_in(3000, inet_aton(\"127.0.0.1\"));while($buff ne \"welcome\")&#123; socket(SOCK, AF_INET, SOCK_STREAM, getprotobyname(\"tcp\")); connect(SOCK, $addr); SOCK-&gt;autoflush(1); sysread(SOCK, $buff, 40); chomp $buff; STDOUT-&gt;autoflush(1); if($buff ne \"welcome\") &#123; $cont++; sleep(1); &#125; if($cont == 3) &#123; die \"try 3 times and still cannot connect\\n\"; &#125;&#125;print \"$buff\\n\";# do somethingsend(SOCK, $in, 0);my $l = sysread(SOCK, $buff, 1000);close SOCK; 十二、默认变量$0 程序名称 $$ 当前程序的pid $&quot; 表格输出时的默认分隔符 $| 布尔量，输出缓存标识 $. &lt;&gt;读入一个文本时读入的行号 $/ 以&quot;一行&quot;为单位读入文本时判断&quot;一行&quot;的标记 $\\ 输出时的后缀 $] 当前perl的版本号 十三、管道当程序尝试写入到一个管道并且没有程序来读取这些数据，将返回一个PIPE异常。 可通过设置$SIG{PIPE} = sub { ... }; 来捕获和处理异常 读管道 open OUT,&quot;ls -hl|&quot;or die; 写管道 open OUT,&quot;|cat&quot;or die; 十四、变量类型my：申明词法变量，在作用域内使用有意义，脱离了作用域就不存在了。 our：这个是一个全局的声明。可以在任何作用域中进行访问和修改，当然修改之后其值也就相应的变化了。 local：改变软件包变量，这个声明比较有意思，他是一个动态作用域变量，在全局和局部都是可见的，当他在一个子块中被修改时 他便会被临时的修改 当他离开这个子块（作用域） 他的值便又恢复成原来的值了。这种变量类型属于Perl 4的历史遗留，尽量少用。 其实对于my和local，主要还是和typeglob有关系 对于一个perl中的变量，都有一个符号表与之对应 比如有 $perl = &apos;a&apos;; @perl = ...; %perl = ...; sub perl {}; open(perl,...); 看起来其为同名，不同类型的各种符号 但在perl中，他们都是存放在一个的符号表中的同一个表项中的,都是在名为perl的表项。 对于local操作，其实是在这个代码段前，先把此typeglob中的各个项的值保存，然后在进行对这些变量的操作和运算，这样的话在该代码段结束前，这些变量“看起来”好象没什么变化，等到该代码段结束了，local 的变量就会取出原来备份的值，在替换了现有的值。 my并没有用到typeglob和符号表，my是在每个代码段都建立一个特殊的地方来专门存储这些变量，而且my的变量中没有了typeglob的概念，也就是说my中的$a, @a都是按一定的顺序存放到一个内存区中的，不会出现 *b=*a 的情况了。而在代码段结束的时候，只要这些变量的引用记数为0，就释放这些变量。 加之my特有的某些技术，所以速度一般要比较快，所以在代码段中，除非特殊的情况，一般常用my来定义变量. 传递句柄不能用my。 十六、POD在pod中，用段类型可分为三种，普通段落，字面段落（Verbatim Paragraph）和命令段落。 使用POD注意，在两个主体之间要多空一行。 12345678910111213141516=head* 标题=over 缩进数目=item=back 项目列表，里面至少有一个item，且item只能在这里面=begin html&lt;hr&gt; &lt;img src=\"example.png\"&gt;&lt;p&gt; This is a raw HTML paragraph &lt;/p&gt;=end htmlbegin和end之间的代码在pod2html时会直接放成html的形式，而在转换成其他非html文档是会被忽略L&lt;...&gt; 添加链接I&lt;...&gt; 斜体B&lt;...&gt; 粗体 十七、format报表在有特殊对齐要求的方面有用 格式变量 $~ 中 ($FORMAT_NAME) 格式名字 $^ ($FORMAT_TOP_NAME) 当前的表头格式名字存储在 $% ($FORMAT_PAGE_NUMBER) 当前输出的页号 $= ($FORMAT_LINES_PER_PAGE) 每页中的行数 $| ($FORMAT_AUTOFLUSH) 是否自动刷新输出缓冲区存储 $^L ($FORMAT_FORMFEED) 在每一页(除了第一页)表头之前需要输出的字符串存储在 注:这些变量以文件句柄为基础设定，因此你需要 select 与特定格式关联的文件句柄来影响这些格式变量 调用输出 write 最后直接用write函数来显示格式化的文本内容. 多页报表 $% 当前输出的页面编号 $= 页中的行数 $- 还有多少剩下的行数 在使用输出时,最好建一个表的顶部输出.这样看起来会好看很多. 实例 123456789101112131415161718192021222324252627#!/usr/bin/perluse strict;use warnings;my ($name,$login,$office,$uid,$gid, $home);open FD,\"&lt;/etc/passwd\" or die \"$?\";while(&lt;FD&gt;)&#123; ($name,$login,$office,$uid,$gid, $home) = split (\":\",$_); $^ = 'STDOUT_TOP'; $~ = 'STDOUT'; $= = 39; write;&#125;format STDOUT_TOP =@&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"Page $%\" Passwd File Name Login Office Uid Gid Home ------------------------------------------------------------------.format STDOUT =@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @||||||| @&lt;&lt;&lt;&lt;&lt;&lt;@&gt;&gt;&gt;&gt; @&gt;&gt;&gt;&gt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;$name, $login, $office,$uid,$gid, $home1; 十八、perl 5.10 新特性use 5.010 后可在旧版的perl中运行新版本的特性 use autodie; 可在一般需要检查函数成功与否，比如open这样的函数中省去die的程序部分。 given-when 对应switch语句: 1234given($a)&#123; when(\"ab\") &#123;print \"here ab\";&#125; when(\"cd\") &#123;print \"here cd\";&#125;&#125; ~~ 智能匹配，可用数组，哈希进行匹配，用数组时使用的是数组的值，用哈希使用的是哈希的键。 自带的模块List::Util可对列表进行不同的处理，查找最大值，查找最长字符串，求和，查找第一次出现的值 正则匹配中，使用 \\h 表示水平空白字符，也即除了换行符以外的水平空白 \\v 表示垂直空白符 \\R 表示各个操作系统的行终止符 \\N 匹配非换行符，注意，其匹配的是不是\\n的所有字符哦 使用/p修饰符，是每次匹配的变量不再影响下一次使用时的速度，其匹配的结果保存在${^MATCH}中 可以串联文件测试符操作，如-r -w 串联后为-rw 十九、子程序在子程序中，使用wantarray 操作符，其会判断当前子程序运行在标量还是列表上下文，若是列表上下文，则返回1。通过这个操作符，可以实现动态返回值。 使用local * 对引用参量本地化，可避免大量使用$$或者@$符号 子程序中，直接修改@_变量会修改所传的参数值，当然，传递进常量时，就会报错。 一般的子程序没有像c那样的原型申明，但是可以自行添加原型申明以达到特殊效果。 比如pop函数实际使用的是数组的引用，但是在调用时可以不用传入类似\\@tmp 这样的参量。 匿名子程序，$name = sub {} 变量有7种类型，其中一种CODE即为保存子程序所用，用这种形式，可以实现动态子程序选择的功能 访问匿名子程序时，$name-&gt;(传递的参数) 给子函数传递哈希，显试表达参数，且与参数顺序无关，还可使用无参数的方式。 123456power(base=&gt;12, power=&gt;2);sub power &#123;my %args = @_;my $base = $args&#123;base&#125; || 2;...&#125; 二十、文件操作-s 获得文件的大小 二十一、引用ref 操作符可获得引用的类别，常见的有：`SCALAR ARRAY HASH CODE GLOB Regexp` 常见的复合数据结构都是通过引用实现的 子程序的引用 `$code_ref = \\&amp;code_name` typeglobs的引用 `$a = \\*STDOUT` 二十二、实用模块Inline 库在perl中嵌入c函数，可加快算数运算速度，效果明显 LWP::Simple用来抓取网页，其稳定性好于wget，但是安装较为麻烦 XML::Parser解析XML格式 Math::Round包含各种对小数的近似处理 Log4Perl很方便的日志模块 benchmark测试程序速度，`use Benchmark` Regexp::Common利用现成的正则表达式解决实际问题，不用重复发明车轮 Expect Linux下命令交互，方便自动处理 Date::Manip 方便的时间处理，计算将来时间 Time::HiRes 处理毫秒级别的时间 XML::Rss 产生或解析RSS IO::Socket 创建TCP服务器或客户端 Text::Abbrev 创建散列，并添加快捷的检索标志，用户交互时有用 GD 绘制点阵图 SVG 绘制矢量图 Tk GUI编程 Lingua::Han::PinYin 汉字转换成拼音的有意思的模块 Win32::GUI windows下创建GUI Win32::Clipboard 操作剪贴板 Thread 线程 Thread::Queue 现成可用的队列 use Regexp::Common::net 匹配IP地址的正则表达式，/$RE{net}{IPv4}/ Carp 报错时添加调用的函数名称 PDL perl的科学计算模块，类似MATLAB，也可以画图，自称比MATLAB快 Text::CSV_XS 强大的逐行分割文件的模块 Getopt::Std 处理程序输入参数 二十三、数据库数据库占位符不能使用在数据表名上 与MySQL连接：安装MySQL的客户端和服务器端(client&amp;server)，安装其工具套件(devel)和共享库(shared)，然后安装DBD和DBI的perl包 二十四、typeglob*bar{PACKAGE} %name:: 为包含name包的所有变量的哈希表 *a = *b 类似别名的赋值 绑定变量tie 以OO的形式绑定一个变量，使用户可以自定义添加任何行为。被绑定的变量可以使标量，数组，哈希和文件句柄 二十五、require use dorequire：加引号用于代码块，不加引号用于模块 use：只用于模块 do：必须加引号，可用于代码块和模块 1 use引入的名称不需要后缀名,而require需要 2 use语句是编译时引入的，require是运行时引入的 3 use引入模块的同时，也引入了模块的子模块。而require则不能引入，要在重新声明 二十六、CPAN以下地址是在windows下[CPAN在教育网的升级地址](ftp://openware.byr.edu.cn/pub/mirror/CPAN/) 以下方法移除默认的CPAN镜像 o conf urllist unshift http://www.perl.com/CPAN/ o conf commit 或者修改 /etc/perl/CPAN/Config.pm 也行 以下方法重新配置CPAN o conf init 二十七、map，grepmap{}里面，用逗号间隔的数据将被当作列表传递，比如 @a = (1,2,3); @b = (4,5,6); @c = map {$a[$_], $b[$_]} 0..2; 将会生成142536这样间隔的数组。 如果将逗号变成分号，则会产生456这个数组 施瓦兹排序：结合map，sort，map和匿名数组，将需要比较的数值记录在数组中，减少计算，加速排序。 @sorted_name = map {$_-&gt;[0] };# 取出原本的filename sort { $a-&gt;[1] &lt;=&gt; $b-&gt;[1] };#--依照modified_time去比大小 map { [$_, -M] }; #--[filename, modified_time] @files; #----輸入的所有filename 以a中元素为key，1为值生成哈希表 %h = map {$_, 1} @a; 解析CGI传入参数 use CGI qw(param); %params = map { $_, ( param($_) )[0] } grep { lc($_) ne &apos;submit&apos; } param(); 产生随机密码 @a = (0 .. 9, &apos;a&apos; .. &apos;z&apos;); $password = join &apos;&apos;, map { $a[int rand @a] } 0 .. 7; 转置矩阵 123456789101112@matrix = ( [1, 2, 3], [4, 5, 6], [7, 8, 9] );foreach $xyz (@matrix) &#123; print \"$xyz-&gt;;[0] $xyz-&gt;;[1] $xyz-&gt;;[2]\\n\";&#125;@transposed = map &#123; $x = $_; [ map &#123; $matrix[$_][$x] &#125; 0 .. $#matrix ]; &#125; 0 .. $#&#123;$matrix[0]&#125;;print \"\\n\";foreach $xyz (@transposed) &#123; print \"$xyz-&gt;;[0] $xyz-&gt;;[1] $xyz-&gt;;[2]\\n\";&#125; 二十八、pack unpack使用unpack分割制定列宽的数据 二十九、嵌入其他语言三十、单行perl-n 自动以单行的形式读取文件 -p 自动在最后打印$_内容 -e 执行单行perl -a 自动切分到数组@F中 三十一、测试性能使用 perl -d:DProf a.pl 运行程序的同时产生分析文件tmon.out 再使用DProfpp tmon.out 分析程序内函数的调用次数和占有时间","categories":[],"tags":[]},{"title":"微航保技术简介","slug":"微航保技术简介","date":"2018-03-11T12:20:43.000Z","updated":"2018-06-11T12:28:08.643Z","comments":true,"path":"2018/03/11/微航保技术简介/","link":"","permalink":"http://www.afanail.com/2018/03/11/微航保技术简介/","excerpt":"项目结构在项目tmt-workflow的基础上进行修改开发，但是比其简单的多,项目布局如下：","text":"项目结构在项目tmt-workflow的基础上进行修改开发，但是比其简单的多,项目布局如下： .wehb(微航保)├── .idea(.vscode) // 编辑器配置文件(可忽略)├── bower_components // bower依赖下载目录│ ├── angular // angular前端框架│ ├── artTemplate // 腾讯模板引擎│ ├── hammer // 移动手势插件等│ ├── fastClick // fastClick│ ├── Swiper // 轮播图插件等│ ├── ……… // ………├── build // 本地浏览器运行资源目录│ ├── css // css样式│ ├── image // 图片目录│ ├── js // js脚本目录│ ├── view // 页面组件模板│ ├── vendor //等同于bower_components│ ├── index.html // 主界面│ ├── /.html // 其它主界面├── dist // 等同于build（发布上线目录，经各种代码优化）├── node_modules // npm 依赖│ ├── gulp // gulp│ ├── gulp // gulp│ ├── gulp-less // gulp-less│ ├── ……… // ………│ ├── ……… // ………│ ├── ……… // ………├── src // 源码目录│ ├── image // 图片│ │ ├── funicom // 精灵图│ │ ├── index // 对应各主页图片│ │ ├── ……… // ………│ ├── js // 脚本│ │ ├── env.js // 环境切换配置│ │ ├── fetch.js // 获取数据│ │ ├── mUtils.js // 常用的js方法│ │ └── rem.js // px转换rem│ ├── less // less│ │ ├── mixin.less // css常用函数│ │ ├── base.less // css常用样式│ │ ├── property.less // css自定义属性│ │ └── var.less // css自定义变量│ │ └── index // 对应各主界面样式│ │ └── ……… // ………│ │ └── ……… // ………│ ├── view // 可复用页面组件│ │ ├── banner .html // 可复用banner组件│ │ ├── proList.html // 子页面│ │ └── ……… // ………│ │ └── ……… // ………│ ├── index.html // 主界面│ ├── /.html // 其他界面├── .babelrc // babel配置文件├── .babelrc // eslint配置文件.gitignore├── . gitignore // 上传到git服务器忽略文件├── bower.json // bower配置文件├── gulpfile.js // 项目最核心文件├── package.json // npm配置文件(次核心)├── postcss.config.js // css自动前缀配置文件至此，整个项目布局一览无余。运行此项目前提是计算机安装了nvm、node、npm以及gulp。最核心文件gulp和次核心文件package.json其实都是有关于前端开发环境。以gulp.js其中抽取的部分核心代码为例子：1234567891011121314151617181920212223242526;(function () &#123; // 加载gulp等插件 var gulp = require('gulp'); // 定义项目路径 var app = &#123; srcPath: 'src/', &#125;; //定制gulp任务 gulp.task('js', function() &#123; .pipe($.plumber()) .pipe($.uglify()) .pipe($.connect.reload()); &#125;); gulp.task('serve', ['js',…rest], function() &#123; $.connect.server(&#123; root: [app.devPath], livereload: true, port: 3000 &#125;); open('http://localhost:3000'); gulp.watch(app.srcPath + 'script/**/*.js', ['js']); &#125;); // 执行gulp默认命令 gulp.task('default', ['serve']);&#125;)(); 简单分析：以node为代理服务器通过gulp工具让前端开发模拟线上环境开发。优点是css自动填充兼容性前缀，本地热更新，提升开发效率等。缺点是不易上手。前端开发环境定制性高，各种环境配置确实是比较折腾。","categories":[],"tags":[]},{"title":"Java","slug":"Java","date":"2018-02-26T13:30:21.000Z","updated":"2018-02-26T13:40:48.905Z","comments":true,"path":"2018/02/26/Java/","link":"","permalink":"http://www.afanail.com/2018/02/26/Java/","excerpt":"","text":"要想创建一个接口，需要使用interface关键字来替代Class关键字。就像类一样，可以在interface关键字前面添加public关键字，如果不添加此关键字，则它只具有包访问权限，这样它只能在同一个包内可用。接口也可以包含域，但是这些域隐式的是static和final。要让一个类遵循某个特定的接口（或者一组接口），需要使用implements关键字，它表示：interface只是它的外貌，但是我现在要声明它是如何工作的。一旦实现了某个接口，其实现就变成了一个普通的目标，就可以按照常规的方式扩展它。接口中的方法是public的。","categories":[],"tags":[{"name":"-- Thinking in Java","slug":"Thinking-in-Java","permalink":"http://www.afanail.com/tags/Thinking-in-Java/"}]},{"title":"书单","slug":"lookbook","date":"2018-01-25T11:02:44.000Z","updated":"2018-01-25T11:02:55.058Z","comments":true,"path":"2018/01/25/lookbook/","link":"","permalink":"http://www.afanail.com/2018/01/25/lookbook/","excerpt":"以下是对一些读过的书和一些买后随便翻了翻的书的个人感觉。 都是java web开发的程序员可能接触的书，其他的如设计/手机开发/其他语言的书就不写了，因为自己只做过java web开发，那些书没什么资格评判。 因为不是每本书都翻开确定一下再写的，可能有张冠李戴或记忆错误的情况，如发现了请指正。 如有好书我这里没列举到的，请补充。此书单将持续完善。","text":"以下是对一些读过的书和一些买后随便翻了翻的书的个人感觉。 都是java web开发的程序员可能接触的书，其他的如设计/手机开发/其他语言的书就不写了，因为自己只做过java web开发，那些书没什么资格评判。 因为不是每本书都翻开确定一下再写的，可能有张冠李戴或记忆错误的情况，如发现了请指正。 如有好书我这里没列举到的，请补充。此书单将持续完善。 js书籍： 《Javascript权威指南》犀牛书 厚，唯一的顶尖著作，上册的每个章节都将一个知识点深入挖掘讲透，必看。下册API无关紧要。 《Javascript高级程序设计》 厚，与犀牛书有很大重叠，但感觉各个方面都不如犀牛书。可以看犀牛书之后随便翻翻这本书，有的地方可做补充。 《Javascript精粹》蝴蝶书 薄，让人喜欢javascript的一本书。 《Javascript DOM编程艺术》 薄，最佳入门书没有之一，对新手来说，前两本太厚让人望而生畏心生恐惧，这本书是优选，豆瓣评分高达8.7。 css书籍： 首先入门还是w3school的教程。大部分作为非美工的程序员就够用了。 看过几本不错的书但忘了名字，待补充。 《精通CSS高级WEB标准解决方案》 《CSS设计指南》 入门之后可以用来提高。 《CSS禅意花园》 非新手向，更适合已经熟悉之后寻找灵感和……欣赏艺术。 html的书籍： ……w3school的教程足够了，讲js和css的书里都会讲。 前端性能： 《构建高性能web站点》 《高性能网站建设指南》 类似的两本薄书，都看过之后会觉得自己无敌了，不想看书YSlow的军规其实也够了，重要的是要知其所以然。 rest: 《REST实战》 厚书，没看呢，老外的很多理论书籍过于想当然和自我神化，不接地气让人不喜，讲到后面敏捷的地方还会议论。 《图解HTTP》 倒是http协议的理解至关重要，有语义的东西不用白不用，method啦，状态码啦，但不要宗教般地抠，比如put和post谁增谁改啥的。 这本书萌萌哒。 前端框架： 《锋利的jquery》 其实就是jqueryAPI的加强版，觉得jqueryAPI足够的话就不用看这本了。 《jquery技术内幕》 与《struts2技术内幕》《spring技术内幕》一系列的好书，讲源码的。这三本书都值得一看。但注意“源码无用论”和“源码神圣论”都不可取。 《深入浅出extjs》 可能是extjs唯一的一本可读的书。非常不喜欢这个框架的思想。html和css都丧失了权力一切由它来托管了，未免权力欲过于旺盛。 真正要用ext的话，官方demo和api是最好的选择，尤其是demo。 《用AngularJS开发下一代web应用》 《单页web应用 Javascript从前端到后端》 《Backbone.js实战》 mv*框架大热以来较热的几个框架，对这几个框架都只有摸索，感觉angularJs风险略大，有点像extjs的想当然，一切都要在它内部来，如果能解决当然省时省力，如果不能解决就糟了。但问题是千变万化的。backbone较轻量，功能弱，风险低，功能弱与风险低从来都是共同出现。 另外还有requireJs，也应该研究研究，这些前端架构级框架都不熟。本能地觉得不切实际，但还是该研究研究再下结论。 传统开发中使用的前端技术，毫无疑问jquery是枪王之王。 《Bootstrap用户手册》 《深入理解Bootstrap》 前者超薄，完全不需要，看Bootstrap官网即可（版本更新时中文官网可能跟最新版本对不上，推荐英文官网）。后者是好书，讲应用也讲源码。 基于Bootstrap的前端CSS框架Metronic超酷，页面常用的组件里面都有，其实就是个最佳实践的大整合大杂烩，里面没有的自己找Bootstrap插件就好。 Bootstrap的伟大在于作为一个脚手架，给各种js组件提供平台，只要都是bootstrap版的插件，整合起来样式一致性一般没什么问题。 java基础书籍： 《scjp考试指南》 无数次被人求推荐书籍，无数次说出这本书之后被鄙视：“我不是为了考证”。但这本书真不是只能用来考证。 对j2se的讲解，既简约又精当，知识足够，又不会把人吓走的书，当然是入门的不二之选。 《Thinking in Java》 java界的顶级图书，每个章节都深入讲一个点，可以通读一遍，然后按需再翻具体章节强化。跟《Javascript权威指南》读法是一样的。 但初学者不适合读这本书，已经无数人说过了。但从别的语言转java的人可以直接读这本书。 《Core Java》 评价很高，个人不喜欢，就像《Javascript高级程序设计》被《Javascript权威指南》全面压制一样，《Core Java》也活在《Thinking in Java》的阴影之下。 《Java解惑》 好玩的书，让你喜欢“有趣的”java。 《深入理解Java虚拟机》 《深入java虚拟机》 知其然又知其所以然，java虚拟机的内部原理，理解了没坏处。 《Effective Java》 最喜欢的书之一，箴言式的规谏，作者的经验之谈，告诉你怎样写出优雅的代码。 java web基础书籍： 《scwcd考试指南》 《Head First JSP & Servlet》 《scwcd考试指南》与《scjp考试指南》一系列，但质量不高。相比之下scwcd的官方推荐教材《Head First JSP & Servlet》（该系列中文版都译为深入浅出xxx）更好。 这两本书都是将jsp的标签讲的很透，但如果使用jstl和el，两本书讲的都稍嫌不足，需要另查资料。 java性能书籍： 《java程序性能优化》 《java性能优化权威指南》 《web性能测试实战》 《零成本实现web性能测试——基于Apache Jmeter》 《Java并发编程实战》 经验型书籍，没什么好说。 因为我也就是粗粗看过。但知道都是好书。 java框架书籍： 《struts2技术内幕》 《spring技术内幕》 《Spring3.x企业应用开发实战》 都来自iteye博主的手笔，第1本和第3本尤为推荐。《strut2技术内幕》的哲学思辨之美让我惊为天人，《Spring3.x企业应用开发实战》的实用和接地气也让人爱不释手，国内的程序员高手写的书比起国外的官方/经典著作，更适合中国人阅读。不要崇洋媚外。当然想看第一手资料那还是国外的好。 《Hibernate实战》 Hibernate作者Gavin King的作品，够权威吧。但个人也不喜欢Hibernate，这么多年都没能用纯熟，类似对Extjs的不喜欢一样，前者尝试解决O/R的不匹配，后者尝试解决O/DOM的不匹配，一切以OO为目标，强力扭转乾坤，这属于逆天行事，当然做的都很出色。但感觉像逆练《九阴真经》练出绝世武功，走错的路，居然成绩斐然，让人赞叹你的强大，但不是说你成绩斐然就不是错而是对了。 Mybatis的好书籍没发现过，而且已经有中文文档了。 《深入浅出Hibernate》 《spring2.0技术手册》 两本经典的好书，有一点点古老了，前者用来Hibernate入门的话还是不二之选，另外满江红的中文文档都非常棒。 至于java的优秀类库基本都是开源的，到官网找demo/文档/API足矣。类库一般较小较轻，英文文档硬看也能看下来。框架较重，中文讲原理的书看了提纲挈领，否则容易陷入迷雾不能自拔。 类库和框架的区别是什么？答：控制反转。 至于一些java技术就不赘述了，SpringSide本身就是个大目录，沿着它给打开的窗户们一样样探究吧。 设计模式书籍： 《Head First设计模式》 《设计模式之禅》 《java与模式》 《设计模式java中的应用》 …… 设计模式的书没有特别好的也没有特别糟的，不同作者其实也没有什么发挥的余地，都是讲那些东西，所以都很像。 设计模式的要点是通读，都理解了，在脑海中留存，以后写程序适当的时候设计模式自然会蹦出来。 个人感觉最好用的，工厂单例原型迭代这些最简单的不说了，门面调停者这些偏架构的也不说了，最好用的是：适配器，策略，模板，另外组合、访问者、装饰器等各有各的用。桥接一直没有很好的理解。享元轻易用不上。代理spring的aop几近完美不用自己玩。解释器用的机会也不多。别的看情况使用。 《反模式》 介绍的是一些理论上不合理、但非常普及、能解决某些问题的“反模式”。 把“反模式”一锤子打死也不对，但不是非用不可的情况还是轻易不要用。 架构思想书籍： 《企业应用架构模式》 Martin Fowler的不朽著作，也是其人最好的一本书，十几年前的书，牛到了其中的种种思想，现在看来都是理所当然了，可见其影响力和普及程度。 《Expert One-on-One J2EE Development without EJB》 《J2EE设计开发编程指南》 java界的巨人，Spring作者Rod Johnson的封王之作，这两本书同时期出现的spring彻底改变了java世界的格局，用老爵爷的语气说，将他妈的EJB从王座上拉了下来。 “水，善利万物而不争，处众人之所恶，故几于道。”——《道德经》中的这句话，个人感觉可以用来赞颂Spring的伟大。 唯一的顶级框架，java界的万王之王。 个人非常崇拜的SpringSide正是以Spring为核心，提供的最佳实践的展示。功德无量。 《J2EE核心模式》 更早的书了，有空可以读读，不是特别必要。 《大型网站技术架构》 《软件架构设计》 国人的书籍，讲的是“架构”而不是“框架”了，前一本强烈推荐，淘宝系的书籍都很不错。 数据库书籍： 数据库的思想，行列含义，各种范式什么的，好理解。 oracle,mysql,sql server...等主流数据库，书籍都太多了，而且没有特别出彩的（怎么出彩？）或者特别差劲的，随意挑选就可以。不买书网上查资料其实也没问题。 当然这指的是开发人员使用的数据库技术，更深的DBA技术我不了解，如果以后接触到再补充。 《Sql反模式》 为领域建模之后，画E-R图，然后建表，是自然而然的事，不需要书籍。 反模式的议论见上文，SQL中也有一些反模式，这本书做了介绍。 编程基础书籍： 《java数据结构和算法》等数据结构、算法书籍 《编译原理》 《算法导论》 《计算机程序的构造和解释》 《编程珠玑》 《代码大全》 等等…… 不用一本本说了，基础的东西几十年也不会过时，认真读了受用无穷。 可惜太过深入，书太厚，节奏太快，一直没能细读，有时间读书也读更“高层”的书去了，太可惜了。 网络安全书籍： 《白帽子讲web安全》 《Web前端黑客技术揭秘》 中国人写的安全书籍，做网站的必看，尤其是仇恨值高的。 软件工程类： 《人月神话》 70年代出的书到现在依然畅销，永垂不朽的名作，程序员必读。 《构建之法》 接地气的著作，软件开发的全景图，不是高高在上的指导，而是娓娓道来手把手来教。 《敏捷软件开发 原则，模式与实践》 个人看过的敏捷类书籍中相对不错的。个人认为敏捷开发宣言背下来，敏捷的价值观记下来，按实际情况灵活运用就是了。有些敏捷爱好者的宗教式狂热特别吓人，简直走火入魔，不可取。 《高效程序员的45个习惯：敏捷开发修炼之道》 这45个习惯，无论敏捷与否，都是应该具备的，应该说是“优雅的”“职业的”行为。 很明显，有些公司的工作不“敏捷”，但不代表程序员不能从这本书中受益。 《代码整洁之道》 《重构——改善既有代码的设计》 职业程序员有义务写好自己的代码，写给接手代码的人，更是写给半年后的自己。 最基本的职业道德，不需要多说。","categories":[],"tags":[{"name":"-- 书单","slug":"书单","permalink":"http://www.afanail.com/tags/书单/"}]},{"title":"React项目总结","slug":"React项目总结","date":"2018-01-10T16:14:05.000Z","updated":"2018-06-10T16:22:58.931Z","comments":true,"path":"2018/01/11/React项目总结/","link":"","permalink":"http://www.afanail.com/2018/01/11/React项目总结/","excerpt":"安装node官网地址:https://nodejs.org/en/ 注:mac自由安装windows建议下载6.x(7.x版本有可能会出现node-sass不兼容的情况)远程服务器(ubuntu)可使用git命令下载(省去上传这一步) sudo git clone https://github.com/nodejs/node.git sudo chmod -R 755 node cd node sudo ./configure sudo make sudo make install","text":"安装node官网地址:https://nodejs.org/en/ 注:mac自由安装windows建议下载6.x(7.x版本有可能会出现node-sass不兼容的情况)远程服务器(ubuntu)可使用git命令下载(省去上传这一步) sudo git clone https://github.com/nodejs/node.git sudo chmod -R 755 node cd node sudo ./configure sudo make sudo make install node版本管理可使用n或nvm(参考http://taobaofed.org/blog/2015/11/17/nvm-or-n/)感觉n的体验比nvm好,切换后各种编辑器,IDE不需要修改node地址 npm代理参考http://note.youdao.com/noteshare?id=b32c531a012cce6e03712fe5e32b5dc0并确认已使用私有仓库 项目初始化(以webstorm为例)项目check下来后执行npm install项目导入到webstorm后如果识别”import”等语法出错,preferences设置选择jsx 启动配置 标注1说明:使用babel-node而不是node的原因是本地不需要打包node的服务端模块,babel-node可运行”import”等node暂不支持的语法mac可选择node_modules/babel-cli/bin/下的babel-node.jswindows请选择node_modules/.bin/下的babel-node.cmd标注2说明如图: 环境变量说明(环境变量都可以通过process.env.XXX获取,想要知道环境变量哪里使用过也可以这样去查找): NODE_ENV—–express默认需要的运行模式参数,可选development/production PORT———-监听端口 SERV_ENV—–服务器环境,可选test/official IS_LOCAL——是否本地启动 VNAME——–webpack打包的view name VDEPLOY——webpack打包时是否为部署(压缩)模式 VCLEAN——-webpack打包时是否清理文件夹 VEXTRACT—–webpack打包时是否提取样式文件 本地启动 控制台分两段输出第一段 1&#123; NODE_ENV: &apos;development&apos;, IS_LOCAL: &apos;1&apos;, SERV_ENV: &apos;test&apos; &#125; 最后输出 1webpack: Compiled successfully. 启动成功! app(服务端)部分代码解释app.js1import babelRegister from &apos;babel-register&apos;; 服务端渲染时识别”import”等语法 12345678//匹配服务端渲染不需要读取的文件const extensions = [&apos;.css&apos;, &apos;.less&apos;, &apos;.scss&apos;, &apos;sass&apos;, &apos;jpg&apos;, &apos;png&apos;], app = express();for (let item of extensions) &#123; require.extensions[item] = () =&gt; &#123; return false; &#125;;&#125; 服务端渲染时对react组件中引用的上述格式的文件忽略, 如果有其他需要忽略的格式出现,请在此处添加 controllers/interface目录对访问地址上的参数service,appid,funid做处理 controllers/request/base/request_base.js12345678910111213execute(config) &#123; let serverRequest = new ServerRequest(this.nodeRequest); if (config) &#123; serverRequest.recreatePostData(config.sendData); serverRequest.funid = config.funId; serverRequest.finish = config.finish; if (config.service) &#123; serverRequest.service = config.service; &#125; &#125; this.doRequest(serverRequest);&#125; node转发请求到tomcat的通用实现流程,如果有特殊需求,可基于RequestBase类扩展 controllers/template_helper目录旧的纯粹使用art-template的模板方法,用react做服务端渲染的请无视这个文件夹 views(视图层)部分代码解释cfg文件夹 结构与其他项目webpack配置结构一样,同样是在location新增/修改页面入口 node-env模块获取参数对应本文档上述的”环境变量说明” 配合webpack.config实现了react热更新 common/footer.html withPlatformFunctions这个参数对应链接上的wpf,指定是否下发jsbridge代码,如果项目在app内打开不需要jsbridge或者是外部(比如微信)打开,这个时候可以指定链接上的wpf参数为0(不下发),默认下发. common/components写本文档的时候只写了两个顶层公共组件Toast和Loading(以Toast组件为例作简要使用说明) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import &apos;./styles/toast.scss&apos;;import React from &apos;react&apos;;import storeActions from &apos;../modules/store-actions&apos;;let toastTimeout = null;/** * 渲染Toast */export default class Toast extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; show: 0 &#125; &#125; toast = (toastText, toastState = 1) =&gt; &#123; //立即隐藏toast if(toastState !== 1) &#123; toastTimeout &amp;&amp; window.clearTimeout(toastTimeout); this.setState(&#123; show: 0 &#125;); return; &#125; if(!toastText) &#123; return; &#125; this.setState(&#123; toastText: toastText, show: 1 &#125;); //如果toast状态为展示中,清除倒计时并重新执行 toastTimeout &amp;&amp; window.clearTimeout(toastTimeout); toastTimeout = setTimeout(() =&gt; &#123; this.setState(&#123; show: 0 &#125;); &#125;, 3000); &#125; componentDidMount() &#123; storeActions.toast.add(this.toast); &#125; render() &#123; return ( &lt;div className=&#123;`toast_container$&#123;this.state.show === 1 ? &apos;&apos; : &apos; setnone&apos;&#125;`&#125;&gt; &lt;div className=&quot;toast_tips&quot;&gt;&#123;this.state.toastText&#125;&lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 结合storeActions模块 123456789101112import signals from &apos;signals&apos;;/** * 全局事件系统 */const Signal = signals.Signal;const storeActions = &#123; toast: new Signal(), loading: new Signal(), overlay: new Signal()&#125;;export default storeActions; Toast组件使用方法: 在程序的适当位置引入(譬如App) 123456import Toast from &apos;./**/common/components/toast&apos;;......render() &#123; ...... &lt;Toast /&gt;&#125; 在需要使用toast的模块/组件内引入storeActions123import storeActions from &apos;./**/common/modules/store-actions&apos;;......storeActions.toast.dispatch(&apos;hello&apos;); 注:当程序需要实现一些跨组件通信的需求的时候,可参考实现.(有调研过Redux,觉得暂时对于我们的应用还不是很必要,会增加程序复杂度) projectXXX/index.jsx1234567891011121314151617ReactDOM.render( &lt;AppContainer&gt; &lt;App data=&#123;initialState&#125;/&gt; &lt;/AppContainer&gt;, document.getElementById(&apos;react-html-container&apos;));if (module.hot) &#123; module.hot.accept(&apos;./components/app&apos;, () =&gt; &#123; require(&apos;./components/app&apos;); ReactDOM.render( &lt;AppContainer&gt; &lt;App data=&#123;initialState&#125;/&gt; &lt;/AppContainer&gt;, document.getElementById(&apos;react-html-container&apos;) ); &#125;);&#125; 实现热更新修改components/app下的无论是同步import还是异步require.ensure的模块,浏览器会在不刷新页面的前提下实现更新(由于样式文件被提取后热更新会失败,开发时统一设置不提取,即本文档提到的VEXTRACT环境变量) 无论服务端还是客户端渲染,顶层组件(App)都带有一个data的props 为了方便,在模块App中将其放置到一个可供其他模块访问的对象中 12345//把静态数据写到storeStaticsObject.assign(storeStatics, &#123; phead: props.data.phead, browser: props.data.browser&#125;); 特别说明一下browser对象下面的isapp元素,它的值是从链接上获取的,当我们在服务端渲染UI需要判断是否在app内的时候就可以用它去判断.为了避免误会,如果链接上不带isapp这个参数,browser对象中的isapp为undefined http(s)切换为了frontend_service使用不同协议都能正常访问,服务层requestBase类会使用不同的协议向tomcat发送请求,而在view层中,写页面时则需要对资源访问地址做一些处理 对服务器下发的外链资源,统一接入utils.getFormatImg方法处理 12345678910111213141516171819202122getFormatImg(src, param = &apos;0&apos;) &#123; const browser = storeStatics.browser; if (!src || typeof src !== &apos;string&apos;) &#123; return &apos;&apos;; &#125; //远程服务器图片删除protocol if (src.indexOf(&apos;https://&apos;) === 0) &#123; src = src.slice(6, src.length); &#125; else if (src.indexOf(&apos;http://&apos;) === 0) &#123; src = src.slice(5, src.length); &#125; if (!src.includes(&apos;imageView2&apos;) &amp;&amp; !src.includes(&apos;.gif&apos;)) &#123; if (browser.isSupportWebp) &#123; src += &apos;?imageView2/&apos; + param + &apos;/format/webp&apos;; &#125; else if (src.includes(&apos;.png&apos;) || src.includes(&apos;.tmp&apos;)) &#123; src += &apos;?imageView2/&apos; + param + &apos;/format/png&apos;; &#125; else &#123; src += &apos;?imageView2/&apos; + param + &apos;/format/jpg&apos;; &#125; &#125; return src;&#125; 对自行上传的七牛资源,粘贴时请去除协议1&lt;img src=&quot;//img.xmiles.cn/xxxxxxx.png&quot; /&gt; 测试可参考http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html 全局安装mocha1npm i mocha -g webstorm集成mocha这只是其中一种配置方法,也可以使用babel-node 参数说明1mocha &apos;./app/test/**/*.@(js|jsx)&apos; --recursive --compilers js:babel-register --colors --bail -t 20000 ‘./app/test/*/.test.@(js|jsx)’ –recursive—-测试app/test目录下全部.test.js(jsx) –compilers js:babel-register————–babel-register编译 –bail————————————-第一个测试用例失败后终止测试 -t 20000———————————主要用于异步测试的timeout控制,单位为ms 测试命令(参考根目录下的build.sh文件)12//windows下用setexport IS_LOCAL=1&amp;&amp;export NODE_ENV=production&amp;&amp;export SERV_ENV=official&amp;&amp;npm test 部署流程(参考根目录下的build.sh,build.gradle文件以及jenkins配置) 其他说明.babelrc所有经过babel编译这一步都会用到,谨慎修改,比如app目录和views目录的打包都用到 .eslintrcjs语法检测 .npmrc对一些github上即使设置了代理下载仍然很慢的资源使用国内地址 pass_xx.passwd服务器账户密码,用文件而不是直接使用字符串是因为当密码有特殊字符时不知道怎么处理才能登陆上去 start.config.jspm2 启动文件 启动命令12//windows下用setexport START_PORT=13333&amp;&amp;pm2 start start.config.js --env dev 其中–env dev指定环境变量,启动正式服务器时不需要这个参数 logspm2的log暂时还没有很好的利用起来,只是做一些线上调试的时候使用 附 webstorm激活服务器 http://idea.ibdyr.com http://idea.iteblog.com/key.php webstorm增加模板提高效率 一些好用的npm模块 npm-check nodemon","categories":[],"tags":[]},{"title":"Java核心技术摘要","slug":"关于Java核心技术","date":"2017-12-29T11:29:19.000Z","updated":"2018-03-09T14:21:27.119Z","comments":true,"path":"2017/12/29/关于Java核心技术/","link":"","permalink":"http://www.afanail.com/2017/12/29/关于Java核心技术/","excerpt":"每天Java后台都来问我一些简单的样式问题和一些js不为人轻易发现的问题。那我也要问他们一些简单的Java问题。哈哈哈。","text":"每天Java后台都来问我一些简单的样式问题和一些js不为人轻易发现的问题。那我也要问他们一些简单的Java问题。哈哈哈。 面向对象程序设计 反射与代理 接口与内部类 异常处理 泛型程序设计 集合框架 事件监听器模型 使用 Swing UI 工具箱进行图形用户界面设计 并行操作 类是一个加载程序逻辑的容器，程序逻辑定义了应用程序的行为。类是构建所有Java程序和applet的构建块，Java应用程序中的全部内容都必须放置在类中。每个单词的第一个字母应该大写。源代码的文件名必须与公共类的名字相同，并用.java作为扩展名。编译后会得到.class 文件，与源文件在同一个目录下。运行已经编译的程序时，Java虚拟机将从指定类中的main方法开始执行，为了代码能够执行，在类的源文件中必须包含一个main方法。当然，也可以将用户自定义的方法添加到类中，并且在main方法中调用他们。main方法声明为public。回车不是语句结束的标志，如果需要可以将一条语句写在多行上。Java是一种强类型的语言，这就意味着必须为每一个变量声明类型。（js是弱类型的语言，不必声明类型）。 1234567public class ClassName&#123; public static void main(String[] args) &#123; program statements &#125;&#125; 在Java中，一共有8种基本类型（primitive type）,其中有4种整型，2种浮点型，1种用于表示Unicode编码的字符单元的字符类型char和1种用于表示真值的Boolean类型.1234字节位相关知识1字节 8位 第一位为符号位 -2^(8-1) ~ 2^(8-1) 1111 1111d0111 1111 第一位为0表示正数,最大为127 4种整型: int 4字节(32位) 超过20亿 short 2字节(16位) long 8字节(64位) byte 1字节(8位) 由于Java程序必须保证在所有机器上都能够得到相同的运行结果,所以各种数据类型的取值范围必须固定.长整型数值有一个后缀L或l(40000000000000L).十六进制数值有一个前缀0X或0x(0xcafe).八进制有一个前缀0,如010,八进制表示法比较容易混淆,所以建议最好不要使用八进制常数.从Java7开始,加上前缀0b或者0B可以写二进制数.还可以为数字字面量加下划线,如1_000_000表示一百万,Java编译器会除去这些下划线.Java中没有任何无符号形式的int long short byte类型. 浮点类型 浮点类型用于表示小数部分的数值.在Java中有俩种浮点类型. float(单精度) 4字节 (小数点有效位数为6~7) double(双精度) 8字节 (有效位数为15位) float类型的数值有一个后缀F或f,没有后缀F的浮点数值(如3.14)默认为double类型. 所有的浮点数值计算都遵循IEEE 754规范,有三种表示溢出和出错情况的三个特殊的浮点数值: 正无穷大 负无穷大 NaN(不是一个数字,如0/0,所有的非数值都是不相同的.) 浮点数值不适用于无法接受舍入误差的金融计算中.例如System.out.println将打印出0.8999999999,而不是人们想象的0.9.这种舍入误差的主要原因是浮点数值采用2进制无法精确的表示分数1/10.这就好像十进制数无法精确表示分数1/3一样.如果在计算中不允许有任何舍入误差,就应该使用BigDecimal类. char类型原本用于表示单个字符.如今,有些Unicode字符可以用一个char表示,另外一些Unicode字符则需要俩个char值. Boolean类型 false true 用来判断逻辑条件.整型值和布尔值之间不能相互转换. 变量 在Java中,每个变量都有一个类型(type).在声明变量时,变量的类型位于变量名之前. double salary; int vacationDays; long earthPopulation; boolean done; 每个声明是一条完整的Java语句,所以必须以分号结束.变量名必须是一个以字母开头并由数字构成的序列.Java字母包括&apos;A&apos;~&apos;Z&apos;,&apos;a&apos;~&apos;z&apos;,&apos;_&apos;,&apos;$&apos;或在某种语言中表示字母的任何Unicode字符. 在Math类中,包含了各种各样的数学函数.在编写不同类别的程序时,可能需要的函也不同. 要想计算一个数值的平方根,可以使用sqrt方法: double x = 4; double y = Math.sqrt(x); System.out.println(y); // print 2.0println方法和sqrt方法存在微小的差异,println方法处理System.out对象.但是,Math类中的sqrt方法处理的不是对象,这样的方法被称为静态方法. 类型转换规则 如果俩个操作数中有一个是double类型,则另一个操作数会转换为double类型. 否则,如果其中一个是float类型,另一个操作数将会转换为float类型. 否则,如果其中一个操作数是long类型,另一个操作数将会转换为long类型. 否则俩个操作数都将会转换为int类型 12345//上面是自动转换机制,小类型自动转换大类型.//强制转换机制: 在圆括号中给出想要转换的目标类型,后面紧跟待转换的变量名.double x=9.997;int nx=(int) x; //强制类型转换通过截断小数部分将浮点值转换为整型// warn: 如果试图将一个数值从一种类型强制转换为另一种类型,而又超出了目标类型的表示范围,结果就会截断为一个完全不同的值.(byte) 300的实际值为44. 自增自减运算符会改变变量的值,所以他们的操作数不能是数值.例如4++就不是一个合法的语句. 异或: 男性和女性才能生孩子(囧); 位掩码技术左位移: n &lt;&lt; m =&gt; n*2^m右位移: n &gt;&gt; m =&gt; n/2^mint fourthBitFormRight = (n &amp; 0b10000 )/0b10000;int fourthBitRight = (n &amp; (1&lt;&lt;3)) &gt;&gt; 3; 自定义枚举类型: 枚举类型包括有限个命名的值enum Size {SMALL,MEDIUM,LARGE,EXTRA_LAGER};Size s=Size.MEDIUM;字面量: 未经过声明赋值直接使用的变量.char数据类型是一个采用UTF-16表示Unicode码点的代码单元.length方法将返回采用UTF-16编码表示的给定字符串所需要的代码单元的数量.打印到标准输出流(控制台窗口),调用System.out.println即可. 123456789101112131415161718192021222324public class Retirement&#123; public static void main(String[] args) // read inputs &#123; Scanner in = new Scanner(System.in); System.out.println(\"how much money will you need to retire?\"); double goal = in.nextDouble(); System.out.println(\"How much money will you contribute every year?\"); double payment = in.nextDouble(); System.out.print(\"Interest rate in %:\"); double interestRate = in.nextDouble(); double balance=0; int years =0; // update account balance while goal isn't reached while(balance &lt; goal )&#123; balance += payment; double interest = balance * interestRate/100; balance+=interest; years++; &#125; System.out.println(\"you are retire\"+years+\"years.\"); &#125;&#125; 如果基本的整数和浮点数精度不能够满足需求,可以使用Java.math中的俩个很有用的类:BigInteger和BigDecimal.这俩个类可以处理包含任意长度数字序列的数值.BigInteger类实现了任意精度的整数运算,BigDecimal实现了任意精度的浮点运算.使用静态的valueOf方法可以将普通的数值转换为大数值.BigInteger a = BigInteger.valueOf(100) 数组是一种数据结构,用来存储同一类型值的集合.在声明数组变量的时候要指出数组类型(数据元素类型紧跟[])和数组变量的名字.声明整型数组a:int[] a;new 运算符创建数组(创建了一个可以存储100个整数的数组,所有元素的初始化都为0):int[] a = new int[100]; 12345678910111213141516171819202122232425262728import java.util.*;public class LotteryDrawing&#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.print(\"How many numbers do you need to draw?\"); int k = in.nextInt(); System.out.print(\"what is the highest number you can draw?\"); int n = in.nextInt(); int[] numbers = new int[n]; for(int i=0;i&lt;numbers.length;i++)&#123; numbers[i] = i+1; &#125; int[] result = new int[k]; for(int i=0;i&lt;result.length;i++)&#123; int r=(int)(Math.random()*n); result[i]=numbers[r]; numbers[r]=numbers[n-1]; n--; &#125; Array.sort(result); System.out.println(\"bet the following combination.It'll make you rich\"); for(int r : result) System.out.println(r); &#125;&#125; 123456789101112131415161718192021222324252627public class LotteryArray&#123; public static void main(String[] args) &#123; final int NMAX = 10; // allocate triangular array int[][] odds = new int[NMAX+1][]; for(int n=0;n&lt;=NMAX;n++)&#123; odds[n]=new int[n+1]; &#125; for(int n=0;n&lt;odds.length;n++)&#123; for(int k=0;k&lt;odds[n].length;n++)&#123; int lotteryOdds = 1; for(int i=1; i&lt;=k;i++)&#123; lotteryOdds = lotteryOdds*(n-i+1)/i; &#125; odds[n][k] = lotteryOdds*(n-i+1)/i; &#125; &#125; for(int[] row : odds)&#123; for(int odd: row)&#123; System.out.printf(\"%4d\",odd); &#125; System.out.println(); &#125; &#125;&#125; 对象与类型 面向对象程序设计 对象构造 使用预定义类 包 用户自定义类 类路径 静态域与静态方法 文档注释 方法参数 类设计技巧 对象的行为: 可以对对象施加哪些操作,或可以对对象施加哪些方法?对象的状态: 当施加哪些方法时,对象如何响应?对象标识: 如何辨别具有相同行为与状态的不同对象? 在一个源文件中,只能有一个公有类,但可以有任意数目的非公有类.当编译这段代码的时候,编译器将在目录下创建俩个类文件,EmployeeTest.class和Employee.class 12345678910111213141516171819202122232425262728293031323334353637383940import java.time.*;public class EmployeeTest&#123; public static void main(String[] args)&#123; // fill the staff array with three Employee objects Employee[] staff = new Employee[3]; staff[0]=new Employee(\"Carl Cracker\",75000,1987,12,15); staff[1]=new Employee(\"Harry Hacker\",50000,1989,10,1); staff[2]=new Employee(\"Tony Tester\",40000,1990,3,15); // raise everyone's salary by 5% for(Employee e : staff) e.raiseSalary(5); // print out information about all Employee objects for(Employee e : staff) System.out.println(\"name\"+e.getName()+\",salary=\"+e.getSalary()+\",hireday=\"+e.getHireDay()); &#125;&#125;class Employee&#123; private String name; private double salary; private LocalDate hireDay; public Employee(String n,double s,int year,int month,int day)&#123; name = n; salary = s; hireDay = LocalDate.of(year,month,day); &#125; public String getName()&#123; return name; &#125; public double getSalary()&#123; return salary; &#125; public LocalDate getHireDay()&#123; return hireDay; &#125; public void raiseSalary(double byPercent)&#123; double raise = salary * byPercent /100; salary += raise; &#125;&#125; 类通常包括类型属于某个类类型的实例域,一个方法可以访问所属类的所有对象的私有数据.在下面俩种情况下使用静态方法:一个方法不需要访问对象状态,其所需要参数都是通过显示参数提供(例如: Math.pow)一个方法只需要访问类的静态域(例如: Employee.getNextId); 如果多个方法有相同的名字不同的参数,便产生了重载.Java允许重载任何方法,而不只是构造器方法.要完整描述一个,需要指出方法名和参数类型.这叫做方法的签名.必须明确地初始化方法中的局部变量,但是如果没有初始化类中域,将会自动化初始化为默认值. 下面程序4-5中的程序展示了本节讨论的很多特性:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.*;public class ConstructorTest&#123; public static void main(String args)&#123; // fill the staff array with three Employee objects Employee[] staff = new Employee[3]; staff[0] = new Employee(6000); staff[1] = new Employee(\"Harry\",40000); staff[2] = new Employee(); // print out infomation about all Employee objects for(Employee e : staff) System.out.println(\"name=\"+e.getName()+\".id=\"+e.getId()+\",salary=\"+e.getSalary()); &#125;&#125;class Employee&#123; private static int nextId; private int id; private String name = \"\"; // instance field initialization private double salary; // static initialization block static &#123; Random generator = new Random(); // set nextId to a random number between 0 and 999 nextId = generator.nextId(1000); &#125; // object initialization block &#123; id = nextId; nextId++; &#125; // three overloaded constructors public Employee(String n, double s)&#123; name = n; salary = s; &#125; public Employee(double s)&#123; // calls the Employee(String, double) constructor this(\"Employee #\"+nextId,s); &#125; // the default constructor public Employee()&#123; // name initialized to \"\" -- see above // salary not explictly set --initialized to 0 // id initialized in initialization block &#125; public String getName()&#123; return name; &#125; public double getSalary()&#123; return salary; &#125; public int getId()&#123; return id; &#125;&#125; 可以为任何一个类添加finalize方法,finalize方法方法回收短缺的资源,在垃圾回收清除对象之前调用.如果某个资源需要在使用完毕之后立刻关闭,那么就需要由人工来管理.对象用完时,可以使用一个close方法来完成相应的清理操作. Java允许使用包(package)将类组织起来,借助于包可以方便地组织自己的代码,并将自己的代码与别人提供的代码库分开管理.标准的Java类库分布在多个包中,包括Java.lang java.util java.net等. 类设计技巧: 应用这些技巧可以使得设计出来的类更具有oop专业水准. 1 一定要保证数据私有 2 一定要对数据初始化 3 不要在类中使用过多的基本类:用其他的类代替多个相关的基本类型的使用. 4 不是所有的域都需要独立的域访问器和域更改器. 5 将职责过多的类进行分解 6 类名和方法名要能够体现他们的职责:命名类名的良好习惯是采用一个名词(Order) 前面有形容词修饰的名词(RushOrder) 或动名词(有&quot;ing&quot;后缀)修饰名词(BillingAddress).对于方法来说,习惯是访问器方法用小写get开头,更改器方法用小写set开头. 7 优先使用不可变的类 继承 类 超类 子类 参数数量可变的方法 Object:所有类的超类 枚举类 泛型数组列表 反射 对象包装器与自动装箱 继承的设计技巧 “is-a”规则的另一种表述法是置换法则,它表明程序中出现超类对象的任何地方都可以用子类对象置换. 对象包装器与自动装箱 所有的基本类型都有一个与之对应的类,这些类称为包装器.这些对象包装器类拥有很明显的名字:Integer Long Float Double Short Byte Character Void Boolean(前6个类派生于公共的超类Number).对象包装器类是不可变的,一旦构造了包装器,就不允许更改包装器在其中的值.同时,对象包装器还是final,不能定义他们的子类. 继承的设计技巧 1 将公共操作和域放在超类 2 不要使用受保护的域 3 使用继承实现&quot;is-a&quot;关系 4 除非所有继承的方法都有意义,否则不要使用继承 5 在覆盖方法时,不要改变预期的行为 6 使用多态,而非类型信息 7 不要过多的使用反射(反射机制使得人们可以通过在运行时查看域和方法,让人们编写出更具有通用性的程序,这种功能对于编写系统程序来说极其实用,但是通常不适于编写应用程序.反射是很脆弱的,即编译器很难帮助人们发现程序中的错误,因此只有在运行时才会发现错误并导致异常) 反射 编写动态操纵Java代码的程序.反射库(reflection library)提供了一个非常丰富且精心设计的工具集,以便编写能够动态操纵Java代码的程序.它是Java组件的体系结构.特别是在设计或运行中添加新类时,能够快速的应用开发工具动态的查询新添加类的能力. 能够分析类能力的程序称为反射(reflective).反射机制的功能极其强大. 反射机制可以用来: 在运行时分析类的能力 在运行时查看对象,比如编写一个toString方法供所有类使用. 实现通用的数组操作代码 利用Method对象,这个对象很像C++中的函数指针 反射是一种功能强大且复杂的机制,使用它的主要人员是工具构造者,而不是应用程序员. Class类在程序运行期间,Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识.这个信息跟踪着每个对象所属的类,虚拟机利用运行时类型信息选择相应的方法执行.保存这些信息的类被称为Class,Object类中的getClass()方法将会返回一个Class类型的实例. 在java.lang.reflect包中有三个类Field Method 和 Constructor分别用于描述类的域 方法和构造器.这三个类都有一个叫做getName的方法,用来返回项目的名称接口 lambda表达式与内部类 接口 内部类 接口示例 代理 lambada表达式 在Java程序设计中,接口不是类,而是对类的一组需求描述,这些类需要遵从接口描述的统一格式进行定义.例子: Arrays类中的sort方法承诺可以对对象数组进行排序,但要求满足下列前提:对象所属的类必须实现了Comparable接口.下面是Comparable接口的代码1234567891011// 任何实现Comparable接口的类都需要包含compareTo方法,并且这个方法的参数必须是一个Object对象,返回一个整型数值.// 接口中的所有方法自动属于public,在接口声明中不用提供关键字public public interface Comparable&#123; int compareTo(Object other); &#125; // Java SE 5.0中,Comparable接口已经改进为泛型类型 public interface Comparable&lt;T&gt;&#123; int compareTo(T other); &#125; //接口中还可以定义常量,重要的是知道接口不能提供哪些功能,接口绝对不能有实例域.接口没有实例,Java SE8 可以在接口中提供简单的方法,但是不能引用实例域. 提供实例域和方法实现的任务应该由实现接口的那个类来完成.为了让类实现一个接口,通常需要下面俩个步骤:1 将类声明为实现给定的接口2 对接口中的所有方法进行定义要将类声明为实现某个接口,需要使用关键字implenments:class Employee implements Comparable , 以下是compareTo方法的实现:12345//实现接口时,必须把方法声明为public,否则编译器将认为这个方法的访问属性为包可见性,即类的默认访问属性. public int compareTo(Object otherObject)&#123; Employee other = (Employee) otherObject; return Double.compare(salary,other.salary); &#125; 回调是一种常见的程序设计模式,在这种模式中,可以指出某个特定事件发生时应该采取的动作.在标准类库中采用的是面向对象方法,它将某个类的对象传递给定时器,然后,定时器调用这个对象的方法,由于对象可以携带一些附加的信息,所以传递一个对象比传递一个函数灵活得多.定时器需要知道调用哪一个方法,并要求传递的对象所属所属的类实现了java.awt.event包中ActionListener接口,下面是这个接口:1234public interface ActionListener&#123; void actionPerformed(ActionEvent event)&#125; 假设希望每隔10秒打印一条信息,”At the one,the time is …”,然后响一声,就应该定义一个实现ActionListener接口的类,然后将需要执行的语句放在actionPerformed方法中.123456class TimePrinter implements ActionListener&#123; public void actionPerformed(ActionEvent event)&#123; System.out.println(\"At the one, the time is \"+ new Date()); Toolkit.getDefaultToolkit().beep(); &#125;&#125; 接下来,构造这个类的第一个对象,并将它传递给Timer构造器12ActionListener listener = new TimePrinter();Timer t =new Timer(1000,listener) 最好,启动定时器1t.start() lambda表达式 123456789101112131415161718192021222324package lambda;import java.util;import javax.swing.*;import javax.swing.Timer;public class lambdaTest&#123; public static void main(String[] args)&#123; String[] planets = new String[] &#123;\"Mercury\",\"Venus\",\"Earth\",\"Mars\",\"Jupiter\",\"Saturn\",\"Urans\",\"Neptune\"&#125;; System.out.prinln(Arrays.toString(planets)); System.out.ptinln(\"Sorted in dictionary order:\"); Arrays.sort(planets); System.out.printlnn(Arrays.toString(planets)); System.out.println(\"Sorted by length:\"); Arrays.sort(planets,(first,second)-&gt;first.length()-second.length()); System.out.println(Arrays.toString(planets)); Timer t = new Timer(1000,event-&gt;System.out.println(\"The time is\"+new Date())); t.start(); JOptionPane.showMessageDialog(null,\"Quit program?\"); System.exit(0); &#125;&#125; 最好把lambda表达式看作是一个函数,而不是一个对象,另外要接受lambda表达式可以传递到函数式接口. 内部类内部类(inner Class)是定义在另一个类中的类.使用内部类的主要原因有三点: 内部类方法可以访问该类定义所在作用域中的数据,包括私有数据. 内部类可以对同一个包中的其他类隐藏起来 当想要定义一个回调函数且不想编写大量代码时,使用匿名内部类比较便捷. 123456789101112131415// 俩个参数: 发布通告和开关铃声的标志// TimerPrinter 对象是由TalkingClock类的方法构造public class TalkingClock&#123; private int interval; private boolean beep; public TalkingClock(int interval,boolean beep)&#123;...&#125; public void start()&#123;...&#125; public class TimePrinter implements ActionListener&#123; public void actionPerformed(ActionEvent event)&#123; System.out.println(\"At the tone,the time is\" + new Date()); if (beep) Toolkit.getDefaultToolkit().beep(); &#125; &#125;&#125;// 内部类既可以访问自身的数据域,也可以访问创建它的外围类对象的数据域.\\ 只有内部类可以是私有类,而常规类只可以具有包可见性,或公有可见性. 前6章代理和反射看的比较费劲 异常 断言和日志 处理错误 使用断言 捕获异常 记录日志 使用异常机制的技巧 调试技巧 在Java程序设计中,异常对象都是派生于Throwable类的一个实例.所有的异常都是由Throwable继承而来的,但是下一层立即分解为俩个分支:Error和Exception 123456789101112131415package pair3;public class Pair&lt;T&gt;&#123; private T first; private T second; public Pair() &#123; first = null; second = null &#125; public Pair(T first, T second)&#123; this.first = first; this.second = second &#125; public T getFirst() &#123; return first; &#125; public T getSecond() &#123; return second; &#125; public void setFrist(T newValue) &#123; first = newValue; &#125; public void setSecond(T newValue) &#123; second = newValue; &#125;&#125; 12345678910111213141516171819202122232425262728package pair3;import java.time.*;public class Employee&#123; private String name; private double salary; private LocalDate hireDay; public Employee(String name, double salary, int year, int month, int day) &#123; this.name = name; this.salary = salary; hireDay = LocalDate.of(year, month, day); &#125; public String getName()&#123; return name; &#125; public double getSalary()&#123; return salary; &#125; public LocalDate getHireDay()&#123; return hireDay; &#125; public void raiseSalary(double byPercent)&#123; double raise = salary * byPercent / 100; salary += raise; &#125;&#125; 12345678910111213141516171819package pair3;public class Manager extends Employee&#123; private double bonus; public Manager(String name,double salary, int year, int month, int day)&#123; super(name,salary,year,month,day); bonus = 0; &#125; public double getSalary()&#123; double baseSalary = super.getSalary(); return baseSalary + bonus; &#125; public void setBonus(double b)&#123; bonus = b; &#125; public double getBonus()&#123; return bonus; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package pair3;public class PairTest3&#123; public static void main(String[] args)&#123; Manager ceo = new Manager(\"Gus Greedy\",800000,2003,12,15); Manager cfo = new Manager(\"Sid Sneaky\", 600000,2003,12,15); Pair&lt;Manager&gt; buddies = new Pair&lt;&gt;(ceo, cfo); printBuddies(buddies); ceo.setBonus(1000000); cfo.setBonus(500000); Manager[] mangers = &#123; ceo, cfo&#125;; Pair&lt;Employee&gt; result = new Pair&lt;&gt;(); minmaxBonus(managers, result); System.out.println(\"first: \"+ result.getFirst().getName() + \",second: \"+ result.getSecond().getName()); maxminBonus(managers,result); System.out.prinln(\"first:\" + result.getFirst().getName()+\",second:\"+result.getSecond().getName()); &#125; public static void printBuddies(Pair&lt;? extends Employee&gt; p)&#123; // 子类限定可以读取对象 Employee first = p.getFirst(); Employee second = p.getSecond(); System.out.println(first.getName() + \" add \" + second.getName() + \" are buddies. \"); &#125; public static void minmaxBonus(Manger[] a,Pair&lt;? super Manager&gt; result)&#123; // 父类限定可以设置对象 if (a.length == 0) return; Manager min = a[0]; Manager max = a[0]; for (int i=0; i&lt; a.length; i++)&#123; if(min.getBonus() &gt; a[i].getBonus()) min = a[i]; if(max.getBonus()&lt;a[i].getBonus()) max = a[i]; &#125; result.setFirst(min); result.setSecond(max); &#125; public static void maxminBonus(Manager[] a, Pair&lt;? super Manager&gt; result) &#123; minmaxBonus(a,result); PairAlg.swapHelper(result); &#125;&#125;class PairAlg&#123; public static boolean hasNulls(Pair&lt;?&gt; p)&#123; return p.getFirst() == null || p.getSecond() == null; &#125; public static void swap(Pair&lt;?&gt; p) &#123; swapHelper(P); &#125; public static &lt;T&gt; void swapHelper(Pair&lt;T&gt; p)&#123; T t=p.getFirst(); p.setFirst(p.getSecond()); p.setSecond(t); &#125;&#125; 集合 Java集合框架 视图与包装器 具体的集合 算法 映射 遗留的集合 容器和组件是”组合(composite)”模式带滚动条的面板是”装饰器(decorator)”模式布局管理器是”策略(strategy)”墨菲闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域","categories":[],"tags":[{"name":"-- Java","slug":"Java","permalink":"http://www.afanail.com/tags/Java/"}]},{"title":"webpack","slug":"webpack","date":"2017-12-18T03:16:32.000Z","updated":"2017-12-29T11:51:24.742Z","comments":true,"path":"2017/12/18/webpack/","link":"","permalink":"http://www.afanail.com/2017/12/18/webpack/","excerpt":"webpack是一个现代 JavaScript 应用程序的模块打包器(module bundler). 当webpack处理应用程序时,它会递归地构建一个依赖关系图(dependency grapy),其中包含应用程序需要的每个模块.然后将这些模块打包成一个或多个bundle.它是高度可配置的.","text":"webpack是一个现代 JavaScript 应用程序的模块打包器(module bundler). 当webpack处理应用程序时,它会递归地构建一个依赖关系图(dependency grapy),其中包含应用程序需要的每个模块.然后将这些模块打包成一个或多个bundle.它是高度可配置的.四个核心概念: 入口(entry) 输出(output) loader 插件(plugins) 入口(entry)入口起点(entry point)指示webpack应该使用哪个模块,来作为构建内部依赖图的开始.进入入口起点后,webpack会找出哪些模块和库是入口起点(直接和间接)依赖的.每个依赖项随即被处理,最后输出到称之为bundles的文件夹中. 1234// webpack.config.jsmodule.exports = &#123; entry: './path/to/my/entry/file.js'&#125;; 多页应用程序12345678// 告诉webpack需要三个独立分离的依赖图const config = &#123; entry: &#123; pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' &#125;&#125; 使用CommonsChunkPlugin为每个页面间的应用程序共享代码创建bundle.由于入口起点增多,多页面应用能复用入口起点之间的大量代码/模块,从而可以极大地从这些技术中受益. 出口(output)output属性告诉webpack在哪里输出它所创建的bundles,以及如何命名这些文件.在配置中指定一个output字段,来配置这些处理过程: 123456789// webpack.config.jsconst path = require('path');module.exports = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname,'dist'), filename: 'my-first-webpack.bundle.js' &#125;&#125; 如果创建了多个单独的”chunk”文件(例如,使用多个入口起点或使用像CommonsChunkPlugin 这样的插件),则应该使用占位符来确保每个文件具有唯一名称1234567891011&#123; entry:&#123; app: './src/app.js', search: './src/search.js' &#125;, output: &#123; filename: '[name].js', path: __dirname + 'dist' &#125;&#125;// 写入到硬盘: ./dist/app.js ./dist/search.js loaderloader让webpack能够去处理那些非JavaScript文件(webpack自身只理解JavaScript).loader可以将所有类型的文件转换为webpack能够处理的有效模块,然后你就可以利用webpack的打包能力,对他们进行处理.本质上,webpack loader将所有类型的文件,转换为应用程序的依赖图可以直接引用的模块.在更高的层面上,webpack的配置中 loader 有俩个目标. 1 识别出应该被对应的 loader 进行转换的那些文件(使用 test 属性) 2 转换这些文件,从而使其能够被添加到依赖图中(并且最终添加到bundle中 use 属性) 1234567891011121314const path = require('path');const config = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname,'dist'), filename: 'my-first-webpack.bundle.js' &#125;, module: &#123; rules: [ &#123;test:/\\.txt$/,use:'raw-loader'&#125; ] &#125;&#125;;module.exports = config; loader 用于对模块的源码进行转换. loader可以使你在 import 或加载模块时预处理文件.loader类似于其他构建工具的任务 task ,比如 gulp. 并提供了处理前端构建步骤的强大方法.loader可以将文件从不同的语言转换为 JavaScript,或将内联图像转换为dataURL. loader甚至允许你直接在 JavaScript 模块中 import CSS文件. 例如,使用 loader 告诉webpack 加载CSS文件,或者将 TypeScript 转换为 JavaScript. 为此,首先安装相应的loader.npm install --save-dev css-loader npm install --save-dev ts-loader12345678module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/, use: 'css-loader' &#125;, &#123; test: /\\.ts$/,use: 'ts-loader' &#125; ] &#125;&#125; 还可以 import 语句或任何等效于 import的方法中指定loader.使用!将资源中的loader分开.分开的每个部分都相对于当前目录解析.import Styles from &#39;style-loader!css-loader?modules!./styles.css&#39;;尽可能使用module.rules,因为这样可以减少源码中的代码量,并且可以在出错时,更快的调试和定位loader中的问题.loader特性: 1 loader支持链式传递.能够对资源使用流水线(pipeline).一组链式的loader将按照先后顺序进行编译.loader链式中的第一个loader返回值返回给下一个loader.在最后一个loader,返回webpack所预期的JavaScript. 2 loader可以是同步的,也可以是异步的. 3 loader 运行在Node.js中,并且能够执行任何可能的操作. 4 loader接收查询参数.用于对loader传递配置 5 loader 也能够使用 options 对象进行配置 6 除了使用 package.json 常见的 main 属性,还可以将普通的 npm 模块导出为loader,做法是在 package.json 里定义一个 loader 字段. 7 插件为 loader 带来更多的特性 8 loader 能够产生额外的任意文件 loader 通过预处理函数,为JavaScript生态系统提供了更多的能力.用户现在可以更加灵活的引入细粒度逻辑,例如压缩,打包等 解析loaderloader将从模块路径解析(npm install node_modules)loader模块需要导出一个函数,并且使用Node.js兼容的JavaScript编写.通常使用npm进行管理.按照约定,loader通常将被命名为xxx-loader(json-loader). 插件(plugins)loader将被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务.插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量.插件接口的功能及其强大,可以用来处理各种各样的任务.想要使用一个插件,你只需要require()它,然后把它添加到plugins数组中.多数插件可以通过option选项自定义,你也可以在一个配置文件中因为不同的目的而多次使用同一个插件,这时需要通过使用 new 操作符来创建它的一个实例.1234567891011121314151617181920const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装const webpack = require('webpack'); // 用于访问内置插件const path = require('path');const config = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname,'dist'), filename: 'my-first-webpack.bundle.js' &#125;, module: &#123; rules: [ &#123;test: /\\.txt$/, use: 'raw-loader'&#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsplugin(), new HtmlWebpackPlugin(&#123;template:'./src/index.html'&#125;) ]&#125;module.exports = config;","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://www.afanail.com/tags/webpack/"},{"name":"模块打包","slug":"模块打包","permalink":"http://www.afanail.com/tags/模块打包/"}]},{"title":"ES6 ES7","slug":"ES6","date":"2017-12-05T11:29:48.000Z","updated":"2018-01-01T05:26:56.776Z","comments":true,"path":"2017/12/05/ES6/","link":"","permalink":"http://www.afanail.com/2017/12/05/ES6/","excerpt":"Class语法123456789// ES5 构造函数生成对象function Point(x,y)J&#123; this.x=x; this.y=y;&#125;Point.prototype.toString = function()&#123; return '('+ this.x+','+this.y+')';&#125;；var p=new Point(1,2); ES6则通过Class语法,constructor为构造方法,this关键字为实例对象.ES5的构造函数对应ES6的Point类的构造方法. ES6的类可以看成是构造函数的另一种写法.类的所有方法都定义在类的prototype属性上面.类的内部定义的方法,都是不可枚举的.这一点与ES5的行为不一致.","text":"Class语法123456789// ES5 构造函数生成对象function Point(x,y)J&#123; this.x=x; this.y=y;&#125;Point.prototype.toString = function()&#123; return '('+ this.x+','+this.y+')';&#125;；var p=new Point(1,2); ES6则通过Class语法,constructor为构造方法,this关键字为实例对象.ES5的构造函数对应ES6的Point类的构造方法. ES6的类可以看成是构造函数的另一种写法.类的所有方法都定义在类的prototype属性上面.类的内部定义的方法,都是不可枚举的.这一点与ES5的行为不一致.12345678910class Point&#123; constructor(x,y)&#123; this.x=x; this.y=y; &#125; toString()&#123; return '('+this.x+','+this.y+')'; &#125;&#125;var p=new Point(1,2); 类的属性名,可以采用表达式.Square类的方法名,是从表达式得到的.123456789let methodName = \"getArea\";class Square&#123; constructor(length)&#123; //... &#125; [methodName]()&#123; //... &#125;&#125; constructor方法是类的默认方法,通过new命令生成对象的实例时,自动调用该方法.一个类必须有constructor方法,如果没有显示定义,一个空的constructor方法会被默认添加.constructor方法默认返回实例对象(即this),完全可以指定返回另外一个对象.1234567// constructor返回一个全新的对象,结果导致实例对象不是Foo实例.class Foo&#123; constructor()&#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo; //false; 类的构造函数,不使用new是没办法调用的,会报错,这是它跟普通函数的一个主要区别,后者不用new也可以执行.与ES5一样,实例的属性除非定义在其本身(既定义在this对象上),否则都是定义在原型上(即定义在class上).与ES5一样,类的所有实例共享一个原型对象.12345678var p1=new Point(2,3);var p2=new Point(3,2);p1.__proto__ === p2.__proto__; //true;p1.__proto__.printName=function()&#123; return \"Oops\";&#125;var p3=new Point(4,2);p3.printName();//Oops; Class不存在变量提升(hoist),这一点与ES5完全不同.1234567// class 不会提升,才可以继承&#123; let Foo=class(); class Bar extends Foo&#123; //... &#125;&#125; class表达式,与函数一样,类也可以使用表达式的形式定义.12345678910111213// 表达式定义了一个类,这个类的名字是MyClass而不是Me,Me只在Class的内部代码可用,指代当前类.const MyClass=class Me&#123; getClassName()&#123; return Me.name; &#125;&#125;let inst=new MyClass();inst.getClassName();//MeMe.name; // ReferenceError:Me is not defined// Me只在Class内部有定义,如果类的内部没有定义的话,可以省略Me,也就是可以写成下面的形式.const MyClass=class&#123; //...&#125; 采用Class表达式,可以写出立即执行的Class.12345678910let person=new class&#123; constructor(name)&#123; this.name=name; &#125; sayName()&#123; console.log(this.name); &#125;&#125;('张三');person.sayName();//'张三';// person是一个立即执行的类的实例. 利用Symbol值,实现私有方法和私有属性的效果.1234567891011const bar=Symbol('bar');const snaf=Symbol('snaf');export default class myClass&#123; foo(baz)&#123; // 公有方法 this[bar](baz); &#125; // 私有方法 [bar](baz)&#123; return this[snaf]=baz; &#125;&#125; this的指向: 类的内部如果有this,它默认指向类的实例.但是必须非常小心,一旦单独使用该方法,很可能报错. 123456789101112// 将printName方法中的this单独提出来使用,this会指向该方法运行时所在的环境,因为找不到print方法而导致错误.class Logger&#123; printName(name='there')&#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text)&#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125;=logger;printName();// TypeError: Cannot read property 'print' of undefined 类和模块内部,默认就是严格模式,所以不需要使用’use strict’指定运行模式.只要你的代码写在类或模块中,就只有严格模式可用.考虑到未来所有的代码,其实都是运行在模块中的,所以ES6实际上把整个语言升级到了严格模式.本质上,ES6的类只是ES5的函数的一层包装,所以函数的许多特性都被Class继承,包括name属性.1234class Point()&#123;&#125; Point.name; // Point // name属性总是返回紧跟在Class关键字后面的类名. Class的继承: 类通过extends关键字实现继承,比ES5的通过修改原型链实现继承要清晰和方便很多.12345678910111213// ColorPoint 继承了Point类的所有方法和属性.在ColorPoint内部加上代码class ColorPoint extends Point&#123; constructor(x,y,color)&#123; //调用父类的constructor(x,y); super(x,y); this.color=color; &#125; toString()&#123; return this.color+\"\"+super.toString(); //调用父类的toString(); &#125;&#125;;// super关键字,它在这里表示父类的构造函数,用来新建父类的this对象.// 子类必须在constructor方法中调用super方法,否则新建实例会报错.这是因为子类没有自己的this对象,而是继承父类的this对象,然后对其加工.如果不调用super方法,子类就得不到this对象. ES6的继承机制与实质是先创造父类的实例对象this,所以必须先调用super方法,然后再用子类的构造函数修改this.(与ES5不一样),如果子类没有定义constructor方法,这个方法会被默认添加.也就是说不管有没有显示定义,任何一个子类都有constructor方法.1234constructor(...args)&#123; super(...args);&#125;//在子类的构造函数中,只有调用super之后,才可以使用this关键字,否则会报错.这是因为子类实例的构建,是基于对父类实例的加工,只有super方法才能返回父类实例. 子类的proto属性,表示构造函数的继承,总是指向父类.子类的prototype属性的proto属性,表示方法的继承,总是指向父类的prototype属性.Object.getPrototypeOf()方法可以用来从子类上获取父类.Object.getPrototypeOf(ColorPoint) === Point; // truesuper关键字: 可以当做函数使用,也可以当做对象使用.在这俩种情况下,他的用法完全不同.1234567891011121314151617181920212223242526272829// 第一种情况// 子类B的构造函数之中的super(),代表调用父类的构造函数.这是必须的,否则JavaScript引擎会报错.class A &#123;&#125;clsss B extends A &#123; constructor()&#123; super(); // super内部的this指向B,只能用在子类的构造函数中. &#125;&#125;// 第二种情况,super作为对象时,在普通方法中,指向父类的原型对象;在静态方法中,指向父类.class A &#123; constructor()&#123; this.x=1; &#125; print()&#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor()&#123; super(); this.x=2; &#125; m()&#123; super.print(); // super.print.call(this); &#125;&#125;let b=new B();b.m() //2 如果super作为对象,用在静态方法之中,这时super将指向父类,而不是父类的原型对象.12345678910111213141516class Parent &#123; static myMethod(msg)&#123; console.log('static',msg); &#125; myMethod(msg)&#123; console.log('instace',msg); &#125;&#125;class Child extends Parent&#123; static myMethod(msg)&#123; super.myMethod(msg); &#125;&#125;Child.myMethod(1); // static 1var child = new Child();child.myMethod(2); // instance 2 使用super的时候,必须显示指定是作为函数,还是作为对象使用,否则会报错.1234567class A &#123;&#125;class B extends A &#123; constructor()&#123; super(); console.log(super.valueOf() instanceof B); //true &#125;&#125; 最后,由于对象总是继承其他对象的,所以可以在任意一个对象中,使用super关键字.123456var obj=&#123; toString()&#123; return \"MyObject:\"+super.toString(); &#125;&#125;obj.toString(); // MyObject: [object Object] 子类实例的proto属性的proto属性,指向父类实例的proto属性,子类实例的原型的原型,是父类实例的原型.123456789var p1 = new Point(2,3);var p2 = new ColorPoint(2,3,'red');p2.__proto__ === p1.__proto__; // false;p2.__proto__.__proto__ === p1.__proto__; //true// 因此,通过子类实例的__proto__.proto__属性,可以修改父类实例的行为.p2.__proto__.proto__.printName =function()&#123; console.log('Ha');&#125;p1.printName(); // \"Ha\" 原生构造函数的继承:ES5无法继承原生构造函数.ES6则可以.Boolean()Number()String()Array()Date()Function()RegExp()Error()Object()1234567891011class MyArray extends Array&#123; constructor(...args)&#123; super(...args); &#125;&#125;var arr=new MyArray();arr[0]=12;arr.length; //1arr.length=0;arr[0]; // undefined 这也意味着ES6可以自定义原生数据结构(比如Array,String)的子类,这是ES5无法做到的.extends关键字不仅可以用来继承类,还可以用来继承原生构造函数.因此可以在原生数据结构的基础上,定义自己的数据结构.下面就是定义了一个带版本功能的数组.1234567891011121314151617181920212223class VersionedArray extends Array&#123; constructor()&#123; super(); this.history=[[]]; &#125; commit()&#123; this.history.push(this.slice()); &#125; revert()&#123; this.splice(0,this.length,...this.history[this.history.length-1]) &#125;&#125;var x=new VersionedArray();x.push(1);x.push(2);x //[1,2];x.history; //[[]]x.commit();x.history; //[[],[1,2]]x.push(3);x //[1,2,3];x.revert();x //[1,2] 下面一个自定义Error子类的例子.123456789101112131415161718class ExtendableErroe extends Error &#123; constructor(message)&#123; super(); this.message=message; this.stack=(new Error()).stack; this.name=this.constructor.name; &#125;&#125;class MyError extends ExtendableError&#123; constructor(m)&#123; super(m); &#125;&#125;var myerror=new MyError('11'):myerror.message //11myerror.instanceof Error // truemyerror.name // \"MyError\"myerror.stack 注意 继承Object的子类,有一个行为差异.12345678class NewObj extends Object&#123; constructor()&#123; super(...args); &#125;&#125;var o=new NewObj(&#123;attr:true&#125;);console.log(o.attr===true); // false//ES6改变了Object构造函数的行为,一旦发现Object方法是new Object()这种形式调用的,ES6规定Object构造函数会忽略参数. Class的取值函数(getter)和存值函数(setter)与ES5一样,在Class内部可以使用get和set关键字,对某个属性设置存值函数和取值函数,拦截该属性的行为.123456789101112131415161718class MyClass&#123;constructor()&#123; //...&#125;get prop()&#123; return \"getter\";&#125;set prop()&#123; console.log( \"setter:\"+value );&#125;&#125;let inst = new MyClass();inst.prop=123; // setter: 123inst.prop// getter 存值函数和取值函数是设置在属性的descriptor对象上的.123456789101112131415class CustomHTMLElement&#123; constructor(element)&#123; this.element=element; &#125; get html()&#123; return this.element.innerHTML; &#125; set html()&#123; this.element.innerHTML=value; &#125;&#125;var descriptor = Object.getOwnPropertyDescriptor(CustomHTMLElement.prototype,\"html\");\"get\" in descriptor // true\"set\" in descriptor // true// 存值函数和取值函数是定义在html属性的描述对象上面,这与ES5完全一致. Class的Generator方法:在某个方法前面加(*)号就表示该方法是一个Generator函数.12345678910111213141516class Foo&#123; constructor(...args)&#123; this.args=args; &#125; * [Symbol.iterator]()&#123; for(let arg of this.args)&#123; yiled arg; &#125; &#125;&#125;for(let x of new Foo('hello','world'))&#123; console.log(x);&#125;//hello//world// Foo 类的Symbol.iterator 方法前有一个星号,表示该方法是一个Generator函数Symbol.iterator方法返回一个Foo类默认遍历器,for...of循环会自动调用这个遍历器. Class的静态方法.加上static关键字,就表示该方法不会被实例继承,而是直接通过类来调研,这就称为”静态方法”.12345678class Foo&#123; static classMethod()&#123; return 'hello'; &#125;&#125;Foo.classMethod() //'hello'var foo = new Foo();foo.classMethod() // TypeError: foo.classMethod is not a function 父类的静态方法可以被子类继承123456789class Foo&#123; static classMethod&#123; return \"hello\"; &#125;&#125;class Bar extends Foo&#123;&#125;Bar.classMethod(); // \"hello\" 静态方法也可以从super对象上调用.1234567891011class Foo&#123; static classMethod()&#123; return \"hello\"; &#125;&#125;class Bar extends Foo&#123; static classMethod()&#123; return super.classMethod() +\",,too\"; &#125;&#125;Bar.classMethod(); // \"hello,,too\" class的静态属性和实例属性12345class Foo&#123;&#125;Foo.prop=1;Foo.prop //1 目前,只有这一种方法可行,因为ES6明确规定,Class内部只有静态方法,没有静态属性.ES7有一个静态属性的提案,目前babel转码器支持.这个提案对实例属性和静态属性都规定了新的写法.12345678910111213141516class MyClass&#123; myProp=42; //类的实例属性可以用等式,写入类的定义中. constructor()&#123; console.log(this.myProp); // 42 &#125;&#125;// 对于那些在 constructor 里面已经定义的实例属性,新写法允许直接列出.class ReactCounter extends React.Component&#123; constructor(props)&#123; super(props); this.state=&#123; count:0 &#125; &#125; state;&#125; 类的静态属性只要在上面的实例属性的写法前面加上static关键字就可以了.123456class MyClass&#123; static myStaticProp=42; constructor()&#123; console.log(MyClass.myStaticProp);//42 &#125;&#125; Minxin模式指的是,将多个类的接口”混入”(mixin)另一个类.它在ES6的实现如下. 123456789101112131415161718function mix(...mixins)&#123; class Mix&#123;&#125; for(let mixin of mixins)&#123; copyProperties(Mix,mixin); copyProperties(Mix.prototype,mixin,prototype); &#125; return Mix;&#125;function copyProperties(target,source)&#123; for(let key of Reflect.ownKeys(source))&#123; if(key!==\"constructor\" &amp;&amp; key !== \"prototype\" &amp;&amp; key !== \"name\")&#123; let desc = Object.getOwnPropertyDescriptor(source,key); &#125; &#125;&#125;class DistributedEdit extends mix(Loggable,Serializable)&#123; //...&#125; Iterator (遍历器)的概念:ES6之后又四种数据结构 Array Object Map Set, 需要一种统一的接口机制,来处理所有不同的数据结构.遍历器就是这样一种机制.它是一种接口,为各种不同的数据结构提供访问机制,只要部署iterator接口,就可以完成遍历操作.iterator的作用有三个:1.为各种数据结构提供统一简便的访问接口;2.使得数据结构的成员能够按照某种次序排列;3.ES6创造了一种新的遍历命令for…of循环,Iterator接口主要供for…of循环.123456789101112var it=makeIterator(['a','b']);it.next() // &#123; value: \"a\", done: false &#125;it.next() // &#123; value: \"b\", done: false &#125;it.next() // &#123; value: undefined, done: true &#125;function makeIterator(array)&#123; var nextIndex=0; return &#123; next: function()&#123; return nextIndex &lt; array.length ? &#123; value: array[nextIndex++], done: false &#125; : &#123; value: undefined, done: true &#125;; &#125; &#125;&#125; 凡是部署了Symbol.iterator属性的数据结构,就称为部署了遍历器接口.调用这个接口,就会返回一个遍历器对象.当使用for..of循环遍历某种数据结构时,该循环会自动寻找iterator接口.ES6规定,默认的iterator接口部署在数据结构的Symbol.iterator属性.只要有这个属性,就可以认为是”可遍历的”,Symbol.iterator属性本身是一个函数,执行这个函数,会返回一个遍历器.至于属性名Symbol.iterator,它是一个表达式,返回Symbol对象的iterator属性.这是一个预定义好的类型为Symbol的特殊值,所以要放在方括号内.12345678910111213// 对象默认不可遍历,因为此对象有Symbol.iterator属性,所以是可遍历的const obj=&#123; [Symbol.iterator] : function () &#123; return &#123; next : function () &#123; return &#123; value: 1, done: true &#125;; &#125; &#125;; &#125;&#125;; ES6中有三类数据结构原生具备iterator接口: 数组\\某些类似数组的对象\\Set和Map结构.1234567let arr = ['a','b','c'];let iter = arr[Symbol.iterator]();iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125; yield* 后面跟的是一个可遍历的结构,他会调用该结构的遍历器接口.12345678910let generator = function* () &#123; yield 1; yield* [2,3,4]; yield 5;&#125;;var iterator = generator();iterator.next() //&#123; value: 1, done: false &#125;iterator.next() //&#123; value: 2, done: false &#125;iterator.next() //&#123; value: 3, done: false &#125;... 由于数组的遍历会调用遍历器接口,所以任何接受数组作为参数的场合,其实都调用了遍历器接口.下面是一下例子.12345for...ofArray.from()Map(),Set(),WeakMap(),WeakSet() (比如 new Map([['a','1'],['b','2']]))Promise.all()Promise.race() 可以覆盖原生的Symbol.iterator方法,达到修改遍历器行为的目的.1234567891011121314151617var str = new String(\"hi\");[...str] //[\"h\",\"i\"];str[Symbol.iterator] = function () &#123; return &#123; next: function () &#123; if (this._first)&#123; this._first = false; return &#123; value: \"bye\", done: false &#125; &#125;else&#123; return &#123; done: true &#125;; &#125; &#125; _first: true &#125;&#125;[...str] //[\"bye\"]str // \"hi\" Generator函数是ES6提供的一种异步编程解决的方案,语法行为与传统函数完全不同.从语法上理解,Generator函数是一个状态机,封装了多个内部状态.执行Generator函数会返回一个遍历器对象.Generator函数除了是状态机,还是一个遍历器生成函数.返回的遍历器对象,可以依次遍历Generator函数内部的每一个状态.形式上,Generator函数是一个普通函数,但是有俩个不同的特征.一是,function关键字与函数名之间有一个星号,二是函数内部使用yield语句,定义不同的内部状态.1234567// 该函数有三个状态: hello world return(结束执行)function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator(); Proxy 用于修改某些操作的默认行为,等同于在语言层面上做出修改,属于一种’元编程’(meta programming),即对编程语言进行编程.123456789101112131415// 对一个空对象架设一层拦截,重新定义了属性的读取和设置行为.Proxy实际上重载了点运算符,即用自己的定义覆盖了语言的原始定义.var obj = new Proxy(&#123;&#125;,&#123; get: function(target,key,receiver)&#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target,key,receiver); &#125;, set:function(target,key,value,receiver)&#123; console.log(`setting $&#123;key&#125;!`); return Reflect.set(target,key,value,receiver); &#125;&#125;);obj.count = 1; // setting count!++obj.count; // getting count! // setting count! // 2 ES6提供原生的Proxy构造函数,用来生成Proxy实例.var proxy = new Proxy(target,handler);Proxy对象的所有用法,都是上面这种形式,不同的只是handler参数的写法.其中,new Proxy()表示生成一个Proxy实例,target参数表示所要拦截的目标对象,handler参数也是一个对象,用来定制拦截行为.1234567891011121314// 要使得Proxy起作用,必须对Proxy实例进行操作,而不是对目标对象进行操作.var proxy = new Proxy(&#123;&#125;,&#123; get: function(target,property)&#123; return 35; &#125;&#125;);proxy.time; //35proxy.name; //35// 如果handler没有设置任何拦截,那就等同于直接通向原对象var target = &#123;&#125;;var handler = &#123;&#125;;var proxy = new Proxy(target,handler);proxy.a = 'b';target.a; // \"b\" Proxy实例也可以作为其他对象的原型对象.1234567var proxy = new Proxy(&#123;&#125;,&#123; get: function()&#123; return 35; &#125;&#125;)let obj = Object.creat(proxy);obj.time; // 35 同一个拦截器,可以设置多个操作123456789101112131415161718192021var handler = &#123; get : function(target,name)&#123; if(name==='prototype')&#123; return Object.prototype; &#125; return 'Hello, '+name; &#125;, apply: function(target,thisBinding,args)&#123; return args[0]; &#125; constructor: function(target,args)&#123; return &#123;value: args[1]&#125;; &#125;&#125;;var fproxy = new Proxy(function(x,y)&#123; return x + y;&#125;,handler);fproxy(1,2) //1new fproxy(1,2) // &#123;value: 2&#125;fproxy.prototype === Object.prototype // truefproxy.foo // \"Hello, foo\" 下面是Proxy支持的拦截操作一览.对于可以设置但是没有设置拦截的操作,则直接落在目标对象上,按照原先的方式产生结果.123456get(target,propKey,receiver) // 拦截对象属性的读取. 比如 proxy.foo 和 proxy['foo'].set(target,propKey,value,receiver) // 拦截对象属性的设置,比如 proxy.foo = v 或者 proxy['foo'] = v,返回一个布尔值.has(target,propKey) // 拦截 propKey in proxy 操作,返回一个布尔值deleteProperty(target,propKey) // 拦截delete proxy[propKey]的操作,返回一个布尔值ownKeys(target) // 拦截Object.getOwnPropertyNames(proxy) Object.getOwnPropertySymbol(proxy) Object.keys(proxy), 返回一个数组,返回目标对象所有自身的属性和属性名.... Reflect 对象与Proxy对象一样.也是ES6为了操作对象而提供的新API.Reflect对象的设计目的: 1 将Object对象的一些明显属于语言内部的方法(Object.defineProperty),放在Reflect对象上.现阶段,某些方法同时在Object和Reflect对象上部署,未来新的方法将只部署在Reflect对象上,也就是说,从Reflect对象上可以拿到语言内部的方法. 2 修改某些Object方法返回结果,让其变得合理.比如,Object.defineProperty(obj,name,descJ)在无法定义属性时,会抛出一个错误,而Reflect.defineProperty(obj,name,desc)则会返回false. 12345678910111213// 老写法try&#123; Object.defineProperty(target,property,attributes); // success&#125; catch(e)&#123; // failure&#125;// 新写法if (Reflect.defineProperty(target,property,attributes))&#123; // success&#125;else&#123; // failure&#125; 3 让Object操作都变成函数行为.某些Object操作是命令式,比如 name in obj 和 delete obj[name], 而Reflect.has(obj,name) 和 Reflect.deleteProperety(obj,name)让他们变成函行为 1234// 老写法'assign' in Object // true// 新写法Reflect.has(Object,'assign') // true 使用Proxy实现观察者模式观察者模式(Observe mode)指的是函数自动观察数据对象,一旦对象有变化,函数就会自动执行.123456789101112// 数据对象person是观察者目标,函print是观察者.一旦数据对象发生变化,print就会自动执行. const person = observable(&#123; name: '张三', age: 20 &#125;) function print()&#123; console.log(`$&#123;person.name),$&#123;person.age&#125;`); &#125; observe(print); person.name = '李四'; // 输出 // 李四, 20 下面,使用Proxy写一个观察者模式的最简单实现,既实现observable和observe这俩个函数.思路是observable函数返回一个原始对象的Proxy代理,拦截赋值操作,触发充当观察者的各个函数. 12345678const queuedObservers = new Set();const observe = fn =&gt; queueObservers.add(fn);const observable = obj =&gt; new Proxy(obj,&#123;set&#125;);function set(target,key,value,receiver)&#123; const result = Reflect.set(target,key,value,receiver); queueObservers.forEach(observer =&gt; observer()); return result;&#125;","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://www.afanail.com/tags/ES6/"}]},{"title":"数据结构与算法","slug":"dataStructor","date":"2017-11-09T02:14:20.000Z","updated":"2017-12-09T11:54:29.000Z","comments":true,"path":"2017/11/09/dataStructor/","link":"","permalink":"http://www.afanail.com/2017/11/09/dataStructor/","excerpt":"本文为一些算法的实现，以C++/C 为编程语言。1234567891011121314151617// 头插法建立双链表void CreateListF(DLinkList *&amp;L,ElemType a[],int n)&#123; DLinkList * s; int i; L = (DLinkList *)malloc(sizeof(DLinkList)); L-&gt;prior=L-&gt;next=NULL; for(i=0;i&lt;n;i++)&#123; s = (DLinkList *)malloc(sizeof(DLinkList)); s-&gt;data=a[i]; s-&gt;next=L-&gt;next; if(L-&gt;next!=NULL)&#123; L-&gt;next-&gt;prior=s; &#125; L-&gt;next=s; s-&gt;prior=L; &#125;&#125;","text":"本文为一些算法的实现，以C++/C 为编程语言。1234567891011121314151617// 头插法建立双链表void CreateListF(DLinkList *&amp;L,ElemType a[],int n)&#123; DLinkList * s; int i; L = (DLinkList *)malloc(sizeof(DLinkList)); L-&gt;prior=L-&gt;next=NULL; for(i=0;i&lt;n;i++)&#123; s = (DLinkList *)malloc(sizeof(DLinkList)); s-&gt;data=a[i]; s-&gt;next=L-&gt;next; if(L-&gt;next!=NULL)&#123; L-&gt;next-&gt;prior=s; &#125; L-&gt;next=s; s-&gt;prior=L; &#125;&#125; 12345678910111213141516171819202122232425void Commnode(LinkList * &amp;LA,LinkList * LB,LinkList * LC)&#123; // TODO:为什么时间复杂度为O(m+n+p)? m.n.p对应各个表的Length LinkList * pa = LA-&gt;next,* pb=LB-&gt;next,* pc=LC-&gt;next,* q, * r; LA-&gt;next = NULL; //此时LA作为新建单链表的头结点 r=LA; // r始终指向单链表的尾节点 while(pa!=NULL)&#123; while(pb!=NULL&amp;&amp;pa-&gt;data&gt;pb-&gt;data)&#123; pb=pb-&gt;next; &#125; while(pc!=NULL&amp;&amp;pa-&gt;data&gt;pc-&gt;data)&#123; pc=pc-&gt;next; &#125; if(pb!=NULL &amp;&amp; pc!=NULL &amp;&amp; pa-&gt;data==pb-&gt;data&amp;&amp;pa-&gt;data==pc-&gt;data)&#123; r-&gt;next=pa; r=pa; pa=pa-&gt;next; &#125; else&#123; q=pa; pa=pa-&gt;next; free(q); &#125; &#125; r-&gt;next=NULL; //尾节点的next域置空&#125; 12345678910111213void CreateListR(DLinkList *&amp;L,ElemType a[],int n)&#123; DLinkList * s, * r; int i; L = (DLinkList *)malloc(sizeof(DLinkList)); r = L; for (i=0;i&lt;n;i++)&#123; s=(DLinkList *)malloc(sizeof(DLinkList)); s-&gt;data=a[i]; r-&gt;next=s;s-&gt;piror=r; r=s; &#125; r-&gt;next=NULL;&#125; 123456789101112void dels(LinkList * &amp;L)&#123; LinkList * p = L-&gt;next,* q; while(p-&gt;next!=NULL)&#123; if(p-&gt;data==p-&gt;next-&gt;data)&#123; q=p-&gt;next; p-&gt;next=q-&gt;next; free(q); &#125; else p=p-&gt;next; &#125;&#125; 123456789101112131415161718192021222324void move2(SqlList *&amp;L)&#123; int i=0,j=L-&gt;length-1; ElemType pivot=L-&gt;data[0]; while(i&lt;j)&#123; while(j&gt;i&amp;&amp;L-&gt;data[j]&gt;pivot) j--; L-data[i]=L-&gt;data[j]; i++; while(i&lt;j&amp;&amp;L-&gt;data[i]&lt;=pivot) i++; L-&gt;data[j] = L-&gt;data[i]; j--; &#125; L-&gt;data[i]=pivot; printf(\"i=%d\\n\",i);&#125;i=0,j=5; pivot=3;// 第一轮循环 data[0]=1, (1,8,2,7,1,5), i=1 j=4 ,data[4]=8 (1,8,2,7,8,5)i=1 j=3// 第2轮循环(3,8,2,7,1,5) 1234567891011121314151617181920212223242526272829303132void LinkTable(HList * h1,HList * h2,HList * &amp;h)&#123; int i,j,k; DList * p = h1-&gt;next,* q, * s, * r; printf(\"连接字段是：第1个表序号，第二个表序号：\")； scanf(\"%d%d\",&amp;i,&amp;j); h=(HList *)malloc(sizeof(HList));// 创建结果表头节点 h-&gt;Row=0; h-&gt;Col=h1-&gt;Col+h2-&gt;Col; h-&gt;next=NULL; while(p!==NULL)&#123; q=h2-&gt;next; while(q!==NULL)&#123; if(p-&gt;data[i-1]i==q-&gt;data[j-1])&#123; s=(DList *)malloc(sizeof(DList)); for(k=0;k&lt;h1-&gt;Col;k++) s-&gt;data[k]=h1-&gt;data[k]; for(k=0;k&lt;h2-&gt;Col;k++) s-&gt;data[h1-&gt;Col+k]=q-&gt;data[k]; if(h-&gt;next) h-&gt;next=s; else r-&gt;next=s; r=s; h-&gt;Row++; &#125; q=q-&gt;next; &#125; p=p-&gt;next; &#125; r-&gt;next=NULL;&#125; 12345678910111213141516171819202122bool ListDelete(DLinkList *&amp;L,int i,ElemType &amp;e)&#123; int j=0; DLinkList * p=L,* q; while(j&lt;i-1&amp;&amp;p!=NULL)&#123; j++; p=p-&gt;next; &#125; if(p==NULL) return false; else &#123; q=p-&gt;next; if(q==NULL) return false; e=q-&gt;data; p-&gt;next=q-&gt;next; if(p-&gt;next!==NULL) p-&gt;next-&gt;prior=p; free(p); return true; &#125;&#125; 123456789101112131415161718192021bool ListInsert(DLinkList *&amp;L,int i,ElemType e)&#123; int j=0; DLinkList * p=L,* s; //p指向头节点，j设置为0 while(j&lt;i-1&amp;&amp;p!=NULL)&#123; // 查找第i-1个节点 j++; p=p-&gt;next; &#125; if(p==NULL) return false; else &#123; s=(DLinkList *)malloc(sizeof(DLinkList)); s-&gt;data=e; s-&gt;next=p-&gt;next; if(p-&gt;next!=NULL) p-&gt;next-&gt;piror=s; s-&gt;piror=p; p-&gt;next=s; return true; &#125;&#125; 1234567891011121314151617181920212223void ListInsert1(SqList * &amp;L,ElemType e)&#123; int i=0,j; while(i&lt;L-&gt;length &amp;&amp; L-&gt;data[i]&lt;e)&#123; // 有序表的插入 （递增递减） i++; for (j=ListLength(L);j&gt;i;j--)&#123; L-&gt;data[j]=L-&gt;data[j-1]; &#125; L-&gt;data[i]=e; L-&gt;length++; &#125;&#125;// 单链有序表void ListInsert2(LinkList * &amp;L,ElemType e)&#123; LinkList * pre = L, * p; while(pre-&gt;next!=NULL&amp;&amp;pre-&gt;next-&gt;data&lt;e)&#123; pre=pre-&gt;next; &#125; p=(LinkList *)malloc(sizeof(LinkList)); p-&gt;data=e; p-&gt;next=pre-&gt;next; pre-&gt;next=p;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void UnionList(SqList * LA,SqList * LB,SqList * &amp;LC)&#123; int i=0,j=0,k=0; // i,j分别为LA，LB的下标，K为LC中元素的个数 LC=(SqList *)malloc(sizeof(SqList)); //建立有序顺序表LC while(i&lt;LA-&gt;length&amp;&amp;j&lt;LB-&gt;length)&#123; if(LA-&gt;data[i]&lt;LB-&gt;data[j])&#123; LC-&gt;data[k]=LA-&gt;data[i]; i++;k++; &#125; else&#123; LC-&gt;data[k]=LB-&gt;data[j]; j++;k++; &#125; &#125; while(i&lt;LA-&gt;length)&#123; LC-&gt;data[k]=LA-&gt;data[i]; i++;k++; &#125; while(j&lt;LB-&gt;length)&#123; LC-&gt;data[k]=LB-&gt;data[j]; j++;k++; &#125; LC-&gt;length=k;&#125;// 单链表存放有序表的归并算法如下void UnionList1(LinkList * LA,LinkList * LB,LinkList * &amp;LC)&#123; LinkList * pa = LA-&gt;next,* pb = LB-&gt;next, * r,* s; LC=(LinkList *)malloc(sizeof(LinkList)); r=LC; while(pa!=NULL&amp;&amp;pb!=NULL)&#123; if(pa-&gt;data&lt;pb-&gt;data)&#123; s=(LinkList *)malloc(sizeof(LinkList)); s-&gt;data=pb-&gt;data; r-&gt;next=s;r=s; pa=pa-&gt;next; &#125; else &#123; s=(LinkList *)malloc(sizeof(LinkList)); s-&gt;data=pb-&gt;data; r-&gt;next=s;r=s; pb=pb-&gt;next; &#125; &#125; while(pa!=NULL)&#123; s=(LinkList *)malloc(sizeof(LinkList)); s-&gt;data=pa-&gt;data; r-&gt;next=s; r=s; pa=pa-&gt;next; &#125; while(pb!=NULL)&#123; s=(LinkList *)malloc(sizeof(LinkList)); s-&gt;data=pb-&gt;data; r-&gt;next=s; r=s; pb=pb-&gt;next; &#125; r-&gt;next=NULL;&#125;","categories":[],"tags":[{"name":"数据结构与算法 C++/C","slug":"数据结构与算法-C-C","permalink":"http://www.afanail.com/tags/数据结构与算法-C-C/"}]},{"title":"Sybase SQL Server相关","slug":"sql","date":"2017-10-21T03:14:20.000Z","updated":"2017-12-10T01:40:27.000Z","comments":true,"path":"2017/10/21/sql/","link":"","permalink":"http://www.afanail.com/2017/10/21/sql/","excerpt":"– DDL数据定义：创建和定义数据库中的对象，表 关键字 视图 规则 默认值 存储过程 触发器 临时表1234Create TableCreate ViewDrop TableDrop View –DML数据操作语言，操作数据库中的对象和数据12345selectdeleteinsertexecute 执行存储过程update –DCL数据控制语句，赋予用于访问数据库对象的权限，系统管理员具有使用DCL命令的最高权限，有权使用所有数据库对象。12grant 授权revoke 回收权限","text":"– DDL数据定义：创建和定义数据库中的对象，表 关键字 视图 规则 默认值 存储过程 触发器 临时表1234Create TableCreate ViewDrop TableDrop View –DML数据操作语言，操作数据库中的对象和数据12345selectdeleteinsertexecute 执行存储过程update –DCL数据控制语句，赋予用于访问数据库对象的权限，系统管理员具有使用DCL命令的最高权限，有权使用所有数据库对象。12grant 授权revoke 回收权限 – 打开一个数据库12345678910111213141516use database_name;select select_list from database_name where search_conditions group by aggregates_free_expression having search_condition order by column_name;select pub_name,state from publishers;select distinct staste from authors;select pub_name ,\"的ID号是\",pub_id from publishers;select au_id,au_lname,au_fname from authors where state=\"UT\";select title,price*total_sales from titles where price*total_sales&gt;75000 order by title desc;select au_id,au_fname,au_lname from authors where state in(\"CA\",\"WA\",\"MD\");select au_id,au_fname,au_lname from authors where staste not in(\"CA\"); – sql 的四个通配符为，必须在引号内，like, not like – % 匹配0到多个字符的字符串 – _ 匹配单个字符 – [] 匹配给定范围内的任一个字符 – [^] 匹配不含在给定范围的单个字符12345678910111213141516select pub_name from authors pub_name like \"B%Y\";select au_fname from authors where au_fname like \"__i%\";--查询某一范围内的信息select title from title where price&lt;15 or price&gt;20;select title from titles where price not between 15 and 20;--union 子句，将俩个以上的查询结果合并成一个单一的结果。将不同的集组合成为一个单一的结果返回给客户机程序。每一个select语句所得到的数据类型必须是相同的。select title from titles where price*total_sales&gt;1000;select pub_name from publishers;select au_lname from authors where au_lname like \"D%\"; – title pub_name au_lname 类型相同，可以使用union子句将这三个结果集合组成一个单一的结果集。12345678select title from titles where price*total_sales&gt;10000unionselect pub_name frompublishers unionselect au_lname fromauthors whereau_lname like \"D%\"; – union列标题以第一个查询结果为准– 使用多表查询，表名和视图名可以是俩个或者俩个以上（最多可达16个）。–（相等连接）12345select au_fname,au_lname,pub_name from authors,publishers where authors.city=publishers.city;select t.title,a.au_lname,a.au_fname from authors a,titles t,titleauthor ta where a.au_id=ta.au_idand ta.title_id=t.title_idand t.price&gt;20; – insert 向表中输入数据1insert into table_name(column_name1,column_name2) values (values1,values2); – 列的个数必须与values子句中的个数相同；值的数据类型必须和列的数据类型相对应，values子句中的顺序必须和表中的顺序保持一致。1insert publishers(pub_id,pub_name,city,staste) values(\"9999\",\"QUE Cororation\",\"Indianapolis\",\"IN\"); – 允许省略列的清单，values子句中值的顺序必须和表中列的顺序保持一致，个数一致，数据类型相同。否则Sybase拒绝插入数据。1insert stores values(\"9999\",\"The QUE Bookstop\",\"1701 MCP Avenue\",\"Indianaplis\",\"IN\",\"USA\",\"37012\",\"net120\"); – update修改表中的数据，修改表中一列或者多列的值,如果省略where子句，将修改表中的所有行12update table_name set column_name=expressionwhere expression; –当对表 修改失败时，不会得到Sybase给出的信息，因为这不是一个错误，如果想要知道数据是否被修改，比较简单的方法是使用查询语句查看1update authors set au_lname=\"flagstaff\" where au_id=\"238-95-7766\"; –delete 语句用来从表中删除数据。要小心，它将数据从表中永久删除。需要从备份中恢复。123delete from table_name where search_condition;delete publishers where pub_id=\"9999\"; – 文法规定 {}必须至少选其中的一个选项。[]可选可不选 --标识符1-30个字符组成，第一字符可以是字母（A-Z，a-z) 或@ #其他字符可以是字母 数字 或符合 $ # _,@表示一个局部变量，列名和索引名必须是唯一的。 -- 存储过程可以在远程的SQL服务器上运行，其运行结果可显示在调用该过程的终端上。 declare @var int exec gateway...gyroyalty; -- 数据类型用来说明表列 存储过程参数及局部变量的数据特征，即数据的长度 存储格式等。 -- 在存储过程使用参数之前，必须先定义参数的数据类型和数据的长度。 -- 在存储过程中使用参数之前，必须先定义参数的数据类型和数据的长度。 -- 数值型 整型、浮点型、货币型 -- 字符型数据类型 char(n)为定长字符型。输入的字符数据必须用单引号或者双引号括起来。输入数据的超长部分被截断，不足部分系统自动用空格补足。 -- varcha(n)为可变长度的字符型。n为字节数，其值为1-255之间，n表示该类型数据的最大长度。其存储长度为输入的数据值的实际长度，超长部分将被截断，空字符串 &quot; &quot;作为空格存储。 -- nchar(n)多字节字符集 -- nvarchar -- text 文本型，只能用于说明表的列类型，不能用于局部变量或存储过程参数。允许空值，可用于表示可变长度的列。 -- datetime 显示当前服务器的名称为 -- select getdate() -- binary(n) 二进制型，长度为n字节，n必须在1——255之间。必须在输入的第一个二进制值前面加0X。 -- varbinary(n) 变长二进制型，存储数据慢，所占空间小 -- bit timestamp image -- bit only 0 and 1,logic and not null and not index. not 1 defalut 1 -- timestamp 数据类型，向表中插入一行数据时，timestamp类型的列值自动进行计数，不能手动输入timestamp列的值，该值varbinary（8）格式进行存储，且在表中是唯一的。 -- image 为图像型。只能用来说明表的列类型，但不能用于局部变量和存储过程中的参数。允许空值。 – 2.用户定义的数据类型：用户定义的数据类型是在系统数据类型的基础上定义的，实际上是对常用系统数据类型的重新定义。目的：使用户可以用名字来存取经常使用的类型和长度信息。12345-- sp_addtype typename,systype[(length)][,nulltype]sp_addtype dbname1,\"char(20)\",\"not null\";sp_addtype dbname2,\"varchar(10)\",\"null\"; – 用户数据类型被成功定义，就会自动加入到系统表中，使我们可以像使用系统数据类型一样使用它。 – sp_help 显示用户定义的数据类型。 – sp_droptype dbname1 删除用户自定义类型dbname1; – sybase 局部变量用户自定义的变量，全局变量是Sybase定义的变量 – 局部变量 declare定义局部变量,不能与Sybase的全局变量同名，其数据类型可以是系统数据类型，也可以是用户定义的类型。但不能是text和image类型。刚定义的局部变量在未赋值之前其值为null（空）。使用select语句可以对局部变量进行赋值 -- declare @variale_name datatype -- select @variable_name=expression [,@variable_name=expression]...[from...][where...];该语句只能给局部变量赋值，且不显示结果。 declare @var1 int,@var2 money select @val1=-68,@var2=97.564; – 局部变量只能在定义他的批处理 存储过程或触发器中使用，否则无效。 – 以下几种情况使用局部变量： -- 1 在while循环语句中，用于循环计数 -- 2 在if_else语句中，用于条件判断 -- 3 向存储过程传递参数或者接收从存储过程中返回的信息。 -- 4 向客户应用程序返回标准信息的同时，返回不同的客户信息。 – 全局变量 -- Sybase定义的变量。全局变量以@@开始，如@@error -- 全局变量只能出现在常量出现的地方。 – 函数： 系统函数 统计函数 字符串函数 数学函数 日期函数 数据类型转换函数 文本和图像函数 123456789declare @i1 int,@isum intselect @i1=1,@isum=0while @i1&lt;=1000begin select @isum=@isum+@i1 select @i1=@i1+1 if @i1&gt;1000 select @isumend – 一个实体对应一张表，实体的一个属性就是表中的一列，实体的一个实例就是表中的一行，实体间的关系表现为表的关联。表是关系型数据库的最基本的概念，是数据存储和加工的场所。 – 关键字 primary key 主键 表中的一个列或者多个列组成。主键能唯一的识别表中的每一行。不能为空，外键描述一个表与其他表的关系– foreign key 外键 能表示另一个表的主键。实际上外键本身是主键的拷贝。 – system tables 文件夹中 – 数据库的完整性就是数据的正确性和一致性，它反映了现实世界中实体的本来面貌。完整性分为数据完整性和参照完整性。 – 一个表满足数据的完整性，是说该表的任一行数据都是实体的一个合法的实例，而且这种合法性的验证不涉及系统中的其他表的数据。 – 参照完整性：表与表之间的关系而言的。俩个表的数据是一致的协调的，俩个表的主关键字外关键字也是一致协调的。教师表中教师ID一定在教师表中存在，对教师表中的某个教师ID进行修改删除时，若这个教师ID在教师课程表中存在，则不允许修改删除，或要求同时修改删除教师课程表中的教师ID，否则这俩个表中的一致性就受到了破坏，也就不难报障俩表的参照完整性。Sybase提供了一系列手段来报障完整性，如数据类型，规则，默认值，唯一索引和触发器等。 – 数据库的组成，在Sybase数据库中，含有表（tables）视图（views）索引（indexs)规则（rules）默认值（defaults)用户定义数据类型（user-defined datatype)存储过程（stored procedures)触发器（triggers)等数据库对象。 – 表是Sybase的核心，别的对象均是围绕表而创建的，他们从不同的角度扩充了表的功能。 – 表由行和列组成，它要满足关系型数据库的最基本要求：表中的所有属性（列）都是不可再分的基本数据项。 – database device、 dump device – 使用SQL命令创建数据库设备123456disk init /*初始化命令*/name=\"mydev2\",/* database device logic name*/physname=\"e:\\device\\mydev2.dat\",/*database device physical name*/vdevno=2,/* database device number*/size=1024/* 2MB block 1block=2kb*/go – 临时表名不应该超过13个字符包括#，因为SQL server另给临时表名加一个内部的数字后缀。 – 临时表的优点是，在临时数据库tempdb上执行操作时不记录日志，能提高系统性能。临时表通常用来保存中间结果。只有在创建它的会话中才可能访问临时表。在当前会话期结束时临时表会被自动删除，用户可以使用drop Table命令删除临时表。所有用户均可以创建临时表。用户定义的数据类型不能用于临时表，除非该数据类型已经tempdb中存在。123456create table #temptable(task char(30)),start datetime,stop datetime,notes varchar(200)go – sybase 不允许从一个已存在的表中删除列，我们可以采用其他的方法。12345678create table newtab(au_id id not null,au_lname varchar(40) not null)goinsert into newtab(au_id,au_lname) values(select au_id,au_lname from authors)godrop table authorsgo sp_rename newtab,authorsgo – 只有表的所有者才能删除表，删除表的权限不能转让。不能删除一个正在使用的表，但是可以删除另一个数据库中的表。不能删除系统表。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384--1 sales tableuse mydatabasecreate table sales(stor_id char(4) not null,ord_num varchar(20) not null,date datetime not null)go --2 salesdetail tableuse mydatabasecreate table salesdetail(stor_id char(4) not null,ord_num varchar(20) not null,title_id tid not null,qty smallint not null,discount float not null)go--3 titleauthor tableuse mydatabase create table titleauthor(au_id id not null,title_id tid not null,au_ord tinyint null,royaltyper int null)go--4 titles tableuse mydatabase create table titles(title_id tid not null,title varchar(80) not null,type char(12) not null,pub_id char(4) null,price money null,advance money null,total_sales int null,notes varchar(200) null,pubdate datetime not null,contract bit not null)go --5 stores tableuse mydatabasecreate table stores(stor_id char(4) not null,stor_name varchar(40) null,stor_address varchar(40) null,city varchar(20) null,state char(2) null,country varchar(12) null,postalcode char(10) null,payterms varchar(12) null)go--6 discount tableuse mydatabasecreate table discount(discounttype varchar(40) not null,stor_id char(4) null,lowqty smallint null,highqty smallint null,discount float not null)go-- au_pjx tableuse mydatabasecreate table au_pix(au_id char(11) not null,pic image null,format_type char(11) null,bytesize int null,pixwidth_hor char(14) null,pixwidth_vert char(14) null)go--8 blurbs tableuse mydatabasecreate table blurbs(au_id id not null,copy text null)go – 表的分割：用来解决在表上执行多个并行insert事务时引发的页面竞争问题。– 分割表将产生附加的页链，每个页链都有自己的最后一页。这样并发插入操作可获得多个最后一页，从而减少了页竞争而提高了插入性能。Sybase可以将一个表中的数据分割到多个物理设备上，保证在这些设备上均匀分布数据。段可以将数据库对象存放到不同的物理设备上，通过数据分割同样可以将数据均匀分布在多个物理设备上。 – 分割表可在俩种情况下进行 -- 1在同一个数据库设备上分割表 -- 2在多个数据库设备上分割表 –单索引建在一个列上，复合索引创建在多个列上，这些列必须属于同一个表。 -- 1 唯一索引：唯一索引是指不能有俩行相同索引值的索引（包括null） -- 2 簇式索引：数据在表中的物理存储顺序与索引顺序一致。创建簇式索引的表就是排了序的表。当创建一个簇式索引时，非簇式索引就会被自动创建。 -- 3 非簇式索引：数据行的物理存储顺序与索引顺序不同。一个非簇式索引是一个额外的表。其中包含索引列和一个指针。索引列按索引值的排序，指针则指向数据的实际物理行，一个表中多达249个非簇式索引。 –使用簇式索引的数据的查找比使用非簇式索引的数据的查找速度要快。默认会自动生成一个非簇式索引 –四类组合型索引：惟一的簇式索引、惟一的非簇式索引、非惟一的簇式索引、非惟一的非簇式索引 12345use mydatabasecreate unique clustered index pubinxon publishers(pub_id)with fillfactor=90go – 经常使用规则定义表列数据的有效范围，在没有提供某列的值时，插入默认值到数据库中的表列中。123create defalut datedefaultas getdate()go – create rule 语句不能和其他的SQL语句写在同一个批处理中。1234567891011121314151617181920Create view stateview2as select au_id,au_lname from authors where state=\"CA\";select * from stateview2 gocreate view pubviewas select * from publishers where city=\"Boston\"gocreate view typegroupas select type,count(*) from titles group by typego – 只能在那些不含有结果数据或函数结果的视图的列上执行insert update delete操作 – 存储过程是SQL语句和流程控制语句的集合。有俩种存储过程：系统存储过程和用户定义的存储过程。系统存储过程以sp_开始。 – 创建存储过程12345678Create procedure pro_publishersas select *from publishersgopro_publishersgo – 使用一个输入参数查找特定作者1234567891011121314151617create procedure pro_authorInfo@psauthorID char(11)asselect *from authorswhere au_id=@psauthorIDreturn 0gopro_authorInfo \"172-32-1176\";-- 在参数中赋予默认值Create procedure pro_newauthorInfo@psauthorID char(11)=\"172-32-1176\"asselect * from authorswhere au_id=@psauthorIDreturn 0go – 使用输出参数output，创建一个能进行俩个数学运算的存储过程。– 1 up_DoMath12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152create procedure up_DoMath@psOperator varchar(12),@pnFirstNumber int,@pnSecondNumber int,@rnResult int output /*存放俩数运算结果*/asprint \"compute right now.\"if @psOperator=\"Multiply\" begin select @rnResult=@pnFirstNumber*@pnSecondNumber return 0 endelse if @psOperator=\"ADD\" begin select @rnResult=@pnFirstNumber+@pnSecondNumber return 0 endelse if @psOperator=\"Subtract\" begin select @rnResult=@pnFirstNumber-@pnSecondNumber return 0 endelse if @psOperatoro=\"Divide\" begin select @rnResult=@pnFirstNumber/@pnSecondNumber return 0 endelse begin /* error info*/ select @rnResult=0 return -99 endreturn 0go-- 2 procedure up_Multiplycreate procedure up_Multiply@pnFirstNumber int,@pnSecondNumber intasdeclare @nRC int, @nMathResult intprint \"compute now\"exec up_DoMath \"Multiply\",@pnFirstNumber,@pnSecondNumber,@nMathResult outputselect @nMathResultreturn 0go – 可以从以下几种调用程序中来执行存储过程： -- 一个存储过程 -- 一个批命令 -- 一个触发器 -- 一段client-library DB-Library程序 -- 写入一个客户、服务器开发工具中的任意程序 – 如果调用执行另一过程的存储过程，被调用过程就能存取调用过程所创建的对象，过程嵌套限制为16层。超过16层的嵌套就会导致事务失败。系统失败状态-1~-99之间，用户可以在范围之外定义自己的返回状态值 – 触发器 trigger 是一种特殊的存储过程。在对表进行插入 删除 修改操作时，它起作用。触发器通过维持不同表中逻辑上相关数据的一致性，保证数据的参照完整性。参照完整性是指主键值与相应的外键值必须完全匹配。 – 触发器的主要优点是：当数据变化时，他们能够自动响应，而不管是录入数据还是应用程序的影响。它专用一个数据的更新操作。对于这样的SQL语句，触发器执行一次（在数据更新语句完成后立即被触发）。触发器和触发它的语句被当作一个事务处理，事务可以在触发器中回退。 – 主表从表。外键值。 – 外键对主键经常是多对一的关系。 – 触发器的工作 – 参照完整性触发器保证外键的值与主键的值一致，当数据更新影响一个键列时，触发器通过临时触发器检查表比较新的列值与相应键的值。编写触发器时，被比较的数据存放在临时触发器检查表中。 – 编写触发器，用到俩个特殊的表，deleted和inserted表。这是俩个临时表。这俩个表用来检查一些数据更新的影响并为触发器动作设置条件。不能直接改变触发器检查表中的数据，但是能够使用select语句来检测insert update delete操作带来的影响。– 创建触发器 修改触发器 删除触发器 条件插入触发器的具体使用。12Create trigger trigger_name on table_name for&#123;insert,update,delete&#125;as sql_statement; – table_name 为激活触发器的表名，该表有时被称为触发表。触发器只能在当前数据库中创建。– SQL_statement 为激活触发器后要执行的一段程序，触发条件是insert update 和 delete，如果要执行多个SQL语句组成，则必须用begin和end语句括起来。 123create trigger newtri_author on dbo.authors for insert,update,delete asprint \"正在对authors表进行数据处理\"go – 一个表最多可有3个触发器：insert触发器 update触发器和delete触发器。也可以建立一个触发器，用在insert update delete这3个操作上，此时只能建立一个，后建立的触发器将覆盖先建立的触发器。 – updated 语句执行期间，被修改的行从触发器表拷贝到deleted表中。 – 下面介绍创建触发器 修改触发器 删除触发器 和条件插入触发器的具体使用。 – authors 表进行insert操作的语句如下：12insert authors values(\"333-22-111\",\"zhang\",\"xiamei\",\"408 286-2428\",\"22Cle\",,\"san\",\"ca\",\"usa\",\"95123\")go – 执行该语句，触发器被触发，显示“正在对authors表进行数据处理”的信息。 – 因为创建的是insert update delete触发器，当对表进行update delete操作时，也会触发tri_author触发器。 – 触发器特别有用，因为他们能强制施加参照完整性，保证数据在表中的合法性。// 下午和小莫不能那样说，应该说这种写法和特别，别具风格。– 数据在输入表之前已合法化。在titleauthor表上创建insert触发器。sql语句为：1234567891011Create trigger tri_insert on titleauthor for insert asif(select count(*) from authors,inserted where authors.au_id=inserted.au_id)!=@@rowcount begin rollback transaction /*回滚事务*/ print \"au_id 号在authors表中不存在.\" endelse print \"已成功，因为au_id在表中存在。\"go – 因为主键是行及其他表外键的唯一标识，所以修改主键要格外小心。一般来说最好禁止对主键的修改。但是如果只是想在某些情况下禁止修改，那么可以使用update触发器。 – 禁止在周末修改authors表的au_id列1234567891011121314151617181920create trigger tri_update_auidon authorsfor updateas/* 如果修改au_id列，并且是在周末修改的，则回退事务，显示信息。*/if update(au_id) and datename(dw,getdate()) in (\"saturday\",\"sunday\") begin rollback transaction print \"对不起，不允许在周末修改authors表的主键！\" endgo-- if update 子句检查对指定列的插入或修改操作。create trigger trigger_name for&#123;insert,update&#125; asif update(column_name)[&#123;and|or&#125; update(column_name)&#125;]...sql statement.-- 因为已经在创建触发器的 on 子句中指定了表名，所以if update子句中不需要在列名前使用表名。 2– 外键的update触发器 某些原因要修改外键，允许在外键上创建update触发器。那么外键上的update触发器要根据主表检查所有的修改并且当他们与主键不匹配时回退他们。触发器检查俩种可能失败的原因是：1.所修改的外键在自身的表中不存在。2.外键在主表中不存在。 123456789101112131415161718192021222324 -- 给titleauthor表中的au_id列创建update触发器 Create trigger tri_update_titleauthor on titleauthor for update as declare @row int /*存储修改的行数*/ select @row=@@RowCount if update(au_id) begin if (select distinct inserted.au_id from inserted) is null begin rollback transaction print \"对不起，这个au_id在titleauthor表中不存在。\" end else if(select count(*) from authors,inserted where authors.au_id=insetted.au_id)!=@row beign rollback transaction print\"对不起，这个au_id在authors主表中不存在。\" end else print\"修改titleauthor表成功。\" endgo – 游标及其使用 -- sybase提供了一种称为游标的对象，可以通过游标实现对结果集的按行操作。 -- 游标是一种使用户可以逐行读取select结果集的方法。每个游标都与一个select语句向联系。 游标由俩个位置组成：游标结果集和游标位置。 – 在一个应用程序中可以使用俩种类型的游标，服务器端游标和客户端游标。 -- 服务器端游标：是由数据库管理并且容易被客户应用程序开发人员所访问的游标。select语句执行的结果不返回客户端缓冲区中，直到进行游标读取fetch操作时才将相应的一行或几行数据返回客户端。 --客户端游标：是指游标结果集均返回给客户端应用程序缓冲区中。游标从客户端缓冲区中读取数据。在客户端缓冲区中的数据不能及时反映数据库数据的变化。如果应用程序要修改游标当前位置的行，而该行的数据已被其他用户修改（游标打开后修改），则操作失败。 服务器端游标具有客户端游标的全部性能而不需要额外开销或限制。因此在Sybase10或者更高的版本中使用服务器端游标。 – 使用游标需要经过说明游标、打开游标、从游标中读取数据、使用游标修改数据、关闭游标及释放游标的步骤。 – 封锁是事务T向系统发送请求，对某个数据库对象加锁。加锁后，事务T就对此数据库有了一定的控制能力，其他事务必须等到事务T释放它的锁之后，才能更新此数据库对象。因此封锁机制可以使多个事务“串行化”。但这些加锁过程并不是由程序员在程序中显示规定的，而是由SQL server的事务管理机制根据事务的结构自动完成的（除holdlock）。 – 有俩种类型的锁，表锁和区间锁。它们锁定的数据比单个数据页的数据多。当用户发出一个不含where子句的update操作请求时，此时出现表锁，使用户可以更新表的每一行。– 当Sybase需要创建一个数据库区间（8页数据）以响应用户的查询时，就会出现区间锁。","categories":[],"tags":[{"name":"sql sybase","slug":"sql-sybase","permalink":"http://www.afanail.com/tags/sql-sybase/"}]},{"title":"perl-learning","slug":"Perl相关","date":"2017-10-01T03:25:22.000Z","updated":"2017-12-29T11:45:36.458Z","comments":true,"path":"2017/10/01/Perl相关/","link":"","permalink":"http://www.afanail.com/2017/10/01/Perl相关/","excerpt":"因为工作大部分时间从前端转到Perl后台，这里记录的是工作中遇到的问题及本人的一些想法。Perl在做机票报表方面确实有得天独厚的优势，本文一切基于Perl 5.18。Perl连接数据库1234567891011use Sybase::CTlib; # 使用 Sybase::CTlib包$db = &amp;connect_database(); #连接数据库$sql =\" select rtrim(name) from ctninfo..sysobjects where type='U' \"; #编写SQL语句$db-&gt;ct_execute($sql); # 执行 while($db-&gt;ct_results($restype) == CS_SUCCEED) &#123; if($restype==CS_ROW_RESULT) &#123; while(@row = $db-&gt;ct_fetch) &#123; $table_name&#123;$row[0]&#125;=1; #取出数据 &#125; &#125;&#125;","text":"因为工作大部分时间从前端转到Perl后台，这里记录的是工作中遇到的问题及本人的一些想法。Perl在做机票报表方面确实有得天独厚的优势，本文一切基于Perl 5.18。Perl连接数据库1234567891011use Sybase::CTlib; # 使用 Sybase::CTlib包$db = &amp;connect_database(); #连接数据库$sql =\" select rtrim(name) from ctninfo..sysobjects where type='U' \"; #编写SQL语句$db-&gt;ct_execute($sql); # 执行 while($db-&gt;ct_results($restype) == CS_SUCCEED) &#123; if($restype==CS_ROW_RESULT) &#123; while(@row = $db-&gt;ct_fetch) &#123; $table_name&#123;$row[0]&#125;=1; #取出数据 &#125; &#125;&#125; 1234567891011# 去重 my @array=(1,3,1,4,5,1); my %count;@array=grep &#123; ++$count&#123; $_ &#125; &lt; 2&#125; @arry;# scalar 函数返回数组的长度for(my $i=0;$i&lt;scalar(@array);$i++)&#123; # $array[$i]... to do everything&#125;# scalar 函数同时返回标量上下文my $num='13'; my $len;$len=scalar($num); # 13","categories":[],"tags":[{"name":"perl CGI 编程","slug":"perl-CGI-编程","permalink":"http://www.afanail.com/tags/perl-CGI-编程/"}]},{"title":"0到1实现简单的jQuery城市选择控件","slug":"0到1实现简单的jQuery城市选择控件","date":"2017-09-30T11:19:47.000Z","updated":"2017-10-04T11:06:12.000Z","comments":true,"path":"2017/09/30/0到1实现简单的jQuery城市选择控件/","link":"","permalink":"http://www.afanail.com/2017/09/30/0到1实现简单的jQuery城市选择控件/","excerpt":"好久没有写博客了，最近忙着学习后端的相关知识。感觉数据库相关知识还给了大学老师。SQL虽然简单，但是越到后面越难，特别是你要考虑性能之类的。要写好SQL语句也是有一定的难度的。上一次说分享一下如何封装jQuery插件，因为最近在写后台的代码。所以抽时间来总结一下，巩固一下基础知识。所以，这是非常简单的jQuery插件。","text":"好久没有写博客了，最近忙着学习后端的相关知识。感觉数据库相关知识还给了大学老师。SQL虽然简单，但是越到后面越难，特别是你要考虑性能之类的。要写好SQL语句也是有一定的难度的。上一次说分享一下如何封装jQuery插件，因为最近在写后台的代码。所以抽时间来总结一下，巩固一下基础知识。所以，这是非常简单的jQuery插件。 静态页面很多后端的同事问我，如何快速的入前端的门槛。我给他们的建议是写淘宝京东的页面。多写静态页面，写着写着就入门了。凡事开头难，中间难，最后难。不过今天这个确实比想象的简单。首先看一下完成的效果图。 插件特性1.单例2.支持搜索(借用了阿里的API)3.搜索框函数节流4.兼容IE7+ 插件使用 一，引进插件（依赖jquery）&lt;link rel=&quot;stylesheet&quot; href=&quot;kuCity.css&quot;&gt;&lt;script src=&quot;http://cdn.bootcss.com/jquery/1.9.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;kuCity.js&quot;&gt;&lt;/script&gt;首先让我们先看一下布局。12 然后是css, 代码中有相关的注释。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133*&#123; margin:0; padding:0;&#125;.kucity&#123; font-family: \"微软雅黑\"; font-size:12px; position: absolute; top:50px; left:50px; width: 317px; *border:1px solid #dedede; box-shadow: 0 0 5px 1px #dedede; padding:10px;&#125;.kucity h3&#123; font-size:12px; font-weight: normal; color:#666;&#125;.kucity .kucity_nav&#123; font-size:0; padding-top:10px; list-style: none;&#125;.kucity .kucity_nav li&#123; cursor: pointer; font-size:12px; margin-left:-1px; border:1px solid #dedede; display: inline-block; color:#666; padding:3px 7px; transition:all .2s;&#125;.kucity .kucity_nav li.active&#123; background-color: rgb(4, 168, 253); border-color:rgb(4, 168, 253); color:#fff;&#125;/*kucity_body*/.kucity .kucity_body&#123; padding:10px 5px; max-height: 230px; overflow-y:auto; &#125;.kucity .kucity_body .kucity_item&#123; display: none; &#125;.kucity .kucity_body .kucity_item.active&#123; display: block;&#125;.kucity_item dt, .kucity_item dd&#123; display: inline-block;&#125;.kucity_item dl&#123; padding:3px 0;&#125;.kucity_item dt&#123; color:rgb(32, 117, 249); padding-top:3px; vertical-align: top; width:10%;&#125;.kucity_item dd&#123; width:90%;&#125;.kucity_item dd span&#123; width: 24%; display: inline-block; cursor: pointer; padding:3px 0; border:1px solid #fff; transition:all .3s;&#125;.kucity_item dd span:hover&#123; color:rgb(4, 168, 253); text-decoration: underline;&#125;.kucity .result&#123; list-style: none;&#125;.kucity .result li&#123; padding:5px; background-color: #fff; margin:2px 0; cursor: pointer; overflow: hidden;&#125;.kucity .result li.active, .kucity .result li.active .letter&#123; background-color: rgb(4, 168, 253); color:#fff;&#125;.kucity .result li .letter&#123; float:right; color:#999;&#125;.kucity .result li .noresult&#123; padding:0 8px; color:rgb(253, 130, 27);&#125;.kucity .result li:hover, .kucity .result li:hover &gt; .letter&#123; background-color: rgb(4, 168, 253); color:#fff!important;&#125;/*滚动条*/.kucity_body::-webkit-scrollbar &#123; width: 5px; height: 16px; background-color: #F5F5F5; &#125; /*定义滚动条轨道 内阴影+圆角*/ .kucity_body::-webkit-scrollbar-track &#123; border-radius: 10px; background-color: #F5F5F5; &#125; /*定义滑块 内阴影+圆角*/ .kucity_body::-webkit-scrollbar-thumb &#123; border-radius: 5px; background-color: #dedede; &#125; .kucity_body::-webkit-scrollbar-thumb:hover&#123; background-color: #999;&#125; 接下来是我们编写的jQuery插件。 首先是获取数据，可以利用mock.js来模拟数据。这里我们先写死数，到联调时再换相关接口数据。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245(function($) &#123; // 对接口前模拟数据 var allCities = ['北京|beijing|bj', '上海|shanghai|sh', '重庆|chongqing|cq', '深圳|shenzhen|sz', '广州|guangzhou|gz', '杭州|hangzhou|hz', '南京|nanjing|nj', '苏州|shuzhou|sz', '天津|tianjin|tj', '成都|chengdu|cd', '南昌|nanchang|nc', '三亚|sanya|sy', '青岛|qingdao|qd', '厦门|xiamen|xm', '西安|xian|xa', '长沙|changsha|cs', '合肥|hefei|hf', '西藏|xizang|xz', '内蒙古|neimenggu|nmg', '安庆|anqing|aq', '阿泰勒|ataile|atl', '安康|ankang|ak', '阿克苏|akesu|aks', '包头|baotou|bt', '北海|beihai|bh', '百色|baise|bs', '保山|baoshan|bs', '长治|changzhi|cz', '长春|changchun|cc', '常州|changzhou|cz', '昌都|changdu|cd', '朝阳|chaoyang|cy', '常德|changde|cd', '长白山|changbaishan|cbs', '赤峰|chifeng|cf', '大同|datong|dt', '大连|dalian|dl', '达县|daxian|dx', '东营|dongying|dy', '大庆|daqing|dq', '丹东|dandong|dd', '大理|dali|dl', '敦煌|dunhuang|dh', '鄂尔多斯|eerduosi|eeds', '恩施|enshi|es', '福州|fuzhou|fz', '阜阳|fuyang|fy', '贵阳|guiyang|gy', '桂林|guilin|gl', '广元|guangyuan|gy', '格尔木|geermu|gem', '呼和浩特|huhehaote|hhht', '哈密|hami|hm', '黑河|heihe|hh', '海拉尔|hailaer|hle', '哈尔滨|haerbin|heb', '海口|haikou|hk', '黄山|huangshan|hs', '邯郸|handan|hd', '汉中|hanzhong|hz', '和田|hetian|ht', '晋江|jinjiang|jj', '锦州|jinzhou|jz', '景德镇|jingdezhen|jdz', '嘉峪关|jiayuguan|jyg', '井冈山|jinggangshan|jgs', '济宁|jining|jn', '九江|jiujiang|jj', '佳木斯|jiamusi|jms', '济南|jinan|jn', '喀什|kashi|ks', '昆明|kunming|km', '康定|kangding|kd', '克拉玛依|kelamayi|klmy', '库尔勒|kuerle|kel', '库车|kuche|kc', '兰州|lanzhou|lz', '洛阳|luoyang|ly', '丽江|lijiang|lj', '林芝|linzhi|lz', '柳州|liuzhou|lz', '泸州|luzhou|lz', '连云港|lianyungang|lyg', '黎平|liping|lp', '连成|liancheng|lc', '拉萨|lasa|ls', '临沧|lincang|lc', '临沂|linyi|ly', '芒市|mangshi|ms', '牡丹江|mudanjiang|mdj', '满洲里|manzhouli|mzl', '绵阳|mianyang|my', '梅县|meixian|mx', '漠河|mohe|mh', '南充|nanchong|nc', '南宁|nanning|nn', '南阳|nanyang|ny', '南通|nantong|nt', '那拉提|nalati|nlt', '宁波|ningbo|nb', '攀枝花|panzhihua|pzh', '衢州|quzhou|qz', '秦皇岛|qinhuangdao|qhd', '庆阳|qingyang|qy', '齐齐哈尔|qiqihaer|qqhe', '石家庄|shijiazhuang|sjz', '沈阳|shenyang|sy', '思茅|simao|sm', '铜仁|tongren|tr', '塔城|tacheng|tc', '腾冲|tengchong|tc', '台州|taizhou|tz', '通辽|tongliao|tl', '太原|taiyuan|ty', '威海|weihai|wh', '梧州|wuzhou|wz', '文山|wenshan|ws', '无锡|wuxi|wx', '潍坊|weifang|wf', '武夷山|wuyishan|wys', '乌兰浩特|wulanhaote|wlht', '温州|wenzhou|wz', '乌鲁木齐|wulumuqi|wlmq', '万州|wanzhou|wz', '乌海|wuhai|wh', '兴义|xingyi|xy', '西昌|xichang|xc', '襄樊|xiangfan|xf', '西宁|xining|xn', '锡林浩特|xilinhaote|xlht', '西双版纳|xishuangbanna|xsbn', '徐州|xuzhou|xz', '义乌|yiwu|yw', '永州|yongzhou|yz', '榆林|yulin|yl', '延安|yanan|ya', '运城|yuncheng|yc', '烟台|yantai|yt', '银川|yinchuan|yc', '宜昌|yichang|yc', '宜宾|yibin|yb', '盐城|yancheng|yc', '延吉|yanji|yj', '玉树|yushu|ys', '伊宁|yining|yn', '珠海|zhuhai|zh', '昭通|zhaotong|zt', '张家界|zhangjiajie|zjj', '舟山|zhoushan|zs', '郑州|zhengzhou|zz', '中卫|zhongwei|zw', '芷江|zhijiang|zj', '湛江|zhanjiang|zj' ]; var regEx = /^([\\u4E00-\\u9FA5\\uf900-\\ufa2d]+)\\|(\\w+)\\|(\\w)\\w*$/i, // 匹配汉字，拼音 regExChiese = /([\\u4E00-\\u9FA5\\uf900-\\ufa2d]+)/, // 只匹配拼音 reg_ah = /^[a-h]$/i, // 匹配首字母为 a-h reg_ip = /^[i-p]/i, // 匹配首字母为 i-p reg_qz = /^[q-z]/i; // 匹配首字母为 q-z //构建城市分类字面量 var city = &#123; hot: &#123;&#125;, ABCDEFGH: &#123;&#125;, IJKLMNOP: &#123;&#125;, QRSTUVWXYZ: &#123;&#125; &#125;; //城市按首字母分类，填充到分类字面量 (function() &#123; for (var i = 0, len = allCities.length; i &lt; len; i++) &#123; var part = regEx.exec(allCities[i]), en = part[1], //中文名 letter = part[2], //拼音 spletter = part[3], //拼音简写 first = letter[0].toUpperCase(), //拼音首字母 ltPart; //当前字母下的城市 if (reg_ah.test(first)) &#123; ltPart = 'ABCDEFGH'; &#125; else if (reg_ip.test(first)) &#123; ltPart = 'IJKLMNOP'; &#125; else if (reg_qz.test(first)) &#123; ltPart = 'QRSTUVWXYZ'; &#125; city[ltPart][first] ? city[ltPart][first].push(en) : (city[ltPart][first] = [], city[ltPart][first].push(en)); //设置前16个城市为热门城市 if (i &lt; 16) &#123; city.hot['hot'] ? city.hot['hot'].push(part[1]) : (city.hot['hot'] = [], city.hot['hot'].push(part[1])); &#125; &#125; &#125;)(); var kucity = null; // 定义构造函数 KuCity var KuCity = function(target) &#123; this.target = target; this.container = null; this.resultct = null; this.init(); &#125;; // KuCity原型对象 KuCity.prototype = &#123; constructor: KuCity, //初始化 init: function() &#123; this.creatItem(); this.tabChange(); this.citySelect(); this.inputSearch(); this.stopPropagation(); &#125;, //创建市列表 creatItem: function() &#123; var template = '&lt;div class=\"kucity\"&gt;&lt;div class=\"citybox\"&gt;&lt;h3 class=\"kucity_header\"&gt;热门城市(支持汉字/拼音搜索)&lt;/h3&gt;&lt;ul class=\"kucity_nav\"&gt;&lt;li class=\"active\"&gt;热门城市&lt;/li&gt;&lt;li&gt;ABCDEFGH&lt;/li&gt;&lt;li&gt;IJKLMNOP&lt;/li&gt;&lt;li&gt;QRSTUVWXYZ&lt;/li&gt;&lt;/ul&gt;&lt;div class=\"kucity_body\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;ul class=\"result\"&gt;&lt;/ul&gt;&lt;/div&gt;'; $('body').append(template); this.container = $('.kucity'); this.resultct = $('.result'); for (var group in city) &#123; var itemKey = []; for (var item in city[group]) &#123; itemKey.push(item); &#125; itemKey.sort(); var itembox = $('&lt;div class=\"kucity_item\"&gt;'); itembox.addClass(group); for (var i = 0, iLen = itemKey.length; i &lt; iLen; i++) &#123; var dl = $('&lt;dl&gt;'), dt = '&lt;dt&gt;' + (itemKey[i] == 'hot' ? '' : itemKey[i]) + '&lt;/dt&gt;', dd = $('&lt;dd&gt;'), str = ''; for (var j = 0, jLen = city[group][itemKey[i]].length; j &lt; jLen; j++) &#123; str += '&lt;span&gt;' + city[group][itemKey[i]][j] + '&lt;/span&gt;' &#125; dd.append(str); dl.append(dt).append(dd); itembox.append(dl); &#125; $('.kucity_body').append(itembox); this.container.find('.hot').addClass('active'); &#125; &#125;, //列表切换 tabChange: function() &#123; $('.kucity_nav').on('click', 'li', function(e) &#123; var current = $(e.target), index = current.index(); current.addClass('active').siblings().removeClass('active'); $('.kucity_item').eq(index).addClass('active').siblings().removeClass('active'); $(' .kucity_body').scrollTop(0); &#125;) &#125;, //城市选择 citySelect: function() &#123; var self = this; $('.kucity_item dd').on('click', 'span', function(e) &#123; self.target.val(($(e.target).text())); self.container.hide(); &#125;) &#125;, //搜索 inputSearch: function() &#123; var self = this; this.target.on('keyup', function(e) &#123; self.throttle(search, this); &#125;) // 输入框搜索 function search(e) &#123; console.log(1) var container = self.container; self.triggleShow(false); var value = $(this).val(); if (value) &#123; // 借用阿里的api接口 var url = 'https://sjipiao.alitrip.com/city_search.do?_ksTS=1439362066383_11337&amp;lines=10&amp;_input_charset=utf-8&amp;needProvince=true&amp;q=' + value; $.ajax(&#123; url: url, type: 'get', dataType: 'jsonp' &#125;).done(function(re) &#123; creatResult(re); &#125;) &#125; else &#123; self.triggleShow(true); &#125; // 创建搜索结果选项item function creatResult(re) &#123; var result = re.result, len = result.length, str = ''; if (!!len) &#123; for (var i = 0; i &lt; len; i++) &#123; str += '&lt;li&gt;&lt;span class=\"name\"&gt;' + result[i].cityName + '&lt;/span&gt;&lt;span class=\"letter\"&gt;' + result[i].py + '&lt;/span&gt;&lt;/li&gt;' &#125; container.find('.result').html('').html(str).find('li').eq(0).addClass('active'); &#125; else &#123; container.find('.result').html('&lt;li&gt;没有找到&lt;span class=\"noresult\"&gt;' + value + '&lt;/span&gt;相关信息&lt;/li&gt;'); &#125; &#125; &#125; &#125;, //列表，结果，整体 显示切换 triggleShow: function(open) &#123; var container = this.container; if (open === 'all') &#123; container.hide() &#125; else if (open) &#123; container.find('.citybox').show().end().find('.result').hide(); &#125; else &#123; container.find('.citybox').hide().end().find('.result').show(); &#125; &#125;, //函数节流 throttle: function(fn, context) &#123; clearTimeout(fn.tId); fn.tId = setTimeout(function()&#123; fn.call(context); &#125;, 100) &#125;, //阻止事件冒泡 stopPropagation: function() &#123; var self = this; //阻止事件冒泡 this.container.on('click', stopPropagation) this.target.on('click', stopPropagation) //页面点击 隐藏 $(document).on('click', function() &#123; self.container.hide(); &#125;) //阻止冒泡，可进一步做兼容性处理 function stopPropagation(e) &#123; e.stopPropagation(); &#125; &#125; &#125;; // 对外暴露接口。 $.fn.kuCity = function(options) &#123; var target = $(this); target.on('focus', function(e) &#123; var top = $(this).offset().top + $(this).height(), left = $(this).offset().left; kucity = kucity ? (kucity.container.show(), kucity) : new KuCity(target); kucity.container.offset(&#123; 'top': top + 10, 'left': left &#125;); kucity.target = $(e.target); kucity.triggleShow(true); kucity.resultct.on('click', 'li', function() &#123; kucity.target.val($(this).find('.name').text()); kucity.triggleShow('all'); &#125;) &#125;) return this; &#125;;&#125;)(jQuery) 二，使用到这里就结束了，是不是非常简单。$(&#39;.search&#39;).kuCity();","categories":[],"tags":[{"name":"jQuery插件","slug":"jQuery插件","permalink":"http://www.afanail.com/tags/jQuery插件/"}]},{"title":"Perl项目前后端分离？","slug":"Perl项目前后端分离？","date":"2017-08-15T12:12:55.000Z","updated":"2017-08-15T12:16:15.000Z","comments":true,"path":"2017/08/15/Perl项目前后端分离？/","link":"","permalink":"http://www.afanail.com/2017/08/15/Perl项目前后端分离？/","excerpt":"昨天逛StackOverflow，发现ruby项目也能实现前后端分离。那么Perl项目应该也可以实现前后端分离吧？当然这只是我个人的猜想，毕竟才看完Perl语言入门这本书。intermediate perl 也才看了几章，上代码仓库perl-learning。","text":"昨天逛StackOverflow，发现ruby项目也能实现前后端分离。那么Perl项目应该也可以实现前后端分离吧？当然这只是我个人的猜想，毕竟才看完Perl语言入门这本书。intermediate perl 也才看了几章，上代码仓库perl-learning。 Perl的正则表达式无比强大，用过的人都知道好。这几天一直在改一些小需求，发现Perl与angular有一些相似之处。Perl项目我看见最早的代码标注时间是2004年，真是有年份的代码。在小规模的项目里，Perl显然很容易上手。但是在比较大的项目，上手Perl就相对新手来说比较不友好了。为什么呢？先看一份最简单的Perl文件，只是作为说明用途，不能用于生产环境。123456789101112131415161718192021222324252627282930313233343536373839404142require \"common.pl\";require \"base.pl\";#...use Socket;use MD5;#...# 调用common.pl文件里写好的HTMLHEADER方法，生成HTML头部&amp;HTMLHEADER();print qq! &lt;script&gt; function demo()&#123; console.log('this is a test demo'); &#125; demo();&lt;/script&gt;! print qq`&lt;h1&gt;this is test head title&lt;/h1&gt;`;$sql = \"select * from table\";# 调用连接数据库函数&amp;db_connect();$db-&gt;ct_execute($sql);while($db-&gt;ct_results($restype) == CS_SUCCEED) &#123; if ($restype==CS_ROW_RESULT) &#123; while(@row = $db-&gt;ct_fetch) &#123; if ($row[1] eq \"0\") &#123; print qq`&lt;link href=\"demo.css\" rel=\"stylesheet\" type=\"text/css\" /&gt;`; &#125; elsif ($row[1] eq \"1\") &#123; print qq`&lt;link href=\"test.css\" rel=\"stylesheet\" type=\"text/css\" /&gt;`; &#125; &#125; &#125;&#125;#...# 调用common.pl文件里写好的HTMLHEADER方法，生成HTML尾部&amp;FOOTER(); 我们再来看一下一份最简单的angular文件，只作说明，不能用于生产环境。123456789101112131415161718192021&lt;!doctype html&gt;&lt;html lang=\"en\" ng-app=\"app\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 指令 属性方式 --&gt;&lt;div app-head-bar text=\"公司职位\"&gt;&lt;/div&gt;&lt;div app-company com=\"company\"&gt;&lt;/div&gt;&lt;div app-position-class com=\"company\"&gt;&lt;/div&gt;&lt;script src=\"vendor/angular/angular.min.js\" charset=\"utf-8\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 把Perl的函数当成angular的指令，触类旁通。回归主题，再来说为什么Perl大项目对新手不友好。因为Perl可以内嵌太多语言了，html css js sql 等等，刚一接触肯定比较晕。所以从开始写Perl需求的时候，就一直在想能不能像ruby项目那样去实现前后端分离，让Perl程序少掺杂一些前端语言。所以还需要深入学习后台，站在更远的视野去看待问题。","categories":[],"tags":[{"name":"Perl","slug":"Perl","permalink":"http://www.afanail.com/tags/Perl/"},{"name":"angular","slug":"angular","permalink":"http://www.afanail.com/tags/angular/"}]},{"title":"前端工程自动化","slug":"前端工程自动化","date":"2017-07-30T09:17:54.000Z","updated":"2017-07-30T12:10:05.000Z","comments":true,"path":"2017/07/30/前端工程自动化/","link":"","permalink":"http://www.afanail.com/2017/07/30/前端工程自动化/","excerpt":"因为我是自动化方向出身的，对自动化算是有一些认识，前端领域虽然发展飞快，但是应用普及速度却不尽人意，前阵子腾讯开源了ncnn,这是要实现自动化编程的节奏啊！但是现在国内好多对前端的看法还是停留在美工的层面，这科技差距就像北上广深和大西北，令人唏嘘！其实做软件开发的无所谓前后端，眼界也不能局限于某一个领域。回到话题，为什么要前端自动化？因为前端重要啊！在这个颜控的社会，前端好比外貌，后端好比内在。这也是为什么前端在现在大部分公司大概占技术团队三分之一席位的事实。","text":"因为我是自动化方向出身的，对自动化算是有一些认识，前端领域虽然发展飞快，但是应用普及速度却不尽人意，前阵子腾讯开源了ncnn,这是要实现自动化编程的节奏啊！但是现在国内好多对前端的看法还是停留在美工的层面，这科技差距就像北上广深和大西北，令人唏嘘！其实做软件开发的无所谓前后端，眼界也不能局限于某一个领域。回到话题，为什么要前端自动化？因为前端重要啊！在这个颜控的社会，前端好比外貌，后端好比内在。这也是为什么前端在现在大部分公司大概占技术团队三分之一席位的事实。什么是前端工程自动化？腾讯的WeFlow工作流程解释的很清楚。简言之就是帮助我们自动去做某事,更高效高简洁更优化更有体验。从grunt到gulp，再从gulp到webpack,也就是短短俩三年的时间。前端技术日新月异，框架和工具层出不穷。但是归根结底还是HTML、CSS、JavaScript，万变不离其中，还是以打好基础为主。虽然JavaScript能作为后端语言替代Java、PHP等后台语言，但是至今市场份额少还是有原因的。我们从零开始搭建一个最简单前端项目来展示前端工程自动化。首先新建一个项目znsq。引入gulpfile.js（项目核心脚本）文件，实现热更新，压缩图片压缩文件等功能。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* * gulpfile.js * author: zhengjingfa * date: 2017.04.21 * email: zjfapk@163.com */// 定义目录var app = &#123; srcPath:'src/', buildPath:'build/', distPath:'dist/'&#125;/*1.引入gulp与gulp插件 使用时，要去下载这些插件*/var gulp = require('gulp');var less = require('gulp-less');var cssmin = require('gulp-cssmin');var uglify = require('gulp-uglify');var concat = require('gulp-concat');var connect = require('gulp-connect');var imagemin = require('gulp-imagemin');var open = require('open');/*把bower下载的前端框架放到我们项目当中*/gulp.task('lib',function () &#123; gulp.src('bower_components/**/*.js') .pipe(gulp.dest(app.buildPath+'lib')) .pipe(gulp.dest(app.distPath+'lib')) .pipe(connect.reload()) //当内容发生改变时， 重新加载。&#125;);/*2.定义任务 把所有html文件移动另一个位置*/gulp.task('html',function () &#123; /*要操作哪些文件 确定源文件地址*/ gulp.src(app.srcPath+'**/*.html') /*src下所有目录下的所有.html文件*/ .pipe(gulp.dest(app.buildPath)) //gulp.dest 要把文件放到指定的目标位置 .pipe(gulp.dest(app.distPath)) .pipe(connect.reload()) //当内容发生改变时， 重新加载。&#125;);/*3.执行任务 通过命令行。gulp 任务名称*//*定义编译less任务 下载对应的插件 gulp-less* 把less文件转成css放到build* */gulp.task('less',function () &#123; gulp.src(app.srcPath+'style/index.less') .pipe(less()) .pipe(gulp.dest(app.buildPath+'css/')) /*经过压缩，放到dist目录当中*/ .pipe(cssmin()) .pipe(gulp.dest(app.distPath+'css/')) .pipe(connect.reload())&#125;);/*合并js*/gulp.task('js',function () &#123; gulp.src(app.srcPath+'js/**/*.js') .pipe(concat('index.js')) .pipe(gulp.dest(app.buildPath+'js/')) .pipe(uglify()) .pipe(gulp.dest(app.distPath+'js')) .pipe(connect.reload())&#125;);/*压缩图片*/gulp.task('image',function () &#123; gulp.src(app.srcPath+'images/**/*') .pipe(gulp.dest(app.buildPath+'images')) .pipe(imagemin()) .pipe(gulp.dest(app.distPath+'images')) .pipe(connect.reload())&#125;);/*同时执行多个任务 [其它任务的名称]* 当前bulid时，会自动把数组当中的所有任务给执行了。* */gulp.task('build',['less','html','js','image','lib']);/*定义server任务* 搭建一个服务器。设置运行的构建目录* */gulp.task('server',['build'],function () &#123; /*设置服务器*/ connect.server(&#123; root:[app.buildPath],//要运行哪个目录 livereload:true, //是否热更新。 port:9999 //端口号 &#125;) /*监听哪些任务*/ gulp.watch('bower_components/**/*',['lib']); gulp.watch(app.srcPath+'**/*.html',['html']); gulp.watch(app.srcPath+'js/**/*.js',['js']); gulp.watch(app.srcPath+'images/**/*',['image']); gulp.watch(app.srcPath+'style/**/*.less',['less']); //通过浏览器把指定的地址 （http://localhost:9999） open('http://localhost:9999');&#125;);/*定义默认任务* 直接执行gulp 会调用的任务* */gulp.task('default',['server']); 通过npm init初始化package.json文件，把项目依赖的gulp插件写入，所需要的插件在&quot;devDependencies&quot;里。然后再把项目所需的文件根据gulpfile.js文件搭建好。如图12345678910111213141516171819202122// package.json&#123; \"name\": \"znsq\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"gulp\": \"^3.9.1\", \"gulp-concat\": \"^2.6.1\", \"gulp-connect\": \"^5.0.0\", \"gulp-cssmin\": \"^0.1.7\", \"gulp-imagemin\": \"^3.2.0\", \"gulp-less\": \"^3.3.0\", \"gulp-uglify\": \"^2.1.2\", \"open\": \"0.0.5\" &#125;&#125; 执行npm install，下载插件。执行bower install,下载项目所需类库框架。此时项目目录然后打开终端，切换到项目目录下，运行命令gulp之后，浏览器会自动打开本地端口localhost:9999。此时项目目录基本上到此已经实现了一个小的工作流程，其中跳过了nvm、npm等可能需要一些时间折腾的部分。下一个话题准备分享一下如何为jQuery贡献自己开发的插件，如何开发自己的jQuery插件，如何自己开发一个类jQuery库，前提是时间允许，囧。","categories":[],"tags":[{"name":"front-end","slug":"front-end","permalink":"http://www.afanail.com/tags/front-end/"},{"name":"auto","slug":"auto","permalink":"http://www.afanail.com/tags/auto/"}]},{"title":"IE7-hack-respond","slug":"IE7-hack-respond","date":"2017-07-22T11:51:28.000Z","updated":"2017-07-22T13:48:07.000Z","comments":true,"path":"2017/07/22/IE7-hack-respond/","link":"","permalink":"http://www.afanail.com/2017/07/22/IE7-hack-respond/","excerpt":"最近收到了几笔打赏，先谢谢这些不知名的小伙伴，然后我关闭打赏功能啦，写博客是为了记录个人的学习工作生活，并没有什么其他用途，哈哈。现在兼容IE系列的应该很少见了，不过如果客户有需求，还是要考虑兼容的，相比前几年要兼容IE6，最近一俩年所接手的项目需求都是兼容IE9+，所以没有办法体会到前人对兼容各种浏览器所做出的努力与付出。首先来说一下项目的需求，要求兼容IE7，并且实现响应式，而且大屏幕和小屏幕的功能不尽相同，大屏幕是pc端尺寸，小屏幕规定在270px~600px之间。","text":"最近收到了几笔打赏，先谢谢这些不知名的小伙伴，然后我关闭打赏功能啦，写博客是为了记录个人的学习工作生活，并没有什么其他用途，哈哈。现在兼容IE系列的应该很少见了，不过如果客户有需求，还是要考虑兼容的，相比前几年要兼容IE6，最近一俩年所接手的项目需求都是兼容IE9+，所以没有办法体会到前人对兼容各种浏览器所做出的努力与付出。首先来说一下项目的需求，要求兼容IE7，并且实现响应式，而且大屏幕和小屏幕的功能不尽相同，大屏幕是pc端尺寸，小屏幕规定在270px~600px之间。兼容IE7+就不要考虑用CSS3的媒介属性了，而且需求时间5天不借助框架情况下实现一套响应式网站，考虑到业务的复杂程度，有点不太现实。你看我的博客换了个响应式的主题，今天改了一天的bug,而且还是用了别人写好的框架，这还是一个简单的业务需求少的网站，可见做一个比较拿的出手的响应式网站是需要费周折的。响应式虽然很火，由于种种原因，也不见得有多少大公司在用，几乎所有都是分成移动、PC俩套来做。先说一下IE7浏览器方面的hack，下面这种hack肯定不少见，特别是在一些大型的网站，一个网页大部分都是这种hack。不过随着技术的更新，相信会出现更好的解决的方法。1234&lt;!--[if lt IE 9]&gt;&lt;script type=\"text/javascript\" src=\"js/html5shiv.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"js/respond.min.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; IE7 hack在IE7下要实现弹性布局,肯定不能使用flexbox布局。古老版本的flexbox布局出现了。当然这只是简单的实现某一部分的功能，肯定不能媲美真正的弹性布局。完整的代码如下，利用浮动以及BFC原理实现了这一功能，兼容IE6+。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;&lt;title&gt;flexbox另一种方式&lt;/title&gt;&lt;style&gt;.dfcont&#123; border:1px solid red; box-sizing:border-box; padding:8px; &#125;.fl&#123; float:left; border:1px solid pink; background:#fff; padding:12px; line-height:26px; &#125;.fr&#123; float:right; border:1px solid yellow; padding:12px; line-height:26px; &#125;.dfafter&#123; line-height:32px; margin-top:12px; text-align:left; background:blue; overflow:hidden; &#125;.clearfix&#123;*zoom:1;&#125;.clearfix:after&#123; content:\"\"; display:block; clear:both; &#125;.dfinner&#123; margin:0 12px; background:darkseagreen; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"dfcont clearfix\"&gt;&lt;div class=\"fl\"&gt;我浮动到左边&lt;Br/&gt;因为脱离文档流所以不受父元素控制&lt;br&gt;&lt;/div&gt;&lt;div class=\"fr\"&gt;我浮动到右边&lt;Br/&gt;同样也不受父元素控制。&lt;br/&gt;&lt;/div&gt;&lt;div class=\"dfafter\"&gt;&lt;div class=\"dfinner\"&gt;我是浮动元素后面内容,我要实现flex特性的功能。我是flex的古老版实现方式。&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; IE7下input的placeholder属性完全失效，亲测最好的解决方法如下,前提条件是项目引用到jQuery库。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!--[if lt IE 10]&gt;&lt;script&gt;$(function()&#123; $(\"input[type!='password'],textarea\").bind(&#123; \"focus\":function()&#123; var placeholderVal = $(this).attr(\"placeholder\"); var realVal = $(this).val(); if($.trim(realVal)==placeholderVal)&#123; $(this).val(\"\"); &#125; &#125;, \"blur\":function()&#123; var placeholderVal = $(this).attr(\"placeholder\"); var realVal = $(this).val(); if($.trim(realVal)==\"\")&#123; $(this).val(placeholderVal); &#125; &#125; &#125;); $(\"input[type!='password'],textarea\").each(function(i,n)&#123; $(this).val($(this).attr(\"placeholder\")); &#125;); $(\"input[type='password']\").bind(&#123; \"focus\":function()&#123; var placeholderVal = $(this).attr(\"placeholder\"); var realVal = $(this).val(); if($.trim(realVal)==placeholderVal)&#123; var copy_this = $(this).clone(true,true); $(copy_this).attr(\"type\",\"password\"); $(copy_this).insertAfter($(this)); $(this).remove(); $(copy_this).val(\"\"); $(copy_this).focus(); &#125; &#125;, \"blur\":function()&#123; var placeholderVal = $(this).attr(\"placeholder\"); var realVal = $(this).val(); if($.trim(realVal)==\"\")&#123; var copy_this = $(this).clone(true,true); $(copy_this).attr(\"type\",\"text\"); $(copy_this).insertAfter($(this)); $(this).remove(); $(copy_this).val(placeholderVal); &#125; &#125; &#125;); $(\"input[type='password']\").each(function(i,n)&#123; var placeHolderVal = $(this).attr(\"placeholder\"); var copy_this = $(this).clone(true,true); $(copy_this).attr(\"type\",\"text\"); $(copy_this).insertAfter($(this)); $(this).remove(); $(copy_this).val(placeHolderVal); &#125;); &#125;);&lt;/script&gt;&lt;![endif]--&gt; IE7下的inline-block、fixed均有问题，具体的hack如下,fixed解决方法过几天再贴上。12345.box &#123; display: inline-block; *display:inline; *zoom:1; &#125; IE7的hack多种多样，以上几种只是常见的，具体可以上caniuse查看搜索，如果你有更好更多的hack，欢迎补充。有的时候写样式用了一天，但是调试兼容用了俩天，这实属颠倒本质，没想到兼容性的问题也真的是令人头疼的问题。 响应式实现响应式有很多种方法，现在最常用的是CSS3的媒介查询，配合respond.js是可以实现兼容IE6+的。但是为什么一开始就不考虑用这个技术呢，首先兼容IE6+并不是全部都支持，还有一些无法功能全部支持，其次需求时间不允许(耦合性强)。那有没有更好的方法呢？肯定是有的。一是用jQuery的load方法，通过判断屏幕尺寸大小加载不同的页面。二是通过js来实现响应式。三是通过判断浏览器的屏幕尺寸，设置浏览器的window.location.href属性值。这三种方式我都亲自测试过，最后个人感觉最有效的方式是通过设置浏览器的window.location.href属性值。第一种方法实质是ajax获取页面内容，存在不安全隐患，如xss攻击，第二种方法要写过多的js脚步来实现。第三种的核心代码如下。1234567891011121314function browserRedirective(url1,url2) &#123;// 获取浏览器宽度 var browserWidth = document.documentElement.clientWidth ? document.documentElement.clientWidth : document.body.clientWidth; if (browserWidth &gt; 270 &amp;&amp; browserWidth &lt; 600 )&#123; window.location.href = url1; &#125; else &#123; // 如果是当前路径，返回。 if (window.location.pathname.indexOf()&gt;-1)&#123; return &#125; window.location.href = url2; &#125;&#125; 通过这种方法，将俩个页面独立为俩个URL，不再考虑响应式之间的耦合性，方便以后各个屏幕尺寸之间的功能扩展。如果你有更好的方法，欢迎补充。忙碌的一周过去了，关于Perl的学习，持续关注perl-learning下一步的计划是利用空闲时间开发个人微信公众号以及个人小程序，O(∩_∩)O谢谢支持！","categories":[],"tags":[{"name":"IE 兼容性","slug":"IE-兼容性","permalink":"http://www.afanail.com/tags/IE-兼容性/"},{"name":"js实现响应式","slug":"js实现响应式","permalink":"http://www.afanail.com/tags/js实现响应式/"}]},{"title":"perl-learning","slug":"perl-learning","date":"2017-07-15T03:25:22.000Z","updated":"2017-07-22T04:11:25.000Z","comments":true,"path":"2017/07/15/perl-learning/","link":"","permalink":"http://www.afanail.com/2017/07/15/perl-learning/","excerpt":"perl 是一门编程语言。因为工作上的原因需要用到perl，这才对perl有了了解。相对JS而言，perl貌似更简单易用。同为脚本语言，perl风靡一时，当下肯定没有JS热门。更多的是用在生信等领域，而JS是随着web2.0的兴起而逐渐壮大，你看ES7都快出来了。先来看一下perl的最基本入门程序。","text":"perl 是一门编程语言。因为工作上的原因需要用到perl，这才对perl有了了解。相对JS而言，perl貌似更简单易用。同为脚本语言，perl风靡一时，当下肯定没有JS热门。更多的是用在生信等领域，而JS是随着web2.0的兴起而逐渐壮大，你看ES7都快出来了。先来看一下perl的最基本入门程序。123456789#!/usr/bin/perlprint \"Hello,world!\\n\"=podlarry 推出了Perl 1 Itermediate Perl 2 Mastering Perl 3 Programming perl 额外练习 《Learning Perl Student Workbook》=cut 其中 #!/usr/bin/perl，意思为perl脚本的默认存放位置是“/usr/bin/perl”；比较新奇的是perl的多行注释： =pod、=cut只能在行首 以=开头，以cut结尾 =后面要紧接一个字符，=cut后面可以不用 关于perl的更多知识，入门推荐 Learning Perl,之后按书籍顺序： 1 Itermediate Perl 2 Mastering Perl 3 Programming perl 让我们再来看一个perl文件， Heredoc技巧。 123456789101112131415161718192021222324252627282930313233#!/usr/bin/perl=pod Heredoc一种在命令行和程序语言里定义一个字串的方法。注意点： 1.必须后接分号；2.END可以用任何语言代替，必须保证开始结束标识一致；3.开始标识不带引号与带引号的作用一样，会解析转义；4.结束标识必须占一行。必须行首开始。5.当内容需要内嵌引号的时候，不需要加转义字符，本身对单双引号转义；=cut$a = 10;$var = &lt;&lt; \"eof\";这是一个Here文档实例，使用双引号。“可以输入双引号”，‘可以输入单引号’；可以在这里输入字符串和变量；例如： a = $a;eofprint \"$var\\n\";$var = &lt;&lt; 'dfc';这是一个单引号的例子；a = $a;dfcprint \"$var\\n\";# perl Heredoc变量可以重复,例如上面的$var;# perl 用反斜线来转义$res = \"zjf\";print \"$res\\n\";print '$res\\n';# perl标识符与其他编程语言一样； 这也是比较新奇的技巧。在我学习perl的过程，我会把学习代码放到仓库perl-learning，欢迎莅临指导。","categories":[],"tags":[{"name":"perl","slug":"perl","permalink":"http://www.afanail.com/tags/perl/"}]},{"title":"教你如何巧妙解决网页乱码","slug":"教你如何巧妙解决网页乱码","date":"2017-06-28T11:34:04.000Z","updated":"2017-07-22T03:54:52.000Z","comments":true,"path":"2017/06/28/教你如何巧妙解决网页乱码/","link":"","permalink":"http://www.afanail.com/2017/06/28/教你如何巧妙解决网页乱码/","excerpt":"约定俗成不是好的标准，却是近似好的标准。 我们编写好的html文件，在浏览器显示往往会乱码，这就是编码格式的问题。在约定情况下，通常默认utf-8编码格式。但是，有一些有一定历史的公司，比如网易，我们可以看到它的编码格式是简体中文，也就是国标编码2312,简称gb2312。","text":"约定俗成不是好的标准，却是近似好的标准。 我们编写好的html文件，在浏览器显示往往会乱码，这就是编码格式的问题。在约定情况下，通常默认utf-8编码格式。但是，有一些有一定历史的公司，比如网易，我们可以看到它的编码格式是简体中文，也就是国标编码2312,简称gb2312。 如果你这个时候把编码格式设置为其它的呢？相信你会看到一些似懂非懂的文字。我就比较好奇试了一下。 结果不出意料，果然乱码了。从这个小细节，我们引出了一个问题。当前后台没有约定编码格式（可能是新来的傻傻的认为编码格式都是utf-8），这时候编码格式就不一样了。就像上面出现的情况一样。可能你会像我一样去修改html文件的meta标签，设置chartset与后台一样的编码格式，然后再返回给后台，但是你会发现居然没有什么毛线效果，该乱码还是乱码。然后我们百度、谷歌的方法也不一定有用，这个时候你会怀疑是不是遇到了什么天大的难题了。 其实解决的方法很简单，简单到我们都没有想到。在webstrom下，右下角有个很明显的 utf-8 可选项，点击它，如下图所示。选择你们约定好的编码格式，这个问题也就到此为止了。 其实这只是一个很小的细节，但是引发出来的问题还是不少的，比如网页上的某个标签的编码格式与整体的页面不一致该如何设置，在IE6浏览器的环境下又该如何设置，这些可能都是我们会遇到的问题。你都知道怎么解决吗？ 诚然，好的规范需要共同约定，需要共同遵守！","categories":[],"tags":[{"name":"编码格式","slug":"编码格式","permalink":"http://www.afanail.com/tags/编码格式/"}]},{"title":"抓住17年的尾巴","slug":"抓住17年的尾巴","date":"2017-06-17T15:44:23.000Z","updated":"2017-07-22T03:53:34.000Z","comments":true,"path":"2017/06/17/抓住17年的尾巴/","link":"","permalink":"http://www.afanail.com/2017/06/17/抓住17年的尾巴/","excerpt":"17年也要结束了，一切来的那么快。年前的计划是否实现了,这显然没有那么重要了。还有半年的时间，切忌不要等到赶着时间去抓17年的尾巴。","text":"17年也要结束了，一切来的那么快。年前的计划是否实现了,这显然没有那么重要了。还有半年的时间，切忌不要等到赶着时间去抓17年的尾巴。 new Date 关于工作，就像标题一样，一切都是新的时间对象。跳槽来到了一家只有我一个前端的公司，所以一切几乎等同于从零开始。对一个东西有很深感情，很多不是因为一见钟情，很多不是因为互相喜欢，而是从一开始到结束，从浅到深，慢慢培养的感情。而我们似乎都急于求成，感情上如此，生活亦是。 once super 一个人的团队可以干些什么？这似乎是一道双向的数据绑定题。首先，赋予我们极大的自由，可以运用自己热衷并且擅长的技术，可以调动自己的创造性，极大可能的挖掘自己的潜能。从前端代码规范，前端工程自动化，前端技术选型，似乎可以任君胡作非为一番了。前人栽树，后人乘凉。还是要妥当才好。团队不可能永远一个人，你不是一个人在战斗。你只是暂时一个人代表一个团队在战斗。你会慢慢喜欢上你从无到有的团队的，请坚信这一点。单枪匹马与千军万马孰优孰劣一目了然。 make kludeg 然而，一切有想象中的那么自由吗？往往限制自己的就是我们自己。你似乎已经忘记团队的存在了，这才是多么可怕的事情。所以事情没有想的那么容易。但是也没有想象中的那么困难。这个流动性大的环境下，时刻做好准备才是硬道理。你看前端框架更新多快，就知道流动性有多大了。所以真的有必要去重构之前的一些代码吗？还是标注kludeg让接下来的开发者谨慎注意某些复杂的代码片段。有一些10几年的老项目，存在是有它的道理的。新的东西不一定好，旧的东西不一定会被淘汰。往往要看当权者如何折中了。不要为了前端而前端，好像就是这个理。 web browser 我曾经是一度的希望，会不会有个大神上的大神，出来一统前端，破解今日百家争艳的局面。更希望哪个web browser能够并购所有browser，IE也行，Chrome也罢。这样就不会有兼容性，就不会有纷呈复杂的前端技术了。现在想想，才知道自己那时候是多么幼稚。也正是因为如此，前端才变得更具挑战性，未来才更加不确定性，更加富有往各种方向发展的可能性。想想垄断，是多么可怕的词。如今的局面，可能都是最好的安排。 catch 17end 不管什么局面，都是时间的积累造就的，没有人能够一蹴而就。生活如此，感情亦是。太快了，反而更需要花时间沉淀。Because，one day, when you review your code and project, you would doubt that how stupid to gulp this. 本来今天想早点睡觉的，没想到又快到凌晨1点多了，黑眼圈也是需要时间积累的，大概我的黑眼圈就是这样来的吧。刚好今天是父亲节，好久没有给父亲打电话了。想一想，应该是从来没有给父亲打过真正意义上的电话。父亲实在太辛苦了，一个人要赚钱养8口人的大家庭。我们兄弟姐妹从来与父亲不来电，不谈心事，不谈生活，不谈其它，因为是母亲承担了这些孩子成长上琐碎的事情。我们心里都明白，父亲是知道孩子成长道路上琐碎的事情的，甚至比母亲还上心。可是生活造就了一切，有的人就是默默无闻的付出，得到的也不是掷地有声的回报。但是，这默默无闻付出的背后，你可曾知道这也是无时无刻幸福与满足交织涌向心头，胜过千倍万倍娇弱做作的我爱你！","categories":[],"tags":[{"name":"工作计划","slug":"工作计划","permalink":"http://www.afanail.com/tags/工作计划/"}]},{"title":"less小技巧","slug":"less小技巧","date":"2017-06-16T14:23:03.000Z","updated":"2017-06-16T15:04:41.000Z","comments":true,"path":"2017/06/16/less小技巧/","link":"","permalink":"http://www.afanail.com/2017/06/16/less小技巧/","excerpt":"后端转前端，或者UI转前端，往往会写不好css，有没有一种可以像写函数式编程那样对方法来编写css，答案是有的，比如less、sass、stylus等。 什么是less？ 这里不多说，请看中文网介绍less中文网。","text":"后端转前端，或者UI转前端，往往会写不好css，有没有一种可以像写函数式编程那样对方法来编写css，答案是有的，比如less、sass、stylus等。 什么是less？ 这里不多说，请看中文网介绍less中文网。 我个人对less、sass、stylus对理解，简单对概括为：让css更接近编程语言。 less是最容易上手对，如果你使用less一段时间，发现会爱不释手。因为它更接近编程思维，优点多多。 less技巧 就拿移动端来举例子，我们常用像素单位rem,可以很好的适配各种机型的屏幕。首先通过设置js让html元素的字体大小随着屏幕大小的改变而改变。 123var font = window.screen.width / 10 + 'px'; console.log(font); document.getElementsByTagName('html')[0].style.fontSize = font; 通过less的unit函数转化属性值的单位，定义函数.fs、.w… @px是一个变量也是一个参数,我们可以在调用它的时候给它传递实际参数。下面是移动开发时候经常使用的函数，仅供参考。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/*把像素转成rem 375/10 = 37.5 375 它是ipone6的屏幕宽度*///默认是20px.fs(@px:20px)&#123; font-size: unit(@px/37.5,rem);&#125;.w(@px)&#123; width: unit(@px/37.5,rem);&#125;.h(@px)&#123; height: unit(@px/37.5,rem);&#125;.lh(@px)&#123; line-height: unit(@px/37.5,rem);&#125;.pl(@px)&#123; padding-left: unit(@px/37.5,rem);&#125;.pr(@px)&#123; padding-right: unit(@px/37.5,rem);&#125;.pt(@px)&#123; padding-top: unit(@px/37.5,rem);&#125;.pb(@px)&#123; padding-bottom: unit(@px/37.5,rem);&#125;.mt(@px)&#123; margin-top:unit(@px/37.5,rem);;&#125;.mb(@px)&#123; margin-bottom:unit(@px/37.5,rem);&#125;.ml(@px)&#123; margin-left:unit(@px/37.5,rem);&#125;.mr(@px)&#123; margin-right:unit(@px/37.5,rem);&#125;.top(@px)&#123; top:unit(@px/37.5,rem);&#125;.bottom(@px)&#123; bottom:unit(@px/37.5,rem);&#125;.left(@px)&#123; left:unit(@px/37.5,rem);&#125;.right(@px)&#123; right:unit(@px/37.5,rem);&#125;.padding(@tb,@lr)&#123; padding: unit(@tb/37.5,rem) unit(@lr/37.5,rem);;&#125;.fl&#123; float: left;&#125;.fr&#123; float: right;&#125;.clearfix&#123; clear: both;&#125; 可复用属性提取重复属性，定义一个函数。可在内部和外部调用。1234567891011121314151617div&#123;//不会被编译btn () &#123;background: #000;color: #888;&#125;header &#123;//内部调用 btn; ...&#125;&#125;footer&#123;// 外部调用 div &gt; btn;&#125; 关于less的技巧还有很多很多，这里只是简单提了一下。孰能生巧，多用就会了。sass、stylus其实跟less都一样，语法也很相似。当你学会less，你就基本掌握了sass、stylus，何乐而不为呢？","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://www.afanail.com/tags/css/"},{"name":"less","slug":"less","permalink":"http://www.afanail.com/tags/less/"}]},{"title":"NBA总决赛G3","slug":"NBA总决赛G3","date":"2017-06-08T04:04:05.000Z","updated":"2017-07-22T03:52:08.000Z","comments":true,"path":"2017/06/08/NBA总决赛G3/","link":"","permalink":"http://www.afanail.com/2017/06/08/NBA总决赛G3/","excerpt":"今天的比赛可能是整个系列赛最精彩的一场了。双方教练斗智斗勇，场上球员各显神通。最终勇士队以118-113击败骑士队涉险过关。","text":"今天的比赛可能是整个系列赛最精彩的一场了。双方教练斗智斗勇，场上球员各显神通。最终勇士队以118-113击败骑士队涉险过关。回到主场，这是骑士必须拿下的比赛，而勇士也是有备而来，双方球员必须使出浑身解数，争取拿下比赛。前俩场，库里和杜兰特发挥特别出色。克莱汤普森由于身担防守欧文的重责，进攻端发挥有所失常。依靠勇士强大的整体，勇士前俩场刀不血刃的拿下了比赛。 第三场比赛，骑士明显有了针对性的调整，从场上球员的站队以及跑位，可以看到库里明显被夹击了。骑士队的战术执行的很坚决，一方面三分线外夹击库里，一方面协防杜兰特，限制勇士俩大进攻点的发挥。克莱汤普森受益于骑士队的战术，当库里和杜兰特被对方狠狠的盯死的时候，汤普森多出了很多的空位，所以汤普森今天的爆发是意料之中的。 再说说今天骑士队的詹姆斯，上半场火力全开，得了27分，14投11中，4篮板3助攻。特别是第一节的詹姆斯，10投9中。几乎一个人对抗整支勇士队。真所谓吕布战群英，精彩绝伦。下半场勇士队立马就走出了调整，多次让杜兰特去防守詹姆斯，可是没想到，欧文这时候站了出来，各种不可思议的突破，各种鬼魅的神仙球。借助欧文神奇的发挥，第三节骑士队终于实现了比分的反超。 进入比赛关键的第四节，勇士队先排上替补阵容，保证主力队员的休息时间。这是骑士队必须拿下的比赛，主力球员是要战斗到最后时刻了。比分一直是骑士领先，勇士队替补阵容很好的完成的战术作用。比赛还剩下最后的6分钟左右的时间时候，科尔令旗一挥，勇士队熟悉的死亡五小上阵。最厉害的总是最后出场的，果不其然，勇士队慢慢的缩小了比分。 直到比赛还剩下48秒左右，勇士队111：113落后骑士队俩分，杜兰特控球从后场到前场，当所有人都以为勇士队会叫暂停布置一次成功的战术都时候。杜兰特做出了一个令人想不到的选择，顶着詹姆斯的防守，双眼紧紧盯着篮筐，无视詹姆斯，仿佛全世界只有篮球、篮筐，还有那投出篮球一刻在空中划过的闪耀全世界的弧线，当球坠入篮筐那一刻，杀神降临，杜兰特归位。在这历史的一刻，杜兰特用行动证明了他的价值，证明了他可能才是这个星球上打篮球最好的人。 最终比赛的数据：腾讯NBA数据库","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.afanail.com/tags/随笔/"}]},{"title":"愿世间没有。。。","slug":"愿世间没有...","date":"2017-05-28T16:00:00.000Z","updated":"2017-07-22T03:54:29.000Z","comments":true,"path":"2017/05/29/愿世间没有.../","link":"","permalink":"http://www.afanail.com/2017/05/29/愿世间没有.../","excerpt":"活了大概五分之一的人生以上，从来没有一天像今天这样的心情。如果可以，愿世间没有。。。","text":"活了大概五分之一的人生以上，从来没有一天像今天这样的心情。如果可以，愿世间没有。。。 我爷爷属牛。原谅我不知道今年多少岁，只是最接近百岁的那一只牛。很多人不理解为什么人会老，为什么人会死。就像人一样，为什么会是人。可能这就是一直以来的不可违背的伦理。这个世界千千万万人，如果有那么一个俩个人，不为人知的一直活在我们不知道的空间里。监视着我们，直到我们快老去，我们快不为人知。那个一直不为人知的一俩个人，会不会出来跟你说：“嘿！欢迎来到不为人知的世界！这个世界无比真挚的欢迎来自人间的你！“。如果存在这样的事情，那么不为人知就显得有一些廉价了。我们都相信这个世界的确有这么一俩个人，谁敢说不是呢？如果可以，愿世间没有这样不为人知的一俩个人！ 记得我在很小的时候，我是什么都不懂。每天跟着爷爷，有糖吃，特别喜欢粘着爷爷。农村的街道很宽很干净很少人，爷爷的自行车很高很稳很响亮。”玲玲玲“，那时候的车玲显得格外悦耳，格外动听。我就坐在车头，是那个白白胖胖的无所畏惧的无敌小小子。那时候的天空很蓝，白云很白，清风很轻，人也格外舒坦。爷爷骑着车，在乡间田园的路上，有小草野花，有流水小船，有深处人家。哼着歌，响着铃铛，喀拉拉，无比轻盈的轮滑，留下一道道岁月的痕迹，让我去追寻，去回忆。如果可以，愿世间没有追寻，没有回忆。 不知道我是从什么时候开始懂事，可能是体毛初长的时候，也可能是情窦初开的时候。一瞬间，也可能是所有瞬间堆积成的一瞬间，反正在不知不觉的某一刻，我们就开始懂事了。明白了爸妈为什么早出晚回，明白了爷爷奶奶为什么还下地干活。农村的五伏天，天天热辣，天天背朝黄天。没有空调，没有风扇，只有夏天的树，芭蕉做的扇。我喜欢芭蕉扇，喜欢夏天的树，一直一直。爷爷说，夏天是收割的季节，天气要热些好，稻谷才好晒些，最怕这个季节的风台了。咱们农民是靠天靠地吃饭，要感谢有现在的天和地。我有些懂事了，认为爷爷说的对。如果可以，愿世间没有天地，我们可以靠自己。 后来，我长大了。我也不知道什么时候长大的，可能是第一次失恋，可能是第一次初恋。无所谓了，反正你的年龄决定你长大了。我离开了家，上了高中，集体宿舍。都是农村的娃娃，显得特别好相处。这是我们镇最好的高中，也是我们镇最坏的高中，也是我们镇唯一的高中。我在这里度过了三年，改变了我许多。人都是慢慢变化的，我也是。在这里，有很多学生，我只认识我宿舍的，我班级的，还有一俩个我心底里默默喜欢的女生。我们读书不老好，打篮球却是十分热爱，逃课打篮球是经常的事情。更有甚者，有年级默认的联盟，有球队。这太影响我了，我默默长大了。高考了，为了高考而高考了。老师都说一本是好的，二本也是好的。但是专业呢？没有人敢和你说读那个专业是好的，敷衍一句兴趣吧。导致很多人读了十几年书，专业是最后一刻才确定的，也有乱写的，比如我。那么问题来了，这样往往会出事的，事实却是如此。我很茫。爷爷说，娃娃，没事的，抗日我也抗过了，去吧，河南并不老远！好好读就是了！如果可以，愿世间没有距离，没有远离。 再后来，我上了大学。但是我却没有好好读。或者说，好好读不如读好好。浪费了大把青春时光。想追回，不知谈何说起。我爱我的大学，虽然自知无力去爱。总会有人说重来一次怎样怎样，还是这样。你不是不相信科学，而是有一种力量叫做冥冥之中的注定。失去的就是失去的，也许会回来，也许回不来，而我们还执拗个啥，执拗个啥。放不下的，却是最远久的过。过去的，却是最降近的未来。最悲哀的是，在这最将近的未来，你不知道执拗个啥，执拗个啥！如果可以，愿世间没有失去，唯有珍惜！ 端午节，爷爷身体不好，百岁将近。人是不都有这么一刻，年轻的时候不知道为什么，年老的时候也不知道为什么，人就是会这样子！？我们拼搏，我们奋斗，我们努力，我们终究只是时间的产物，一刻一秒，若有若无，化作灰烬。如果可以，愿世间没有时间，只有永恒！ 我还是那个我，你也是。只不过我们多了一个理由，去拥有更美好的世界！那就是，如果可以，你也可以！！！","categories":[],"tags":[{"name":"-随笔","slug":"随笔","permalink":"http://www.afanail.com/tags/随笔/"}]},{"title":"ES7--大势所趋","slug":"ES7-大势所趋","date":"2017-05-25T16:20:21.000Z","updated":"2017-07-22T03:53:08.000Z","comments":true,"path":"2017/05/26/ES7-大势所趋/","link":"","permalink":"http://www.afanail.com/2017/05/26/ES7-大势所趋/","excerpt":"最快的是，技术的更新；最慢的是，更新的应用。 也许你已经厌烦JavaScript的回调，虽然快，但是异步。老司机可能会发现JavaScript貌似很在意一个问题，那就是如何解决异步。","text":"最快的是，技术的更新；最慢的是，更新的应用。 也许你已经厌烦JavaScript的回调，虽然快，但是异步。老司机可能会发现JavaScript貌似很在意一个问题，那就是如何解决异步。一开始我们写回调函数callback，总是深深的被包含在花括号中，无法自拔。这种嵌套的结构一来不易于代码的维护，二来容易出错。相信经历过的人都知道。12//伪代码&#123;&#123;&#123;&#123;callback()&#125;&#125;&#125;&#125; 直到有一天，承诺（promise）出现了，生成器（generator）出现了。这里的promise，让异步可以以同步的方式实现。教程有很多，这里不细讲了，总之写起来很麻烦。反正我是觉得写起来比生成器麻烦。 其实JavaScript的生成器很大程度上借鉴了Python的生成器，学过Python的人都知道。但是生成器不是用来解决异步的，但是生成器却能用来解决异步。生成器更像一种语法糖，把你返回的值存储起来，直到调用才暴露出来，这也是它能解决异步的原因之一。 现在，你去看很多源码的时候，好奇的发现async和await，这俩货究竟是什么东西啊？紧跟标题，大势所趋的ES7。借用koa中最常见的代码块来看1234567app.use(async (ctx, next) =&gt; &#123; if (ctx.request.path === '/error') &#123; ctx.response.body = 'ERROR page'; &#125; else &#123; await next(); &#125;&#125;) 这里的async相当于middleware，await的作用是调用下一个middleware。如果之前对回调了解不是很深刻，可能会比较蒙，await通过next（）调用回调，解决了异步。当然，我在这里解释的也不是很清楚，如果想深入了解，可上GitHub。","categories":[],"tags":[{"name":"ES7","slug":"ES7","permalink":"http://www.afanail.com/tags/ES7/"}]},{"title":"Google I/O 2017 for front-end development","slug":"Google-I-O-2017-for-front-end-development","date":"2017-05-18T17:41:15.000Z","updated":"2017-07-22T03:53:05.000Z","comments":true,"path":"2017/05/19/Google-I-O-2017-for-front-end-development/","link":"","permalink":"http://www.afanail.com/2017/05/19/Google-I-O-2017-for-front-end-development/","excerpt":"不知道下一年，世界又会是哪个科技引领潮流。 web componentTwitter和来自印度的Ola，现场展示了modern mobile webApp。虽然组件化的框架polymer从15年开始已经发布，但是polymer框架2.0现在才进入预发布状态。work box的出现很大程度上弥补了server work的不足。so will polymer be a competitor to react? 好吧，welcome back polymer! React is a JavaScript framwork for rendering HTML! React is not certainly not Web Components.","text":"不知道下一年，世界又会是哪个科技引领潮流。 web componentTwitter和来自印度的Ola，现场展示了modern mobile webApp。虽然组件化的框架polymer从15年开始已经发布，但是polymer框架2.0现在才进入预发布状态。work box的出现很大程度上弥补了server work的不足。so will polymer be a competitor to react? 好吧，welcome back polymer! React is a JavaScript framwork for rendering HTML! React is not certainly not Web Components.add webApp to home screen, 然后和native app做对比，从数据流量，媒介，手机流畅度等方面介绍webApp。progressive web app越来越受欢迎。未来web领域可能与VR结合，但是未来一起不可预料，又可以想象。 front-end developers 现在可以让自己的website试用谷歌的 AMP-bind and PWA接口。这无疑给front-end developer多一种新的选择去构建自己的progressive web app。 看完第一场演讲，深觉印度的IT行业发展之快。感触良多，未来不可预料，又可以想象！","categories":[],"tags":[{"name":"Google I/O 2017","slug":"Google-I-O-2017","permalink":"http://www.afanail.com/tags/Google-I-O-2017/"},{"name":"随笔","slug":"随笔","permalink":"http://www.afanail.com/tags/随笔/"}]},{"title":"Webpack2.x踩坑与总结","slug":"webpack-之路","date":"2017-02-12T11:13:12.000Z","updated":"2017-05-22T11:28:48.000Z","comments":true,"path":"2017/02/12/webpack-之路/","link":"","permalink":"http://www.afanail.com/2017/02/12/webpack-之路/","excerpt":"本地安装npm包后如何在命令行运行 在npm安装包的时候，如果使用全局安装，即npm install -g，则在安装完成后可以在终端运行作为命令去运行，但是如果是本地安装的包npm install –save-dev ，则无法这样直接运行。那么如何运行本地安装的包呢？首先进入项目目录（即package.json所在目录），然后使用以下命令即可运行：1$ node_modules/.bin/&lt;packageName&gt;","text":"本地安装npm包后如何在命令行运行 在npm安装包的时候，如果使用全局安装，即npm install -g，则在安装完成后可以在终端运行作为命令去运行，但是如果是本地安装的包npm install –save-dev ，则无法这样直接运行。那么如何运行本地安装的包呢？首先进入项目目录（即package.json所在目录），然后使用以下命令即可运行：1$ node_modules/.bin/&lt;packageName&gt; 除了可以这样在命令行运行外，还可以在文件中运行123//index.jslet webpack = require('webpack');webpack(); 1$ node index.js webpack1.x升级2.x 1.module.loaders改成了module.rules旧的loaders被新的rules取代，后者允许配置loader以及其他更多项。123456789101112131415161718192021222324252627module: &#123; loaders: [ rules: [ &#123; test: /\\.css$/, loaders: [ use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\", query: &#123; options: &#123; modules: true &#125; ] &#125;, &#123; test: /\\.jsx$/, loader: \"babel-loader\", // Do not use \"use\" here options: &#123; // ... &#125; &#125; ]&#125; 以上写法中，Rule.loader是Rule.use: [ { loader } ]的简写。 2.链式调用loaders在webpack1.x中loaders可以链式调用，在2.x中依旧有该特性，使用rule.use配置项，use中设置一个loaders的数组而在1.x中使用!连接各个loader，旧版写法只有在使用旧的module.loaders时有效。123456789101112module: &#123; loaders: &#123; rules: &#123; test: /\\.less$/, loader: \"style-loader!css-loader!less-loader\" use: [ \"style-loader\", \"css-loader\", \"less-loader\" ] &#125;&#125; 3.取消在模块中自动添加-loader后缀webpack2.x中不再添加-loader1234567891011121314module: &#123; rules: [ &#123; use: [ \"style\", \"style-loader\", \"css\", \"css-loader\", \"less\", \"less-loader\", ] &#125; ]&#125; 根据官方说法，做出这样更改的原因是省略-loader会对新手造成误解，所以去掉这个功能，如果想打开这个旧的功能，可以配置resolveLoader.moduleExtensions，但是并不推荐这么做。123resolveLoader: &#123; moduleExtensions: [\"-loader\"] &#125; 4.使用options配置loader在webpack1.x中可以通过webpack.config.js的自定义属性来配置loader，这在webpack2.x中无法执行12345678910111213141516171819202122module.exports = &#123; ... module: &#123; use: [&#123; test: /\\.tsx?$/, loader: 'ts-loader' &#125;] &#125;, // does not work with webpack 2 ts: &#123; transpileOnly: false &#125; &#125;//webpack2 use optionsmodule.exports = &#123; ... module: &#123; use: [&#123; test: /\\.tsx?$/, loader: 'ts-loader' options: &#123; transpileOnly: false &#125; &#125;] &#125;&#125; webpack插件的使用 webpack-dev-server1.x升级2.x 1.在CLI使用的时候，–inline默认开启，无需在输入命令时添加 2.删除contentBase用proxy代替 3.减少控制台无用输出，在1.x中，当我们停掉服务器后，控制台会一直输出错误信息，但是在2.x中只会输出[WDS] Disconnected! extract-text-webpack-plugin 在使用webpack将vue_spa打包后，并不会出现css，因为css被打包入build.js，如果从vue组件中抽离出css，需要安装插件extract-text-webpack-plugin，在使用的时候需要配合v2版本的才可以使用（如果使用了webpack2，则对应的插件版本都需要用v2版本）。具体配置如下：1234567891011121314151617181920212223module:&#123; rules:[ &#123; test: /\\.vue$/, loader: 'vue', options: &#123; loaders:&#123; css: extractTextPlugin.extract(&#123; loader: 'css-loader', fallbackLoader: 'vue-style-loader' &#125;) &#125; &#125; &#125; ]&#125;,plugins: [ new webpack.HotModuleReplacementPlugin(), new extractTextPlugin(&#123; filename:'/style.css', allChunks:true &#125;)] 在options中：options.loader: string | object | loader[] (必填项) 这里的 loader(s) 用于将资源转换为css导出模块options.fallbackLoader: string | object | loader[] 当css没有被导出的时候这里的 loader(s) 会被使用 （即当在plugins模块中设置allChunks:false的时候）在plugins中：filename：可以设置被导出的css文件的路径以及名字allChunks：从所有附加块中提取（默认情况下，它只从初始块中提取）html-webpack-plugin12345plugins: [ new htmlWwebpackPlugin(&#123; filename: 'assets/admin.html' &#125;),] title：用于生成文档的documentfilename：要注入的html文件，默认为index.html。可以自定义（例如：assets/admin.html）inject：true | ‘head’ | ‘body’ | false将资源注入所给的template或templateContent，当设置为 true 或者 ‘body’，所有的资源会被注入到body底部。而head则会将js放到headelementfavicon: 在输出的html中添加faviconhash: true | false 如果为true，则将一个唯一的webpack编译散列附加到所有包含的脚本和CSS文件。这对缓存清除很有用。cache: true | false 如果为true（默认），尝试仅在更改后才发出文件。是否要更换preset？webpack2.x默认支持es6的模块，所以在编译时候没有必要将它们先转换为CommonJS模块再处理，所以在github中出现了babel-preset-es2015-webpack，但是这个模块我在使用的时候出现了Cannot remove ‘babel-plugin-transform-es2015-modules-commonjs’ from the plugin list.的问题，根据babel-preset-es2015-webpack中的叙述以及issues#14可知，babel-preset-es2015已经支持不转换模块中的import和export，只需要设置.babelrc12345678910&#123; \"presets\": [ [ \"es2015\", &#123; \"modules\": false &#125; ] ]&#125; 使用CommonsChunkPlugin将第三方库单独打包 很多情况下我们会引入第三方库，但是默认情况下，webpack会将第三方库与我们自己写的js一起打包进生成文件中，为了让第三方库与我们自己写的js分开，webpack2.x内置一个插件CommonsChunkPlugin，它可以让webpack在打包的时候将我们自己写的js与第三方库分开，具体用法如下：12345678910111213141516171819entry:&#123; app: './src/main.js', vendor: [ 'lodash', 'axios', 'vue', 'vue-router' ]&#125;,output: &#123; path: path.resolve(__dirname + '/dist'), publicPath: '/dist', filename: '[name].js'&#125;,plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name:'vendor' &#125;)] 这里需要注意一点，这里在在输出的时候需要使用filename: ‘[name].js’，否则会报错。 原文出处：Webpack2.x踩坑与总结","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://www.afanail.com/tags/Webpack/"}]},{"title":"JavaScript简明教程（全）","slug":"javaScript简明教程（全）","date":"2016-12-29T05:37:19.000Z","updated":"2017-07-22T03:52:56.000Z","comments":true,"path":"2016/12/29/javaScript简明教程（全）/","link":"","permalink":"http://www.afanail.com/2016/12/29/javaScript简明教程（全）/","excerpt":"JavaScript与Java没有半毛钱关系，网景公司员工Brendan Eich用了10天时间设计了JavaScript语言。 JavaScript的范围JavaScript的范围：BOM + DOM + ECMAScript BOM简单说明123456BOM即Browser Object Mode,浏览器对象模型。BOM提供了独立于内容而与浏览器窗口进行交互的对象。BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。因为BOM主要用于管理窗口与窗口之间的通信，因此其核心对象是window。BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C。BOM结构体系","text":"JavaScript与Java没有半毛钱关系，网景公司员工Brendan Eich用了10天时间设计了JavaScript语言。 JavaScript的范围JavaScript的范围：BOM + DOM + ECMAScript BOM简单说明123456BOM即Browser Object Mode,浏览器对象模型。BOM提供了独立于内容而与浏览器窗口进行交互的对象。BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。因为BOM主要用于管理窗口与窗口之间的通信，因此其核心对象是window。BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C。BOM结构体系 DOM简单说明12345DOM即Document Object Model，文档对象模型。当网页被加载时，浏览器会创建页面的文档对象模型，即DOM。DOM(文档对象模型)被构造为对象的树。DOM由一系列相关的对象构成，引申为Document对象。DOM的标准化组织是W3C。 ECMAScript简单说明123456789ECMAScript指代JavaScript的核心语法。JavaScript 由 Brendan Eich 发明。JavaScript于1995 年出现在 Netscape 中于 1997 年被 ECMA（一个标准协会）采纳。语法核心：变量基本数据类型对象类型结构(循环|条件|判断)面向对象 javascript语法javascript数据类型基本类型（简单数据类型） * string * number * boolean * undefined * null 复杂类型（复杂数据类型） * Object * Array * Date * RegExp * Function * String * Number * Boolean * null * Math javascript部分操作符的说明一元操作符只能够操作一个值的操作符叫做一元操作符。① 递增和递减操作符:12345678910[01] 前置型,递增和递减操作在包含他们的语句被求值之前就执行。[02] 后置型,递增和递减操作在包含他们的语句被求值之后才执行。var num1 = 2;var num2 = 20;var num3 = --num1 + num2; //21var num4 = num1 + num2; //21var num1 = 2;var num2 = 20;var num3 = num1-- + num2; //22var num4 = num1 + num2; //21 ② 一元加和减操作符:一元加操作符对结果不会有任何的影响。一元减操作符主要用于表示负数。 位操作符01 按位非(NOT):使用 ~ 表示，执行按位非的结果就是返回数值的反码。操作数的负值减去1。123var num1 = 25;var num2 = -num1 - 1; //-26consol.log(~num1) //-26 02 按位与(AND):使用&amp;表示，操作两个操作数。只要有0就为0。03 按位或(OR):使用|表示，操作两个操作数。只要有1就为1。04 按位异或(XOR):使用 ^ 表示，操作两个操作数。相同则为0，不同则为1。05 左移|右移(|有符号|无符号)。 布尔操作符 布尔操作符一共有三个，分别是：非、与、或。 01 逻辑非，符号：！ 说明：取反，可应用于任何值，！！相当于没有操作。02 逻辑与，符号：&amp;&amp; 说明：两个值都为真的时候，结果为真。属于短路操作，如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。03 逻辑或，符号：||说明：两个值只要有一个为真，那么结果为真。属于短路操作，如果第一个操作数为真，那么就不会再对第二个操作数求值了。技巧：可以利用逻辑或短路操作的特点来避免为变量赋null或undefined值。123var myObject = refObject || backupObject;//如果refObject的值不是null,那么它的值将被赋值给myObject//如果是null,那么就将backupObject的值赋值给myObject。 乘性操作符乘 *除 /模 % 加性操作符加 +减 - 说明：上述五种操作符在操作数为非数值的时候内部会执行自动的类型转换。 关系操作符大于 &gt;小于 &lt;小于等于 &lt;=大于等于 &gt;=说明：返回布尔类型的值，要么为false，要么为true。 相等操作符01 相等和不相等[先转换再比较]，符号是 == 和！=比较的规则:[01] 如果操作数中有布尔值，则先转换为数值再比较。[02] 如果是字符串和数值比较，则先将字符串转换为数值再比较。[03] 如果是对象和其他类型的值比较，则先调用对象的valueOf方法，然后用得到的基本类型值去比较。[04] null和undefined是相等的。[05] NaN和NaN不相等。[06] 如果两个操作符都是对象，则比较他们是不是同一个对象，如果指向的是同一个对象则返回true，否则返回false。02 全等和不全等[仅比较不转换],符号是===和!==比较的规则:[01] null和undefined是不全等的，因为它们是不同类型的值。[02] 类型相同，且值相等，则返回true，否则返回false。 条件操作符符号：表达式1 ? 字面量1 ：字面量2说明：如果表达式1的结果为true，则使用字面量1，否则使用字面量2。 赋值操作符符号：=、+=、-=、*=、&lt;&lt;=等等说明：使用赋值操作符对性能而言，没有任何的提升，只是简化了赋值操作而已。 值类型和引用类型01 值类型和引用类型简单说明值类型主要有：12345数值字符串布尔类型undefinednull 引用类型主要有：123对象（Object类型）数组（Array）函数 (Function) 值类型：保存为简单的数据值，赋值只是简单的数据值的复制引用类型:保存为对象，其本质是指向内存位置的引用(地址)，赋值是对地址的复制值类型代码示例1234567var num1 = 10;var num2 = num1; //把num1的值复制一份给num2,num1和num2的值相等,除此之外没有任何其他关系console.log(num1,num2); //10,10console.log(num1 == num2); //truenum2 = 20; //修改num2的值为20,不会对num1产生任何的影响console.log(num1,num2); //10,20console.log(num1 == num2); //false 引用类型代码示例12345678910111213var arr1 = [1,2,3];var arr2 = arr1;console.log(arr1,arr2); //[1,2,3],[1,2,3]console.log(arr1 == arr2); //truevar arr3 = [1,2,3];console.log(arr3); //[1,2,3]console.log(arr1 == arr3,arr2 == arr3); //false,false/** * 代码说明: * arr1和arr2在比较的时候,值相等(都是[1,2,3]),且引用相等(都指向堆中同一块数据),因此arr1和arr2相等 * arr3和arr1以及arr2比较的时候,值相等([1,2,3]),但是引用不相等(arr3指向的是堆中另外一块数据),因此不等 * 总结:引用类型在比较相等的时候,只有值和引用都相等才相等 * */ 02 值类型和引用类型的赋值赋值操作(=):把当前变量存储的值复制一份给接收的变量。值类型的赋值:把当前变量存储的值(具体的数据)复制一份给接收的变量。引用类型的赋值:把当前变量存储的值(具体数据的引用即地址)复制一份给接收的变量。12345678//引用类型使用注意 console.log(arr1,arr2); //[1,2,3],[1,2,3]; console.log(arr1 == arr2); //true arr1.push(4); console.log(arr1,arr2); //[1,2,3,4],[1,2,3,4] /** * 代码说明:因为arr1和arr2内部的引用指向的是同一块数据,所以修改了arr1会对arr2也产生影响 * */ 03 值类型和引用类型作为函数参数处理形参:占位用的参数,用来接收数据的参数而已。实参:实际传递的参数。函数的调用:在函数调用的时候,函数默认会把实参的值赋值给形参。值类型作为参数：在函数内部对形参变量进行修改不会影响到实参的值。引用类型作为参数：在函数内部对形参变量进行修改会影响到实参的值，因为他们的引用指向同一个对象。04 值类型和引用类型的相关图示基本类型的赋值12var str1 = \"hello zhangsan\";var str2 = str1; 引用类型的结构和赋值123456789var car = &#123; color:\"黑色\", number:\"B99\"&#125;;var p1 = &#123; name:\"王宝宝\", age:30, car:car&#125;; 12345var obj1 = &#123; name:\"lisi\", age:18 &#125;; var obj2 = obj1; 对象的动态特性在js中可以动态的对对象属性进行增加、修改和删除；代码示例12345678910111213141516171819//01 创建对象var obj = &#123; name:\"刘德华\", age:60&#125;;//02 动态的为对象添加属性obj.height = \"180cm\";console.log(obj.height);//03 动态的为对象添加方法obj.maiMeng = function () &#123; console.log(\"华仔会卖萌噢\");&#125;;obj.maiMeng();//04 修改属性的值:如果设置的属性以前不存在,那么就是添加,如果设置的属性已经存在了,那么就是修改obj.name = \"王宝强\";console.log(obj.name)//05 删除属性delete obj.name;console.log(obj.name); //undefined 访问对象的方法01 可以使用点语法访问02 可以使用[]语法访问，注意对象的属性必须是字符串 关键字in和delete的使用01 in关键字01 判断属性是否存在于对象中，注意所有的key都是字符串02 for in循环中 遍历对象的 键代码示例12345678910var obj = &#123; name:\"张三\", age:18&#125;;for(k in obj)&#123; console.log(k,obj[k]);&#125;//检测obj对象中是否存在name这个属性console.log(\"name\" in obj); 注意：in关键字操作数组的时候检测的是索引值并非数组元素02 delete关键字01 删除对象的属性02 删除未使用var声明的变量03 返回值为boolean类型，true则表示是否删除成功注意1201 删除的属性如果不存在，返回true02 删除的如果是原型中的属性，返回true 但是删除不成功 循环和分支循环结构1234forwhiledo...whilefor..in 分支结构12if...else..swith..case break和continue对比break:终止循环，循环中后面的代码不再执行continue:结束当前循环，循环后面的代码不再执行，继续下一次循环 调试工具的使用开启调试窗口 windows 平台: f12; Mac: option+command+i;调试窗口介绍 指针: 选择页面中的元素 手机: 使用移动端界面调试 Elements: 查看页面 DOM 树 Console: 控制台(注意, 控制台与该页面是一个整体, 在控制台中的任何操作, 会影响到页面) Source: 代码调试调试工具的使用 逐过程运行, 一次运行一个函数 单步运行(逐步运行), 一次运行一句, 如果是函数, 进入函数体内运行 继续运行. 从当前状态运行下去, 直到出现断点, 如果没有断点则运行结束设置断点技巧 逐步与逐过程混合 断点加继续运行 条件断点(右键添加 add contitional breakpoint)利用 watch 监视窗口可以查看对象成员 异常处理常见的异常分类运行环境的多样性导致的异常（浏览器）语法错误，代码错误异常的特征:一旦代码出现异常，后面的代码就不会再执行异常捕获使用try-catch语句捕获异常123456try&#123; //这里写可能出现异常的代码&#125;catch(e)&#123; //这里的e就是捕获的异常对象 //可以在这里写，出现异常后的处理代码&#125; 异常捕获语句执行的过程为：01 代码正常运行, 如果在try中出现了错误, try 里面出现错误的语句后面的代码都不再执行, 直接跳转到 catch 中02 在catch中处理错误信息03 继续执行后面的代码04 如果 try 中没有出现错误, 那么不走 catch 直接执行后面的代码捕获异常的优点：通过try-catch语句进行异常捕获之后，代码将会继续执行，而不会中断。注意：语法错误异常用try-catch语句无法捕获，因为在预解析阶段，语法错误会直接检测出来，而不会等到运行的时候才报错。try..catch使用示例1234567891011121314151617//01 try ... catch结构的使用//a(); 若直接调用则爆出:Uncaught ReferenceError: a is not defined错误//在开发中,我们对于可能会报错或者是发生异常的代码用try结构进行处理try&#123; a(); //如果发生异常,那么至少不会到正程序中断&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest();//结论:使用try...catch结构,如果发生了异常,那么不会影响后面代码的执行,且我们可以在发生异常信息之后做出具体的处理 手动抛出异常案例：自己写的一个函数，需要一个参数，如果用户不传参数，此时想直接给用户抛出异常，就需要了解如何抛出异常。抛出异常使用throw关键字，语法如下：手动抛出异常信息（字符串）:123456789101112131415try&#123; //a(); //如果发生异常,那么至少不会到正程序中断 //不使用系统默认的异常信息,尝试手动抛出 throw \"对不起,您调用了尚未定义的方法\";&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest(); 手动抛出异常信息（对象）:1234567891011121314151617181920212223try&#123; //a(); //如果发生异常,那么至少不会到正程序中断 //不使用系统默认的异常信息,尝试手动抛出 throw &#123; errMsg:\"具体的错误信息提示\", errCode:\"指定错误类型的代号,如1001等\" &#125;;&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e); //在try语句中抛出的错误信息是什么,那么得到的异常信息就是什么 //如果抛出的是字符串,那么得到的就是字符串 //如果抛出的是对象,那么此处得到的就是对象 console.log(e.errMsg); console.log(e.errCode);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest(); 异常捕获语句的完整模式异常捕获语句的完整模式为try-catch-finally123456789101112131415try&#123; //在执行的时候可能发生异常的代码 b();&#125;catch (e)&#123; //如果try代码块中的代码在执行中发生了异常,那么就会执行该代码块的代码 //通过打印e对象可以查看具体的异常信息 console.log(e); //打印异常信息&#125;finally &#123; //不论try语句中的代码是否会发生异常,都一定会执行此处的代码块 //一般在前端开发中很少使用,常用语后台开发的资源释放工作 console.log(\"无论如何总要执行的代码\");&#125; finally中的代码，不管是否发生异常，都会执行。一般用在后端语言中，用来释放资源，JavaScript中很少会用到。 DOM操作获取元素操作123getElementByIdgetElementsByTagNamegetElementsByClassName 元素节点操作1234567appendChildinsertBeforeremoveChildreplaceChildcloneNodecreateElementcreateTextNode（创建文本节点） 属性节点操作123getAttributesetAttributeremoveAttribute 常用DOM属性1234classNameinnerHTMLinnerText/textContent valuechildren 代码示例12345678910111213141516//0 获取页面中指定的标签,并设置其样式 var divID = document.getElementById(\"divId\"); divID.style.backgroundColor = \"pink\"; divID.style.height = \"40px\"; divID.style.width = \"200px\"; //01 创建新的标签 var div = document.createElement(\"div\"); //02 设置标签的样式 div.style.backgroundColor = \"red\"; div.style.height = \"100px\"; div.style.width = \"300px\"; div.style.fontSize = \"20\"; //03 设置标签的内容 div.innerText = \"这是一个自己创建的标签\"; //04 把标签插入到页面中 document.body.appendChild(div); 面向对象编程 面向对象方法被人谈论了二十多年了，直到今天，我们还一直在谈对象。 面向层过程和面向对象编程01 面向对象编程和面向过程编程是一种编程思想,和具体的语言关系不大。02 面向过程编程和面向对象编程的主要区别1234567891011121314151617181920面向过程编程: 关注点在于解决问题需要的每一个详细的步骤 示例: 自己洗衣服的过程 ① 收集需要洗的脏衣服 ② 准备洗衣粉、洗衣液等 ③ 把衣服放到一个盆里 ④ 接水 ⑤ 把洗衣粉放到盆里 ⑥ 摩擦,摩擦,不断的摩擦 ⑦ 把洗好的衣服用清水冲洗干净 ⑧ 尽量把把洗好的衣服的水分拧干 ⑨ 晾晒 面向对象编程: 关注点在于解决问题需要的对象身上 示例: 使用洗衣机洗衣服的过程 ① 收集需要洗的脏衣服 ② 找到合适的洗衣机 ③ 设定洗衣服和烘干的程序 03 面向过程和面向对象他们的区别就类似于自己洗衣服和使用洗衣机洗衣服|自己做饭吃和去餐馆吃饭 面向对象编程的相关概念01 对象 什么是对象? 所有的一切都是对象,在开发中有一项重要的工作就是对象的划分。一般来说,我们所指的对象是某个具体的事物,而非泛泛的类别。02 对象的特征(静态描述信息) 所谓特征就是一些特定的描述信息 如:学生(性别、年龄、班级、专业、籍贯、家庭住址) 如:汽车(颜色、车牌、品牌、价格等)03 对象的行为(动态特性) 如:人(吃饭、睡觉、玩游戏、奔跑、运动等) 如:狗(吃、睡、咬人、叫、流口水)04 js中的对象 键-值对(key-value)的集合。05 现实生活中的对象和js对象的对应关系 静态的描述信息 - js对象中的属性(属性就是定义在对象内部的变量) 动态的行为特征 - js对象中的方法(方法就是定义在对象内部的函数)06 代码示例：12345678910111213141516171819202122232425 var zhangsan = &#123; name:\"张三\", sex:\"男\", age:18, address:\"天上人间1号公馆\", eat:function () &#123; console.log('能吃'); &#125;, sleep:function () &#123; console.log(\"能睡\"); &#125;, say:function () &#123; console.log(\"能说话\"); &#125;, run:function () &#123; console.log(\"能运动\"); &#125;, song:function () &#123; console.log(\"能唱歌\"); &#125; &#125;; //打印对象的属性并调用相关的方法console.log(zhangsan.name,zhangsan.age,zhangsan.address); zhangsan.say(); zhangsan.sleep(); 面向对象的三大特性面向对象的三大特性:封装、继承、多态01 封装:复用|信息隐蔽代码示例123456789101112131415161718192021//01 封装的简单说明//001 观察以下杂乱无关的语句,它们仅仅只是一堆无意义的全局变量var name = \"乘风波浪会有时\";var actors = [\"彭于晏\",\"邓超\"];var showTime = \"2016-1-28 - 2016-2-28\";var director = \"韩寒\";var type = \"喜剧\";var play = function () &#123; //播放......&#125;;//002 把上面的变量封装到对象中(更具有意义)var film = &#123; name:\"乘风破浪会有时\", actors:[\"彭于晏\",\"邓超\"], showTime:\"2016-1-28 - 2016-2-28\", director:\"韩寒\", type:\"喜剧\", play:function () &#123; //播放...... &#125;&#125; 02 继承:获取已经存在的对象已有属性和方法的一种方式(获取他人已有财富和资源的一种方式)。代码示例123456789101112131415//继承的简单示例//001 创建一个空的对象var nullObj = &#123;&#125;;// 上面的对象film拥有了很多的属性和方法//002 设法让nullObj拥有film中所有的属性和方法//方法一:自己重新写一遍//方法二:通过某种方式来获得,比如遍历该对象,然后完成赋值for(var k in film)&#123; nullObj[k] = film[k];&#125;for(var k in nullObj)&#123; console.log(nullObj[k]);&#125; 03 多态(polymorphism) 多态:polymorphism = poly(复数) + morph(形态) + ism 多用于强类型语言中，JavaScript具备与生俱来的多态特性。 多态表现为: ① 同一操作,作用于不同的对象,会产生不同的解释和行为。 ② 隐藏不同。 创建对象的方法字面量方式创建对象基本写法123456789var book1 = &#123; name:\"声名狼藉者的生活\", price:42.00, author:\"福柯\", press:\"北京大学出版社\", read:function () &#123; console.log(\"我的书名为:声名狼藉者的的生活,作者为福柯....\"); &#125; &#125;; 存在的问题[01] 代码复用性差[02] 如果要创建大量的同类型对象，则需要些大量重复性代码 内置构造函数创建对象JS中的内置构造函数123456789StringNumberBoolean 注意：(区别于string number boolean)DateArrayFunctionObjectRegExp 基本写法12345678var book1 = new Object();book1.name = \"声名狼藉者的生活\";book1.price = 42.00;book1.author = \"福柯\";book1.press = \"北京大学出版社\";book1.read = function () &#123; console.log(\"我的书名为:声名狼藉者的的生活,作者为福柯....\");&#125;; 问题01 创建的对象无法复用,复用性差02 如果需要创建多个同类型的对象,如(书籍)则需要写大量重复的代码,代码的冗余度高 工厂函数创建对象基本写法12345678910111213141516171819202122function createBookNew (name,price,author,press) &#123; var book = new Object(); book.name = name; book.price = price; book.author = author; book.press = press; book.read = function () &#123; console.log(\"我的书名为:\"+book.name+\",作者为\"+book.author+\"....\"); &#125;; return book;&#125;//使用工厂函数来创建对象var book1 = createBookNew(\"声名狼藉者的的生活\",\"42.00\",\"福柯\",\"北京大学出版社\");var book2 = createBookNew(\"人性的枷锁\",\"49.00\",\"毛姆\",\"华东师范大学出版社\");var book3 = createBookNew(\"悟空传\",\"28.00\",\"今何在\",\"湖南文艺出版社\");//打印对象的属性,调用对象的方法console.log(book1.name);console.log(book2.name);console.log(book3.name);book1.read();book2.read();book3.read(); 工厂函数说明:001 工厂函数方式创建对象其本质是对内置构造函数创建对象的过程进行了封装002 适用于大规模“批量生产”同类型的对象1234567891011121314function createBook (name,price,author,press) &#123; //001 参数 = 原料 var book = new Object(); //002 创建对象并设置对象的属性和方法 = 对原料进行加工 book.name = name; book.price = price; book.author = author; book.press = press; book.read = function () &#123; console.log(\"我的书名为:\"+book.name+\",作者为\"+book.author+\"....\"); &#125;; //003 把处理好的对象返回给我们 == 产品出厂 return book;&#125; 封装思路:使用函数把固定不变的部分封装起来，变化的部分提取为函数的参数。工厂函数创建对象的实现过程:① 提供一个创建对象的函数（参数）② 在该函数内部使用new 关键字和Object构造器创建对象③ 设置对象的属性④ 设置对象的方法⑤ 返回对象 自定义构造函数创建对象基本写法123456789101112131415function 构造函数名(参数1,参数2,参数3...) &#123; //设置对象的属性 this.属性01 = 参数1; this.属性02 = 参数2; //设置对象的方法 this.方法01 = function () &#123; //..... &#125;; this.方法02 = function () &#123; //..... &#125;&#125;//自定义构造函数方式创建对象var 对象01 = new 构造函数名(实参01,实参02,实参03...);var 对象02 = new 构造函数名(实参01,实参02,实参03...); 代码示例12345678910111213141516171819function CreateBook (name,price,author,press) &#123; this.name = name; this.price = price; this.author = author; this.press = press; this.read = function () &#123; console.log(\"我的书名为:\"+this.name+\",作者为\"+this.author+\"....\"); &#125;;&#125;var b1 = new CreateBook(\"声名狼藉者的的生活\",\"42.00\",\"福柯\",\"北京大学出版社\");var b2 = new CreateBook(\"人性的枷锁\",\"49.00\",\"毛姆\",\"华东师范大学出版社\");var b3 = new CreateBook(\"悟空传\",\"28.00\",\"今何在\",\"湖南文艺出版社\");//打印对象的属性,并调用对象的方法测试console.log(b1.author);console.log(b2.author);console.log(b3.author);b1.read();b2.read();b3.read(); 构造函数与new关键字:new关键字的作用：用于创建对象（Object类型）。构造函数和普通函数的区别：函数的首字母大写。构造函数的作用:用于完成对象的初始化。 自定义构造函数和简单工厂函数的对比：1234① 函数的首字母大写(用于区别构造函数和普通函数)② 创建对象的过程是由new关键字实现③ 在构造函数内部会自动的创建新对象,并赋值给this指针④ 自动返回创建出来的对象 构造函数的执行过程① 使用new关键字创建对象② 把新创建出来的对象赋值给this③ 在构造函数内部,使用this为新创建出来的对象设置属性和方法④ 默认返回新创建的对象(普通函数如果不显示的return则默认返回undefined)。 构造函数的返回值01 如果在构造函数中没有显示的return,则默认返回的是新创建出来的对象02 如果在构造函数中显示的return,则依照具体的情况处理 [01] return 的是对象,则直接返回该对象,取而代之本该默认返回的新对象 [02] return 的是null或基本数据类型值,则返回新创建的对象 构造函数方式创建对象存在的问题每次创建对象,都会重新创建函数，那么如果创建的对象数量很多,而对象方法内部的实现一模一样,则造成了资源浪费。 构造函数的使用注意函数传值：可以把构造函数的对象方法抽取为参数。代码示例：1234567891011121314151617//001 创建一个构造函数function Person(name,age,toDoSomeThing) &#123; //002 在构造函数内部设置对象的属性和方法 this.name = name; this.age = age; this.sayName = function () &#123; console.log(this.name); &#125;; this.toDoSomeThing = toDoSomeThing;&#125;//003 使用构造函数创建对象var zhangsan = new Person(\"张三\",18,function () &#123; console.log(\"张三在读书\");&#125;);var lisi = new Person(\"李四\",20,function () &#123; console.log(\"李四在玩耍\");&#125;); 对象类型:01 检查对象的类型：instanceOf02 获取对象的类型：Object.prototype.toString.call(dog) 对象的构造器属性12345function Dog(name) &#123; this.name = name; this.color = \"黄色\"; &#125;console.log(dog.constructor); 属性的名称：constructor属性的作用：指向创建该对象的构造函数，类似于现实生活中所有的产品都标有生产厂家一样。 构造函数的调用01 构造函数可以像普通函数一样不通过new关键字直接调用02 在使用构造函数创建对象的时候，如果没有传递参数，则（）可以省略代码示例:1234567891011//01 创建构造函数function Person() &#123; this.name = \"张三\"; this.age = 20; this.sayName = function () &#123; console.log(this.name); &#125;&#125;//02 使用构造函数创建对象var p1 = new Person();var p2 = new Person; //说明:如果不需要传递参数,则在调用构造函数的时候()可以省略 this指向01 如果使用new 构造函数的方式调用，则this指向内部默认创建出来的空对象02 如果像调用普通函数一样调用构造函数，则this指向全局对象window(不要这样使用) 原型对象原型对象概念 在构造函数创建出来的时候,系统会默认帮构造函数创建并关联的一个新对象 自定义构造函数的原型对象默认是一个空对象。 原型对象的作用 构造函数中的原型对象中的属性和方法可以被使用该构造函数创建出来的对象使用。 即以自定义构造函数方式创建出来的所有对象,自动拥有和共享该构造函数的原型对象中的所有属性和方法。 如何访问构造函数的原型对象① 构造函数.protoType② 对象.__proto__（不推荐） 设置原型对象的属性和方法① 利用对象的动态特性来为构造函数的原型对象添加属性和方法② 替换原型对象 实例和实例化：实例化:通过构造函数创建具体对象的过程。实例:通过构造函数实例化出来的对象,我们称之为该构造函数的一个实例。注意:在说实例的时候,一定要指定是某个具体构造函数的实例。 原型的使用方法① 利用对象的动态特性给原型添加属性|方法，如果要添加的方法过多,则有大量重复代码。② 直接替换原型对象：01 替换前后创建的对象所指向的原型对象不一致02 替换原型对象会切断和之前的原型对象之间的关系 原型对象的使用注意1234567① 访问属性:构造函数创建出来的对象在访问属性的时候,会先在实例内查找,如果没有找到则进一步到对应的原型对象中查找。② 设置属性:在使用点语法进行赋值的时候,无法操作到对应的原型对象,如果该属性在对象中已经存在，则修改该属性的值。如果该属性在对象中尚未存在,则新增该属性。③ 设置原型对象的属性:[01] 设置原型对象的属性,只能通过构造函数.Prototype的方式替换原型对象的方式设置。[02] 如果原型对象的属性是值类型，那么只能通过Person.prototype.属性的方式修改其值。如果原型对象的属性是引用类型,那么可以通过对象名.引用对象.属性名的方式设置修改： (001) 使用构造函数创建出来的多个对象的原型对象中的该属性指向的是同一块数据。 (002) 某个对象对该原型对象属性进行了修改会影响到其他的对象。 __proto__属性说明：__proto__是一个非标准属性,即ECMAScript中并不包含该属性,这只是某些浏览器为了方便开发人员开发和调试而提供的一个属性,不具备通用性。建议:在调试的时候可以使用该属性,但不能出现在正式的代码中。 继承 关于继承，通俗说子继父业。在JavaScript中，Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。 相关方法在讲继承之前，我们必须先了解一些相关的方法。 hasOwnProperty和in属性操作in关键字作用：用来检查对象中是否存在某个属性(不区分实例属性和原型属性)。语法：“属性名” in 对象。代码示例:12345678910111213141516&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125; //03 创建对象 var p1 = new Person(); //04 使用in关键字判断对象中是否存在以下属性:name age sayHello console.log(\"age\" in p1); //false console.log(\"name\" in p1); //true console.log(\"sayHello\" in p1); //true&lt;/script&gt; 对象的hasOwnProperty方法作用：用来检查对象中是否存在指定的属性(只检查实例属性)语法：对象.hasOwnProperty(“属性名”)代码示例123456789101112131415161718&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125; Person.prototype.des = \"默认的描述信息\"; //03 创建对象 var p1 = new Person(); //04 使用hasOwnProperty方法判断该属性是否是对象的实例属性 console.log(p1.hasOwnProperty(\"age\")); //false console.log(p1.hasOwnProperty(\"name\")); //true console.log(p1.hasOwnProperty(\"sayHello\")); //false console.log(p1.hasOwnProperty(\"des\")); //false&lt;/script&gt; 判断某对象中存在且只存在某个原型属性123function isProperty(obj, property) &#123; return !obj.hasOwnProperty(property) &amp;&amp; (property in obj); &#125; constructor构造器属性说明 使用构造函数创建对象,则 原型对象中的constructor属性指向对应的构造函数 实例对象中的constructor指向对应的构造函数,其中这里的constructor就是从原型中获取的即constructor时实例对象中的原型属性,而非实例属性 代码验证123456789101112131415//01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125;; Person.prototype.des = \"默认的描述信息\"; //03 创建对象 var p1 = new Person(); function isProperty(obj, property) &#123; return !obj.hasOwnProperty(property) &amp;&amp; (property in obj); &#125; console.log(isProperty(p1, \"constructor\")); //true isprotoTypeOf和instanceisprotoTypeOf作用：判断是否是某个实例对象的原型对象语法:构造函数.protoType.isPrototypeOf(对象)用法示例123456789&lt;script&gt; function Person() &#123;&#125; function Dog() &#123;&#125; Person.prototype.name = \"嘿嘿\"; var p1 = new Person(); console.log(Person.prototype.isPrototypeOf(p1));//rue console.log(Object.prototype.isPrototypeOf(p1));//true console.log(Dog.prototype.isPrototypeOf(p1));//false&lt;/script&gt; instance作用：用于检查对象是否是某个构造函数(类型)的实例语法：对象 instance 构造函数注意：所有的对象都是Object构造函数（类型）的实例用法示例12345678&lt;script&gt; var arr = [1,2,3]; console.log(arr instanceof Array); //true console.log(Array instanceof Object); //true console.log(arr instanceof Object); //true //instanceOf在判断的时候,算上整条原型链 //arr 是Array 和Object 任何一个类的示例&lt;/script&gt; 继承继承基本概念继承：即通过一定的方式实现让某个类型A获取另外一个类型B的属性或方法。其中类型A称之为子类型，类型B称之为父类型或超类型。 javaScript中的继承Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。继承有两种方式：接口继承和实现继承，在js中只支持实现继承，实现继承主要依赖原型链来完成。JavaScript中实现继承的几种方式：说明:其他语言中继承通常通过类来实现，js中没有类的概念，js中的继承是某个对象继承另外一个对象，是基于对象的。123401 原型式继承02 原型链继承03 经典继承(借用构造函数)04 组合继承 原型式继承原型链继承的方式A1234567891011121314151617&lt;script&gt; //01 提供一个构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置原型对象的属性 Person.prototype.className = \"逍遥派1班\"; //03 使用构造函数来创建原型对象 var p1 = new Person(\"张三\",10); var p2 = new Person(\"李四\",20); //04 打印p1和p2对象中的className属性 console.log(p1.className); console.log(p2.className); //结论:对象p1和p2继承了构造函数原型对象中的属性className //但是这并不是严格意义上的继承&lt;/script&gt; 原型链继承的方式B1234567891011121314151617181920&lt;script&gt; //01 提供一个构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置原型对象的属性 Person.prototype = &#123; constructor:Person, className:\"逍遥派1班\" &#125;; //03 使用构造函数来创建原型对象 var p1 = new Person(\"张三\",10); var p2 = new Person(\"李四\",20); //04 打印p1和p2对象中的className属性 console.log(p1.className); console.log(p2.className); //结论:对象p1和p2继承了构造函数原型对象中的属性className //注意:使用原型替换的方式实现继承的时候,原有原型对象中的属性和方法会丢失&lt;/script&gt; 原型链继承的方式C1234567891011121314151617181920212223//01 提供超类型|父类型构造函数function SuperClass() &#123; this.name = 'SuperClass的名称'; this.showName = function () &#123; console.log(this.name); &#125;&#125;//02 设置父类型的原型属性和原型方法SuperClass.prototype.info = 'SuperClass的信息';SuperClass.prototype.showInfo = function () &#123; console.log(this.info);&#125;;//03 提供子类型function SubClass() &#123;&#125;//04 设置继承(原型对象继承)SubClass.prototype = SuperClass.prototype;SubClass.prototype.constructor = SubClass;var sub = new SubClass();console.log(sub.name); //undefinedconsole.log(sub.info); //SuperClass的信息sub.showInfo(); //SuperClass的信息sub.showName(); //sub.showName is not a function 点评：上面的方法可以可以继承超类型中的原型属性和原型方法，但是无法继承实例属性和实例方法 原型链继承实现思想：利用原型（链）让一个对象继承另一个对象的属性和方法实现本质：重写原型对象 原型链123456① 每个构造函数都有原型对象② 每个对象都有自己的构造函数③ 每个构造函数的原型都是一个对象④ 那么这个构造函数的原型对象也有自己的构造函数⑤ 那么这个构造函数的原型对象的构造函数也有自己的原型对象以上形成一个链式的结构,称之为原型链 原型链中的属性搜索原则12345当访问某个对象的成员的时候,会先在自身中查找,如果找到则直接使用如果在自身中没有找到,则去当前创建当前对象的构造函数的原型对象中查找,如果找到了则直接使用如果在该原型对象中没有找到,则继续查找原型对象的原型对象(创建该原型对象的构造函数所对应的原型对象),如果找到则直接使用如果在原型对象的原型对象中也没有找到,则继续向上搜索....直到Object的原型对象,若还是没有,则返回undefined(属性)或报错(方法)。 基本写法·代码示例1234567891011121314151617181920212223//01 提供超类型|父类型function SuperClass() &#123; this.name = 'SuperClass的名称'; this.showName = function () &#123; console.log(this.name); &#125;&#125;//02 设置父类型的原型属性和原型方法SuperClass.prototype.info = 'SuperClass的信息';SuperClass.prototype.showInfo = function () &#123; console.log(this.info);&#125;;//03 提供子类型function SubClass() &#123;&#125;//04 设置继承(原型对象继承)SubClass.prototype = new SuperClass();SubClass.prototype.constructor = SubClass;var sub = new SubClass();console.log(sub.name); //SuperClass的名称console.log(sub.info); //SuperClass的信息sub.showInfo(); //SuperClass的信息sub.showName(); //SuperClass的名称 点评：可以继承父类型中的原型属性|原型方法,以及实例属性和实例方法 注意点① 确定原型和实例的关系 instanceof + isPrototypeOf()② 注意重写原型对象的位置，必须先实现原型继承，然后再设置子对象的原型属性和原型方法③ 完成继承之后，不能使用字面量的方式来创建原型[因为会切断原型] 问题① 父对象的实例属性会转换为子类型原型的原型属性，而如果父类型是实例属性是引用类型则会存在共享问题② 在创建子类型的实例时，不能向父类型的构造函数中传递参数1234567891011121314151617//01 提供父对象的构造函数function SuperType() &#123; //02 在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈'];&#125;;//03 提供子对象的构造函数function SubType() &#123;&#125;;//04 设置原型继承SubType.prototype = new SuperType();//05 创建父对象构造函数的实例对象,并对内部的实例化属性进行修改var subDemo1 = new SubType();var subDemo2 = new SubType();alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈subDemo1.family.push('爷爷','奶奶');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶 经典继承（借用构造函数）经典继承又称为借用构造函数|伪造继承 基本思想在子类型构造函数的内部调用超类型|父类型构造函数说明：需要借助call|apply方法代码示例1234567891011121314151617181920212223242526//01 提供父类型(对象)的构造函数 function SuperType(name) &#123; //02 在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈']; //实例属性 this.name = name; &#125;; SuperType.prototype.info = '父类型的原型属性'; //03 提供子类型（对象）的构造函数 function SubType() &#123; //经典继承|借用构造函数|伪造对象继承 //SuperType.call(this); //构造参数传递参数 SuperType.call(this,'张老汉'); &#125;; //04 创建父类型的实例对象,并对内部的实例化属性进行修改 var subDemo1 = new SubType(); var subDemo2 = new SubType(); alert(subDemo1.info); //undefined alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈 alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈 subDemo1.family.push('爷爷','奶奶'); alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶 alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈 //测试构造函数传递参数 alert(subDemo1.name); 点评：能够继承父类型的实例属性,但是无法继承父类型的原型属性和原型方法 经典继承的优点① 解决实例对象共享问题，通过调用父对象的构造函数来实现每个子类型（对象）的实例对象均拥有一份父类型实例属性和方法的副本② 可以在调用call方法的时候向构造函数传递参数 经典继承的问题① 冒充继承的方法无法实现函数的重用② 无法继承父对象的原型属性和原型方法 组合继承组合继承|伪经典继承 基本思想① 使用原型链实现对原型属性和方法的继承② 通过伪造(冒充)构造函数来实现对实例属性的继承代码示例1234567891011121314151617181920212223242526272829//01 提供父类型的构造函数function SuperType(name) &#123; //在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈']; //实例属性 this.name = name;&#125;;//原型方法SuperType.prototype.showName = function () &#123; console.log(this.name);&#125;//02 提供子类型的构造函数function SubType(name) &#123; //冒充|伪造 构造参数传递参数 SuperType.call(this,name);&#125;;SubType.prototype = SuperType.prototype;//SubType.prototype = new SuperType();//02 创建父类型的实例对象,并对内部的实例化属性进行修改var subDemo1 = new SubType('张三');var subDemo2 = new SubType('张四');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈subDemo1.family.push('爷爷','奶奶');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈//测试构造函数传递参数subDemo1.showName(); //张三subDemo2.showName(); //张四 基本包装类型基本类型：字符串 + 数值 + null + undefined + 布尔值为了便于操作基本类型，ECMAScript提供了三个特殊的引用类型：Boolean + Number + String。上述类型和其他的引用类型类似，同时也具备与各自的基本类型相应的特殊行为，每当我们读取一个基本类型的值的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。123var str = '测试字符串';console.log(str.length); //5console.log(str.substring(2)); //字符串 思考：属性和方法本是对象的特征，字符串如何能够拥有length属性以及其他类似subString等方法，内部怎么实现的？基本类型值并不是对象，因此从逻辑上讨论他们不应该有属性和方法。 内部的具体处理:123（1）创建String类型的一个实例对象（2）在实例对象上面读取指定的属性（length）,调用指定的方法（subString）（3）销毁该对象 NumberNumber是与数字值相对应的引用类型。创建Number类型的对象：var num = new Number(10); String String是字符串的对象包装类型。创建字符串类型的对象：var str = new String(‘hello World’); BooleanBoolean是与布尔值对象的引用类型。可以通过调用Boolean构造函数传递参数来创建boolean类型的对象。var bool = new Boolean(true); 基本包装类型的代码示例1234567891011121314//001 Stringvar str = '测试字符串';console.log(str.length); //5console.log(str.substring(2)); //字符串//002 Numbervar num = new Number(10);console.log(num); //Number &#123;[[PrimitiveValue]]: 10&#125;console.log(typeof num); //objectconsole.log(typeof 10); //number//003 Booleanvar bool = new Boolean(true);console.log(bool); //Boolean &#123;[[PrimitiveValue]]: true&#125;console.log(typeof bool); //objectconsole.log(typeof true); //boolean 基本包装类型的注意点[1] 对象还是基本数据类型值？对象：通过new 调用构造函数创建出来的是对象基本数据类型值：直接通过字面量方式赋值|通过省略new关键字调用构造函数方式创建的是基本数据类型值。12345ex: var str1 = new String('hello'); var str2 = 'hello'; var str3 = String('hello'); 说明：以上代码中，str1是对象，而str2和str3是字符串（基本数据类型值） [2] 相等问题基本类型值判断相等=&gt;值相等引用类型值判断相等=&gt;值相等且引用相等对象是引用类型，因此在判断相等的时候有诸多的注意点和容易出错的地方123456789101112131415161718ex var str1 = '这是一个字符串'; //基本数据类型 var str2 = String('这是一个字符串'); //基本数据类型 console.log(str1 == str2); //true 相等 var str3 = new String('这是一个字符串'); //引用类型-对象 console.log(str1 == str3); //true //值相等 console.log(str2 == str3); //true //值相等 console.log(str1 === str3); //false //值相等,但是引用不相等 console.log(str2 === str3); //false //值相等,但是引用不相等 //判断下面的变量是否相等 var num1 = 10; //基本数据类型 var num2 = new Number(10); //对象 console.log(num1 == num2); //true console.log(num1 === num2); //false var bool1 = true; var bool2 = new Boolean(true); console.log(bool1 == bool2); //true console.log(bool1 === bool2); //false 原型链及相关属性方法简单说明原型链代码示例1234567891011121314151617&lt;script&gt; //01 提供Person构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置Person的原型对象 Person.prototype.showName = function () &#123; console.log(this.name); &#125; //03 创建Student构造函数 function Student(number) &#123; this.numer = number &#125; //04 设置Student的原型对象 Student.prototype = new Person();&lt;/script&gt; 原型链图示例 Object对象Object构造函数01 使用Object构造函数创建字符串对象12345678//01 创建字符串对象var str1 = new String(\"测试字符串\");var str2 = new Object(\"测试字符串\");var str3 = str1;//注意:对象比较相等(需要引用[地址]相等)console.log(str1 == str2); //falseconsole.log(str1 === str2); //falseconsole.log(str1 === str3); //true 02 使用Object构造函数创建数字对象12var num = new Object(10);console.log(typeof num); //object 03 使用Object构造函数创建布尔类型对象12var bool = new Object(true); console.log(typeof bool); //object js中所有的内置或自定义对象都继承自Object对象,几乎所有的对象都可以使用Object.prototype上面的属性和方法 Object.prototype01 因为js中所有的对象都继承自Obejct,都可以使用Object对象的原型属性和方法,因此不要轻易的扩展Object.prototype。02 Object.property中的属性和方法 ① constructor 指向原型相关联的构造函数，为Object ② hasOwnProperty 判断对象中是否拥有某个实例属性(不包括原型链上面的属性) ③ isPrototypeOf 校验某个对象是否是指定对象的原型对象(整条原型链) ④ propertyIsEnumerable 属性是否存在且可枚举(使用for循环可以遍历,即目标属性能否在for循环中显示出来) ⑤ toString() 返回一个描述目标对象的字符串,对象则返回[object object] toString(参数) 参数出可以传入一个用于进制数的参数,该参数的默认值为10(主要针对Number类型有效) ⑥ toLocaleString 同toString,但是会做一些本地化的处理。 ⑦ valueOf() 如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。 Date对象调用该方法会返回一个时间戳。 constructor说明：该属性指向创建该对象的构造函数，在这里为Object123456function Person() &#123; &#125; var p = new Person(); console.log(p.constructor); //function Person() &#123;&#125; console.log(Person.prototype.constructor); //function Person() &#123;&#125; console.log(Object.prototype.constructor); //function Object() &#123; [native code] &#125; hasOwnProperty说明：判断对象中是否拥有某个实例属性(不包括原型链上面的属性)12345678function Person() &#123; this.name = \"默认的姓名\"&#125;//检查对象中是否拥有指定的属性(实例属性)var p1 = new Person();p1.hasOwnProperty(\"name\"); //truep1.hasOwnProperty(\"age\"); //falsep1.hasOwnProperty(\"constructor\"); //对象的constructor是从原型对象上继承的 isPrototypeOf说明：校验某个对象是否是指定对象的原型对象(整条原型链);1234567891011121314&lt;script&gt; var obj = &#123; name:\"张三\", age:20, hello:function () &#123; console.log(\"hello\"); &#125;, showName:function () &#123; console.log(this.name); &#125; &#125; //属性是否存在且可以枚举 console.log(obj.propertyIsEnumerable(\"name\")); //true&lt;/script&gt; toString说明：返回一个描述目标对象的字符串,对象则返回[object object]12345678910111213&lt;script&gt; var obj = &#123;&#125;; console.log(obj.toString()); //打印[object Object] var arr = [1,2,3,4,5]; console.log(arr.toString()); //打印1,2,3,4,5 var num = 10; console.log(num.toString()); //10 var date = new Date(); console.log(date.toString()); //Mon Feb 13 2017 19:00:13 GMT+0800 (CST) //toString方法可以传入参数,在处理Number类型数据的时候,可以传入指定的进制 console.log(num.toString(2)); //1010 == 1*2*2*2+0*2*2+1*2+1*1 = 10 console.log(num.toString(3)); //101 == 1*3*3 + 0*3 + 1*1 = 10&lt;/script&gt; toLocaleString说明：作用同toString方法一致，但是会做一些本地化的处理. valueOf说明：① 如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。② 如果是Date类型，则返回时间戳。123456789&lt;script&gt; var obj = &#123;&#125;; console.log(obj + 1); //[object Object]1 //说明:如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。 var o = &#123;name:\"张三\"&#125;; console.log(o + 1); //[object Object]1 var date = new Date(); console.log(date.valueOf()); //1486984088998&lt;/script&gt; 静态成员和实例成员静态成员 定义在构造函数上面的成员(属性和方法) 实例成员 定义在实例对象上面的成员(属性和方法) 建议 ① 把工具类的方法写成静态方法 ② 把和对象相关的方法写成实例方法(成员) 代码示例12345678910111213141516&lt;script&gt; function Person() &#123; this.name = \"张三\"; //实例属性 this.showName = function () &#123; console.log(this.name); &#125;; &#125; //为Person构造函数添加静态成员 Person.des = \"描述信息\"; Person.add = function (msg) &#123; console.log(\"添加信息\" + msg); &#125;; Person.add(\"这是一个+操作\"); var p1 = new Person(); p1.showName();&lt;/script&gt; Function构造函数函数创建的几种方式 12301 函数声明02 字面量的方式创建03 使用new Function的形式创建 函数创建代码示例 12345678function func01() &#123; console.log(\"函数声明\"); &#125; var func02 = function () &#123; console.log(\"字面量方式创建\"); &#125; //使用Function构造函数创建 var func03 = new Function(); Function构造函数创建函数 参数说明:可以传入多个参数 最后一个参数:传入的最后一个参数为函数的函数体内容 其他参数:创建出来的函数的参数 如果只有一个参数,则表示这是该函数的函数体内容 传递参数的格式:以字符串的方式进行传参代码示例123456//需求01 使用Function构造函数创建一个函数对象,该函数执行一行打印操作var funcName01 = new Function(\"console.log('让我掉下眼泪的,不止昨夜的酒')\");funcName01();//需求02 使用Function构造函数创建一个函数对象,该函数需要接受两个参数,要求返回他们的和var funcName02 = new Function(\"a\",\"b\",\"return a + b;\");console.log(funcName02(10, 20)); //30 解决函数体代码过长的问题（1）使用转义字符，写在一行中（2）使用+操作符来拼接字符串（3）使用``操作符来管理字符串（4）使用模板先处理字符串，然后在js中获得模板中的内容 arguments、length和calleearguments参数说明：在js中的函数中，有两个隐藏的参数分别是this和arguments1234arguments 是一个类似数组的结构,可以通过下标来操作函数的参数,但并非数组类型的。在函数调用的时候,会将函数的所有参数都传入arguments对象中保存,因此我们可以通过操作arguments属性来操作参数形参的数量大于实参的数量,则依次传入,未传入的设置为undefined形参的数量小于实参的数量,则arguments中保存实际的值 length 函数内部的arguments数组拥有length属性,可以通过该属性获取用户调用时传入的实参的个数 函数本身有一个length属性,可以通过该属性来获取形式参数的个数 callee方法 函数内部的arguments对象中,有一个callee方法,该方法指向函数自身,常用于匿名函数的递归调用。 代码示例12345678910111213141516171819&lt;script&gt; function func() &#123; console.log(arguments); console.log(arguments.length); //调用函数时实际传入的参数数量 &#125; func(1,2,3,4,5); console.log(func.length); //预期的参数数量 —— 函数的形参数量 function func02(a,b) &#123; console.log(a, b); console.log(arguments); &#125; func02(1,2,3); //实参的数量 &gt; 形参的数量 则arguments保存实参的值 func02(1); //实参的数量 &lt; 形参的数量 则不足的补undefined //匿名函数调用 (function () &#123; //如果需要在该函数中调用自身,则可以使用arguments.callee方法 arguments.callee(); &#125;)();&lt;/script&gt; Function的应用01 数组去重123456789101112 var func = new Function(\"arr\",` var array = []; for(var i = 0 ; i&lt;arr.length; i++) &#123; if(array.indexOf(arr[i]) == -1) &#123; array.push(arr[i]); &#125; &#125; return array;`); console.log(func([1, 2, 3, 4, 5, 3, 4, 2]));; 02 返回传入函数中所有数据的最大值123456789101112var func = function () &#123; var maxNumber = arguments[0]; for(var i = 0;i&lt;arguments.length;i++) &#123; if (maxNumber &lt; arguments[i]) &#123; maxNumber = arguments[i]; &#125; &#125; return maxNumber;&#125;console.log(func(1, 2, 3, 45, 5, 6, 7, 8, 30, 21)); eval 简单说明eval 的基本使用eval函数用来讲字符串转换为JS的代码,并执行 eval 处理JSON数据代码示例123456&lt;script&gt; var jsonData = '&#123;\"name\":\"张三\",\"age\":18&#125;'; //把json的数据转换为对象 var obj = JSON.parse(jsonData); console.log(obj);&lt;/script&gt; 12345678910111213&lt;script&gt; var jsonData = '&#123;\"name\":\"张三\",\"age\":18&#125;'; //var obj = eval(jsonData); //注意:如果直接这样写代码则会报错 //正确的处理方式 //方式一 eval(\"var obj = \" + jsonData); console.log(obj); //方式二 //说明:使用eval来解析json格式字符串的时候,会将&#123;&#125;解析为代码块,而不是字面量 // 在使用的时候为了避免这种错误,需要在JSO的最外面加上(),如此则会把大括号当做一条语句来解析 var o = eval(\"(\"+jsonData+\")\"); console.log(o);&lt;/script&gt; eval 注意事项 ① eval函数本身功能强大,但它的特性也为程序带来了很大的不确定性,因此在开发中并不推荐使用。 ② eval函数是动态的执行代码,因此其效率不如直接执行静态脚本高。 eval和Function比较12相同点:都能够把字符串转换为Javascript的代码不同点:eval转换为js的代码之后马上就执行,而Function需要先创建函数,调用函数之后才会执行。 Function.prototype原型链关于Function和自定义构造函数的原型对象 Function.prototype 是一个空的函数 自定义构造函数的原型对象是一个空的对象 说明 Function也可以被当做是一个构造函数 通过new Function创建出来的函数,可以认为是Function的实例化对象。 Function的原型对象是一个空的函数,这个空的函数也是一个对象,它的原型对象是Object.prototype。 在JS中,Object的原型对象是所有对象的祖宗。 Function是构造函数,则其原型对象为空的函数 空的函数的原型对象为Object.prototype Function本身也是对象,则其构造函数为:function Function() { [native code] } 是自身 同Object类型 Object本身是构造函数,其原型对象是Object.prototype Object本身也是对象,其构造函数为:function Function() { [native code] 代码示例123456789101112131415//01 提供Person构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置Person的原型对象 Person.prototype.showName = function () &#123; console.log(this.name); &#125; //03 创建Student构造函数 function Student(number) &#123; this.numer = number &#125; //04 设置Student的原型对象 Student.prototype = new Person(); 完整的原型链示意图Object和Function的关系01 Object构造函数是通过Function构造函数实例化出来的02 Function构造函数也是通过Function构造函数实例化出来的 代码示例12345678&lt;script&gt; //检查对象是否是某个构造函数的实例 console.log(Function instanceof Function); console.log(Function instanceof Object); console.log(Object instanceof Object); console.log(Object instanceof Function); //注意:以上打印结果均为true&lt;/script&gt; 对象的拷贝操作浅拷贝如果对象中的属性是引用类型的值,那么存在数据共享问题,修改某个对象会对拷贝的对象产生影响代码示例123456789var o = &#123;name:\"张三\",car:&#123;number:\"2017\",type:\"火车\"&#125;&#125;;var obj = &#123;&#125;;//obj对象需要拷贝o对象中所有的属性for (var i in o )&#123; obj[i] = o[i];&#125;console.log(obj);o.car.type = \"飞船\";console.log(obj); 深拷贝 如果对象中的属性是值类型,那么就直接拷贝赋值 如果对象中的属性是引用类型,那么就再次调用拷贝方法,遍历对象 代码示例123456789101112131415161718192021222324252627 var o = &#123;name:\"张三\",car:&#123;number:\"2017\",type:\"火车\"&#125;&#125;; var obj = &#123;&#125;; function deepCopy(obj,tmp) &#123; tmp = tmp || &#123;&#125;; //如果没有传入,那么就创建一个空的对象 for(var i in obj) &#123; if (obj.hasOwnProperty(i)) //只拷贝实例属性 &#123; //判断是否是引用类型 if ((typeof obj[i]) == 'object') &#123; //重新调用拷贝方法 tmp[i] = Array.isArray(obj[i]) ? [] :&#123;&#125;; deepCopy(obj[i],tmp[i]); &#125;else &#123; //直接拷贝 tmp[i] = obj[i]; &#125; &#125; &#125; &#125;deepCopy(o,obj); console.log(obj); o.car.type = \"测试的类型\"; console.log(obj); console.log(o); 注意isArray的兼容性问题isArray是ECMA5中新推出的方法,需要处理兼容性问题123456if (Array.isArray != \"function\")&#123; Array.isArray = function (obj) &#123; return Object.prototype.toString.call(obj) == '[object Array]'; &#125;&#125; Number原型扩展小案例：在Number的原型对象上面定义一个新的方法add(),该方法接收一个参数,并将该参数与自身的值进行相加,然后进行返回。代码实现123456789Number.prototype.add = function (num) &#123; return this + num;&#125;var n = 10;console.log(n.add(3));//console.log(5.add(5)); 错误:解析器无法处理字面量的这种情况var num = new Number(50);console.log(num.add(20)); //70console.log((1).add(4)); //5 使用()把数字包起来 使用注意123（01）使用数字变量可以调用成功（02）使用数字表达式可以调用成功（03）直接使用数字字面量方式调用失败 js的语法解析器无法处理数字字面量这种情况。 With语句with语句简单介绍123with语句是js中一个强大但有争议的特性。with语句允许我们将一个对象的所有属性引用到当前的作用域允许我们无需使用拥有者对象的前缀，就可以直接对这些属性进行引用和赋值操作。 注意：ECMAScript5规范在严格模式下已经禁用了该语句，在开发中不推荐使用，但是要求能够看懂with的代码。 with语句内部细节说明： with语句会创建一个作用域，在该作用域内，在引用特定对象的属性时，可以不使用前缀。应用场景：对深层级对象的引用进行缩短。 在with作用域内部引用属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //[01] 测试with语句作用域内对对象属性的引用 //01 提供全局变量,名称为testValue var testValue = '测试使用的全局变量'; //02 提供对象,对象内部提供属性 var testObject = &#123; name:'对象的名称属性', testValue:'对象内部的属性' &#125;; //03 使用with语句引用 with(testObject) &#123; console.log(name); //对象的名称属性 console.log(testValue); //对象内部的属性 console.log(this); //window &#125; console.log(testValue); //测试使用的全局变量``` 总结：(1) 在with语句作用域内,对象属性的优先级绝对高于在更层级作用域内定义的同名变量(2) this(函数上下文)依然指向window,并不会收到with作用域的影响**在with作用域内进行赋值操作**```js //01 提供一个对象,在内部提供属性 var obj = &#123; name:'对象的内部属性', &#125; //02 with语句测试对对象属性的赋值操作 with(obj) &#123; name = '修正对象中name的值'; //在作用域内部添加变量(思考?该变量是添加为全局作用域还是当前obj对象的属性?) age = '25'; showName = function () &#123; console.log('name == ' + name); &#125;; &#125;; //测试修改对象属性操作 console.log(obj.name); //测试添加对象属性操作 console.log(obj.age); //undefined //obj.showName(); //obj.showName is not a function console.log('____________________'); console.log(this.name); //== name == window.name console.log(window.name); console.log(name); showName(); //==this.showName() ==window.showName() 总结：（1）在with作用域的内部我们可以使用无前缀引用对象的属性进行读取和赋值的操作 但是 不能使用无前缀的方式添加属性（2）如果使用无前缀的方式来添加属性[对不存在的属性进行赋值操作],那么属性将被添加到全局上下文[window|this]（3）可能产生的错误:意外的引入一个全局变量,而非为with作用域对象添加属性 with语句的问题（1）with作用域内操作优先级混乱（2）性能不好，会大大降低js代码的执行性能（3）ECMAScript5规定在严格模式下禁用with特性 with语句简化代码的替代方案使用即时调用函数来替代with语句，通过函数传参的方式使用更短的引用来替代冗长的引用前缀比使用with语句消除前缀的方式更好。123456789101112with(this.style)&#123; width = '200px'; height = '200px'; backgroundColor = '#ca3'; console.log(width); //要访问的本应该是外部的字符串变量 \"错误哈哈\",但是这里被解释为200px&#125;(function (s) &#123; s.width = '200px'; s.height = '200px'; s.backgroundColor = '#ca3';&#125;)(this.style); 使用面向过程的方式处理1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 bookList.push(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; console.log(obj); break; &#125; &#125; //修改操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; obj.author = \"泰戈尔-戈尔泰\" &#125; &#125; //删除操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; //删除该对象 bookList.splice(i, 1); &#125; &#125; console.log(bookList);&lt;/script&gt; 使用函数来封装图书管理操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 function addBook(bookObj) &#123; bookList.push(bookObj); &#125; addBook(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 function getBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125; console.log(getBook(\"什么是批判\")); //修改操作 function updateBookData(name,authorName)&#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; obj.author = authorName; &#125; &#125; &#125; updateBookData(\"飞鸟集\",\"泰戈尔斯坦\"); //删除操作 function removeBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; //删除该对象 bookList.splice(i, 1); &#125; &#125; &#125; console.log(bookList);&lt;/script&gt; 数封装-复用形式12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 function addBook(bookObj) &#123; bookList.push(bookObj); &#125; addBook(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 function getBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125; console.log(getBook(\"什么是批判\")); //修改操作 function updateBookData(name,authorName)&#123; var obj = getBook(name); obj.author = authorName; &#125; updateBookData(\"飞鸟集\",\"泰戈尔斯坦\"); //删除操作 function removeBook(name) &#123; var obj = getBook(name); var index = bookList.indexOf(obj); bookList.splice(index,1); &#125; addBook(&#123;name:\"东京人\",author:\"川端康成\"&#125;); console.log(bookList);&lt;/script&gt; 面向对象的方式管理图书123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;scrip&gt; var obj = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ];泰 function BookManager() &#123; this.bookList = null; &#125; BookManager.prototype = &#123; constructor:BookManager, init:function (arr) &#123; this.bookList = arr || []; &#125;, addBook:function (bookObj) &#123; this.bookList.push(bookObj) &#125;, getBook:function (name) &#123; for (var i = 0; i &lt; this.bookList.length; i++) &#123; var obj = this.bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125;, updateBookData:function (name,authorName)&#123; var obj = this.getBook(name); obj.author = authorName; &#125;, removeBook:function (name) &#123; var obj = this.getBook(name); var index = this.bookList.indexOf(obj); this.bookList.splice(index,1); &#125; &#125;; //01 创建对象 var YYManager = new BookManager(); YYManager.init(obj); console.log(YYManager.bookList); //02 演示添加操作 YYManager.addBook(&#123;name:\"花田半亩\",author:\"田维\"&#125;); console.log(YYManager.bookList); //03 演示查询操作 console.log(YYManager.getBook(\"花田半亩\")); //04 演示更新操作 YYManager.updateBookData(\"花田半亩\",\"甜田\"); console.log(YYManager.getBook(\"花田半亩\"));; //05 演示删除操作 YYManager.removeBook(\"什么是批判\"); console.log(YYManager.bookList); //02 创建第二个人的图书管理对象 var wulitaotaoMManager = new BookManager(); wulitaotaoMManager.init([&#123;name:\"装逼速成\",author:\"六扇门\"&#125;]); console.log(wulitaotaoMManager.bookList);&lt;/script&gt; 总结01 提供构造函数，在构造函数内部设置实例化属性02 把常用的操作提取成对象的实例方法，写在原型对象身上03 提供init方法，用于初始化数据04 注意：如果切断了原型对象那么需要修正内部的构造器属性指向 变量和函数 JavaScript中有严格模式和非严格模式两种运行环境,本章节主要讲严格模式及非严格模式下函数和变量的区别,最后简单讲诉了JavaScript作用域。 私有变量和函数 定义在构造函数内部而被this对象的变量,在外部无法访问到的变量和函数 公有变量和方法 对外暴露接口,可以通过构造函数对象创建的对象访问的属性和方法 代码示例1234567891011121314151617function Car(type,number) &#123; this.type = type; //公共的属性 this.number = number; var city = \"广州\"; //私有变量 var getNumber = function () &#123; //私有函数 return number; &#125;; var getType = function () &#123; return type; &#125;; //能够访问私有变量和函数的方法 --- 特权方法 this.getDescription = function () &#123; console.log(getNumber() + getType() + city); &#125; &#125; var car = new Car(\"汽车\",\"201718\"); car.getDescription(); 说明：能够访问构造函数内部私有变量|函数的方法称之为特权方法 构造函数的问题构造函数本身是一个函数，在调用的时候有多种调用方式。12① new 构造函数（）调用② 构造函数（）调用 以上，第二种调用方式存在作用域安全的问题 作用域安全的构造函数12345678910111213141516171819202122&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; //容错处理 if (this instanceof Person) &#123; //设置实例属性和方法 this.name = name; this.showName = function () &#123; console.log(this.name); &#125; &#125;else &#123; return new Person(name); &#125; &#125; //02 创建对象 var p1 = new Person(\"zhangsan\"); var p2 = new Person(\"lisi\"); p1.showName(); p2.showName();&lt;/script&gt; 新的问题说明:上面的代码在使用借用构造函数方式继承的时候存在问题，无法创建出的对象，原因在于通过call或者是apply函数调用的时候，内部的this绑定的子类型中的对象，因此在使用instanceOf 判断的时候，结果为假。解决：可以设置让子类型（构造函数）的原型对象为父类型的一个实例。代码示例123456789101112131415161718192021222324252627282930&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; //容错处理 if (this instanceof Person) &#123; //设置实例属性和方法 this.name = name; this.showName = function () &#123; console.log(this.name); &#125; &#125;else &#123; return new Person(name); &#125; &#125; //02 创建对象 var p1 = new Person(\"zhangsan\"); var p2 = new Person(\"lisi\"); p1.showName(); p2.showName(); // 使用借用构造函数来实现继承 function Boy(name)&#123; Person.call(this,name); &#125; //需要结合原型继承来解决 instanceOf 实例对象检测的问题 Boy.prototype = new Person(); var boy = new Boy(\"测试的名字\"); boy.showName();&lt;/script&gt; 严格模式关键字 “use strict”;实现严格模式:只需要在脚本代码中添加上上述关键字即可。 关键字具体说明12345(1) 注意区分大小写，必须全部都是小写的(2) 注意空格，整个字符串总共10个字符(3) 单引号和双引号无所谓，但是需要有双引号(4) 必须写在作用域的最顶部，注意其位置(5) 可以加分号，也可以不加，但是必须是一个字符串 注意：以下的关键字写法均是错误的123\"USE strict\";\" use strict \";\"(\"USE strict\").toLowerCase();\" 严格模式使用注意12345678910111 所有的变量必须使用var 关键字声明2 不能使用delete关键字删除全局变量 ,以前默认删除失败,严格模式下直接报错3 在对象中不允许有同名的属性4 函数的参数必须唯一(不能出现同名的参数)5 arguments对象的行为不同,在非严格模式下修改形参的值会反映到arguments中,而严格模式下则相对独立6 禁用了argument.callee和caller函数,他们一个引用函数本身,一个引用调用函数7 不能在if语句中声明函数8 禁止使用eval和arguments作为标识符9 修正this的值,在严格模式下,函数this的值始终是指定的值,无论指定的是什么值。10 禁用了with语句11 去掉了JavaScript中的八进制字面量(以0开头的八进制字面量是无效的语法) 1 所有的变量都必须使用var关键字声明12a = 10; //错误的演示console.log(10); ② 不能使用delete关键字删除全局变量1234//在非严格模式下,删除失败(静默失败) 失败了不吭声,严格模式下直接报错var a = 10;delete a;console.log(a); ③ 在对象中不允许有同名的属性1234567//在非严格模式下,会使用后面的属性赋值作为最终值,在严格模式下则直接报错var obj = &#123; name:\"张三\", name:\"李四\"&#125;console.log(obj); ④ 函数的参数必须唯一(不能出现同名的参数)123456789101112//在非严格模式下,如果函数在定义的时候,使用了多个同名的参数,则在函数内部形参的实际值为最后一个传入的实参值//在严格模式下,直接报错// function func(a,a,a) &#123;// console.log(a);// console.log(arguments);// &#125;function func(a,b,c) &#123; console.log(a); console.log(arguments);&#125;func(1,2,3); arguments对象的行为不同说明：（1）严格模式下,在函数内部修改了对象的指向,对arguments的值不会产生影响（2）在严格模式下,形参的值和arguments的值是相互独立的,在函数内部修改了形参的值对arguments不受影响（3）在非严格模式下，修改了形参的值，arguments中的数据会跟着改变123456789101112131415161718 //测试引用类型的值作为函数的参数function funcName(obj) &#123; console.log(obj); console.log(arguments[0]); //在函数内部修改形参的值 obj = &#123;age:20&#125;; console.log(obj); console.log(arguments[0]); &#125; funcName(&#123;name:\"张三\"&#125;); //测试基本类型数据作为函数的参数 function fun(str) &#123; console.log(str); console.log(arguments[0]); str = \"hello\"; console.log(arguments[0]); &#125; fun(\"hi\"); ⑥ 禁用了argument.callee和caller函数说明：argument.callee是对函数自身的引用argument.calller是对调用函数的引用12345678var num = (function (n) &#123; if (n ==1) &#123; return 1; &#125; return arguments.callee(n-1) + n; &#125;)(10); console.log(num); //55 ⑦ 不能在if语句中声明函数123456789//如果在if语句中声明函数，则会产生语法错误 if (true) &#123; console.log(\"________\"); function demo() &#123; console.log(\"呵呵呵呵\"); &#125; demo(); &#125; ⑧ 禁止使用eval和argument作为标识符1234var eval = \"测试的字符串\";console.log(eval);var arguments = \"参数列表\";console.log(arguments); ⑨ 修正this的值12345678在严格模式下,函数this的值始终是指定的值,无论指定的是什么值var name = \"测试的name\";function demoTest() &#123; //在非严格模式下,打印出来的this为全局的对象window console.log(this); //在严格模式下打印出来的this为undefined&#125;demoTest(); ⑩ 禁用了with语句1234567var o = &#123;name:\"暂时干\",age:20&#125;; with(o) &#123; name = \"lisi\"; age = 48 &#125; console.log(o); 禁用了八进制123//以0开头的数据常常引起混乱//var num = 023; //2*8 + 3 ==&gt; 19//console.log(num); //19 书写格式1234501 必须使用单引号或者是双引号括住字符串02 必须使用小写,不能出现大写字符03 必须是10个字符04 字符串后面的分号可以省略05 必须写在当前作用域的最顶上 代码示例123456789101112&lt;script&gt; //\"use strict\"; //正确写法 //\"use strict\" //正确写法 分号可以省略 //'use strict'; //正确写法 可以使用单引号 //\"use strict\"; //错误写法 必须是10个字符 //\"use Strict\"; //错误写法 所有的字符都必须小写 \"use strict\"; a = 10; // \"use strict\"; //错误写法 必须写在当前作用域的顶端 b = 20; console.log(a);&lt;/script&gt; 作用范围12① 函数的顶部(只对当前的函数有效)② script标签的顶部,只对当前的标签有效,对页面中其他的script无效 代码示例12345678910111213141516 //位置01 对func01和func02都有效 //\"use strict\"; function func01() &#123; //位置02 对func01有效,对func02无效 //\"use strict\"; a = 10; console.log(a); &#125; function func02() &#123; //位置03 对func02有效,但对func01无效 //\"use strict\"; b = 20; console.log(b); &#125;func01(); func02(); 函数的几种调用方式123401 普通函数调用 内部的this指向全局对象window02 构造函数调用 内部的this指向新创建的对象03 对象的方法调用 内部的this指向调用的对象本身04 通过call 或者是apply方式调用(函数上下文),this指向的是当前的上下文对象 this丢失demo演示123456789101112&lt;script&gt; var obj = &#123; name:\"张三\", getName:function () &#123; console.log(this.name); &#125; &#125;; //以对象的方法来进行调用 obj.getName(); //张三 var getName = obj.getName; getName(); //以普通函数的方式调用,此时内部的this指向的是window对象 打印的是window.name 为空值&lt;/script&gt; 代码示例0212345678910111213141516&lt;script&gt; //01 获取页面中id值为demo的标签 //var div = document.getElementById('demo');// var getId = document.getElementById;// var div = getId('demo'); //会报错?// console.log(div); //借用apply来修正this document.getElementById = (function (func) &#123; return function () &#123; return func.apply(document,arguments); &#125; &#125;)(document.getElementById); var getId = document.getElementById; var div = getId('demo'); //会报错? console.log(div);&lt;/script&gt; 代码说明：12301 因为document.getElementById方法的内部实现中需要使用到this,这个this本来期望指向的是document对象02 当我们以document.getElementById来调用的时候,内部的this指向document对象03 但是当我们以getId的方式调用的时候,内部的this指向的是window对象(因为我们以普通的方式进行调用) 作用域变量其作用的范围就是它的作用域 块级作用域说明：JavaScript中没有块级作用域123456for (var i = 0; i &lt; 10; i++) &#123; var num = i; &#125; console.log(i); console.log(num); //说明:如果有块级作用域,则i和num打印的结果应该为undefined 词法作用域123词法作用域:在代码写好的那一刻,变量的作用域就已经确定的动态作用域:变量的作用域由执行时的环境所决定说明:在js中不是动态作用域,当调用的时候,是往上查找的,不会到其他函数的作用域中去查找 在JavaScript中唯一能够产生作用域的东西是函数代码演示123456789101112131415161718192021222324&lt;script&gt; var a = \"这是第一个a\"; function func01() &#123; console.log(a); //先在当前作用域中查找,如果没有则访问全局的作用域 &#125; function func02() &#123; var a = \"这是第二个a\"; func01() &#125; func01(); //打印结果为:这是第一个a func02(); //打印结果为:这是第一个a&lt;/script&gt;&lt;script&gt; var a = \"这是第一个a\"; function func02() &#123; var a = \"这是第二个a\"; func01() &#125; function func01() &#123; console.log(a); //先在当前作用域中查找,如果没有则访问全局的作用域 &#125; func01(); //打印结果为:这是第一个a func02(); //打印结果为:这是第一个a&lt;/script&gt; 词法作用域的规则1234① 在函数内部允许访问外部的变量② 只有函数可以限定作用域③ 作用域规则首先使用提升规则分析④ 如果当前作用域中有该变量,则不考虑外部作用域的同名变量 变量和函数提升JS中的代码执行分为两个步骤① 预解析JavaScript在预解析阶段,会对使用var关键字声明的变量和function声明的代码块进行提升操作,提升到当前作用域的顶端② 执行 代码提升的几种情况 01 函数提升123456&lt;script&gt; func(); function func() &#123; console.log(\"测试的函数\"); &#125;&lt;/script&gt; 02 变量提升1234567&lt;script&gt; console.log(a); //打印出来的结果为undefined var a = 10; //var a; //注意:只会对变量的声明进行提升 //console.log(a); //a = 10&lt;/script&gt; 03 函数同名情况提升12345678910111213141516171819&lt;script&gt; func01(); //打印last function func01() &#123; console.log(\"first\"); &#125; func01(); //打印last function func01() &#123; console.log(\"last\"); &#125; //模拟提升后的情况 function func01() &#123; console.log(\"first\"); &#125; function func01() &#123; console.log(\"last\"); &#125; func01(); func01();&lt;/script&gt; 说明：预处理的时候，同名的函数都会进行提升，但是后面的会覆盖掉前面的 04 变量名和函数同名的情况12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; console.log(a); //打印function function a() &#123; console.log(\"我是一个函数\"); &#125; var a = 20; console.log(a); //打印20 //变量和函数提升后的结果 错误// function a() &#123;// console.log(\"我是一个函数\");// &#125;// var a ;// console.log(a);// a = 20;// console.log(a); //变量和函数提升后的结果 正确 function a() &#123; console.log(\"我是一个函数\"); &#125; console.log(a); var a = 20; console.log(a);&lt;/script&gt;```js总结:如果出现变量和函数同名的情况,则在进行提升的时候,只会提升函数到当前作用域顶端而忽略变量的提升操作**变量的提升是分作用域的**示例代码01```js&lt;script&gt; console.log(a); //undefined var a = 10; //模拟提升 var a; console.log(a); //undefined a = 10;&lt;/script&gt; 示例代码0212345678910111213141516171819&lt;script&gt; var num = 10; function func() &#123; var num = 20; console.log(num); &#125; console.log(num); //10 func(); //20 //模拟提升 var num; function func() &#123; var num; num = 20; console.log(num); &#125; num = 10; console.log(num); //10 func(); //20&lt;/script&gt; 示例代码031234567891011121314151617var num = 10;function func() &#123; console.log(num); var num = 20;&#125;console.log(num); //10func(); //undefiend//模拟提升var num;function func() &#123; var num; console.log(num); num = 20;&#125;num = 10;console.log(num); //10func(); //undefiend 示例代码041234567891011121314151617var num = 10;function func() &#123; console.log(num); num = 20;&#125;console.log(num); //10func(); //10//模拟变量提升var num;function func() &#123; console.log(num); num = 20;&#125;num= 10;console.log(num); //10func(); //10console.log(num); //20 函数表达式的提升说明：在使用函数表达式方式创建函数的时候,整个函数表达式并不会进行提升,只会对var声明的变量提升1234567891011func();var func = function () &#123; console.log(\"会不会被调用\");&#125;//以上如上代码将报错//模拟提升的过程var func;func(); //找不到这个函数func = function () &#123; console.log(\"会不会被调用\");&#125; 作用域链01 在js中函数可以创建作用域 02 函数中又可以创建函数(即又可以开辟新的作用域) 03 函数内部的作用域可以访问外部的作用域 04 如果有多个函数嵌套,那么就会构成一个链式的访问结构,也就是作用域链 05 注意:函数内部的作用域可以访问外部的作用域,但是外部的作用域却不能访问内部的作用域 代码示例1234567891011121314151617&lt;script&gt; function f1() &#123; //f1---&gt;全局作用域 function f4() &#123; //f4--&gt;f1---&gt;全局作用域 function f5() &#123; &#125; &#125; &#125; function f2() &#123; //f2--&gt;全局作用域 function f6() &#123; &#125; &#125; function f3() &#123; &#125;&lt;/script&gt; 作用域链绘图说明 ① 先画出全局作用域线条，然后在上面添加全局作用域中的函数和变量，作为0级作用域链 ② 画出全局作用域中的函数的作用域线条，，然后在上面添加当前作用域中的函数和变量，作为1级作用域链 ③ 以此类推，直至完成 示例代码01123456789function f1() &#123; function f2() &#123; &#125; &#125; var a = 20; function f3() &#123; function f4() &#123; &#125; &#125; 图示 示例代码021234567891011121314function f1() &#123; function f2() &#123; function f5() &#123; var b = \"demo\"; &#125; &#125; &#125; var a = 20; function f3() &#123; var c = \"啊哈哈\"; function f4() &#123; var d = \"test\"; &#125; &#125; 图示 作用域注意点和变量搜索原则注意点 01 在获取值和设置值的时候都是访问变量 02 并非在函数内部写了变量,这个变量就属于当前函数,而是必须使用var 关键字声明的变量才属于当前函数 03 函数在声明的时候,里面的代码并不会执行,只有在函数调用的时候才会执行 04 声明函数时候的函数名,其实也是一个变量名,可以通过这个变量名来进行设置和赋值 05 注意:在变量内部使用var 关键字声明一个变量并不会把同名的全局变量覆盖掉 1234567var a = 10;function f1() &#123; var a = 20; //注意:该行代码并不会覆盖掉全局变量中的变量a console.log(a);&#125;f1(); //20console.log(a); //10 代码点评：12在函数中使用var关键字声明变量a并不会覆盖全局作用域中的a。注意需要同时考虑变量在当前作用域的提升以及访问变量时的搜索原则。 1234567function f1() &#123; console.log(1);&#125;var f1 = \"demo字符串\"; //该行代码会把f1函数覆盖掉f1 = \"demoTest字符串\";console.log(f1);//f1(); 代码点评:函数的名称也是变量，如果在代码中出现同名的变量，那么函数的实现会被覆盖掉 变量搜索原则 01 在使用变量的时候,首先在自己的作用域中查找 02 如果找到了就直接使用,如果没有找到,那么就到上一级作用域中去查找 03 重复上面的步骤,直到0级作用域,如果还是找不到那么就返回undefined(报错) 闭包 闭包是学习JavaScript的难点之一，因JavaScript是单线程，故回调使用频繁，本章节主要讲了闭包以及回调。 闭包简单说明 闭:关闭,封闭 包:包住,包裹 闭包:通过某种方式实现的一个封闭的、包裹的对外不公开的结构|空间 闭包的原理:变量的访问原则(即上一级的作用域无法访问下一级的作用域),其实函数本身就是闭包。 闭包要解决的问题 提供一种间接的方式能够访问到函数内部的数据（变量） 实现思路 01 我们需要能够在函数外部访问函数内部的变量，正常情况无法访问； 02 在函数内部如果新创建函数，那么安装作用域链的原则，这个新创建的内部函数能够访问到函数中的这些变量。 03 我们如果能够操作函数中新创建的函数，那么就能够操作函数中的变量（如访问和设置等） 04 如果要能够操作函数中新创建的函数，那么需要在函数中把新创建的函数返回。 05 调用函数，接收并得到其返回值（是一个函数） 06 调用返回值（函数），通过函数传参的方式来设置函数中的变量。 07 调用返回值（函数），通过在函数内部再次return的方式来访问函数中的变量。 闭包的基本模式 在函数内部创建函数(内部函数),在这个内部函数中,可以操作外部函数中的变量 01 在函数(外部)中创建函数(内部函数),在该函数(内部函数)中操作外部函数中的变量 02 在外部函数中,把内部函数作为返回值返回 03 调用外部函数,并接收其返回值(是一个函数) 04 调用接收到的返回值(内部函数),来间接的操作外部函数中的变量 代码示例123456789function func() &#123; var num = 10; return function (n) &#123; num = n; console.log(num); &#125;&#125;var funcName = func();funcName(\"哗啦哗啦\"); 闭包获取数据获取单个数据（考虑赋值）123456789101112131415function func() &#123; var num = 123; return function (a) &#123; if (a !== undefined) &#123; num = a; &#125; return num; &#125;&#125;var f1 = func();var x = f1(456);var y = f1();console.log(x);console.log(y); 说明：上面的代码能够支持通过闭包对函数中的变量num进行访问（取值）或赋值的操作。 获取多个数据（数组）123456789101112131415function func() &#123; var name = \"张学友\"; var age = 40; return [ function getName() &#123; return name; &#125;, function getAge() &#123; return age; &#125; ]&#125;var foo = func();console.log(foo[0]()); //张学友console.log(foo[1]()); //40 说明：上面的代码能够满足返回多个变量值的需求，但是要数组操作的方式并不常见，且和使用习惯不符合。 利用对象返回并设置对个变量值1234567891011121314151617181920212223242526function foo() &#123; var name = \"张学友\"; var age = 45; return &#123; getName:function () &#123; return name; &#125;, getAge:function () &#123; return age; &#125;, setName:function (nameValue) &#123; name = nameValue; &#125;, setAge:function (ageValue) &#123; age = ageValue; &#125; &#125;&#125;var func = foo();console.log(func.getName()); //张学友console.log(func.getAge()); //45func.setName(\"张三\");func.setAge(30);console.log(func.getName()); //张三console.log(func.getAge()); //30 闭包的作用最基本的作用:闭包中的变量更安全,只能通过特定的接口来访问说明:12(1)创建一个私有的空间,保护数据,外界如果需要访问数据必须通过函数提供的指定方法(2)在这些指定的方法中,我们可以设置一些校验的逻辑,以保证对数据访问和设置的安全性 闭包的使用注意进程和线程 进程指的是系统中正在运行的一个应用程序。 线程:一个进程中可以有一个或多个线程,线程是CPU调度的最小单位,是真正执行任务的。 多线程:一个中可能有多条线程,多条线程之间并发的执行多个不同的任务。 单线程:一个进程中只有一条线程,即同一时间只能执行一个操作,只能干一件事情。 javascript是单线程的 js中的线程主要处理三块任务: 01 渲染任务 02 js的代码执行任务 03 js中的事件处理任务(如setTimeOut方法) javascript中代码的执行顺序 01 先把主任务执行完毕(代码任务)02 主任务执行完毕之后再执行次要的任务(包括setTimeOut方法等) 关于setTimeOut函数 函数的作用:一次性定时器(用于延迟执行任务) 参数: 第一个参数:要执行的任务 第二个参数:要延迟执行的时间,时间的单位是毫秒 函数说明： 01 至少在指定的时间后才能够执行回调函数 02 因为要等主任务中的代码执行完毕之后,才回去检查setTimeOut的回调函数。 通过闭包解决setTimeOut函数的问题12345678910111213&lt;script&gt; for (var i = 0; i &lt; 10; i++) &#123; setTimeout((function (j) &#123; return function () &#123; console.log(j); &#125; &#125;)(i),10); console.log(\"----\"); &#125;&lt;/script&gt; 函数的特殊之处函数的特殊之处在于,它本身是对象,且函数可以提供作用域。 (01) 函数可以在运行时动态的创建,还可以在程序执行过程中创建。 (02) 函数可以赋值给变量,可以被扩展,甚至是删除。 (03) 函数可以作为其他函数的参数和返回值。 (04) 函数可以拥有自己的属性和方法。 注意:{} 块在js中不会创建作用域,哪怕是if或者是while语句中使用var关键字声明的变量也并非局部变量。 函数是可以通过（）调用并执行的对象。 函数是第一型对象12301 函数可以像普通对象一样作为函数的参数02 函数可以像普通对象一样赋值给变量（函数表达式）03 函数可以像普通对象一个作为函数的返回值返回 代码示例123456789101112131415//函数作为参数传递 setTimeout(function () &#123; console.log(1); &#125;,100); //函数作为返回值 function func() &#123; return function () &#123; console.log(\"demo\"); &#125; &#125; var f = func(); f(); //demo //函数赋值给变量 var a = function()&#123;&#125; a(); //直接通过变量的名称调用函数 函数的两个特征1201 函数本质上是对象02 函数可以创建作用域 约定1234var add = function add(a,b)&#123;return a + b;&#125;; //命名函数表达式var add = function (a,b)&#123;return a + b;&#125;; //函数表达式,匿名函数 以上也称为使用字面量的方式来创建函数(或者是函数字面量)function add()&#123;&#125;; //函数声明 代码示例123456789101112131415&lt;script&gt; //01 函数声明 function demo01() &#123; &#125; //02 函数表达式(匿名函数) var demo02 = function () &#123; &#125;; //03 命名函数表达式 var demo03 = function demo03Test() &#123; &#125;; //04 打印name属性 console.log(demo01.name); //demo01 console.log(demo02.name); //demo02 (注意在火狐浏览器中打印出来的name属性为空) console.log(demo03.name); //demo03Test&lt;/script&gt; 函数回调回调函数(回调),当我们把某个函数作为参数传递给另一个函数的时候,这个函数就称为回调函数 函数回调的基本模式12345678910&lt;script&gt; function func(callBack) &#123; //处理其他的操作 callBack(); //调用回调函数 &#125; function demo() &#123; console.log(\"这是一个回调函数\"); &#125; func(demo); //注意调用函数的时候,参数是回调函数的引用(不要加括号);&lt;/script&gt; 函数回调解决this问题说明：如果回调函数是某个对象的方法,而该对象方法中使用了this指针那么该方法作为回调函数来使用的时候,需要注意this123456789101112131415161718192021222324252627//01 提供一个对象,该对象中永远showName方法var obj = &#123; name:\"默认的名字\", age:30, showName:function () &#123; console.log(this.name); &#125;, showAge:function () &#123; console.log(this.age); &#125;&#125;;//02 提供一个函数,该函数接受一个参数(函数引用)function demo(callBack,callBack_obj) &#123; //处理第一个参数传递对象方法字符串的形式 if(typeof callBack == 'string') &#123; callBack = callBack_obj[callBack]; &#125; if (typeof callBack == 'function') &#123; callBack.call(callBack_obj); &#125;&#125;//demo(obj.showName,obj);//demo(obj.showAge,obj);//传递字符串和对象来进行调用demo(\"showName\",obj); 代码说明：123（01）以上代码传入两个参数，分别为具体的回调函数，和该回调函数所属的对象（02）该函数的参数接受两种方式的回调传递（一种是直接传递函数引用，一种是直接以字符串的方式传递对象方法的字符串）（03）在函数内部对传入的回调参数做处理，修正this的问题 函数作为函数的返回值12① 使用闭包实现一个计数器(在该示例中setup函数的返回值为一个函数)② 通过调用返回值(一个函数),可以操作setup函数中的变量 123456789101112&lt;script&gt; var setup = function () &#123; var count = 0; return function () &#123; return count ++; &#125; &#125; var next = setup(); console.log(next()); //0 console.log(next()); //1 console.log(next()); //2&lt;/script&gt; 惰性函数定义说明：某个函数直到第一次使用的时候才被正确的定义,并且其具有向后惰性,执行更少的工作。应用场景:函数有一些初始化的准备工作要做,且只需要执行一次的情况。特点:能够更新自己(函数)的实现。缺点: 01 当重新定义自身的时候,已经添加到原始函数的任何属性都会丢失。 02 如何函数被赋值给了其他的变量或者是对象方法,那么在使用变量或者是对象方法调用时仍然会执行旧的函数体。代码示例123456789function foo() &#123; console.log(\"foo!\"); foo = function () &#123; console.log(\"new foo!\"); &#125;&#125;//函数的调用//foo(); //foo!//foo(); //new foo! 问题： ① 添加属性 ② 把函数赋值给新的变量 ③ 以对象的方法调用函数 当惰性函数定义在处理以上三种情况的时候，使用新的变量名调用或者是是以对象的方法来调用函数，那么该函数在执行的时候并不会更新自身，而是执行旧的函数体的内容 代码示例1234567891011121314151617181920212223242526272829&lt;script&gt; //01 声明函数foo function foo() &#123; console.log(\"foo!\"); foo = function () &#123; console.log(\"foo! foo!\"); &#125; &#125; //02 为foo函数对象添加属性 foo.description = \"foo函数的描述信息\"; //03 把foo函数赋值给其他的变量 var func = foo; //04 把foo函数赋值给对象中的方法 var obj = &#123; showFoo:foo &#125; //05 验证并演示输出 func(); //foo! func(); //foo! console.log(func.description); //foo函数的描述信息 //总结:01 如果把函数赋值给其他的变量,那么在以其他变量的方式调用时不会更新自身,还是执行旧的函数体 obj.showFoo(); //foo! obj.showFoo(); //foo! console.log(obj.showFoo.description); //foo函数的描述信息 //总结:02 如果把函数赋值给对象的方法,那么在以对象方法形式调用时不会更新自身,还是会执行旧的函数体。 foo(); //已经更新过foo函数 foo! foo! foo(); //已经更新过foo函数 foo! foo! console.log(foo.description); //undefined&lt;/script&gt; 即时函数 定义:在函数定义之后立即执行该函数。即时函数模式的组成: ① 使用函数表达式来定义函数(匿名函数,注意不能使用函数声明方式) ② 在函数表达式末尾添加一组(),表示立即执行当前函数。 ③ 将整个函数包装在()中,有两种方式` 即时函数的作用 01 用来将所有的代码包装到当前的作用域中,并且不会将任何的变量泄露到全局作用域中。 02 js中没有代码块作用域,而函数是js中唯一可以创建作用域的。 03 即时函数就是利用了函数创建作用域这一点,来实现对一些需要封装且不允许外部访问的操作。 即时函数的优点01 不会产生全局变量,在即时函数内部定义的所有变量都仅仅只是该函数的局部变量,不会造成全局变量污染问题。02 具有更好的封装性,外部无法访问到该函数内部的数据。 即时函数代码示例12345678//第一种写法(function () &#123; console.log(\"即时函数的第一种写法\");&#125;());//第二种写法(function () &#123; console.log(\"即时函数的第二种写法\");&#125;)(); 写法补充123456789(function (a) &#123; console.log(a); &#125;(20)); +function (b) &#123; console.log(b); &#125;(30); -function (b) &#123; console.log(b); &#125;(40); 即时函数的传参和返回值12345678910//01 接受参数 (function (str) &#123; console.log(str); //hello &#125;)(\"hello\"); //02 提供返回值并赋值给新的变量 var foo = (function () &#123; return 2 + 1; &#125;)(); console.log(foo); //3 即时对象初始化01 结构特征:12345① 提供一个对象,在该对象内部提供一个init初始化方法② 使用()把对象包装起来(让字面量变成表达式)③ 然后随即调用init方法,完成初始化操作。 02 基本结构({}).init(); 03 模式优点 在执行一次性的初始化任务时保护全局的命名空间。 代码示例1234567891011121314&lt;script&gt; (&#123; name:\"张三\", age:23, getDescript:function () &#123; console.log(\"名字:\" + this.name + \"年龄:\" + this.age); &#125;, //注意:在对象中访问对象的属性和方法都需要使用this.前缀 init:function () &#123; this.getDescript(); //其他的初始化处理 &#125; &#125;).init();&lt;/script&gt; 函数属性缓存思路说明 01 函数是对象，因此可以在函数上面添加属性和方法 02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果 03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value） 04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。 代码示例(单个参数)1234567891011121314var func = function (param) &#123; if (func.cache[param] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[param] = result + param; &#125; return func.cache[param];&#125;func.cache = &#123;&#125;; //空对象console.log(func(\"demo\")); //字符串democonsole.log(func(\"test\")); //字符串testconsole.log(func(\"demo\")); //字符串demo 直接使用属性缓存中的数据,而不再进行复杂的计算(可以提升性能) 代码示例（多个参数）12345678910111213var func = function () &#123; var key = JSON.stringify(Object.prototype.slice.call(arguments)); if (func.cache[key] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[key] = result + key; &#125; return func.cache[key];&#125;func.cache = &#123;&#125;; //空对象func(\"123\",\"456\"); ////说明:如果传入的参数数量超过1,则可以将传入的参数序列化为一个json字符串作为参数处理。 代码说明：slice:返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素 函数属性缓存 很高兴你能看到这里，希望对你学习JavaScript有帮助。这是最后一章节，主要讲有关JavaScript的设计模式。 思路说明 01 函数是对象，因此可以在函数上面添加属性和方法 02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果 03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value） 04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。 代码示例(单个参数)12345678910111213var func = function (param) &#123; if (func.cache[param] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[param] = result + param; &#125; return func.cache[param];&#125;func.cache = &#123;&#125;; //空对象console.log(func(\"demo\")); //字符串democonsole.log(func(\"test\")); //字符串testconsole.log(func(\"demo\")); //字符串demo 直接使用属性缓存中的数据,而不再进行复杂的计算(可以提升性能) 代码示例（多个参数）12345678910111213var func = function () &#123; var key = JSON.stringify(Array.prototype.slice.call(arguments)); if (func.cache[key] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[key] = result + key; &#125; return func.cache[key];&#125;func.cache = &#123;&#125;; //空对象func(\"123\",\"456\"); ////说明:如果传入的参数数量超过1,则可以将传入的参数序列化为一个json字符串作为参数处理。 代码说明：slice:返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素 命名空间模式作用:(1)有助于减少程序中所需要的全局变量的数量(2)并且同时还有助于避免命名冲突或过长的名字前缀。 说明：JavaScript中并没有内置的命名空间 如何实现命名空间可以为应用程序创建一个全局对象,然后将所有功能都添加到该全局对象中 从而在具有大量函数,对象和其他变量的情况下并不会污染全局范围。 建议 全局命名空间的名称可以随便写,但建议使用项目的名称或者是APP的名称 按照习惯,通过程序员会约定以全部大写的方式来约定全局命名空间。 命名空间模式的缺点 ① 需要输入更多的字符,在每个变量和函数前面都需要附加上前缀,总体上增加了代码的体积。 ② 仅有一个全局实例,意味着代码的任何部分都能够修改当前的实例。 ③ 很长的前缀意味着需要花更长的时间来解析属性(变量|属性访问原则-就近原则) 代码示例（零散的代码）123456789101112131415&lt;script&gt; //构造函数 function Person() &#123; &#125; function Man() &#123; &#125; var array = [1,2,3,4,5,6]; var testDemo01 = \"测试字符串01\"; var testDemo02 = \"测试字符串02\"; var obj = &#123;&#125;; obj.des = \"描述信息\"; obj.logDes = function () &#123; console.log(obj.des); &#125;&lt;/script&gt; 代码示例(命名空间模式) 1234567891011121314151617&lt;script&gt; //01 提供一个全局变量 var MYAPP = &#123;&#125;; //02 处理构造函数 MYAPP.Person = function () &#123;&#125;; MYAPP.Man = function () &#123;&#125;; //03 处理变量 MYAPP.array = [1,2,3,4,5,6]; MYAPP.testDemo01 = \"测试字符串01\"; MYAPP.testDemo02 = \"测试字符串02\"; //处理对象 MYAPP.obj = &#123;&#125;; MYAPP.obj.des = \"描述信息\"; MYAPP.obj.logDes = function () &#123; console.log(obj.des); &#125;&lt;/script&gt; 说明 01 在使用命名空间模式的时候,因为所有的变量和属性都添加到同一个全局对象下面,因此该全局对象下面可能有很多很多的属性。 02 而我们在添加属性的时候,很有可能该属性已经存在,这导致可能会覆盖掉之前的属性。 03 所以,在添加一个属性或者是创建一个命名空间之前,最好是先检查它是否已经存在。 04 但是如果每次添加属性都需要对属性进行检查则会产生代码冗余问题。 示例代码1234567891011121314151617181920212223242526//01 不好的演示//其他代码//var MYAPP = &#123;&#125;; //注意这是不安全的代码,因为有可能覆盖掉上下文中的代码//02 在创建命名空间之前,先检查该命名空间是否存在// if (MYAPP == 'undefined')&#123;// var MYAPP = &#123;&#125;;// &#125;//03 更好的做法var MYAPP = MYAPP || &#123;&#125;; //如果MYAPP为假,那么就返回&#123;&#125;并赋值给MYAPP//04 添加属性时的检查问题//假如现在需要添加一个name属性,那么在添加之前需要先检查该属性是否存在if (MYAPP.name == 'undefined')&#123; MYAPP.name = \"默认的名称\";&#125;//假如要添加一个obJ属性if (typeof MYAPP.obj == 'undefined')&#123; MYAPP.obj = &#123;&#125;;&#125;//假如要给MYAPP.obj添加属性,则if (typeof MYAPP.obj.des === \"undefined\")&#123; MYAPP.obj.des = \"对象的描述信息\"&#125;console.log(MYAPP.obj); 代码说明：我们在添加属性或者是方法的时候,比较安全的做法是在添加之前先在当前环境中进行检查,以免覆盖但是我们的检查操作催生出了一个新的问题,就是重复代码过多,能否考虑把检查的过程抽取 示例代码1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; var MYAPP = MYAPP || &#123;&#125;; MYAPP.namescape = function (string) &#123; //split() 方法用于把一个字符串分割成字符串数组 var parts = string.split('.'); var parent = MYAPP; console.log(parts); //先去掉最前面的冗余的全局变量 if(parts[0] == \"MYAPP\") &#123; //splice() 方法向/从数组中添加/删除项目,然后返回被删除的项目 //parts.splice(0,1); //slice() 方法可从已有的数组中返回选定的元素 //返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素 parts = parts.slice(1); &#125; console.log(parts,\"处理之后的数组\"); //通过for循环来遍历结构 for (var i = 0; i &lt; parts.length; i++) &#123; //检查属性,如果对应的属性不存在,那么就创建一个属性 if (typeof parent[parts[i]] == 'undefined') &#123; //初始化为一个空的对象 parent[parts[i]] = &#123;&#125;; &#125; //修正parent的值 parent = parent[parts[i]]; &#125; return parent; &#125; //代码示例 var testDemo01 = MYAPP.namescape(\"MYAPP.test.testDemo01\"); var testDemo02 = MYAPP.namescape(\"MYAPP.test.testDemo02\"); console.log(MYAPP); //忽略全面的前缀 MYAPP.namescape(\"sadsa.sadjaldj.adada.test\"); console.log(MYAPP); //演示长命名空间的情况 MYAPP.namescape(\"demo.testDemo.testDemos.ss.dd.qq.ddd.ffff.fff\"); console.log(MYAPP);&lt;/script&gt; 补充说明12301 split() 方法用于把一个字符串分割成字符串数组02 splice() 方法向/从数组中添加/删除项目,然后返回被删除的项目03 slice() 方法可从已有的数组中返回选定的元素 设计模式简单说明概念:设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案 注意,设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案 起源:该属于源于建筑行业 历史: （1）由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学 （2）四人帮著作《设计模式：可复用面向对象软件的基础》（Design Patterns - Elements of Reusable Object-Oriented Software） （3）Gang of Four:Erich Gamma + Richard Helm + Ralph Johnson +John Vlissides 优点: 为了可重用代码、让代码更容易被他人理解、保证代码可靠性 设计模式的分类创建型模式:工厂方法模式 + 抽象工厂模式 + 单例模式 + 建造者模式 + 原型模式 结构型模式:适配器模式 + 代理模式 + ... 行为型模式:观察者模式 + 命令模式 + ... 单例模式的思想保证一个特定的类只有一个实例。 即当我们第二次创建新对象的时候,得到的应该是和第一次创建的对象一模一样的对象(同一个对象) 其他语言中实现单例模式 在其它有Class的语言中,实现单例模式核心步骤是: 01 在创建对象实例时候判断,该类的实例对象是否已经存在,如果已经存在,那么就直接返回 02 如果不存在,那么就创建一个新的实例对象,并保存起来,下次创建实例对象的时候直接使用。 JavaScript中的单例模式JavaScript是一门弱类型,动态,基于原型的语言,并没有类,只有对象。 在JavaScript中要实现单例模式有很多种方式。 最简单的方式:使用字面量的方式来创建对象,因为在JavaScript中对象之间永远不可能相等,除非他们是同一个对象。 使用字面量方式创建的对象总是唯一的12345script&gt; var obj1 = &#123;name:\"zhangsan\"&#125;; var obj2 = &#123;name:\"zhangsan\"&#125;; console.log(obj1 == obj2); //false&lt;/script&gt; 使用new操作符创建对象实现单例 实现单例模式的几种途径 ① 在代码中提供一个全局变量来存储创建出来的实例 缺点:该全局变量可能会被轻易的修改和覆盖 ② 尝试在构造函数的静态成员中缓存实例属性。缺点:函数的静态属性在外部可以直接修改,容易导致实例对象的丢失。 ③ 将实例对象包装在闭包中。优点是安全性较好,无法被轻易的修改,缺点是有额外闭包的开销。 代码示例1234567function China() &#123;&#125;//创建对象var china01 = new China();var china02 = new China();//思考:如果想要实现单例模式,那么最终的结果必要是china01 和china02是同一个对象,那么如何实现 实现方案(一)使用全局变量方式存储创建出来的实例对象代码示例12345678910111213141516171819202122232425262728&lt;script&gt; //01 提供一个全局变量 var instance; //02 提供一个构造函数 function Person() &#123; if (instance == undefined) &#123; instance = this; &#125; this.name = \"默认的名称\"; this.age = 66; //使用全局变量来接收内部创建出来的实例对象(this) return instance; &#125; //03 使用构造函数创建对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2); console.log(p1.name); console.log(p2.name); p1.name = \"修改之后的名称\"; console.log(p1.name); console.log(p2.name); //说明:在上面的方案中我们使用一个全局变量来接收实例对象的值,在构造函数内部也是通过判断这个全局变量来做一些其他的处理 instance = &#123;&#125;; var p3 = new Person(); console.log(p1 == p3);&lt;/script&gt; 说明：这种方法确实可以实现单例模式,但是并不安全,因为全局变量可能会被轻易的修改或者是覆盖,因此不推荐这种方式。 实现方案(二)通过构造函数静态属性来缓存实例对象123456789101112131415161718192021222324252627&lt;script&gt; //01 提供一个构造函数 function Person() &#123; //02 在内部判断构造函数的静态属性中是否拥有实例对象 //如果拥有实例对象,那么就直接返回,否则就设置实例对象,并赋值给构造函数的静态属性 if (typeof Person.instance == \"object\") &#123; return Person.instance; &#125; //设置实例对象的属性和方法 this.name = \"默认的名称\"; this.age = 66; //03 把内部创建的实例化对象赋值给构造函数的静态属性 Person.instance = this; //显示返回 //return Person.instance; //隐式返回 //return this; &#125; //04 创建实例对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2); Person.instance = &#123;&#125;; var p3 = new Person(); console.log(p1 == p3); //false&lt;/script&gt; 说明：在构造函数外部可以直接访问其静态成员(属性和方法),可能会导致实例对象的丢失。 实现方案(二)通过闭包-惰性函数定义来实现12345678910111213141516171819202122&lt;script&gt; //01 提供一个构造函数 function Person() &#123; //02 在函数内部使用私有变量来缓存实例 var instance = this; //03 设置实例对象的属性和方法 this.name = \"默认的姓名\"; this.age = 66; //04 使用惰性函数定义来更新构造函数的实现 //通过一个闭包来返回缓存的实例对象 Person = function () &#123; return instance; &#125; &#125; //05 创建对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2); //代码说明:第一次调用原始构造函数的时候,它会像往常一样返回this(指向内部新创建的实例对象) //再后面调用的时候,它会执行更新后的构造函数,在这个新的函数实现中,我们通过闭包来访问了私有变量,并简单的返回。 //这个instance私有变量存储的是第一次调用构造函数时创建出来的实例对象&lt;/script&gt; 新的问题01 因为内部使用惰性函数定义(重写构造函数会导致之前添加在构造函数中的属性丢失),所以存在属性丢失问题02 在上面的代码中,体现在于创建对象前后设置的构造函数的原型对象丢失问题 代码示例123456789101112131415161718192021222324252627&lt;script&gt; function Person() &#123; var instance = this; this.name = \"默认的姓名\"; this.age = 66; Person = function () &#123; return instance; &#125; &#125; //设置构造函数的原型对象 Person.prototype.des = \"描述信息\"; var p1 = new Person(); //在创建第一个对象之后,设置原型对象 Person.prototype.someThing = \"something\"; var p2 = new Person(); console.log(p1 == p2); console.log(p1.des); //描述信息 console.log(p2.des); //描述信息 console.log(p1.someThing); //undefined console.log(p2.someThing); //undefined //打印对象的构造函数 console.log(p1.constructor.name); //Person console.log(p2.constructor.name); //Person //判断对象的构造函数 console.log(p1.constructor == Person); //false console.log(p1.constructor == p2.constructor,\"构造函数是否一致\");&lt;/script&gt; 解决问题的核心过程1234567891001 提供一个构造函数02 在构造函数内部提供一个私有变量instance03 重写构造函数,返回私有变量instance04 把原有的原型对象赋值给新Person构造函数的原型对象05 调用new 构造函数方法创建一个实例化对象赋值给instance06 修正instance实例的构造器属性,指向新的构造函数(注意:虽然重写了构造函数,但是instance的构造函数仍然是以前的Person)07 设置实例属性和方法08 返回instance对象代码示例 12345678910111213141516171819202122232425262728293031323334353637383940&lt;script&gt; function Person() &#123; //01 提供一个私有变量 var instance; //02 重写构造函数 Person = function () &#123; console.log(instance); //console.log(instance.constructor); var t = this; console.log(t); return instance; &#125;; //03 保留原型属性 Person.prototype = this.__proto__; //这是一个空的对象 Person.lal = \"lala\"; //04 创建并使用私有变量来接收实例对象 instance = new Person(); //05 修正构造函数指针 instance.constructor = Person; //06 设置实例属性和方法 instance.name = \"默认的名字\"; instance.age = 66; //07 返回私有变量 return instance; &#125; Person.haha = \"哈哈\"; //设置构造函数的原型对象 Person.prototype.des = \"描述信息\"; var p1 = new Person(); //在创建第一个对象之后,设置原型对象 Person.prototype.someThing = \"something\"; var p2 = new Person(); console.log(p1 == p2); console.log(p1.des); //描述信息 console.log(p2.des); //描述信息 console.log(p1.someThing); //something console.log(p2.someThing); //something //打印构造器属性 console.log(p1.constructor == Person,\"验证构造器指向\");&lt;/script&gt; 全局变量方式实现单例-改进版1234567891011121314151617181920&lt;script&gt; var Person; (function () &#123; //01 提供一个局部变量instance var instance; Person = function Person() &#123; if (instance) &#123; return instance; &#125; instance = this; this.name = \"默认的名字\"; this.age = 66; &#125; &#125;)(); //创建对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2);&lt;/script&gt; 说明：通过即时函数来限定作用域,外部无法修改内部instance的值(现在是一个局部变量) 工厂模式简单说明工厂模式的目的是用于创建对象,通常在类或者是类的静态方法中实现。 工厂模式的目标 01 用一套方法去创建相似的目标。 02 在编译时不知道具体类型的情况下,为用户提供创建对象的接口 工厂模式实现过程 01 提供一个父构造函数 02 在父构造函数的原型上添加共享的方法 03 在父构造函数身上提供一个静态方法(静态工厂方法) 001 先获取参数(产品类型) 002 判断构造函数是否存在(容错性处理) 003 设置原型链继承:设置子构造函数的原型对象为父构造函数的一个实例对象(目的是为了让子构造函数创建的对象拥有父构造函数上面实例属性和原型属性) 004 使用子构造函数创建实例对象 005 返回新创建的实例对象 04 定义特定的工厂客户(静态方法) 05 通过父构造函数的静态工厂方法来创建产品对象 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; //01 提供一个父构造函数 function PhoneMaker() &#123;&#125;; //02 在父构造函数的原型上添加共享的方法 PhoneMaker.prototype.callPhoneDes = function () &#123; console.log(\"手机的特点是: \" + this.des); &#125; //03 在父构造函数身上提供一个静态方法(静态工厂方法) PhoneMaker.factory = function (type) &#123; //001 先获取参数(产品类型) var typeStr = type; //002 判断构造函数是否存在(容错性处理) if (typeof PhoneMaker[typeStr] !== 'function') &#123; throw \"Error 对应的构造函数不存在,不能生产该种类型的产品\"; &#125; //003 设置原型链继承 PhoneMaker[typeStr].prototype = new PhoneMaker(); //004 使用子构造函数创建实例对象 var newPhone = new PhoneMaker[typeStr](); //005 返回新创建的实例对象 return newPhone; &#125;; //定义特定的工厂客户(静态方法) PhoneMaker.iphone = function () &#123; this.des = \"最安全稳定的系统\"; &#125; PhoneMaker.oppo = function () &#123; this.des = \"充当五分钟,通话两小时\"; &#125; PhoneMaker.vivo = function () &#123; this.des = \"vivo手机,你的音乐手机\"; &#125; //通过父构造函数的静态工厂方法来创建产品对象 var vivo = PhoneMaker.factory('vivo'); var iphone = PhoneMaker.factory('iphone'); var oppo = PhoneMaker.factory('oppo'); vivo.callPhoneDes(); oppo.callPhoneDes(); iphone.callPhoneDes();&lt;/script&gt; 观察者模式观察者模式观察者模式又名为发布-订阅者模式，它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。 观察者模式的特点（优点）12301 观察者模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案02 观察者模式可以取代对象之间硬性编码的通知机制，一个对象不再是显示的调用另外一个对象的接口，这种模式让两个对象松耦合的联系在一起，它们不需要清楚彼此的实现细节就能够相互通信。03 在这种设计模式中，不再是一个对象调用另外一个对象的方法，而是一个对象订阅另一个对象的特定活动并且在状态改变后获得通知 模型01 订阅者也称为观察者02 被观察的对象称为发布者或者是主题03 当发生一个重要事件的时候，发布者将会通知所有订阅者并且经常以事件的形式来传递消息。示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//01 提取成公共的发行者对象 var publisher = &#123; users:&#123; default:[] &#125;, //所有的订阅者对象 addUser:function (fn,type) &#123; //对订阅的类型进行判断 var type = type || \"default\"; //如果是新的订阅类型,那么我们需要做初始化的处理 if (this.users[type] == undefined) &#123; this.users[type] = []; &#125; this.users[type].push(fn); &#125;, removeUser:function (fn,type) &#123; this.tool(type,\"removerUser\",fn); &#125;, publish:function (type) &#123; this.tool(type,\"publish\"); &#125;, tool:function (type,funcType,fn) &#123; var type = type || \"default\"; var users = this.users[type]; if (users == undefined) &#123; console.log(\"当前没有任何订阅者\"); return; &#125; for (var i = 0; i &lt; users.length; i++) &#123; if (funcType == 'publish') &#123; users[i]() &#125;else &#123; if (users[i] == fn) &#123; users.splice(i, 1); break; &#125; &#125; &#125; &#125; &#125;; //02 提供一个工具函数,能够利用发行者对象的模板来快速创建新的发布者 function makePaper(o) &#123; for(var i in publisher) &#123; if (publisher.hasOwnProperty(i) &amp;&amp; typeof publisher[i] == 'function') &#123; o[i] = publisher[i]; &#125; &#125; o.users = &#123;default:[]&#125;; &#125; //03 创建发布者 var paper1 = &#123; day:function () &#123; this.publish(); &#125;, month:function () &#123; this.publish(\"month\") &#125;, year:function () &#123; this.publish(\"year\") &#125; &#125;; //把某个对象编程一个发布者 makePaper(paper1); //04 创建订阅者(当发布者发布消息的时候,订阅者能够收到信息--自动调用订阅者的方法) var obj = &#123; lookDayNews:function () &#123; console.log(\"obj - 查看最新的日报信息\"); &#125;, lookImageNews:function () &#123; console.log(\"obj - 查看图片信息\"); &#125; &#125;; //05 设置订阅 paper1.addUser(obj.lookDayNews); paper1.addUser(obj.lookImageNews,'month'); paper1.day(); paper1.month();&lt;/script&gt; 因本人能力有限，教程中难免出现疏忽，对此带来的不便敬请见谅。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.afanail.com/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.afanail.com/tags/简明教程/"}]},{"title":"有趣的Chrome DevTools","slug":"有趣的ChromeDevTools","date":"2016-11-11T13:46:45.000Z","updated":"2017-07-22T03:54:33.000Z","comments":true,"path":"2016/11/11/有趣的ChromeDevTools/","link":"","permalink":"http://www.afanail.com/2016/11/11/有趣的ChromeDevTools/","excerpt":"Chrome 自带开发者工具很有趣，怎么个有趣法呢？Chrome的JS控制台有很多很多神奇而且有趣的功能。此文仅例举其中几个，一起来看看吧。 我们调试的时候控制台总会有一大堆密密麻麻的代码时，请试着输入 clear() 然后回车，清空所有，回到原始界面。","text":"Chrome 自带开发者工具很有趣，怎么个有趣法呢？Chrome的JS控制台有很多很多神奇而且有趣的功能。此文仅例举其中几个，一起来看看吧。 我们调试的时候控制台总会有一大堆密密麻麻的代码时，请试着输入 clear() 然后回车，清空所有，回到原始界面。 jq选择器第一个有趣的事情就是获取页面上的DOM元素啦！在控制台里通过jQuery选择器选取DOM元素. 如 $(&#39;tagName&#39;) $(&#39;.class&#39;) $(&#39;#id&#39;)等选择器。其实是通过document.querySelector(‘’)返回第一个匹配的DOM元素。通过 $$(&#39;tagName&#39;) $$(&#39;.className&#39;)两个$$符号来选择返回的一个相应的DOM数组。瞧： 获取DOM元素绑定事件其实也是一句代码搞定的事情，但是在调试的时候却非常有用。通过在控制台输入getEventListeners($(&#39;selector&#39;))返回数组对象的格式并且返回元素绑定的所有事件。然后通过getEventListeners($(&#39;selector&#39;)).click[0].listener获取元素绑定的click事件。 Chrome编辑器如果浏览器可以编辑，要记得导出喔。在控制台轻轻输入一句代码，然后试着编辑页面，接下来就是奇迹发生的时候！赶快试一下吧！ 监测事件通过输入monitorEvents($(&#39;selector&#39;)) 监测元素上绑定的所有事件，该元素某个事件被触发就会在控制台里显示出来。monitorEvents($(&#39;selector&#39;),&#39;eventName&#39;)监听元素上绑定的具体事件。第二个参数代表事件类型的名称。monitorEvents($(&#39;selector&#39;),[&#39;eventName1&#39;,&#39;eventName3&#39;,….])同时检测具体指定的多个事件类型。unmonitorEvents($(&#39;selector&#39;)) 用来停止对某个元素的事件监测。 表格形式输出数组先输入数组arr,然后通过输入console.table(variableName)以表格形式查看，如下图： 检查元素你可以直接在控制台里输入下面的方法来检查元素inspect($(&#39;selector&#39;)) 会检查所有匹配选择器的DOM元素，并返回所有选择器选择的DOM对象。inspect($(&#39;img&#39;)[1]) 检查并返回页面上第2个img元素。最后，Chrome DevTools是十分强大的调试工具，这只是冰上一角，深入了解请戳chrome-devtools","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.afanail.com/tags/javascript/"},{"name":"Chrome DevTools","slug":"Chrome-DevTools","permalink":"http://www.afanail.com/tags/Chrome-DevTools/"}]},{"title":"Css简明教程","slug":"css简明教程","date":"2016-11-05T13:26:03.000Z","updated":"2017-07-22T03:53:11.000Z","comments":true,"path":"2016/11/05/css简明教程/","link":"","permalink":"http://www.afanail.com/2016/11/05/css简明教程/","excerpt":"Css简明教程，简洁明了。 CSS基础概念1.CSS的作用：修改样式","text":"Css简明教程，简洁明了。 CSS基础概念1.CSS的作用：修改样式格式：123456&lt;style type=”text/css”&gt; 选择器名称&#123;属性名称：属性对应的值；…&#125;&lt;/style&gt; 属性规定文字的属性 （1）规定文字的样式的属性： font-style:normal(正常的，默认) italic（倾斜） 快捷键：fsn→font-style:normal; （2）规定文字的粗线的属性： font-weight:lighter（细线，默认）bold（加粗） 取值：数字、单词 快捷键：fwb→font-weight:bold; （3）规定文字的大小的属性： font-size:30px; 取值：px（像素） 快捷键：fz30→font-size:30px; （4）规定文字的字体的属性： font-family:微软雅黑; 快捷键：ff→font-family:”微软雅黑”; 注意点：（1）如果取值是中文，需要用双引号或单引号括起来；（2）设置的字体必须是用户电脑里已经安装的字体；（3）如果设置的字体不存在，那么系统就会使用默认的字体来显示；（4）如果不想用默认的字体来显示，可以给字体设置备选方案 font-family: “微软雅黑”，“宋体”…;（5）如果想给中文和英文分别单独设置字体，但凡中文字体，里面都包含了英文；但凡英文字体，里面都不包含中文字体。补充：企业开发中常用的是字体有：中文：宋体 黑体 微软雅黑；英文：Times New Roman Arial；简写：font: style weight size family;注意点：style和weight可以调换位置也可以省略，size和family不可以调换位置也不可以省略，size必须放在family后面，size和family必须放在所有属性后面 规定文本的属性（1）文本装饰属性：text-decoration: ；取值：underline（下划线）/line-through（删除线）/overline（上划线）、none（什么都没有，常用于超链接去除下划线）（2）文本水平对齐属性：text-align: ；取值：right（右）/center（居中）/left（左，默认）（3）文本缩进属性：text-indent: ；取值：em 颜色控制属性color: ;取值：（1）英文（2）rgb（ , , ）：rgb其实就是三原色，其中r（red）g（green）b（blue），rgb（0,0,0）表示黑色，rgb（255,255,255）表示白色，rgb（255,0,0）表示红色，rgb（0,255,0）表示绿色，rgb（0,0,255）表示蓝色（3）rgba（ , , , ）：rgb其实就是三原色；a表示透明度，取值范围0-1，取值越小就越透明（4）十六进制#：本质就是rgb，每两位表示一个颜色（5）缩写十六进制：每个颜色的两位数都是一样的，那么就可以简写 规定背景属性（1）规定背景颜色属性：background-color:取值：英文单词 、rgb、rgba、十六进制、缩写十六进制注意点：同一个标签可以同时设置背景颜色和背景图片，如果颜色和图片同时存在，那么图片会覆盖颜色（2）规定背景图片属性：background-color: url(“”);注意点：图片地址必须放在url()中间，图片可以是本地地址也可以是网络上的地址如果图片的大小没有背景大，那么它会自动的在水平和垂直方向平铺和填充（3）规定背景图片平铺方式属性：background-repeat:取值：repeat:在水平和垂直方向上平铺，默认repeat-x:水平方向上平铺repeat-y:垂直方向上平铺（4）背景定位属性： background-position:水平方向 垂直方向；取值：1.具体的方位名词：水平方向：left right center;垂直方向：top bottom center;2.具体的像素： px注意点：数字可以为负数如何让一张很大的图片无论何时都居中显示?background-position:center top;（5）背景图片关联方式属性： background-attachment：取值：scroll 会随着滚动条而滚动，默认值 fixed 不会随着滚动条而滚动（6）背景尺寸属性：用于设置背景图片的大小 background-size： 取值：默认具体像素:background-size：px px;第一个值宽度，第二个值高度百分比：background-size：% %；宽度的等比拉伸：background-size：auto px;高度等比拉伸: background-size：px auto;cover:告诉系统图片需要等比拉伸到宽度和高度都填满元素contain：告诉系统图片需要等比拉伸到宽度或高度都填满元素 （7）规定背景图片的定位区域属性：告诉系统背景图片从哪个区域开始显示background-origin：取值：padding-box 默认，从padding区域开始显示 border-box从border区域开始显示 content-box从content区域开始显示（8）规定背景的绘制区域属性：用于指定从哪个区域开始绘制背景background-clip：取值：border-box默认，从border开始显示 padding-box 默认，从padding开始显示 content-box从content区域开始显示（9）多重背景图片：1234background:url(“”) no-repeat left top, url(“ ”) no-repeat right top, url(“”) no-repeat left bottom, url(“”) no-repeat right bottom; 注意点：多张图片之间用逗号隔开，先添加的图片会盖住后添加的图片编写多重背景图片时应分开来写123background-image:url(\"images/animal1.png\"),url(\"images/animal2.png\"),url(\"images/animal3.png\");background-repeat: no-repeat, no-repeat, no-repeat;background-position: left top, right top, left bottom; 简写：快捷键是bg+ background：背景颜色 背景图片 平铺方式 关联方式 定位方式；注意点：background的属性任何一个都可以省略 （10）Vertical-align:设置图片与盒子底部对齐 ：vertical-align: bottom;设置图片与盒子顶部对齐： vertical-align: top; 设置图片与文字基线对齐：vertical-align: baseline; 设置图片顶部与文字顶部对齐：vertical-align: text-top; 设置图片底部与文字底部对齐：vertical-align: text-bottom; 设置图片与文字中线对齐： vertical-align: middle; 规定边框的属性（1.1）连写格式一：同时设置四条边框的宽度、样式、颜色 border:边框的宽度 边框的样式 边框的颜色； （1.2）连写格式二：分别设置四条边框的宽度、样式、颜色border-top: 边框的宽度 边框的样式 边框的颜色；border-right:边框的宽度 边框的样式 边框的颜色；border- bottom:边框的宽度 边框的样式 边框的颜色；border- left:边框的宽度 边框的样式 边框的颜色；注意点：连写格式中颜色和宽度可以省略，但是样式不可以省略 （2.1）分开格式一：（1）规定边框的样式的属性： 格式：（同时设置四条边的样式）border-style:上 右 下 左 ；取值：dashed（虚线）solid（实线）注意点：设一个值（上下左右都是一样的） 设两个值（上下）（左右） 设三个值（上）（左右）（下） 设四个值（上）（右）（下）（左）（2）规定边框的宽度的属性：格式：（同时设置四条边的宽度）：border-width:上 右 下 左 ；（3）规定边框的颜色的属性： 格式：（同时设置四条边的颜色）border-color:上 右 下 左； （2.2）分开格式二：（1）规定边框的样式的属性：格式：（分别设置四条边的样式）border-top-style： ； border-light-style: ； border-bottom-style: ； border-left-style: ；（2）规定边框的宽度的属性：格式：（分别设置四条边的宽度）border-top-width： ； border-light-width: ； border-bottom-width: ； border-left-width: ；（3）规定边框的颜色的属性：格式：（分别设置四条边的颜色）border-top-color： ； border-light-color: ； border-bottom-color: ； border-left-color: ； border-radius：设置圆角属性四个参数:左上,右上, 右下 左下, 省略值和它的对角一样 分开写格式： border-top-left-radius: border-top-right-radius: border-bottom-left-radius: border-bottom-right-radius: 注意点：圆角的宽度=正方形的宽度一半就是圆圆角的宽度=长方形宽一半/高一半就是椭圆 圆角的宽度=长方形高就是半圆 圆角的宽度=正方形的边框宽度+宽度的一半就是圆环 4.border-image： 分开写格式： border-image-source: 边框的图片的路径border-image-slice: 设置裁剪的大小 如果是设置数字,则中间内容没有，想要中间也要有背景图片,则需要在最后添加一个参数为fillborder-image-width: 图片边框的宽度border-image-outset: 边框图像区域超出边框的量border-image-repeat: 图像边框是否应平铺(repeat)、自适应铺满(round)或拉伸(stretch)规定内边距的属性就是边框和内容之间的距离注意点：给标签设置内边距后，标签的宽度和高度会发生变化，内边距也会有背景颜色（1）连写格式：padding: 上 右 下 左; （2）分别设置格式： padding-top: ; padding-right: ; padding-bottom: ; padding-left: ; 规定外边距的属性就是标签和标签之间的距离注意点：外边距那一部分是没有背景颜色的 （1）连写格式：margin:上 右 下 左； （2）分别设置格式：margin-top: ; margin-right: ; margin-bottom: ; margin-left: ; 外边距合并的现象： 在默认布局的水平方向上，默认情况外边距是会叠加的 在默认布局的垂直方向上，默认情况外边距是会合并的，谁的外边距比较大就听谁的注意点：1.如果两个盒子是嵌套关系，那么设置了里面有个盒子的顶部的外边距，外面一个盒子也会被顶下来2.如果外面的盒子想保持不变，那么需要给外面的盒子添加一个边框属性3.在企业开发中，一般情况下如果需要控制嵌套关系盒子之间的距离，应该首先考虑padding,其次再考虑margin,因为它本质上是控制兄弟关系之间的间隙的4.在嵌套关系的盒子中，可以利用margin: 0 auto;方式让小盒子在大盒子中水平居中，并且margin: 0 auto;只对水平方向有效margin: 0 auto;和text-align:center;的区别：margin: 0 auto;让盒子中存储的文字和图片水平居中text-align:center;让盒子水平居中清除默认边距（外边距和内边距）：企业开发中为了更好的控制盒子的宽高和计算盒子的宽高，在编写代码前第一件事先清楚默认边距123*&#123;margin:0;padding:0;&#125; 注意点：通配符选择器会找到(遍历)当前界面中所有的标签，所以性能不好企业开发中可以从这个网址中拷贝：http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css 行高属性（行高可以撑起盒子的高度，有时可以省略盒子的高度） 格式： line-height: ； 要想一行文字在盒子中垂直居中那么只需要设置这行文字的行高等于盒子的高度即可 如果是多行文字那么只能通过设置padding来让文字居中 CSS盒子模型：什么是盒子模型CSS盒子模型只是一种形象的比喻，HTML中所有的标签都是盒子结论； （1）在HTML中所有标签都可以设置宽度和高度 宽度/高度 == 存放内容的区域 内边距 ==内容与边框的距离 边框 == 外边距 == （2）内容的宽度和高度：width/height 元素的宽度和高度： 宽度=左边框+左内边距+width+右内边距+右边框 高度同理可证 元素空间的宽度和高度： 宽度=左外边距+左边框+左内边距+width+右内边距+右边框+右外边距 高度同理可证 规律：1.增加了padding之后元素的宽高也会发生变化 2.如果增加了padding之后还想继续保持元素的宽高，那么就必须减去内容的宽高 1.增加了border之后元素的宽高也会发生变化 2.如果增加了border之后还想继续保持元素的宽高，那么就必须减去内容的宽高 盒子box-sizing属性 作用：保证盒子增加了padding和border后，盒子的宽度和高度不变 取值：content-box：默认值，元素的宽高=边距+内边距+内容宽高border-box；元素的宽高==width属性 选择器标签选择器 作用：根据指定的标签名称，在当前界面中找到所有该名称的标签，然后设置属性格式：123标签名称&#123;属性：值；&#125; 注意点：（1）标签选择器选中的是当前界面中的所有标签，而不能单独选中一个标签 （2）标签选择器无论标签藏得多深都能选中 （3）只要是HTML中是标签都可以做标签选择器 id选择器作用：根据指定的id名称找到对应的标签，然后设置属性格式：123#id名称&#123;属性：值；&#125; 注意点：（1）每个HTML都有一个属性叫做id，也就是说每个标签都可以设置id （2）在一个界面中id的名称是不可以重复的 （3）编写id选择器时一定要在id名称面前加上# （4）id的名称是由一定规范的：只能有字母/数字/下划线组成，并且不能以数字开头，企业开发过程中一般都是以字母开头的。Id名称不能是HTML标签的名称。 （5）如果仅仅是为了设置样式，企业开发中一般不会使用id，因为在前端开发中id 是留给js使用的 类选择器 作用：根据指定的类名称找到对应的标签，然后设置属性格式：123.类名&#123;属性：值；&#125; 注意点：（1）每个HTML都有一个属性叫做class，也就是说每个标签都可以设置类名 （2）在一个界面中class的名称是可以重复的 （3）编写class选择器时一定要在类名称面前加上. （4）类的名称是由一定规范的：只能有字母/数字/下划线组成，并且不能以数字开头，企业开发过程中一般都是以字母开头的，不能是HTML标签的名称 （5）类名是专门用来给某个特定的标签设置样式的 （6）在HTML中每个标签是可以同时绑定多个类名 格式：&lt;标签名称 class=”类名1 类名2 ……”&gt; id选择器与class选择器的区别： （1）id相当于人的身份证不可以重复，class相当于人的名称可以重复 （2）一个HTML标签名称只能绑定一个id名称，可以绑定多个class名称 （3）id选择器是以#开头，class是以.开头 （4）id一般是给js使用的，所有除非特殊情况，否则不要使用id去设置样式 后代选择器 作用：找到指定的标签的所有后代标签，然后设置属性格式：123标签名称1 标签名称2&#123;属性：值；&#125; 先找到名称叫做标签名称1的标签，再在这个标签下去查找所有名称叫做标签名称2的标签，然后设置属性 注意点： （1）后代选择器必须用空格隔开 （2）后代不仅是儿子，也包括孙子等等，只要最终是放在指定标签的都是后代 （3）后代选择器不仅仅可以使用标签名称，还可以使用其他选择器 子元素选择器 作用：找到指定标签中所有特定的直接子元素，然后设置属性格式：123标签名称1&gt;标签名称2&#123;属性：值；&#125; 先找到名称叫做标签名称1的标签，然后再在这个标签下去查找所有直接子元素名称叫做标签名称2的标签，然后设置属性 注意点： （1）子元素选择器之间需要用&gt;符号连接，并且不能有空格 （2）子元素选择器只会查找儿子，不会查找其他被嵌套的标签 （3）子元素选择器不仅仅可以使用标签名称，还可以使用其他选择器 后代选择器与子元素选择器的区别与联系： （1）后代选择器用空格作为连接符号，子元素选择器用&gt;作为连接符号 （2）后代选择器会选中指定标签中所有的特定后代标签，子元素选择器只会选中指定标签中的所有特定标签中的直接标签 （3）后代选择器和子元素选择器都可以使用标签名称/id名称/class名称作为选择器，都可以通过各自的连接符号一直延续下去 （4）在企业开发中如果想选中所有特定的标签，那么就使用后代选择器，如果只想选中指定标签中的所有特定儿子标签，那就使用子元素选择器 交集选择器 作用：给所有选择器选中的标签中，相交的那部分设置属性 格式：123 选择器1选择器2&#123;属性：值；&#125; 注意点：（1）选择器和选择器之间没有任何的连接符号 （2）选择器可以使用标签名称/id名称/class名称 （3）企业开发中用的比较少 并集选择器 作用：给所有选择器选中的标签设置属性 格式：123 选择器1，选择器2&#123;属性：值；&#125; 注意点：（1）选择器和选择器之间必须用，来连接 （2）选择器可以使用标签名称/id名称/class名称 兄弟选择器1.相邻兄弟选择器：（CSS2）作用：给指定选择器后面紧跟的那个选择器选中的标签设置属性 格式：123 选择器1+选择器2&#123;属性：值；&#125; 注意点：（1）选择器和选择器之间必须用+来连接 （2）选择器可以使用标签名称/id名称/class名称 （3）相邻兄弟选择器只能选中紧跟其后的那个标签，不能选中隔开的标签 2.通用兄弟选择器：（CSS3）作用：给指定选择器后面的所有选择器选中的所有标签设置属性 格式：123 选择器1~选择器2&#123;属性：值；&#125; 注意点：（1）选择器和选择器之间必须用~来连接 （2）选择器可以使用标签名称/id名称/class名称 （3）相邻兄弟选择器选中的是指定选择器后面某个选择器选中的所有标签，无论有没有隔开 序选择器1.同级别的第几个 （1）first-child:选中同级别的第一个标签 （2）last-child:选中同级别的最后一个标签 （3）nth-child（n）:选中同级别中的第n个标签 （4）nth-last-child（n）:选中同级别中的倒数第n个标签 （5）only-child：选中父元素中唯一的元素 （6）nth-child(odd):选中同级别中的奇数行 （7）nth-child(even):选中同级别中的偶数行 （8）nth-child(xn+y):x、y用户自定义，n是计数器，从0开始递增 注意点：不区别类型 2.同类型的第几个 （1）first-of-type:选中同级别中同类型的第一个标签 （2）first-of-type:选中同级别中同类型的最后一个标签 （3）nth-of-type（n）:选中同级别中同类型的第n个标签 （4）nth-last-of-type（n）:选中同级别中同类型的倒数第n个标签 （5）only-of-type：选中父元素中唯一类型的某个标签 属性选择器作用：根据指定的属性名称找到对应标签，然后设置属性（1）格式：[属性]（2）格式：[属性=value]（3）格式（属性的取值是以什么开头的）： [属性|=value] （CSS2） [属性^=value] （CSS3） 两者之间的区别：CSS2中的只能找到以value开头，并且value是被-和其他内容隔开的，CSS3中的只要是以value开头的都可以找到（4）格式（属性的取值是以什么结尾的）： [属性$=value] （CSS3）（5）格式（属性的取值是否包含某个特定的值）： [属性~=value] （CSS2） [属性*=value] （CSS3） 两者之间的区别：CSS2中的只能找到独立的单词，也就是包含value，并且是被空格隔开的，CSS3中的只要包含value就可以找到 通配符选择器作用：给当前界面上所有的标签设置属性 格式：*{ 属性：值；} 注意点：由于通配符选择器是给界面所有的标签设置属性，所以在设置之前会遍历所有的标签，如果标签比较多，那么性能就会比较差，所有一般在企业开发中不会使用它 CSS三大特性继承性作用：给父元素设置一些属性，子元素也可以使用 注意点：（1）并不是所有的属性都可以继承，只有以color/font-/text-/line开头的属性可以继承。 1.不仅是儿子可以继承，后代都可以继承。2.CSS继承性的特殊性：a标签的文字属性和下划线是不能继承的，h标签的文字大小是不能继承的 应用场景：在企业开发中，一般用于设置网页的一些共性信息，例如网页的文字颜色，字体，大小等 层叠性作用：层叠性是CSS处理冲突的一种能力 注意点：层叠性只有在多个选择器选中“同一个标签”，又设置的 “相同属性”，才会发生层叠性 优先级作用：当多个选择器选中同一个标签，并且给同一个标签设置相同的属性时，如何层叠就由优先级来确定 优先级的判断方式： （1）是否是直接选中（间接选中就是指继承）：如果是间接选中那么就是谁离目标标签比较近就听谁的 （2）相同选中器：如果都是直接选中并且是相同选中器那么谁写在后面就听谁的 （3）不同选择器：如果都是直接选中并且不是相同选中器，那么就按照选择器的优先级来层叠：id&gt;类&gt;标签&gt;通配符&gt;继承&gt;浏览器默认 !important属性作用：用于提升某个直接选中标签的选择器中的某个属性的优先级，可以将被指定的属性的优先级被提升为最高 注意点：（1）只能用于直接选中，不能用于间接选中 （2）只能提升被指定的属性的优先级，其他属性的优先级不变 （3）通配符选择器选中的标签也是直接选中 权重问题： 作用：当多个选择器混合在一起使用时，我们可以通过计算权重来判断谁的优先级最高 权重的计算规则：（1）首先先计算选择器中有多少个id，id多的选择器优先级最高 （2）如果id的个数一样，那么再看类名的个数，类名个数多的优先级最高 （3）如果类名的个数一样，那么再看标签名称的个数，标签个数多的优先级最高 （4）如果id个数一样，类名个数一样，标签名称个数一样，那么此时谁写在后面就听谁的，即优先级一样的时候，谁写在后面就听谁的 注意点：只有选择器直接选中标签才需要计算权重 CSS元素显示模式1.div和span 1.div 作用:一般配合CSS完成网页的基本布局 2.span 作用：一般配合CSS修改网页中的一些局部信息 两者区别：（1）div会单独占领一行，而span不会单独占领一行 （2）div是一个容器级的标签，而span是一个文本级的标签 容器级标签和文本级标签的区别： 容器级的标签中科院嵌套其他所有的吧，而文本级的标签只能嵌套文字/图片/超链接标签容器级的标签：div h u lol li dt dd…… 文本级的标签：span p buis e mind del…… 2.块级元素、行内元素、行内块级元素（1）块级元素：独占一行；如果没有设置宽度，那么默认和父元素一样宽；如果设置了宽度，就按照设置的宽度来显示p div h ul oi li dt dd……（2）行内元素：不会独占一行；如果没有设置宽度，那么默认和内容一样宽；行内元素是不可以设置宽度的span buis strong em ins del……（3）行内块级元素：为了能够让元素既能够不独占一行，又可以设置宽度和高度，那么就出现了块级行内元素 如何转换CSS元素的显示模式？设置元素的display属性取值：block 将元素转换为块级元素inline 将元素转换为行内元素inline-block 将元素转换为行内块级元素 网页布局方式网页元素排版网页的布局方式其实就是指浏览器是如何对网页的元素进行排版的 （1）标准流（文档流/普通流）排版方式浏览器的默认排版方式，有两种排版方式：垂直排版：如果元素是块级元素，那么就会垂直排版水平排版：如果元素是行内元素/行内块级元素，那么就会水平排版 （2）浮动流排版方式【1】浮动流是一种半脱离标准流的排版方式，只有水平排版方式，它只能设置某个元素向左对齐或向右对齐 注意点： （1）浮动流中是没有居中对齐的 （2）浮动流中是不可以使用margin:0 auto; 特点： （1）在浮动流中是不区分行内元素/块级元素/行内块级元素，无论是内元素/块级元素/行内块级元素都可以水平排版，都可以设置宽高 （2）浮动流中行内元素/块级元素/行内块级元素都可以设置宽高 【2】浮动元素脱标： 当某一个元素浮动之后，那么这个元素看上去就像被从标准流中删除一样 脱标后的影响：如果前面一个元素浮动了，而后面一个元素没有浮动，那么这个时候前一个元素就会盖住后面一个元素 【3】浮动元素排序规则： （1）相同方向上的浮动元素，先浮动的元素会显示在前面，后浮动的元素会显示在后面 （2）不同方向上的浮动元素，左浮动找左浮动，有浮动找右浮动 （3）浮动元素浮动后的位置由浮动元素浮动之前在标准流中的位置来决定 【4】浮动元素贴靠方式： （1） 当父元素足够放下所有浮动元素的时候，那么浮动元素就会并列显示 （2）当父元素不够放下所有浮动元素的时候，那么就会从最后一个元素开始向前一个元素贴靠，一直往前贴，直到贴到父元素的边框，这是不管父元素够不够都会贴靠在那里 【5】浮动元素字围现象：浮动元素不会挡住没有浮动元素中的文字, 没有浮动的文字会自动给浮动的元素让位置,这个就是浮动元素字围现象【6】浮动元素高度问题： （1）在标准流中内容的高度是可以撑起父元素的高度 （2）在浮动流中浮动元素是不可以撑起父元素的高度 【7】清除浮动： 《1》方式一：给前面一个元素设置高度 注意点：在企业开发中，我们能不写高度就不写高度，所以这种方式用的比较少 《2》方式二：给后面一个元素添加clear属性 取值：none:默认取值，按浮动元素的规则来排序(右浮动找右浮动,左浮动找左浮动) left:不要找前面的左浮动 right:不要找前面的右浮动 both: 不要找前面的左浮动和右浮动 注意点：当给某个元素添加clear属性之后，那么这个属性的margin属性就会失效 《3》方式三：隔墙法 （1）外墙法：在两个盒子之间添加一个额外的块级元素，并且给这个块级元素添加clear:both;属性 注意点：外墙法可以让第二个盒子使用margin-top属性，但不可以让第一个盒子使用margin-bottom属性。一般在企业开发中，是直接给额外添加的块级元素添加一个高度 （2）内墙法：在第一个盒子中所有子元素最后添加一个额外的块级元素，并且给这个块级元素添加clear:both;属性 注意点：内墙法可以让第二个盒子使用margin-top属性，也可以让第一个盒子使用margin-bottom属性。 （3）区别：外墙法不能撑起第一个盒子的高度，而内墙法可以撑起第一个盒子的高度 《4》方式四：伪元素选择器： 作用：给指定标签的内容前面添加一个子元素或者给指定标签的内容后面添加一个子元素 （1）格式一:给指定标签的内容前面添加一个子元素 标签名称：：before{ 属性名称：值； content: ； 给指定添加的子元素中存储的内容 width: ; height: ; 给指定添加的子元素的宽度和高度 display:block; 给指定添加的子元素的显示模式 visibility:hidden; 隐藏添加的子元素} （2）格式二：给指定标签的内容后面添加一个子元素 标签名称::after{ 属性名称：值； content: ； 设置添加的子元素的内容为空 height:0 ; 设置添加的子元素的高度为0 display:block; 设置添加的子元素为块级元素 visibility:hidden; 隐藏添加的子元素 clear:both; } 兼容IE6：给第一个盒子添加 .box1{*zoom:1;} 《5》 方式六：overflow:hidden; 作用：（1）可以将超出标签范围的内容裁剪掉 （2）可以清处浮动 （3）可以通过overflow:hidden;让里面的盒子设置margin-top之后，外面的盒子不被顶下来 注意点：可以让第二个盒子使用margin-top属性，也可以让第一个盒子使用margin-bottom属性 定位流排版方式《1》相对定位:相对于自己以前在标准流中的位置来移动格式：position:relative注意点：不会脱离标准流的，会继续在标准流占用一定的空间 需要配合 top right left bottom 来使用，但同一方向定位属性只能使用一个 由于相对定位是不脱离标准流的，所以是区分块级元素/行内元素/行内块级元素 由于相对定位是不脱离标准流的，并且相对定位的元素会占用标准流中的位置，所以当给相对定位元素设置margin/padding等属性会影响到标准流的布局应用场景：用于对元素进行微调（想让多个盒子对齐时可以使用【想让多个盒子顶部对齐也可以使用浮动定位】}）配合绝对定位来使用《2》绝对定位：相对于body来定位 格式：position：absolate 定位的参考点规律：默认情况下所有的绝对定位元素是相对于body来定位如果绝对定位的元素有祖先元素，并且祖先元素也是定位流，那么这个绝对定位元素就会以定位流（相对定位/绝对定位/固定定位）的那个祖先元素作为参考点如果绝对定位的元素有多个定位流的祖先元素，那么这个绝对定位流元素就会以离它最近的那个祖先元素作为参考点 注意点：绝对定位是脱离标准流的，不区分块级元素/行内元素/行内块级元素 需要配合 top right left bottom 来使用，但同一方向定位属性只能使用一个 如果一个绝对定位的元素是以body作为参考点，那么其实是以网页首屏的宽度和高度作为参考点，而不是整个网页的宽度和高度作为参考点的 一个绝对定位元素是会忽略祖先元素的padding应用场景：用于对元素的微调,配合相对定位来使用 子绝父相（子元素用绝对定位，父元素用相对定位）相对定位的弊端：不脱离标准流，会继续占用一定的空间，不利于布局界面绝对定位的弊端：默认情况下绝对定位是以body作为参考点，不会随着浏览器的宽度高度的变化而变化 应用场景：当某一个元素覆盖在另一个元素上面时，需要用到定位流绝对定位的水平居中问题： 只需设置绝对定位元素的left:50%; 然后在设置绝对定位元素的margin-left:-元素宽度的一半px 《3》固定定位：固定定位和背景关联方式很像，背景定位可以让背景图片不随着滚动条而滚动，而固定定位可以让某个元素不随着滚动条而滚动 格式：position:fixed; 注意点：固定定位的元素是脱离标准流的，不会占用标准流的空间 固定定位和绝对定位一样，不区分块级元素/行内元素/行内块级元素 应用场景：导航条在网页顶部的固定位置,网页两侧的广告,底部返回顶部的按钮《4》静态定位（默认状态） 格式：position:static定位流z-index:专门用于控制定位流的覆盖关系 规律：默认情况下所有的元素都有一个z-index属性，取值为0 默认情况下定位流元素覆盖标准流的元素 默认情况下定位流的元素后遍写的覆盖先编写的，如果定位流元素中设置了z-index属性，那么谁的z-index比较大，谁就显示在上面注意点：从父现象 （1）如果两个元素父元素都没有设置z-index属性，那么谁的z-index比较大，谁就显示在上面 （2）如果两个元素父元素都设置了z-index属性，那么子元素的z-index就会失效，谁的父元素z-index属性比较大，那么谁就会显示在上面 a标签伪类选择器 （1）作用：专门用来修改a标签不同状态的样式 （2）状态：从未被访问过（默认状态）、被访问过状态、鼠标长按状态、鼠标悬停在上面状态（3）格式：a:link{color： ;}修改从未被访问过状态下的样式 a:visited{color: ;}修改被访问过状态下的样式 a:active{color: ;}修改鼠标长按状态下的样式 a:hover{color: ;}修改鼠标悬停a标签上状态下的样式 （4）注意点： a标签伪类选择器可以单独初中，也可以同时出现。同时出现需要严格准守爱恨原则（love hatd）：a:link、a:visited、 a:hover、a:active 如果默认状态和被访问过状态是一样的，可以简写a{color:} 在企业开发中编写a标签伪类选择器最好写在标签选择器后面 在企业开发中和a标签盒子相关属性都写在标签选择器中（显示模式/宽度/高度/padding/margin） 在企业开发中和a标签文字/背景相关属性都写在伪类选择器中（5）悬停在链接上背景颜色的改变：http://localhost:63342/HTML5学习代码/A标签伪类选择器.html 过渡模块1.格式：1234567选择器&#123; transition-property:属性； transition-duration:时间&#125; 标签:hover&#123;属性：值；&#125; 2.过渡三要素：hover可以使用在任何标签上transition-property: 告诉系统哪个属性需要执行过渡效果 transition-duration:告诉系统过渡效果持续的时长注意点：当多个属性需要同时执行过渡效果，用逗号隔开即可3.其他属性； transition-delay:告诉系统延迟多久后再执行过渡动画 transition-timing-function:告诉系统过渡动画的运动速度 取值：linear匀速 ease逐渐慢下来 ease-in加速 ease-out减速 ease-in-out先加速再减速 4.连写：transition：property duration timing-function delay；注意点：如果多个属性需要同时执行过渡效果，用逗号隔开即可 连写的时候可以省略后面两个参数，因为只有编写了前面两个参数就已经满足了过渡三要素 如果多个属性运动的速度/延迟的时间/持续的时间都一样，那么可以简写为transition：all 值；5.编写过渡套路：先编写基本界面，再修改我们认为需要修改的属性，最后给被修改属性的那个元素添加过渡即可 2D转换模式1.格式：1选择器：hover&#123;transform: ；&#125; 取值：rotate(数字deg) 旋转多少度 translate（ px, px） 平移 第一个值代表水平方向，第二个值代表垂直方向 scale（ , ） 缩放第一个值代表水平方向，第二个值代表垂直方向，取值1代表不变，大于1 代表放大，小鱼1代表缩小。如果水平垂直方向缩放都一样，可以简写为一个参数注意点：如果父元素被缩放了，那么子元素也会被缩放2.综合效果： transform: rotate(数字deg) translate（ px） scale（ , ）；注意点：需要用空格隔开。2D的转换会修改元素坐标系，所以旋转后再平移就不是水平平移了3.形变中心点： 格式：1选择器&#123;：transform-origin： px px；&#125; 第一个参数代表水平方向，第二个参数代表垂直方向 取值：像素、百分比、单词 默认情况下所有的元素都是以自己的中心点作为参考来旋转4.旋转轴点：（1）默认情况下所有的元素都是围绕Z轴进行旋转：transform: rotateZ(数字deg)（2）围绕X轴进行旋转：transform: rotateX(数字deg)（3）围绕Y轴进行旋转：transform: rotateY(数字deg)注意点：屏幕的原点在左上角 左上角transform: rotate(0% 0%)中心点transform: rotate(50% 50%)5.透视属性：近大远小 perspective: px;注意点：想看到近大远小的效果越明显那么像素值就设置越大，想看到近大远小的效果越模糊那么就像素设置越大必须添加到需要呈现近大远小效果的元素的父元素上面 盒子阴影和文字阴影1.盒子阴影：box-shadow:h-shadow v-shadow blur spread color inset;h-shadow水平偏移v-shadow垂直偏移blur模糊度spread阴影扩展color阴影颜色inset内外阴影注意点：盒子阴影分内外阴影，默认是外阴影 快速添加盒子阴影：box-shadow:h-shadow v-shadow blur，阴影颜色由盒子内容颜色决定2.文字阴影：text-shadow:h-shadow v-shadow blur color注意点：快速添加文字阴影test-shadow:h-shadow v-shadow blur，阴影颜色由文字颜色决定3.翻转菜单http://localhost:63342/HTML5学习代码/翻转菜单.html 动画模块1.动画与过渡的异同： 不同点：过渡必须人为的触发才会执行动画 动画不需要人为的触发就会执行动画相同点：过渡与动画都是用来给元素添加动画的，都是系统新增的一些属性，都需要满足三要素才会有动画效果2.动画三要素： （1）告诉系统需要执行哪个动画 （2）告诉系统我们需要自己创建一个名称叫做xxx的动画 （3）告诉系统动画持续的时长3.格式一：（起始动画）12345678910111213141516171819202122232425262728293031 选择器&#123;animation-name: ； animation-duration: ； &#125; @keyframes 动画名称&#123;form&#123;&#125;to&#123;&#125;&#125;格式二：（百分比）选择器&#123;animation-name: ；animation-duration: ；&#125;@keyframes 动画名称&#123;0%&#123;&#125;25%&#123; &#125;50%&#123;&#125;75%&#123;&#125;100%&#123;&#125;&#125; 4.其他属性： animation-delay:告诉系统延迟多久后再执行动画 animation-timing-function:告诉系统动画的执行的速度 取值：linear匀速 ease逐渐慢下来 ease-in加速 ease-out减速 ease-in-out先加速再减速 animation-iteration-count:告诉系统动画被播放的次数 animation-direction:告诉系统是否需要执行往返动画 取值：normal:默认，执行完一次之后回到起点再执行下一次 alternate：执行完一次之后往回执行下一次 animation-play-state: : 告诉系统当前动画是否需要暂停 取值:running: 执行动画 paused: 暂停动画 动画的状态：等待状态 、开始状态 、结束状态 animation-fill-mode:指定动画的等待状态和结束状态的样式 取值：none:不做任何改变 forwords：让元素结束状态保持最后一帧的样式 backwordes：让元素等待状态时候显示动画的第一帧样式 both：让元素等待状态时候显示动画的第一帧样式，让元素结束状态保持最后一帧的样式5.注意点：（1）动画中如果有和默认样式中同名的属性，会覆盖覆盖默认样式中的同名属性 （2）在编写动画的时，固定不变的值写在前面，需要变化的值写在后面6.连写格式：animation：动画名称 动画时长 动画运动速度 延迟时间 执行次数 往返动画；简写模式：animation：动画名称 动画时长 动画运动速度； 3D转换模块1.2D和3D： 2D就是一个平面，只有看到和高度，没有厚度 3D就是一个立体，有宽度和高度，还有厚度 默认情况下，所有元素都呈现2D展现的2.如何让元素呈3D展现？ 和透视效果一样，想看到某个元素的3D效果，只需要给它的父元素添加一个transform-style属性，然后设置perspective-3d即可3.正方体 编写顺序：（先旋转再平移）上 后 下 前 左 右4.长方体：先编写正方体然后再对上后下前四个面进行拉伸 渐变1.线性渐变：直接设置渐变：background: linear-gradient(red,blue);添加渐变方向：background: linear-gradient(to right, red,blue); 可以根据角度设置渐变方向：background: linear-gradient(45deg,red,blue);设置渐变到下一颜色的位置：background: linear-gradient(to right,red 30%,green 80%,blue); 2.径向渐变：默认从中点开始扩散：background: radial-gradient(red,green,blue); 大小范围,位置,颜色：background: radial-gradient(100px at center center,red,blue);可以通过像素进行设置位置：background: radial-gradient(100px at 50px 50px,red,blue);3.重复渐变： 重复线性渐变：background: repeating-linear-gradient(to right,red 10%,blue 20%); 重复径向渐变：background: repeating-radial-gradient(red 10%, blue 20%, yellow公共的项目类写在第一个小范围调整时，使用相对定位；大范围调整使用绝对定位谷歌浏览最小字体是12px，如果想字体再小一些，可以使用缩放属性（inline-block）在一个盒子中，如果一个元素添加了浮动，那么其他元素也要进行浮动，为了页面的稳定性.webpictuer网页图片，谷歌独有图片，图片被压缩处理过，但图片清晰度不会改变，加载速度快 1.如果图片的宽度小于父元素的宽度, 那么可以使用text-align: center;来居中图片2.如果图片的宽度大于父元素的宽度, 但是图片的宽度是已知的, 那么可以使用定位流 left:50%; margin-left: -图片宽度的一半;3.如果图片的宽度大于父元素的宽度, 但是不知道图片的宽度, 那么可以使用给父元素添加text-align: center; 给图片添加margin: 0 -100%;","categories":[{"name":"Css简明教程","slug":"Css简明教程","permalink":"http://www.afanail.com/categories/Css简明教程/"}],"tags":[{"name":"简明教程","slug":"简明教程","permalink":"http://www.afanail.com/tags/简明教程/"},{"name":"css","slug":"css","permalink":"http://www.afanail.com/tags/css/"}]},{"title":"HTML简明教程","slug":"HTML简明教程","date":"2016-10-18T15:45:46.000Z","updated":"2017-07-22T03:52:59.000Z","comments":true,"path":"2016/10/18/HTML简明教程/","link":"","permalink":"http://www.afanail.com/2016/10/18/HTML简明教程/","excerpt":"简单的概念，简洁明了。 常识1.什么是浏览器？功能：（1）将网页渲染出来让用户查看（2）并让用户与网页交互的一种软件主流浏览器：IE（内核：Trident） 火狐（内核：Gecko） 谷歌（内核：Webkit/Blink） Safari（内核：Webkit） 欧朋（内核：Presto）因为内核不同，所以渲染的网页有所不同","text":"简单的概念，简洁明了。 常识1.什么是浏览器？功能：（1）将网页渲染出来让用户查看（2）并让用户与网页交互的一种软件主流浏览器：IE（内核：Trident） 火狐（内核：Gecko） 谷歌（内核：Webkit/Blink） Safari（内核：Webkit） 欧朋（内核：Presto）因为内核不同，所以渲染的网页有所不同2.什么是服务器？超级计算机，24小时不断电不关机，专门用于存储数据 3.什么是URL?我们在浏览器的地址栏输入的就是URL，eg：http://127.0.0.1:80/index.htmlhttp:// URL协议类型127.0.0.1 服务器IP地址:80 服务器的端口号/index.html 需要访问的资源名称 HTML基础1.HTML（超文本标记语言）作用：专门用来描述文本语义的，也就是说告诉浏览器哪些是标题哪些是段落。注意事项：HTML作用只有一个专门给文本添加语义的，不是用来修改文本样式的。&lt;h1&gt;标签的作用是告诉浏览器哪些文字是标题，即给指定文字添加标题语义的.html是纯文本文件 2.乱码问题：（1）基本上都保存为UTF-8:&lt;meta charset=”UTF-8”&gt;（2）保存网页的字符集和网页中指定的字符集设置为一致 3.DTD文档声明：不是HTML标签，必须在第一行，不区分大小&lt;!DOCTYPE html&gt;：HTML5的DTD文档声明是上下兼容的 HTML标签1.标签分类：（1） 双标签1&lt;html&gt;&lt;/html&gt; &lt;title&gt;&lt;/title&gt; &lt;body&gt;&lt;/body&gt;…… 单标签 `&lt;meta&gt; &lt;br&gt;……` （2） 兄弟关系 &lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;嵌套关系 &lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt; 2.&lt;hn&gt;标签：&lt;h1&gt;~&lt;h6&gt; 注意点：（1）H标签是用来给文本添加标题语义的（2）被H系列标签包裹的内容会独占一行（3）在企业开发中一般情况下一个界面只能出现一个H1标签 3.&lt;p&gt;标签：作用：告诉浏览器哪些文字是一个段落注意点：在浏览器中会独占一行 4．&lt;hr&gt;标签：分割线 注意点：在浏览器中会独占一行 5.img标签 （1）格式：&lt;img src=””alt=””title=”” &gt; （2）注意点： 如果我们不指定img标签的宽度和高度，那么系统按照默认图片宽度和高度，如果我们手动指定了Img标签的宽度和高度，有可能导致图片变形。 如果想指定img标签的宽度和高度，又不想图片变形，我们只能只指定宽度或高度其中一个 （3）常用属性： src：用来显示图片的路径 title：用来告诉浏览器，当鼠标悬停在图片上时，需要弹出的描述框中显示什么内容 alt:当需要显示的图片找不到的时候显示什么内容 6.&lt;br&gt;：用于换行 注意点： 多个br标签可以同时使用由于HTML是用于给文本添加语义的，而br标签的语义不是另起一个段落，所以在企业开发中很少使用它 7.路径问题 给src属性赋值有两种方式： （1）相对路径:每次都是从.html文件所在的文件夹开始查找 同级：图片和.html文件存储在同一个文件夹中，格式：src=”xxx.xxx” 下级：存储图片的文件夹和.html文件在同一个文件夹中，格式：src=”xxx/xxx.xxx” 上级：存储图片的位置和存储代码的文件夹在同一个文件夹中，格式：src=”../xxx.xxx” （2）绝对路径:每次都是从指定的盘符开始查找 注意点： 企业开发中如果需要编写路径，统一使用反斜杠/ 企业开发中一般不使用绝对路径，因为可移植性不好 8.a标签：用于控制页面与页面之间的跳转 （1）格式：&lt;a href=””&gt;&lt;/a&gt; （2）注意点： a标签不仅可以让文字可以点击，也可以让图片能够被点击 a标签必须有一个href属性 如果通过a标签的href属性指定一个URL地址，那么必须在地址前加上http://或https:// a标签的href属性除了可以指定一个网址，还可以指定一个本地地址 （3）常用属性： target（跳转方式）：_self:在当前选项卡中跳转，默认。_blank:在新的选项卡中跳转 title：用来告诉浏览器，当鼠标悬停在链接上时，需要弹出的描述框中显示什么内容 （4）假链接：点击之后不会跳转，企业开发前期，其他页面都没有写出来，就用假链接来代替 格式：&lt;a href=”#”&gt;会自动回到网页顶部 &lt;a href=”javascript”&gt;不会自动回到网页顶部 9.base标签：专门用来统一的指定当前网页中所有的超链接需要如何打开 格式：&lt;base target=””&gt; 注意点：如果base和a标签同时指定了打开方式，网页的打开方式由a标签决定 10.锚点：(1)要想通过a标签跳转到当前界面的指定位置，那么必须告诉a标签一个独一无二的id，这样才能在当前界面找到需要跳转到的目标位置,格式： 1234&lt;a href=”zhongbu”&gt;&lt;h2&gt;我是顶部&lt;/h2&gt;&lt;/a&gt;&lt;h2 id=”zhongbu”&gt;我是中部&lt;/h2&gt;&lt;a href=”dibu”&gt; 跳转到底部&lt;/a&gt;&lt;h2 id=”dibu”&gt;我是底部&lt;/h2&gt; (2)想通过a标签跳转到其他界面的指定位置 格式：12&lt;a href=”新界面的网址#123”&gt;跳转到xxx&lt;/a&gt;&lt;h2 id=”123”&gt;欢迎来到这里&lt;/h2&gt; 11.列表标签（1）无需列表：ul 作用：给一堆数据添加列表语义，并且这一堆数据没有先后之分 格式：&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 应用场景：新闻列表 商品列表 导航条（2）有序列表：ol 作用：给一堆数据添加列表语义，并且这一堆数据有先后之分 格式：&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;（3）定义列表：dl 作用：给一堆数据添加列表语义，先通过dt标签定义列表中的所有标题，然后在通过dd标签给标题添加描述信息 格式：&lt;dl&gt;&lt;dt&gt;&lt;/dt&gt;&lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt;dt:定义列表的标题 dd:描述标题对应的含义 应用场景：网页的导航条 做网站尾部的相关信息 做图文混排 12.表格标签：&lt;table&gt;&lt;/table&gt; （1）作用：给一堆数据添加表格语义 （2）格式： &lt;table&gt;&lt;caption&gt;&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; tr：表示一行 td:表示一行的一个单元格 th：专门用来存储每一列的标题，内容会自动加粗居中 caption:专门用来指定表格标题 （3）注意点：表格边框属性border默认为0 常用属性：（1）宽度和高度（table、td） 表格默认宽高度是根据内容的尺寸调整的，也可以通过table标签设置width/height属性来手动设置； 如果给td标签设置width/height属性，只会改变单元格的宽度和高度，不会影响整个表格的宽度和高度 （2）水平对齐（table、td、tr） 给table标签设置align属性，可以控制表格在水平方向的对齐方式； 给tr标签设置align属性，可以控制当前行中的所有单元格的水平方向对齐方式； 给td标签设置align属性，可以控制当前行中的单元格内容的水平方向对齐方式； 注意点：如果同时给tr、td设置align属性，那么单元格中的内容会安照td的设置来对齐 （3）垂直对齐（td、tr） 给tr标签设置设置valign属性,可以控制当前行中的所有单元格的垂直方向对齐方式； 给td标签设置设置valign属性,可以控制当前行的单元格内容的垂直方向对齐方式 注意点：如果同时给tr、td设置valign属性，那么单元格中的内容会安照td的设置来对齐 （4）外边距：单元格与单元格之间的距离，默认情况下cellspacing=2px（5）内边距:单元格的边框与内容之间的间隙，默认情况下cellpadding=1px（6）水平方向上的单元格合并：（行上的单元格合并），给td标签设置一个colspan属性，来指定把一个单元格当作多个单元格（7）垂直方向上的单元格合并：（列上的单元格合并），给td标签设置一个rowspan属性,来指定把一个单元格当作多个单元格 细线表格制作方式：123456789&lt;table bgcolor=\"black\" cellspacing=\"1px\" &gt; &lt;tr bgcolor=\"white\" &gt; &lt;td&gt;1.1&lt;/td&gt; &lt;td&gt;1.2&lt;/td&gt; &lt;/tr&gt; &lt;tr bgcolor=\"white\" &gt; &lt;td&gt;2.1&lt;/td&gt; &lt;td&gt;2.2&lt;/td&gt; &lt;/tr&gt; 表格完整格式：（仅作了解）123456789101112131415161718&lt;table&gt; &lt;caption&gt;&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 13.表单标签：（1）作用：表单是专门用来收集用户信息的表单标签比较特殊，在浏览器中有自己默认的外观和功能。（2）格式： &lt;from&gt;&lt;表单元素&gt;&lt;/from&gt;（3）常见表单元素： input标签（默认有边框）：它有一个type属性，这个属性有很多类型的取值，取值的不同决定了input标签的功能和外观，除了按钮类型的input标签以外，其他标签都可以通过value属性来指定将来提交到服务器的值 《1》&lt;input type=”text”&gt;明文输入框 《2》&lt;input type=”password”&gt;暗文输入框 《3》&lt;input type=”radio”&gt;单选框注意点：默认单选框不会互斥，要想选框互斥，要给每个单选框标签设置一个name属性，并且属性值必须相同。要想让单选框默认选中其中一个，那么就给他添加一个checked属性 《4》&lt;input type=”checkbox”&gt;多选框注意点：默认可以选择多个，要想让单选框默认选中其中一个，那么就给他添加一个checked属性 《5》 按钮 普通按钮：&lt;input type=”button”value=”按钮”&gt;，通过value属性给按钮添加标题 图片按钮：&lt;input type=”img”src=””&gt;，作用与普通按钮一样 重置按钮：&lt;input type=”reset”&gt;，用于清空表单填写的内容 注意点：默认按钮标题是重置，可以通过value属性修改按钮标题 提交按钮：&lt;input type=”submit”&gt;，将表单中填写好的内容提交到远程服务器注意点：要想把表单中填写的内容提交给远程服务器中，需要做到以下两点：&lt;form action=”网址”&gt;&lt;/form&gt;；给需要提交的表单元素都添加name属性 《6》隐藏域：&lt;input type=”hidden”&gt;配合提交按钮将一些数据默默的提交到远程服务器 label标签：默认情况下，文字与输入框是没有关联关系的，也就是说点击文字输入框不会聚焦，如果想聚焦，需要这样：方法一：&lt;label for=”一样”&gt;文字:&lt;/label&gt;&lt;input type=”” id=”一样”&gt;方法二：&lt;labrl&gt;文字：&lt;input type=””&gt;&lt;/label&gt;局限性是不能交叉绑定 14.datalist标签：给输入框绑定待选项（了解）格式：123456&lt;input type=\"text\" list=\"cities\"&gt;&lt;datalist id=”cities”&gt;&lt;option&gt;待选项内容&lt;/option&gt;&lt;option&gt;待选项内容&lt;/option&gt;&lt;option&gt;待选项内容&lt;/option&gt;&lt;/datalist&gt; select标签：用于定义下拉列表格式：12345&lt;select&gt;&lt;option&gt;列表数据&lt;/option&gt;&lt;option&gt;列表数据&lt;/option&gt;&lt;option&gt;列表数据&lt;/option&gt;&lt;/select&gt; 注意点：下拉列表不能输入内容，但是可以选择内容。也可以设置默认值：&lt;option selected=&quot;selected&quot;&gt;列表数据&lt;/option&gt;给下拉列表分类：123&lt;optgroup label=\"分组名称\"&gt;&lt;option&gt;列表数据&lt;/option&gt;&lt;/optgroup&gt; textarea标签：默认情况下可以无限换行，有默认的宽度和高度，默认情况下输入框是可以手动拉伸的格式：&lt;textarea&gt;内容&lt;/textarea&gt;可以通过这样给文本添加列数和行数：&lt;textarea cols=”” rows=””&gt;内容&lt;/textarea&gt;fieldset标签：给表单添加边框legend标签：可以给边框指定一个标题 15.video标签：（1）作用： 播放视频（2）格式： 第一种格式：&lt;video src=””&gt;&lt;/video&gt;第二种格式：&lt;video&gt;&lt;source src=”” type=”video/webm/ogg/mp4”&gt;&lt;/suorce&gt;&lt;/video&gt;由于视频数据非常的重要，所以五大浏览器厂商都不愿意支持别人的视频格式，所以导致了没有一种视频格式是所有浏览器都支持的，这个时候w3c为了解决这个问题，所以有了第二种格式（3）常用属性：width/heightautoplay:用来告诉video标签是否需要自动播放视频 controls: 用来告诉video标签是否需要显示控制条 poster：用来告诉video标签视频没有播放之前显示的占用图片 loop：一般用于做广告视频，用于告诉video标签播放结束后是否需要循环播放preload：预加载视频，与autoplay相冲，如果设置了autoplay属性那么preload就会失效muted静音： 16.audio标签：（1）作用：播放音频（2）格式：第一种格式：&lt;audio src=””&gt;&lt;/audio&gt; 第二种格式：&lt;audio&gt;&lt;source src=”audio/mp3”&gt;&lt;/source&gt;&lt;/audio&gt;（3）常用属性：width/heightautoplay:用来告诉audio标签是否需要自动播放视频 controls: 用来告诉audio标签是否需要显示控制条 loop：用于告诉audio o标签播放结束后是否需要循环播放preload：加载音频，与autoplay相冲，如果设置了autoplay属性那么preload就会失效muted静音： 17.详情和概要标签：（1）作用：利用summary标签来描述概要信息，利用dateils标签描述详情信息，默认情况下是折叠显示，想看详情信息必须点击（2）格式：&lt;details&gt;&lt;summary&gt;概要信息&lt;/summary&gt;详情信息&lt;/details&gt;18.marquee标签：不是w3c推荐的标签，但各个浏览器对他的支持非常好 （1）作用：跑马灯效果，不仅可以让文字滚动也可以让图片滚动 （2）格式：&lt;marquee &gt;内容&lt;/marquee &gt; （3）常用属性： direction：滚动方向 left/right/up/down scrollamount:滚动速度 loop:滚动次数，默认是-1，无限次 behavior:滚动类型 slide滚动到边界就停止alternate滚动到边界就弹回来 19.字符实体&amp;nbsp;空格、&amp;lt;小于号、&amp;gt;大于号、&amp;copy;版权符号","categories":[],"tags":[{"name":"简明教程","slug":"简明教程","permalink":"http://www.afanail.com/tags/简明教程/"},{"name":"HTML","slug":"HTML","permalink":"http://www.afanail.com/tags/HTML/"}]},{"title":"Top 10 ES6 Features","slug":"top10es","date":"2016-10-13T07:41:09.000Z","updated":"2017-07-22T03:51:58.000Z","comments":true,"path":"2016/10/13/top10es/","link":"","permalink":"http://www.afanail.com/2016/10/13/top10es/","excerpt":"Top 10 ES6 Features Every Busy JavaScript Developer Must KnowTop 10 ES6 Features Every Busy JavaScript Developer Must Know 10 ES6 Features Every Busy JavaScript Software Engineer Must Know38 Replies","text":"Top 10 ES6 Features Every Busy JavaScript Developer Must KnowTop 10 ES6 Features Every Busy JavaScript Developer Must Know 10 ES6 Features Every Busy JavaScript Software Engineer Must Know38 RepliesThis essay will give you a quick introduction to ES6. If you don’t know what is ES6, it’s a new JavaScript implementation. If you’re a busy JavaScript software engineer (and who is not?), then proceed reading to learn the best 10 features of the new generation of the most popular programming language—JavaScript. Here’s the list of the top 10 best ES6 features for a busy software engineer (in no particular order):12345678910Default Parameters in ES6Template Literals in ES6Multi-line Strings in ES6Destructuring Assignment in ES6Enhanced Object Literals in ES6Arrow Functions in ES6Promises in ES6Block-Scoped Constructs Let and ConstClasses in ES6Modules in ES6 Disclaimer: the list if highly biased and subjective. It is in no way was intended to diminish usefulness of other ES6 features, which didn’t make it to the list simply because I had to limit the number to 10. Default Parameters in ES6Remember we had to do these statements to define default parameters:123456var link = function (height, color, url) &#123; var height = height || 50 var color = color || 'red' var url = url || 'http://azat.co' ...&#125; They were okay until the value was 0 and because 0 is falsy in JavaScript it would default to the hard-coded value instead of becoming the value itself. Of course, who needs 0 as a value (#sarcasmfont), so we just ignored this flaw and used the logic OR anyway… No more! In ES6, we can put the default values right in the signature of the functions:123var link = function(height = 50, color = 'red', url = 'http://azat.co') &#123; ...&#125; By the way, this syntax is similar to Ruby! Template Literals in ES6Template literals or interpolation in other languages is a way to output variables in the string. So in ES5 we had to break the string like this:123456var name = 'Your name is ' + first + ' ' + last + '.'var url = 'http://localhost:3000/api/messages/' + idLuckily, in ES6 we can use a new syntax $&#123;NAME&#125; inside of the back-ticked string:var name = `Your name is $&#123;first&#125; $&#123;last&#125;.`var url = `http://localhost:3000/api/messages/$&#123;id&#125;` Multi-line Strings in ES6Another yummy syntactic sugar is multi-line string. In ES5, we had to use one of these approaches: Sidenote: If you like this post and interested in a corporate on-site JavaScript, Node.js and React.js training to boost productivity of your team, then contact NodeProgram.com.12345var roadPoem = 'Then took the other, as just as fair,\\n\\t' + 'And having perhaps the better claim\\n\\t' + 'Because it was grassy and wanted wear,\\n\\t' + 'Though as for that the passing there\\n\\t' + 'Had worn them really about the same,\\n\\t' var fourAgreements = ‘You have the right to be you.\\n\\ You can only be you when you do your best.’While in ES6, simply utilize the backticks:12345678var roadPoem = `Then took the other, as just as fair, And having perhaps the better claim Because it was grassy and wanted wear, Though as for that the passing there Had worn them really about the same,`var fourAgreements = `You have the right to be you. You can only be you when you do your best.` Destructuring Assignment in ES6Destructuring can be a harder concept to grasp, because there’s some magic going on… let’s say you have simple assignments where keys house and mouse are variables house and mouse: [Sidenote] Reading blog posts is good, but watching video courses is even better because they are more engaging. A lot of developers complained that there is a lack of affordable quality video material on Node. It’s distracting to watch to YouTube videos and insane to pay $500 for a Node video course! Go check out Node University which has FREE video courses on Node: node.university. [End of sidenote]12345678910var data = $('body').data(), // data has properties house and mouse house = data.house, mouse = data.mouseOther examples of destructuring assignments (from Node.js):var jsonMiddleware = require('body-parser').jsonvar body = req.body, // body has username and password username = body.username, password = body.password In ES6, we can replace the ES5 code above with these statements:123456789var &#123; house, mouse&#125; = $('body').data() // we'll get house and mouse variablesvar &#123;jsonMiddleware&#125; = require('body-parser')var &#123;username, password&#125; = req.bodyThis also works with arrays. Crazy!var [col1, col2] = $('.column'), [line1, line2, line3, , line5] = file.split('\\n') It might take some time to get use to the destructuring assignment syntax, but it’s a sweet sugarcoating. Enhanced Object Literals in ES6What you can do with object literals now is mind blowing! We went from a glorified version of JSON in ES5 to something closely resembling classes in ES6. Here’s a typical ES5 object literal with some methods and attributes/properties:12345678910111213var serviceBase = &#123;port: 3000, url: 'azat.co'&#125;, getAccounts = function()&#123;return [1,2,3]&#125;var accountServiceES5 = &#123; port: serviceBase.port, url: serviceBase.url, getAccounts: getAccounts, toString: function() &#123; return JSON.stringify(this.valueOf()) &#125;, getUrl: function() &#123;return \"http://\" + this.url + ':' + this.port&#125;, valueOf_1_2_3: getAccounts()&#125; If we want to be fancy, we can inherit from serviceBase by making it the prototype with the Object.create method:123456789var accountServiceES5ObjectCreate = Object.create(serviceBase)var accountServiceES5ObjectCreate = &#123; getAccounts: getAccounts, toString: function() &#123; return JSON.stringify(this.valueOf()) &#125;, getUrl: function() &#123;return \"http://\" + this.url + ':' + this.port&#125;, valueOf_1_2_3: getAccounts()&#125; I know, accountServiceES5ObjectCreate and accountServiceES5 are NOT totally identical, because one object (accountServiceES5) will have the properties in the proto object as shown below: Enhanced Object Literals in ES6Enhanced Object Literals in ES6 But for the sake of the example, we’ll consider them similar. So in ES6 object literal, there are shorthands for assignment getAccounts: getAccounts, becomes just getAccounts,. Also, we set the prototype right there in the proto` property which makes sense (not‘proto’ though:12345678910111213141516var serviceBase = &#123;port: 3000, url: 'azat.co'&#125;, getAccounts = function()&#123;return [1,2,3]&#125;var accountService = &#123; __proto__: serviceBase, getAccounts,Also, we can invoke super and have dynamic keys (valueOf_1_2_3): toString() &#123; return JSON.stringify((super.valueOf())) &#125;, getUrl() &#123;return \"http://\" + this.url + ':' + this.port&#125;, [ 'valueOf_' + getAccounts().join('_') ]: getAccounts()&#125;;console.log(accountService)Enhanced Object Literals in ES6 IIEnhanced Object Literals in ES6 II This is a great enhancement to good old object literals! Arrow Functions in ES6This is probably one feature I waited the most. I love CoffeeScript for its fat arrows. Now we have them in ES6. The fat arrows are amazing because they would make your this behave properly, i.e., this will have the same value as in the context of the function—it won’t mutate. The mutation typically happens each time you create a closure. Using arrows functions in ES6 allows us to stop using that = this or self = this or _this = this or .bind(this). For example, this code in ES5 is ugly:12345678910var _this = this$('.btn').click(function(event)&#123; _this.sendData()&#125;)This is the ES6 code without _this = this:$('.btn').click((event) =&gt;&#123; this.sendData()&#125;) Sadly, the ES6 committee decided that having skinny arrows is too much of a good thing for us and they left us with a verbose old function instead. (Skinny arrow in CoffeeScript works like regular function in ES5 and ES6). Here’s another example in which we use call to pass the context to the logUpperCase() function in ES5:12345678var logUpperCase = function() &#123; var _this = this this.string = this.string.toUpperCase() return function () &#123; return console.log(_this.string) &#125;&#125; logUpperCase.call({ string: ‘es6 rocks’ })()While in ES6, we don’t need to mess around with _this:123456var logUpperCase = function() &#123; this.string = this.string.toUpperCase() return () =&gt; console.log(this.string)&#125;logUpperCase.call(&#123; string: 'es6 rocks' &#125;)() Note that you can mix and match old function with =&gt; in ES6 as you see fit. And when an arrow function is used with one line statement, it becomes an expression, i.e,. it will implicitly return the result of that single statement. If you have more than one line, then you’ll need to use return explicitly. This ES5 code is creating an array from the messages array:1234var ids = ['5632953c4e345e145fdf2df8','563295464e345e145fdf2df9']var messages = ids.map(function (value) &#123; return \"ID is \" + value // explicit return&#125;); Will become this in ES6:12var ids = ['5632953c4e345e145fdf2df8','563295464e345e145fdf2df9']var messages = ids.map(value =&gt; `ID is $&#123;value&#125;`) // implicit return Notice that I used the string templates? Another feature from CoffeeScript… I love them! The parenthesis () are optional for single params in an arrow function signature. You need them when you use more than one param. In ES5 the code has function with explicit return:1234var ids = ['5632953c4e345e145fdf2df8', '563295464e345e145fdf2df9'];var messages = ids.map(function (value, index, list) &#123; return 'ID of ' + index + ' element is ' + value + ' ' // explicit return&#125;); And more eloquent version of the code in ES6 with parenthesis around params and implicit return:12var ids = ['5632953c4e345e145fdf2df8','563295464e345e145fdf2df9']var messages = ids.map((value, index, list) =&gt; `ID of $&#123;index&#125; element is $&#123;value&#125; `) // implicit return Promises in ES6Promises have been a controversial topic. There were a lot of promise implementations with slightly different syntax. q, bluebird, deferred.js, vow, avow, jquery deferred to name just a few. Others said we don’t need promises and can just use async, generators, callbacks, etc. Gladly, there’s a standard Promise implementation in ES6 now! Let’s consider a rather trivial example of a delayed asynchronous execution with setTimeout():123setTimeout(function()&#123; console.log('Yay!')&#125;, 1000) We can re-write the code in ES6 with Promise:12345var wait1000 = new Promise(function(resolve, reject) &#123; setTimeout(resolve, 1000)&#125;).then(function() &#123; console.log('Yay!')&#125;) Or with ES6 arrow functions:12345var wait1000 = new Promise((resolve, reject)=&gt; &#123; setTimeout(resolve, 1000)&#125;).then(()=&gt; &#123; console.log('Yay!')&#125;) So far, we’ve increased the number of lines of code from three to five without any obvious benefit. That’s right. The benefit will come if we have more nested logic inside of the setTimeout() callback:123456setTimeout(function()&#123; console.log('Yay!') setTimeout(function()&#123; console.log('Wheeyee!') &#125;, 1000)&#125;, 1000) Can be re-written with ES6 promises:12345678910var wait1000 = ()=&gt; new Promise((resolve, reject)=&gt; &#123;setTimeout(resolve, 1000)&#125;)wait1000() .then(function() &#123; console.log('Yay!') return wait1000() &#125;) .then(function() &#123; console.log('Wheeyee!') &#125;); Still not convinced that Promises are better than regular callbacks? Me neither. I think once you got the idea of callbacks and wrap your head around them, then there’s no need for additional complexity of promises. Nevertheless, ES6 has Promises for those of you who adore them. Promises have a fail-and-catch-all callback as well which is a nice feature. Take a look at this post for more info on promises: Introduction to ES6 Promises. Block-Scoped Constructs Let and ConstYou might have already seen the weird sounding let in ES6 code. I remember the first time I was in London, I was confused by all those TO LET signs. The ES6 let has nothing to do with renting. This is not a sugarcoating feature. It’s more intricate. let is a new var which allows to scope the variable to the blocks. We define blocks by the curly braces. In ES5, the blocks did NOTHING to the vars:123456789101112131415function calculateTotalAmount (vip) &#123; var amount = 0 if (vip) &#123; var amount = 1 &#125; &#123; // more crazy blocks! var amount = 100 &#123; var amount = 1000 &#125; &#125; return amount&#125;console.log(calculateTotalAmount(true)) The result will be 1000. Wow! That’s a really bad bug. In ES6, we use let to restrict the scope to the blocks. Vars are function scoped.123456789101112131415function calculateTotalAmount (vip) &#123; var amount = 0 // probably should also be let, but you can mix var and let if (vip) &#123; let amount = 1 // first amount is still 0 &#125; &#123; // more crazy blocks! let amount = 100 // first amount is still 0 &#123; let amount = 1000 // first amount is still 0 &#125; &#125; return amount&#125;console.log(calculateTotalAmount(true)) The value is 0, because the if block also has let. If it had nothing (amount=1), then the expression would have been 1. When it comes to const, things are easier; it’s just an immutable, and it’s also block-scoped like let. Just to demonstrate, here are a bunch of constants and they all are okay because they belong to different blocks:123456789101112131415function calculateTotalAmount (vip) &#123; const amount = 0 if (vip) &#123; const amount = 1 &#125; &#123; // more crazy blocks! const amount = 100 &#123; const amount = 1000 &#125; &#125; return amount&#125;console.log(calculateTotalAmount(true)) In my humble opinion, let and const overcomplicate the language. Without them we had only one behavior, now there are multiple scenarios to consider. ;-( Classes in ES6If you love object-oriented programming (OOP), then you’ll love this feature. It makes writing classes and inheriting from them as easy as liking a comment on Facebook. Classes creation and usage in ES5 was a pain in the rear, because there wasn’t a keyword class (it was reserved but did nothing). In addition to that, lots of inheritance patterns like pseudo classical, classical, functional just added to the confusion, pouring gasoline on the fire of religious JavaScript wars. I won’t show you how to write a class (yes, yes, there are classes, objects inherit from objects) in ES5, because there are many flavors. Let’s take a look at the ES6 example right away. I can tell you that the ES6 class will use prototypes, not the function factory approach. We have a class baseModel in which we can define a constructor and a getName() method:123456789101112class baseModel &#123; constructor(options = &#123;&#125;, data = []) &#123; // class constructor this.name = 'Base' this.url = 'http://azat.co/api' this.data = data this.options = options &#125; getName() &#123; // class method console.log(`Class name: $&#123;this.name&#125;`) &#125;&#125; Notice that I’m using default parameter values for options and data. Also, method names don’t need to have the word function or the colon (:) anymore. The other big difference is that you can’t assign properties this.NAME the same way as methods, i.e., you can’t say name at the same indentation level as a method. To set the value of a property, simply assign a value in the constructor. The AccountModel inherits from baseModel with class NAME extends PARENT_NAME:12345678class AccountModel extends baseModel &#123; constructor(options, data) &#123;To call the parent constructor, effortlessly invoke super() with params: super(&#123;private: true&#125;, ['32113123123', '524214691']) //call the parent method with super this.name = 'Account Model' this.url +='/accounts/' &#125; If you want to be really fancy, you can set up a getter like this and accountsData will be a property:12345 get accountsData() &#123; //calculated attribute getter // ... make XHR return this.data &#125;&#125; So how do you actually use this abracadabra? It’s as easy as tricking a three-year old into thinking Santa Claus is real:123let accounts = new AccountModel(5)accounts.getName()console.log('Data is %s', accounts.accountsData) In case you’re wondering, the output is:12Class name: Account ModelData is %s 32113123123,524214691 Modules in ES6As you might now, there were no native modules support in JavaScript before ES6. People came up with AMD, RequireJS, CommonJS and other workarounds. Now there are modules with import and export operands. In ES5 you would use &lt;script&gt; tags with IIFE, or some library like AMD, while in ES6 you can expose your class with export. I am a Node.js guy, so I’ll use CommonJS which is also a Node.js syntax. It’s straightforward to use CommonJS on the browser with the Browserify bunder. Let’s say we have port variable and getAccounts method in ES5 module.js:123456module.exports = &#123; port: 3000, getAccounts: function() &#123; ... &#125;&#125; In ES5 main.js, we would require(‘module’) that dependency:12var service = require('module.js')console.log(service.port) // 3000 In ES6, we would use export and import. For example, this is our library in the ES6 module.js file:1234export var port = 3000export function getAccounts(url) &#123; ...&#125; In the importer ES6 file main.js, we use import {name} from ‘my-module’ syntax. For example,123456import &#123;port, getAccounts&#125; from 'module'console.log(port) // 3000Or we can import everything as a variable service in main.js:import * as service from 'module'console.log(service.port) // 3000 Personally, I find the ES6 modules confusing. Yes, they are more eloquent, but Node.js modules won’t change anytime soon. It’s better to have only one style for browser and server JavaScript, so I’ll stick with CommonJS/Node.js style for now. The support for ES6 modules in the browsers are not coming anytime soon (as of this writing), so you’ll need something like jspm to use ES6 modules. For more information and examples on ES6 modules, take a look at this text. No matter what, write modular JavaScript! How to Use ES6 Today (Babel) ES6 is finalized, but not fully supported by all browsers (e.g., ES6 Firefox support). To use ES6 today, get a compiler like Babel. You can run it as a standalone tool or use with your build system. There are Babel plugins for Grunt, Gulp and Webpack. How to Use ES6 Today (Babel)How to Use ES6 Today (Babel) Here’s a Gulp example. Install the plugin: $ npm install –save-dev gulp-babelIn gulpfile.js, define a task build that takes src/app.js and compiles it into the build folder:12345678var gulp = require('gulp'), babel = require('gulp-babel')gulp.task('build', function () &#123; return gulp.src('src/app.js') .pipe(babel()) .pipe(gulp.dest('build'))&#125;) Node.js and ES6 For Node.js, you can compile your Node.js files with a build tool or use a standalone Babel module babel-core. To install it, $ npm install –save-dev babel-coreThen in Node.js, you call this function: require(“babel-core”).transform(es5Code, options)Summary of ES6 Things There are many other noteworthy ES6 features which you probably won’t use (at least not right away). In no particular order: New Math, Number, String, Array and Object methodsBinary and octal number typesDefault rest spreadFor of comprehensions (hello again mighty CoffeeScript!)SymbolsTail callsGeneratorsNew data structures like Map and SetFor overachievers who can’t stop learning about ES6, like some people who can’t stop after the first potato chip (just one more!), here’s the list for further reading:Top 10 ES6 Features Every Busy JavaScript Developer Must Know","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://www.afanail.com/tags/css/"},{"name":"js","slug":"js","permalink":"http://www.afanail.com/tags/js/"}]},{"title":"gulp实现项目模板化","slug":"gulp实行项目模板化","date":"2016-08-13T03:55:22.000Z","updated":"2017-05-22T04:10:52.000Z","comments":true,"path":"2016/08/13/gulp实行项目模板化/","link":"","permalink":"http://www.afanail.com/2016/08/13/gulp实行项目模板化/","excerpt":"使用gulp实现项目模板化gulpnodejs插件自动化WebFrontEnd当一个大项目逐渐成型，或者一个框架又或者一个开发方式逐渐成型的时候，总会有一个所谓的“套路”，我们在工作中往往遵循着这个套路走。所以更换一家公司或者一个部门团队的时候，上手项目并不难，你只需要掌握这个团队管用的“套路”就ok了，关键是：要想办法优化这个“套路”。","text":"使用gulp实现项目模板化gulpnodejs插件自动化WebFrontEnd当一个大项目逐渐成型，或者一个框架又或者一个开发方式逐渐成型的时候，总会有一个所谓的“套路”，我们在工作中往往遵循着这个套路走。所以更换一家公司或者一个部门团队的时候，上手项目并不难，你只需要掌握这个团队管用的“套路”就ok了，关键是：要想办法优化这个“套路”。之前一直在做内部框架的跨平台和自动化构建的事，加上开发业务逻辑的页面已经完成，就没去优化这个开发套路，什么套路呢？当项目中需要一个新的H5页面的时候，就需要手动去copy之前的一个页面代码，然后逐个修改，改成另外一个页面。去掉代码中的业务逻辑，会发现除了名称不同，其余的代码全部相同，秉承着“上级命令一定要完成”总宗旨，非也，是秉承着“我是一个程序员”的宗旨，就应该将一切需要手工完成的工作变成自动化的。所以……所以就不吹NB了，好好写……一个古老的思路是，你应该有一套模板，当有新的页面需要开发的时候，只需一条命令或者一个按钮就可以自动帮你基于这套模板创建一个可直接用于开发的环境。为了达成这个目的，我是用到了：1.gulpgulp的教程这里就不写了。2.该功能主要使用到的gulp插件gulp-load-plugins 加载gulp插件的插件gulp-file-include 文件包含插件gulp-data 提供数据，该数据可被其他gulp插件使用gulp-rename 重命名文件gulp-template 渲染模板上面的插件连接，点击进去就是文档。笔者认为最好的学习方式就是有一个能运行起来的项目，然后看着代码一步步走，所以我把模板化从公司的项目中抽离出来，并做了删减，提炼出一个完整的可运行的项目，并放在我的git仓库，可以运行一下命令查看效果，调试并学习： 下面是gulpfile.js文件和package.json文件gulpfile.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110var gulp = require('gulp');var gulpLoadPlugins = require(\"gulp-load-plugins\");var plugins = gulpLoadPlugins();var util = require(\"gulp-util\");var devPath = './html';var appData = &#123;&#125;;/* * @desc 组装模板 * @src devPath * @deps * @dest devPath + '/tmod/app/dest' */gulp.task('includeTpl',function () &#123; // 获取 gulp 命令的 --name参数的值 （gulp createapp --name=aaa） var appName = util.env.name || 'special'; // 首字母大写 var appNameBig = appName.replace((/\\w/), function(char)&#123; return char.toUpperCase(); &#125;); appData=&#123; app: appName, appapi: appNameBig, appDo: appName + \"Do\", title: appName &#125; return gulp.src([ devPath + '/tmod/app/app.tpl', devPath + '/tmod/app/appDo.tpl', devPath + '/tmod/app/app.html', devPath + '/tmod/app/appApi.tpl', devPath + '/tmod/app/appapiInterFace.tpl' ]) .pipe(plugins.fileInclude(&#123; prefix: '@@', basepath: '@file' &#125;)) .pipe(gulp.dest(devPath + '/tmod/app/dest'));&#125;);/* * @desc 解析模板 * @src devPath * @deps includeTpl * @dest devPath + '/tmod/app/dest' */gulp.task('resolveTpl',[\"includeTpl\"],function () &#123; return gulp.src([ devPath + '/tmod/app/dest/app.tpl', devPath + '/tmod/app/dest/appDo.tpl', devPath + '/tmod/app/dest/app.html', devPath + '/tmod/app/dest/appApi.tpl', devPath + '/tmod/app/dest/appapiInterFace.tpl' ]) .pipe(plugins.data(function () &#123; return &#123;app: appData.app, appDo:appData.appDo,title:appData.title, appapi : appData.appapi&#125;; &#125;)) .pipe(plugins.template()) .pipe(gulp.dest(devPath + '/tmod/app/dest'));&#125;);/* * @desc 创建部署 * @src devPath + '/tmod/app/dest * @deps resolveTpl * @dest devPath + '/modules/' */gulp.task('createapp', [\"resolveTpl\"], function () &#123; // 创建部署入口js文件，如 index.js gulp.src(devPath + '/tmod/app/dest/app.tpl') .pipe(plugins.rename(&#123; basename: appData.app, extname: \".js\" &#125;)) .pipe(gulp.dest(devPath + '/target/'+appData.app)); // 创建部署业务逻辑js文件，如 indexDo.js gulp.src(devPath + '/tmod/app/dest/appDo.tpl') .pipe(plugins.rename(&#123; basename: appData.appDo, extname: \".js\" &#125;)) .pipe(gulp.dest(devPath + '/target/'+appData.app)); // 创建部署html页面文件，如 index.html gulp.src([devPath + '/tmod/app/dest/*.html']) .pipe(plugins.rename(&#123; basename: appData.app, extname: \".html\" &#125;)) .pipe(gulp.dest(devPath + '/target/'+appData.app)); // 创建部署api接口js文件，如 indexApi.js gulp.src(devPath + '/tmod/app/dest/appApi.tpl') .pipe(plugins.rename(&#123; basename: appData.app + 'Api', extname: \".js\" &#125;)) .pipe(gulp.dest(devPath + '/target/clientApi')); // 创建部署跨平台接口js文件，如 indexapiInterFace.js gulp.src(devPath + '/tmod/app/dest/appapiInterFace.tpl') .pipe(plugins.rename(&#123; basename: appData.app + 'apiInterFace', extname: \".js\" &#125;)) .pipe(gulp.dest(devPath + '/target/clientApi'));&#125;); package.json12345678910111213141516&#123; \"name\": \"app\", \"project\": \"app\", \"version\": \"1.0.0\", \"host\": \"http://10.0.69.79\", \"path\": \"/home/huangjian/workstation/bridge/newssdk/bin\", \"devDependencies\": &#123; \"gulp\": \"^3.9.0\", \"gulp-data\": \"^1.2.0\", \"gulp-file-include\": \"^0.13.7\", \"gulp-load-plugins\": \"^0.10.0\", \"gulp-rename\": \"^1.2.0\", \"gulp-template\": \"^2.1.0\", \"gulp-util\": \"^3.0.6\" &#125;&#125; 大家重在研究代码的思路和各个组件的用法及配合，不要去研究代码的细节，比如这个构建出来的项目有什么用啊？当然对于你来说没什么用，因为这个是应用在公司项目中的，这个是为了给大家方便，抽离出来的，所以大家把握好重点。","categories":[],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://www.afanail.com/tags/gulp/"}]},{"title":"jQuery 源码简单分析","slug":"jQuery-源码分析","date":"2016-08-04T16:33:34.000Z","updated":"2017-07-22T03:52:53.000Z","comments":true,"path":"2016/08/05/jQuery-源码分析/","link":"","permalink":"http://www.afanail.com/2016/08/05/jQuery-源码分析/","excerpt":"jQuery时下非常流行，简单好用，工作必用。想更深入学习，可以通过研究其源代码。 jQuery是一个闭包（即时函数）(function( window, undefined ) {}) 让我们来看一看jQuery源代码的基本信息","text":"jQuery时下非常流行，简单好用，工作必用。想更深入学习，可以通过研究其源代码。 jQuery是一个闭包（即时函数）(function( window, undefined ) {}) 让我们来看一看jQuery源代码的基本信息12345678910111213 /*!* jQuery JavaScript Library v2.0.0 版本信息* http://jquery.com/ 官方网站** Includes Sizzle.js 复杂选择器文件名称* http://sizzlejs.com/ 复杂选择器文件网站** Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors 版权信息* Released under the MIT license 开源协议* http://jquery.org/license** Date: 2013-04-18 更新时间*/ 这说明jQuery有多个版本,现在我们分析的是2.0.0版本，在之前的版本版本需要兼容IE678,里面有大量的兼容性处理。从2.0.0版本入手开始研究,从上往下解读注释 包括: 01 官方网站 02 复杂选择器 03 版权信息和开源协议 04 #1335和bug管理系统 jQ本质就是一个闭包 使用闭包的好处： ① 为了避免和其他框架产生冲突(代码说明) ② 多个框架中如果出现了同名的变量或者是函数那么会存在覆盖或者是冲突,而使用闭包结构可以处理这个问题 ③ 其它 传递window参数的好处： ① 参数的区分:形式参数和实际参数 ② 函数作用域说明:函数内部的数据外界无法访问(引申闭包相关知识点) ③ 把内部的数据传递给外部使用 ④ 用于压缩代码(不是很理解) 传递window参数的好处： ① 方便代码的压缩 ② 使用undefined作为形参传入,为了防止代码的修改(在IE以前的版本中undefined可以被修改) jQuery被写成了一个工厂函数根据我们已经清楚的部分来开始初步的搭建框架结构,主要包括以下部分 001 该框架的最外层是一个立即调用函数(闭包),需要接受两个参数window和undefined 002 提供一个jQuery工厂函数 003 设置jQuery函数对象的原型对象(直接替换),并修正构造器属性,添加init方法 004 在jQuery工厂函数内部返回使用init方法创建的对象 005 设置原型对象赋值并讲解fn就是原型对象 03 讲解外界应该如何使用jQuery函数 001 依据我们使用jQuery框架的经验,在HTML文件中通过jQuery或者是$来访问 002 分析外部如何访问闭包内部的数据(在闭包中提供接口返回|把闭包中需要让外界访问的对象通过全局变量传递) 003 书写代码 window.$ = window.jQuery = jQuery; 004 注意说明:外界在调用的时候是通过jQuery()这种方式调用的,那么获取的就是一个jQuery.prototype.init类型的实例化对象 04 验证并说明调用jQuery得到的是jQuery.fn.init类型的实例化对象 代码示例：123456789101112131415161718192021222324252627包含功能: (1) 整体结构(立即调用函数) (2) jQuery工厂函数定义 (3) fn函数 (4) window.$ 和window.jQuery*/(function (window) &#123; //01 jQuery工厂函数 var jQuery = function () &#123; //02 返回一个jQuery.prototype.init类型的实例化对象 return new jQuery.fn.init(); &#125;; //03 替换jQuery工厂函数的原型对象 jQuery.prototype = &#123; //修正构造器属性 constructor:jQuery, init:function () &#123; //...init方法内部实现细节 &#125; &#125; //04 把jQuery工厂函数的原型对象赋值给jQuery.prototype.init的原型对象 jQuery.prototype.init.prototype = jQuery.prototype; //05 为jQuery工厂函数添加fn属性,该方法指向jQuery的原型对象 jQuery.fn = jQuery.prototype; //06 设置让外界能够拿到并使用jQuery工厂函数 window.$ = window.jQuery = jQuery;&#125;)(window); 上面分析的很简单，如果想要深入了解可以到GitHub网站等，希望对您有帮助","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://www.afanail.com/tags/jQuery/"},{"name":"源码分析","slug":"源码分析","permalink":"http://www.afanail.com/tags/源码分析/"}]},{"title":"移动端开发技巧若干","slug":"移动端开发技巧若干","date":"2016-07-22T02:26:53.000Z","updated":"2017-07-22T03:54:38.000Z","comments":true,"path":"2016/07/22/移动端开发技巧若干/","link":"","permalink":"http://www.afanail.com/2016/07/22/移动端开发技巧若干/","excerpt":"一些工作中的技巧。 viewport在做移动端时，要考虑各种各样的问题，这种情况下，如何优雅的设置meta标签，显得尤为重要。12345&lt;meta charset=\"utf-8\"&gt;&lt;meta content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" name=\"viewport\"&gt;&lt;meta name=\"viewport\" content=\"width=640,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" /&gt;&lt;meta content=\"telephone=no\" name=\"format-detection\"&gt;&lt;meta content=\"email=no\" name=\"format-detection\"&gt;","text":"一些工作中的技巧。 viewport在做移动端时，要考虑各种各样的问题，这种情况下，如何优雅的设置meta标签，显得尤为重要。12345&lt;meta charset=\"utf-8\"&gt;&lt;meta content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" name=\"viewport\"&gt;&lt;meta name=\"viewport\" content=\"width=640,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" /&gt;&lt;meta content=\"telephone=no\" name=\"format-detection\"&gt;&lt;meta content=\"email=no\" name=\"format-detection\"&gt; 1、&lt;meta charset=&quot;utf-8&quot;&gt;，设置编码格式为utf-8。 2、 设置视口模式，设备宽带等于视口宽带，初始缩放、最大缩放、最小缩放均为1.0,同时禁止用户缩放。1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" /&gt; 3、微信浏览器页面时，只需将宽度设置为640px。1&lt;meta name=\"viewport\" content=\"width=640,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" /&gt; 4、对格式进行保护，禁止将数字识别为电话号码。1&lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt; 5、同上，禁止Android平台中对邮箱地址的识别。1&lt;meta name=\"format-detection\" content=\"email=no\" /&gt; CSS样式CSS reset因为一些元素在不同对浏览器有不同对效果，所以我们需要重新设置。谨记”优雅降级、渐进增强”原则。12345678910111213141516@charset \"utf-8\";html&#123; -webkit-text-size-adjust:none; -webkit-user-select:none; -webkit-touch-callout: none; font-family: Arial;&#125;body&#123;font-size:16px;&#125;body,h1,h2,h3,h4,h5,h6,p,dl,dd,ul,ol,pre,form,input,textarea,th,td,select&#123;margin:0; padding:0; font-weight: normal;text-indent: 0;&#125;a,button,input,textarea,select&#123; background: none; -webkit-tap-highlight-color:rgba(255,0,0,0); outline:none; -webkit-appearance:none;&#125;em&#123;font-style:normal&#125;li&#123;list-style:none&#125;a&#123;text-decoration:none;&#125;img&#123;border:none; vertical-align:top;&#125;table&#123;border-collapse:collapse;&#125;textarea&#123; resize:none; overflow:auto;&#125; 公用 CSS style12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* 清除浮动 */.clear &#123; zoom:1; &#125;.clear:after &#123; content:''; display:block; clear:both; &#125;/* 定义盒模型（宽高不受边框影响） */.boxSz&#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; -o-box-sizing: border-box; box-sizing: border-box;&#125;/* 换行 */.forWrap&#123; word-break: break-all; /* 仅对英文起作用，以字母作为换行依据。 */ word-wrap: break-word; /* 仅对英文起作用，以单词作为换行依据。*/ white-space: pre-wrap; /* 仅对中文起作用，强制换行。*/&#125;/* 禁止换行 */.unWrap&#123; white-space:nowrap;&#125;/* 禁止换行,超出省略号 */.noWrapEllipsis&#123; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;&#125;/* 多行显示省略号，less写法，@line是行数 */.ellipsisLn(@line) &#123; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: @line;&#125;/* 1px 边框解决方案，示例中设置上边框，可以调整 top、right、bottom、left 的值分别设置上下左右边框 */#box2:after&#123; content: \" \"; position: absolute; left: 0; top: 0; right: 0; height: 1px; border-top: 1px solid #000; color: #C7C7C7; transform-origin: 0 0; transform: scaleY(0.5);&#125;/* 文字两端对齐 */.text-justify&#123; text-align:justify; text-justify:inter-ideograph;&#125;/* flex布局兼容写法并让内容水平垂直居中 */.flex-center&#123; display: -webkit-box; display: -moz-box; display: -ms-flexbox; display: -o-box; display: box; -webkit-box-pack: center; -moz-box-pack: center; -ms-flex-pack: center; -o-box-pack: center; box-pack: center; -webkit-box-align: center; -moz-box-align: center; -ms-flex-align: center; -o-box-align: center; box-align: center;&#125; Css小技巧1、去除android a button input被点击时边框的颜色1a,button,input&#123;-webkit-tap-highlight-color:rgba(255,0,0,0);&#125; 2、ios使用-webkit-text-size-adjust禁止调整字体大小1body&#123;-webkit-text-size-adjust: 100%!important;&#125; 3、android 上去掉语音输入按钮1input::-webkit-input-speech-button &#123;display: none&#125; 4、移动端无微软雅黑字体1body&#123;font-family:Helvetica;&#125; 5、禁用Webkit内核浏览器的文字大小调整功能。1-webkit-text-size-adjust: none; 6、禁止ios和android用户选中文字1.css&#123;-webkit-user-select:none&#125; 7、webkit去除表单元素的默认样式1.css&#123;-webkit-appearance:none;&#125; 8、修改webkit表单输入框placeholder的样式12input::-webkit-input-placeholder&#123;color:#AAAAAA;&#125;input:focus::-webkit-input-placeholder&#123;color:#EEEEEE;&#125; 其他技巧1、打电话和发短信12&lt;a href=\"tel:0755-10086\"&gt;打电话给:0755-10086&lt;/a&gt;&lt;a href=\"sms:10086\"&gt;发短信给: 10086&lt;/a&gt; 2、传图片视频12&lt;input type=file accept=\"image/*\"&gt;&lt;input type=file accept=\"video/*\"&gt; 3、在ios下，取消输入时首字母大写1&lt;input autocapitalize=\"off\" autocorrect=\"off\" /&gt;","categories":[],"tags":[{"name":"开发技巧","slug":"开发技巧","permalink":"http://www.afanail.com/tags/开发技巧/"},{"name":"移动端","slug":"移动端","permalink":"http://www.afanail.com/tags/移动端/"}]},{"title":"JSONP跨域","slug":"JSONP跨域","date":"2016-07-07T16:55:40.000Z","updated":"2017-07-22T03:52:24.000Z","comments":true,"path":"2016/07/08/JSONP跨域/","link":"","permalink":"http://www.afanail.com/2016/07/08/JSONP跨域/","excerpt":"Asynchronous JavaScript and XML (Ajax) 是Web2.0的关键技术。AJAX与服务器交换数据刷新局部网页,不需重载。 因为浏览器及同源策略的限制，ajax不允许跨域通信。同源是指协议、域名和端口都一致的情况。同源策略保证一个源的动态脚本不能读取或操作其他源的http响应和cookie，使浏览器隔离不同源的内容之间互相操作。","text":"Asynchronous JavaScript and XML (Ajax) 是Web2.0的关键技术。AJAX与服务器交换数据刷新局部网页,不需重载。 因为浏览器及同源策略的限制，ajax不允许跨域通信。同源是指协议、域名和端口都一致的情况。同源策略保证一个源的动态脚本不能读取或操作其他源的http响应和cookie，使浏览器隔离不同源的内容之间互相操作。 Access-Control-Allow-Origin解决跨域问题可以在第三方网站开启HTTP的Access-Control-Allow-Origin参数，当目标页面的response包含Access-Control-Allow-Origin 这个header，而且还包含我们的域名时，浏览器就允许拿到它页面的数据：1Access-Control-Allow-Origin: http://www.1oveit.club 当值为 * 表示匹配所有，都能用：1Access-Control-Allow-Origin: * 但是此时的主动权不在我们手里。 JSONP解决跨域还可以使用更为主动的方法，使用JSONP解决跨域问题。分为以下几步：我们知道多个不同的script标签中的数据是可以相互访问的，而script的src的本质就是将导入文件中的内容拷贝到当前script标签中，我们拿到百度搜索URL地址：1https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=ab&amp;cb=jQuery11020672211218553074_1491468814655 搜索之后的结果：1jQuery11020672211218553074_1491468814655(&#123;q:&quot;ab&quot;,p:false,s:[&quot;abs&quot;,&quot;ab胶&quot;,&quot;abc&quot;,&quot;abac形式的成语&quot;,&quot;abcc形式的成语&quot;,&quot;abab式的词语&quot;,&quot;abo&quot;,&quot;abp&quot;,&quot;abstract&quot;,&quot;abs塑料&quot;]&#125;); 从而可以引出跨域(jsonP)原理：1.src可以拿到非当前域的数据。2.script的src的本质就是将导入文件中的内容拷贝到当前script标签中。3.如果src返回的数据符合 函数名称(参数); 格式, 那么就可以实现跨域。具体例子：在本地的文件的script准备回调函数say,123function say(obj) &#123; console.log(obj); &#125; 通过script的src属性拿到百度要搜索的URL并且拼接?wd=ab&amp;cb=say参数，如下：1&lt;script src=&quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=ab&amp;cb=say&quot;&gt;&lt;/script&gt; 最后，调用say方法，1say(&#123;q:&quot;ab&quot;,p:false,s:[&quot;abs&quot;,&quot;ab胶&quot;,&quot;abc&quot;,&quot;abac形式的成语&quot;,&quot;abcc形式的成语&quot;,&quot;abab式的词语&quot;,&quot;abo&quot;,&quot;abp&quot;,&quot;abstract&quot;,&quot;abs塑料&quot;]&#125;); 具体例子：12345678910111213141516 //1.使用src，请求数据 &lt;script src=\"http://datainfo.duapp.com/shopdata/getGoods.php?callback=callback\"&gt; //2.在本地声明一个方法 function callback(args) &#123; console.log(args); &#125; //3.要在服务端要处理跨域 $res = $_GET['callback']; echo $res.\"('我是服务的数据')\"; function callback(args) &#123; console.log(args); &#125;&lt;/script&gt;&lt;!-- 如果服务器返回的是js代码，那么浏览器就会直接执行js代码 借助浏览器的特性来实现跨域--&gt;&lt;script src=\"http://datainfo.duapp.com/shopdata/getGoods.php?call6‘back=callback\"&gt;&lt;/script&gt; 总体的流程大概就是这样子，不过实际开发中要与后台定好接口，希望能够帮到你。","categories":[],"tags":[{"name":"JSONP跨域","slug":"JSONP跨域","permalink":"http://www.afanail.com/tags/JSONP跨域/"}]},{"title":"nvm-Mac安装使用","slug":"nav-Mac安装使用","date":"2016-06-02T04:49:10.000Z","updated":"2017-07-22T03:52:14.000Z","comments":true,"path":"2016/06/02/nav-Mac安装使用/","link":"","permalink":"http://www.afanail.com/2016/06/02/nav-Mac安装使用/","excerpt":"node更新太快了，版本差异各异，这时候有必要安装node版本管理工具nvm了。 安装使用homebrew安装会出现莫名其妙的问题，这里推荐使用curl方式来安装：1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash","text":"node更新太快了，版本差异各异，这时候有必要安装node版本管理工具nvm了。 安装使用homebrew安装会出现莫名其妙的问题，这里推荐使用curl方式来安装：1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash 此时nvm安装在~/.nvm下，紧接着配置环境变量。 配置环境变量推荐大家使用zsh(终端神器)，打开~/.zshrc，在最后一行加上：12export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; 此时nvm都被添加到全局环境变量，紧接着输入source ~/.zshrc重新启动一下配置。输入nvm，会输出以下信息：1234567891011121314151617181920212223242526272829303132333435363738394041➜ ~ nvmNode Version ManagerNote: &lt;version&gt; refers to any version-like string nvm understands. This includes: - full or partial version numbers, starting with an optional &quot;v&quot; (0.10, v0.1.2, v1) - default (built-in) aliases: node, stable, unstable, iojs, system - custom aliases you define with `nvm alias foo`Usage: nvm help Show this message nvm --version Print out the latest released version of nvm nvm install [-s] &lt;version&gt; Download and install a &lt;version&gt;, [-s] from source. Uses .nvmrc if available --reinstall-packages-from=&lt;version&gt; When installing, reinstall packages installed in &lt;node|iojs|node version number&gt; nvm uninstall &lt;version&gt; Uninstall a version nvm use [--silent] &lt;version&gt; Modify PATH to use &lt;version&gt;. Uses .nvmrc if available nvm exec [--silent] &lt;version&gt; [&lt;command&gt;] Run &lt;command&gt; on &lt;version&gt;. Uses .nvmrc if available nvm run [--silent] &lt;version&gt; [&lt;args&gt;] Run `node` on &lt;version&gt; with &lt;args&gt; as arguments. Uses .nvmrc if available nvm current Display currently activated version nvm ls List installed versions nvm ls &lt;version&gt; List versions matching a given description nvm ls-remote List remote versions available for install nvm version &lt;version&gt; Resolve the given description to a single local version nvm version-remote &lt;version&gt; Resolve the given description to a single remote version nvm deactivate Undo effects of `nvm` on current shell nvm alias [&lt;pattern&gt;] Show all aliases beginning with &lt;pattern&gt; nvm alias &lt;name&gt; &lt;version&gt; Set an alias named &lt;name&gt; pointing to &lt;version&gt; nvm unalias &lt;name&gt; Deletes the alias named &lt;name&gt; nvm reinstall-packages &lt;version&gt; Reinstall global `npm` packages contained in &lt;version&gt; to current version nvm unload Unload `nvm` from shell nvm which [&lt;version&gt;] Display path to installed node version. Uses .nvmrc if availableExample: nvm install v0.10.32 Install a specific version number nvm use 0.10 Use the latest available 0.10.x release nvm run 0.10.32 app.js Run app.js using node v0.10.32 nvm exec 0.10.32 node app.js Run `node app.js` with the PATH pointing to node v0.10.32 nvm alias default 0.10.32 Set default node version on a shellNote: to remove, delete, or uninstall nvm - just remove the `$NVM_DIR` folder (usually `~/.nvm`) 使用nvm上面打印的内容已经告诉我们怎么使用了。首先输入nvm ls-remote查看node远程版本：12345➜ ~ nvm ls-remote v0.1.14 v0.1.15 v0.1.16 ... 然后输入nvm install &lt;版本号&gt;比如安装4.1.0版本nvm install v4.1.0紧接着使用，输入nvm use &lt;版本号&gt;比如使用4.1.0版本，输入nvm use v4.1.0 默认nvm当你新开一个bash，输入nvm current时显示为null。可以设置默认的nvm来解决问题，输入nvm alias default v4.1.0,可以看到12➜ ~ nvm alias default v4.1.0default -&gt; v4.1.0 指定v4.1.0作为默认版本 以后新开bash输入nvm current默认显示v4.1.0。","categories":[],"tags":[{"name":"nvm","slug":"nvm","permalink":"http://www.afanail.com/tags/nvm/"},{"name":"node","slug":"node","permalink":"http://www.afanail.com/tags/node/"},{"name":"版本管理工具","slug":"版本管理工具","permalink":"http://www.afanail.com/tags/版本管理工具/"}]},{"title":"JavaScript简明教程（7）","slug":"js-07","date":"2016-05-28T01:05:25.000Z","updated":"2017-07-22T03:52:30.000Z","comments":true,"path":"2016/05/28/js-07/","link":"","permalink":"http://www.afanail.com/2016/05/28/js-07/","excerpt":"很高兴你能看到这里，希望对你学习JavaScript有帮助。这是最后一章节，主要讲有关JavaScript的设计模式。 函数属性缓存思路说明 01 函数是对象，因此可以在函数上面添加属性和方法 02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果 03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value） 04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。","text":"很高兴你能看到这里，希望对你学习JavaScript有帮助。这是最后一章节，主要讲有关JavaScript的设计模式。 函数属性缓存思路说明 01 函数是对象，因此可以在函数上面添加属性和方法 02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果 03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value） 04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。 代码示例(单个参数)12345678910111213var func = function (param) &#123; if (func.cache[param] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[param] = result + param; &#125; return func.cache[param];&#125;func.cache = &#123;&#125;; //空对象console.log(func(\"demo\")); //字符串democonsole.log(func(\"test\")); //字符串testconsole.log(func(\"demo\")); //字符串demo 直接使用属性缓存中的数据,而不再进行复杂的计算(可以提升性能) 代码示例（多个参数）12345678910111213var func = function () &#123; var key = JSON.stringify(Array.prototype.slice.call(arguments)); if (func.cache[key] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[key] = result + key; &#125; return func.cache[key];&#125;func.cache = &#123;&#125;; //空对象func(\"123\",\"456\"); ////说明:如果传入的参数数量超过1,则可以将传入的参数序列化为一个json字符串作为参数处理。 代码说明：slice:返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素 命名空间模式作用:(1)有助于减少程序中所需要的全局变量的数量(2)并且同时还有助于避免命名冲突或过长的名字前缀。 说明：JavaScript中并没有内置的命名空间 如何实现命名空间可以为应用程序创建一个全局对象,然后将所有功能都添加到该全局对象中 从而在具有大量函数,对象和其他变量的情况下并不会污染全局范围。 建议 全局命名空间的名称可以随便写,但建议使用项目的名称或者是APP的名称 按照习惯,通过程序员会约定以全部大写的方式来约定全局命名空间。 命名空间模式的缺点 ① 需要输入更多的字符,在每个变量和函数前面都需要附加上前缀,总体上增加了代码的体积。 ② 仅有一个全局实例,意味着代码的任何部分都能够修改当前的实例。 ③ 很长的前缀意味着需要花更长的时间来解析属性(变量|属性访问原则-就近原则) 代码示例（零散的代码）123456789101112131415&lt;script&gt; //构造函数 function Person() &#123; &#125; function Man() &#123; &#125; var array = [1,2,3,4,5,6]; var testDemo01 = \"测试字符串01\"; var testDemo02 = \"测试字符串02\"; var obj = &#123;&#125;; obj.des = \"描述信息\"; obj.logDes = function () &#123; console.log(obj.des); &#125;&lt;/script&gt; 代码示例(命名空间模式) 1234567891011121314151617&lt;script&gt; //01 提供一个全局变量 var MYAPP = &#123;&#125;; //02 处理构造函数 MYAPP.Person = function () &#123;&#125;; MYAPP.Man = function () &#123;&#125;; //03 处理变量 MYAPP.array = [1,2,3,4,5,6]; MYAPP.testDemo01 = \"测试字符串01\"; MYAPP.testDemo02 = \"测试字符串02\"; //处理对象 MYAPP.obj = &#123;&#125;; MYAPP.obj.des = \"描述信息\"; MYAPP.obj.logDes = function () &#123; console.log(obj.des); &#125;&lt;/script&gt; 说明 01 在使用命名空间模式的时候,因为所有的变量和属性都添加到同一个全局对象下面,因此该全局对象下面可能有很多很多的属性。 02 而我们在添加属性的时候,很有可能该属性已经存在,这导致可能会覆盖掉之前的属性。 03 所以,在添加一个属性或者是创建一个命名空间之前,最好是先检查它是否已经存在。 04 但是如果每次添加属性都需要对属性进行检查则会产生代码冗余问题。 示例代码1234567891011121314151617181920212223242526//01 不好的演示//其他代码//var MYAPP = &#123;&#125;; //注意这是不安全的代码,因为有可能覆盖掉上下文中的代码//02 在创建命名空间之前,先检查该命名空间是否存在// if (MYAPP == 'undefined')&#123;// var MYAPP = &#123;&#125;;// &#125;//03 更好的做法var MYAPP = MYAPP || &#123;&#125;; //如果MYAPP为假,那么就返回&#123;&#125;并赋值给MYAPP//04 添加属性时的检查问题//假如现在需要添加一个name属性,那么在添加之前需要先检查该属性是否存在if (MYAPP.name == 'undefined')&#123; MYAPP.name = \"默认的名称\";&#125;//假如要添加一个obJ属性if (typeof MYAPP.obj == 'undefined')&#123; MYAPP.obj = &#123;&#125;;&#125;//假如要给MYAPP.obj添加属性,则if (typeof MYAPP.obj.des === \"undefined\")&#123; MYAPP.obj.des = \"对象的描述信息\"&#125;console.log(MYAPP.obj); 代码说明：我们在添加属性或者是方法的时候,比较安全的做法是在添加之前先在当前环境中进行检查,以免覆盖但是我们的检查操作催生出了一个新的问题,就是重复代码过多,能否考虑把检查的过程抽取 示例代码1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; var MYAPP = MYAPP || &#123;&#125;; MYAPP.namescape = function (string) &#123; //split() 方法用于把一个字符串分割成字符串数组 var parts = string.split('.'); var parent = MYAPP; console.log(parts); //先去掉最前面的冗余的全局变量 if(parts[0] == \"MYAPP\") &#123; //splice() 方法向/从数组中添加/删除项目,然后返回被删除的项目 //parts.splice(0,1); //slice() 方法可从已有的数组中返回选定的元素 //返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素 parts = parts.slice(1); &#125; console.log(parts,\"处理之后的数组\"); //通过for循环来遍历结构 for (var i = 0; i &lt; parts.length; i++) &#123; //检查属性,如果对应的属性不存在,那么就创建一个属性 if (typeof parent[parts[i]] == 'undefined') &#123; //初始化为一个空的对象 parent[parts[i]] = &#123;&#125;; &#125; //修正parent的值 parent = parent[parts[i]]; &#125; return parent; &#125; //代码示例 var testDemo01 = MYAPP.namescape(\"MYAPP.test.testDemo01\"); var testDemo02 = MYAPP.namescape(\"MYAPP.test.testDemo02\"); console.log(MYAPP); //忽略全面的前缀 MYAPP.namescape(\"sadsa.sadjaldj.adada.test\"); console.log(MYAPP); //演示长命名空间的情况 MYAPP.namescape(\"demo.testDemo.testDemos.ss.dd.qq.ddd.ffff.fff\"); console.log(MYAPP);&lt;/script&gt; 补充说明12301 split() 方法用于把一个字符串分割成字符串数组02 splice() 方法向/从数组中添加/删除项目,然后返回被删除的项目03 slice() 方法可从已有的数组中返回选定的元素 设计模式简单说明概念:设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案 注意,设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案 起源:该属于源于建筑行业 历史: （1）由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学 （2）四人帮著作《设计模式：可复用面向对象软件的基础》（Design Patterns - Elements of Reusable Object-Oriented Software） （3）Gang of Four:Erich Gamma + Richard Helm + Ralph Johnson +John Vlissides 优点: 为了可重用代码、让代码更容易被他人理解、保证代码可靠性 设计模式的分类创建型模式:工厂方法模式 + 抽象工厂模式 + 单例模式 + 建造者模式 + 原型模式 结构型模式:适配器模式 + 代理模式 + ... 行为型模式:观察者模式 + 命令模式 + ... 单例模式的思想保证一个特定的类只有一个实例。 即当我们第二次创建新对象的时候,得到的应该是和第一次创建的对象一模一样的对象(同一个对象) 其他语言中实现单例模式 在其它有Class的语言中,实现单例模式核心步骤是: 01 在创建对象实例时候判断,该类的实例对象是否已经存在,如果已经存在,那么就直接返回 02 如果不存在,那么就创建一个新的实例对象,并保存起来,下次创建实例对象的时候直接使用。 JavaScript中的单例模式JavaScript是一门弱类型,动态,基于原型的语言,并没有类,只有对象。 在JavaScript中要实现单例模式有很多种方式。 最简单的方式:使用字面量的方式来创建对象,因为在JavaScript中对象之间永远不可能相等,除非他们是同一个对象。 使用字面量方式创建的对象总是唯一的12345script&gt; var obj1 = &#123;name:\"zhangsan\"&#125;; var obj2 = &#123;name:\"zhangsan\"&#125;; console.log(obj1 == obj2); //false&lt;/script&gt; 使用new操作符创建对象实现单例 实现单例模式的几种途径 ① 在代码中提供一个全局变量来存储创建出来的实例 缺点:该全局变量可能会被轻易的修改和覆盖 ② 尝试在构造函数的静态成员中缓存实例属性。缺点:函数的静态属性在外部可以直接修改,容易导致实例对象的丢失。 ③ 将实例对象包装在闭包中。优点是安全性较好,无法被轻易的修改,缺点是有额外闭包的开销。 代码示例1234567function China() &#123;&#125;//创建对象var china01 = new China();var china02 = new China();//思考:如果想要实现单例模式,那么最终的结果必要是china01 和china02是同一个对象,那么如何实现 实现方案(一)使用全局变量方式存储创建出来的实例对象代码示例12345678910111213141516171819202122232425262728&lt;script&gt; //01 提供一个全局变量 var instance; //02 提供一个构造函数 function Person() &#123; if (instance == undefined) &#123; instance = this; &#125; this.name = \"默认的名称\"; this.age = 66; //使用全局变量来接收内部创建出来的实例对象(this) return instance; &#125; //03 使用构造函数创建对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2); console.log(p1.name); console.log(p2.name); p1.name = \"修改之后的名称\"; console.log(p1.name); console.log(p2.name); //说明:在上面的方案中我们使用一个全局变量来接收实例对象的值,在构造函数内部也是通过判断这个全局变量来做一些其他的处理 instance = &#123;&#125;; var p3 = new Person(); console.log(p1 == p3);&lt;/script&gt; 说明：这种方法确实可以实现单例模式,但是并不安全,因为全局变量可能会被轻易的修改或者是覆盖,因此不推荐这种方式。 实现方案(二)通过构造函数静态属性来缓存实例对象123456789101112131415161718192021222324252627&lt;script&gt; //01 提供一个构造函数 function Person() &#123; //02 在内部判断构造函数的静态属性中是否拥有实例对象 //如果拥有实例对象,那么就直接返回,否则就设置实例对象,并赋值给构造函数的静态属性 if (typeof Person.instance == \"object\") &#123; return Person.instance; &#125; //设置实例对象的属性和方法 this.name = \"默认的名称\"; this.age = 66; //03 把内部创建的实例化对象赋值给构造函数的静态属性 Person.instance = this; //显示返回 //return Person.instance; //隐式返回 //return this; &#125; //04 创建实例对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2); Person.instance = &#123;&#125;; var p3 = new Person(); console.log(p1 == p3); //false&lt;/script&gt; 说明：在构造函数外部可以直接访问其静态成员(属性和方法),可能会导致实例对象的丢失。 实现方案(二)通过闭包-惰性函数定义来实现12345678910111213141516171819202122&lt;script&gt; //01 提供一个构造函数 function Person() &#123; //02 在函数内部使用私有变量来缓存实例 var instance = this; //03 设置实例对象的属性和方法 this.name = \"默认的姓名\"; this.age = 66; //04 使用惰性函数定义来更新构造函数的实现 //通过一个闭包来返回缓存的实例对象 Person = function () &#123; return instance; &#125; &#125; //05 创建对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2); //代码说明:第一次调用原始构造函数的时候,它会像往常一样返回this(指向内部新创建的实例对象) //再后面调用的时候,它会执行更新后的构造函数,在这个新的函数实现中,我们通过闭包来访问了私有变量,并简单的返回。 //这个instance私有变量存储的是第一次调用构造函数时创建出来的实例对象&lt;/script&gt; 新的问题01 因为内部使用惰性函数定义(重写构造函数会导致之前添加在构造函数中的属性丢失),所以存在属性丢失问题02 在上面的代码中,体现在于创建对象前后设置的构造函数的原型对象丢失问题 代码示例123456789101112131415161718192021222324252627&lt;script&gt; function Person() &#123; var instance = this; this.name = \"默认的姓名\"; this.age = 66; Person = function () &#123; return instance; &#125; &#125; //设置构造函数的原型对象 Person.prototype.des = \"描述信息\"; var p1 = new Person(); //在创建第一个对象之后,设置原型对象 Person.prototype.someThing = \"something\"; var p2 = new Person(); console.log(p1 == p2); console.log(p1.des); //描述信息 console.log(p2.des); //描述信息 console.log(p1.someThing); //undefined console.log(p2.someThing); //undefined //打印对象的构造函数 console.log(p1.constructor.name); //Person console.log(p2.constructor.name); //Person //判断对象的构造函数 console.log(p1.constructor == Person); //false console.log(p1.constructor == p2.constructor,\"构造函数是否一致\");&lt;/script&gt; 解决问题的核心过程1234567891001 提供一个构造函数02 在构造函数内部提供一个私有变量instance03 重写构造函数,返回私有变量instance04 把原有的原型对象赋值给新Person构造函数的原型对象05 调用new 构造函数方法创建一个实例化对象赋值给instance06 修正instance实例的构造器属性,指向新的构造函数(注意:虽然重写了构造函数,但是instance的构造函数仍然是以前的Person)07 设置实例属性和方法08 返回instance对象代码示例 12345678910111213141516171819202122232425262728293031323334353637383940&lt;script&gt; function Person() &#123; //01 提供一个私有变量 var instance; //02 重写构造函数 Person = function () &#123; console.log(instance); //console.log(instance.constructor); var t = this; console.log(t); return instance; &#125;; //03 保留原型属性 Person.prototype = this.__proto__; //这是一个空的对象 Person.lal = \"lala\"; //04 创建并使用私有变量来接收实例对象 instance = new Person(); //05 修正构造函数指针 instance.constructor = Person; //06 设置实例属性和方法 instance.name = \"默认的名字\"; instance.age = 66; //07 返回私有变量 return instance; &#125; Person.haha = \"哈哈\"; //设置构造函数的原型对象 Person.prototype.des = \"描述信息\"; var p1 = new Person(); //在创建第一个对象之后,设置原型对象 Person.prototype.someThing = \"something\"; var p2 = new Person(); console.log(p1 == p2); console.log(p1.des); //描述信息 console.log(p2.des); //描述信息 console.log(p1.someThing); //something console.log(p2.someThing); //something //打印构造器属性 console.log(p1.constructor == Person,\"验证构造器指向\");&lt;/script&gt; 全局变量方式实现单例-改进版1234567891011121314151617181920&lt;script&gt; var Person; (function () &#123; //01 提供一个局部变量instance var instance; Person = function Person() &#123; if (instance) &#123; return instance; &#125; instance = this; this.name = \"默认的名字\"; this.age = 66; &#125; &#125;)(); //创建对象 var p1 = new Person(); var p2 = new Person(); console.log(p1 == p2);&lt;/script&gt; 说明：通过即时函数来限定作用域,外部无法修改内部instance的值(现在是一个局部变量) 工厂模式简单说明工厂模式的目的是用于创建对象,通常在类或者是类的静态方法中实现。 工厂模式的目标 01 用一套方法去创建相似的目标。 02 在编译时不知道具体类型的情况下,为用户提供创建对象的接口 工厂模式实现过程 01 提供一个父构造函数 02 在父构造函数的原型上添加共享的方法 03 在父构造函数身上提供一个静态方法(静态工厂方法) 001 先获取参数(产品类型) 002 判断构造函数是否存在(容错性处理) 003 设置原型链继承:设置子构造函数的原型对象为父构造函数的一个实例对象(目的是为了让子构造函数创建的对象拥有父构造函数上面实例属性和原型属性) 004 使用子构造函数创建实例对象 005 返回新创建的实例对象 04 定义特定的工厂客户(静态方法) 05 通过父构造函数的静态工厂方法来创建产品对象 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script&gt; //01 提供一个父构造函数 function PhoneMaker() &#123;&#125;; //02 在父构造函数的原型上添加共享的方法 PhoneMaker.prototype.callPhoneDes = function () &#123; console.log(\"手机的特点是: \" + this.des); &#125; //03 在父构造函数身上提供一个静态方法(静态工厂方法) PhoneMaker.factory = function (type) &#123; //001 先获取参数(产品类型) var typeStr = type; //002 判断构造函数是否存在(容错性处理) if (typeof PhoneMaker[typeStr] !== 'function') &#123; throw \"Error 对应的构造函数不存在,不能生产该种类型的产品\"; &#125; //003 设置原型链继承 PhoneMaker[typeStr].prototype = new PhoneMaker(); //004 使用子构造函数创建实例对象 var newPhone = new PhoneMaker[typeStr](); //005 返回新创建的实例对象 return newPhone; &#125;; //定义特定的工厂客户(静态方法) PhoneMaker.iphone = function () &#123; this.des = \"最安全稳定的系统\"; &#125; PhoneMaker.oppo = function () &#123; this.des = \"充当五分钟,通话两小时\"; &#125; PhoneMaker.vivo = function () &#123; this.des = \"vivo手机,你的音乐手机\"; &#125; //通过父构造函数的静态工厂方法来创建产品对象 var vivo = PhoneMaker.factory('vivo'); var iphone = PhoneMaker.factory('iphone'); var oppo = PhoneMaker.factory('oppo'); vivo.callPhoneDes(); oppo.callPhoneDes(); iphone.callPhoneDes();&lt;/script&gt; 观察者模式观察者模式观察者模式又名为发布-订阅者模式，它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。 观察者模式的特点（优点）12301 观察者模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案02 观察者模式可以取代对象之间硬性编码的通知机制，一个对象不再是显示的调用另外一个对象的接口，这种模式让两个对象松耦合的联系在一起，它们不需要清楚彼此的实现细节就能够相互通信。03 在这种设计模式中，不再是一个对象调用另外一个对象的方法，而是一个对象订阅另一个对象的特定活动并且在状态改变后获得通知 模型01 订阅者也称为观察者02 被观察的对象称为发布者或者是主题03 当发生一个重要事件的时候，发布者将会通知所有订阅者并且经常以事件的形式来传递消息。示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//01 提取成公共的发行者对象 var publisher = &#123; users:&#123; default:[] &#125;, //所有的订阅者对象 addUser:function (fn,type) &#123; //对订阅的类型进行判断 var type = type || \"default\"; //如果是新的订阅类型,那么我们需要做初始化的处理 if (this.users[type] == undefined) &#123; this.users[type] = []; &#125; this.users[type].push(fn); &#125;, removeUser:function (fn,type) &#123; this.tool(type,\"removerUser\",fn); &#125;, publish:function (type) &#123; this.tool(type,\"publish\"); &#125;, tool:function (type,funcType,fn) &#123; var type = type || \"default\"; var users = this.users[type]; if (users == undefined) &#123; console.log(\"当前没有任何订阅者\"); return; &#125; for (var i = 0; i &lt; users.length; i++) &#123; if (funcType == 'publish') &#123; users[i]() &#125;else &#123; if (users[i] == fn) &#123; users.splice(i, 1); break; &#125; &#125; &#125; &#125; &#125;; //02 提供一个工具函数,能够利用发行者对象的模板来快速创建新的发布者 function makePaper(o) &#123; for(var i in publisher) &#123; if (publisher.hasOwnProperty(i) &amp;&amp; typeof publisher[i] == 'function') &#123; o[i] = publisher[i]; &#125; &#125; o.users = &#123;default:[]&#125;; &#125; //03 创建发布者 var paper1 = &#123; day:function () &#123; this.publish(); &#125;, month:function () &#123; this.publish(\"month\") &#125;, year:function () &#123; this.publish(\"year\") &#125; &#125;; //把某个对象编程一个发布者 makePaper(paper1); //04 创建订阅者(当发布者发布消息的时候,订阅者能够收到信息--自动调用订阅者的方法) var obj = &#123; lookDayNews:function () &#123; console.log(\"obj - 查看最新的日报信息\"); &#125;, lookImageNews:function () &#123; console.log(\"obj - 查看图片信息\"); &#125; &#125;; //05 设置订阅 paper1.addUser(obj.lookDayNews); paper1.addUser(obj.lookImageNews,'month'); paper1.day(); paper1.month();&lt;/script&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.afanail.com/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.afanail.com/tags/简明教程/"}]},{"title":"固定导航，不做抖man","slug":"解决页面抖动","date":"2016-05-10T16:17:25.000Z","updated":"2017-07-22T03:54:49.000Z","comments":true,"path":"2016/05/11/解决页面抖动/","link":"","permalink":"http://www.afanail.com/2016/05/11/解决页面抖动/","excerpt":"如何hold住导航？ 页面结构假设一个网页由Header,Nav,Main三部分构成。","text":"如何hold住导航？ 页面结构假设一个网页由Header,Nav,Main三部分构成。1234567891011Header(Logo, other information)----------------------------------------------Nav(Nav,menu,links)----------------------------------------------Main(Container, Content)----------------------------------------------- 解决方法根据需求，当大于Header的高度时，固定住导航。当我们滚动滚轮时候，此时 Header 会被 Nav 所遮住，再往下面滚动时Nav会固定在顶部。最常规的解决方法,让Header固定定位，Nav上边距为Header的高度：123Header：position: fixedNav: margin-top: A.height 设置滚动事件：12345if (scrollTop &gt; Header.height) &#123; Nav: position: fixed&#125; else &#123; Nav: position: initial&#125; 这样做会所产生的问题： 当 Header fixed 后，页面高度由 Header + Nav + Main 变为 Header + Main，导致 Main 自动上移了 Nav.height，从而使 scrollTop 变小。这样根据滚动事件将执行 Nav: position: initial，用鼠标慢慢拖动时，Nav 会进行多次抖动（fixed-&gt;initial-&gt;fixed-&gt;initial-&gt;……）。 解决的方法如下： 使 Header fixed 后，页面高度依旧为 Header + Nav + Main。 Header: margin-top: A.height Nav-wrap： height: Nav.height 为了使用户产生 Header fixed 后的视觉动感，可设置 scrollTop &gt; Header.height + Nav.height / 3","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://www.afanail.com/tags/css/"},{"name":"js","slug":"js","permalink":"http://www.afanail.com/tags/js/"}]},{"title":"JavaScript简明教程（6）","slug":"js-06","date":"2016-04-25T03:19:14.000Z","updated":"2017-07-22T03:52:34.000Z","comments":true,"path":"2016/04/25/js-06/","link":"","permalink":"http://www.afanail.com/2016/04/25/js-06/","excerpt":"闭包是学习JavaScript的难点之一，因JavaScript是单线程，故回调使用频繁，本章节主要讲了闭包以及回调。 闭包闭包简单说明 闭:关闭,封闭 包:包住,包裹 闭包:通过某种方式实现的一个封闭的、包裹的对外不公开的结构|空间 闭包的原理:变量的访问原则(即上一级的作用域无法访问下一级的作用域),其实函数本身就是闭包。","text":"闭包是学习JavaScript的难点之一，因JavaScript是单线程，故回调使用频繁，本章节主要讲了闭包以及回调。 闭包闭包简单说明 闭:关闭,封闭 包:包住,包裹 闭包:通过某种方式实现的一个封闭的、包裹的对外不公开的结构|空间 闭包的原理:变量的访问原则(即上一级的作用域无法访问下一级的作用域),其实函数本身就是闭包。 闭包要解决的问题 提供一种间接的方式能够访问到函数内部的数据（变量） 实现思路 01 我们需要能够在函数外部访问函数内部的变量，正常情况无法访问； 02 在函数内部如果新创建函数，那么安装作用域链的原则，这个新创建的内部函数能够访问到函数中的这些变量。 03 我们如果能够操作函数中新创建的函数，那么就能够操作函数中的变量（如访问和设置等） 04 如果要能够操作函数中新创建的函数，那么需要在函数中把新创建的函数返回。 05 调用函数，接收并得到其返回值（是一个函数） 06 调用返回值（函数），通过函数传参的方式来设置函数中的变量。 07 调用返回值（函数），通过在函数内部再次return的方式来访问函数中的变量。 闭包的基本模式 在函数内部创建函数(内部函数),在这个内部函数中,可以操作外部函数中的变量 01 在函数(外部)中创建函数(内部函数),在该函数(内部函数)中操作外部函数中的变量 02 在外部函数中,把内部函数作为返回值返回 03 调用外部函数,并接收其返回值(是一个函数) 04 调用接收到的返回值(内部函数),来间接的操作外部函数中的变量 代码示例123456789function func() &#123; var num = 10; return function (n) &#123; num = n; console.log(num); &#125;&#125;var funcName = func();funcName(\"哗啦哗啦\"); 闭包获取数据获取单个数据（考虑赋值）123456789101112131415function func() &#123; var num = 123; return function (a) &#123; if (a !== undefined) &#123; num = a; &#125; return num; &#125;&#125;var f1 = func();var x = f1(456);var y = f1();console.log(x);console.log(y); 说明：上面的代码能够支持通过闭包对函数中的变量num进行访问（取值）或赋值的操作。 获取多个数据（数组）123456789101112131415function func() &#123; var name = \"张学友\"; var age = 40; return [ function getName() &#123; return name; &#125;, function getAge() &#123; return age; &#125; ]&#125;var foo = func();console.log(foo[0]()); //张学友console.log(foo[1]()); //40 说明：上面的代码能够满足返回多个变量值的需求，但是要数组操作的方式并不常见，且和使用习惯不符合。 利用对象返回并设置对个变量值1234567891011121314151617181920212223242526function foo() &#123; var name = \"张学友\"; var age = 45; return &#123; getName:function () &#123; return name; &#125;, getAge:function () &#123; return age; &#125;, setName:function (nameValue) &#123; name = nameValue; &#125;, setAge:function (ageValue) &#123; age = ageValue; &#125; &#125;&#125;var func = foo();console.log(func.getName()); //张学友console.log(func.getAge()); //45func.setName(\"张三\");func.setAge(30);console.log(func.getName()); //张三console.log(func.getAge()); //30 闭包的作用最基本的作用:闭包中的变量更安全,只能通过特定的接口来访问说明:12(1)创建一个私有的空间,保护数据,外界如果需要访问数据必须通过函数提供的指定方法(2)在这些指定的方法中,我们可以设置一些校验的逻辑,以保证对数据访问和设置的安全性 闭包的使用注意进程和线程 进程指的是系统中正在运行的一个应用程序。 线程:一个进程中可以有一个或多个线程,线程是CPU调度的最小单位,是真正执行任务的。 多线程:一个中可能有多条线程,多条线程之间并发的执行多个不同的任务。 单线程:一个进程中只有一条线程,即同一时间只能执行一个操作,只能干一件事情。 javascript是单线程的 js中的线程主要处理三块任务: 01 渲染任务 02 js的代码执行任务 03 js中的事件处理任务(如setTimeOut方法) javascript中代码的执行顺序 01 先把主任务执行完毕(代码任务)02 主任务执行完毕之后再执行次要的任务(包括setTimeOut方法等) 关于setTimeOut函数 函数的作用:一次性定时器(用于延迟执行任务) 参数: 第一个参数:要执行的任务 第二个参数:要延迟执行的时间,时间的单位是毫秒 函数说明： 01 至少在指定的时间后才能够执行回调函数 02 因为要等主任务中的代码执行完毕之后,才回去检查setTimeOut的回调函数。 通过闭包解决setTimeOut函数的问题12345678910111213&lt;script&gt; for (var i = 0; i &lt; 10; i++) &#123; setTimeout((function (j) &#123; return function () &#123; console.log(j); &#125; &#125;)(i),10); console.log(\"----\"); &#125;&lt;/script&gt; 函数的特殊之处函数的特殊之处在于,它本身是对象,且函数可以提供作用域。 (01) 函数可以在运行时动态的创建,还可以在程序执行过程中创建。 (02) 函数可以赋值给变量,可以被扩展,甚至是删除。 (03) 函数可以作为其他函数的参数和返回值。 (04) 函数可以拥有自己的属性和方法。 注意:{} 块在js中不会创建作用域,哪怕是if或者是while语句中使用var关键字声明的变量也并非局部变量。 函数是可以通过（）调用并执行的对象。 函数是第一型对象12301 函数可以像普通对象一样作为函数的参数02 函数可以像普通对象一样赋值给变量（函数表达式）03 函数可以像普通对象一个作为函数的返回值返回 代码示例123456789101112131415//函数作为参数传递 setTimeout(function () &#123; console.log(1); &#125;,100); //函数作为返回值 function func() &#123; return function () &#123; console.log(\"demo\"); &#125; &#125; var f = func(); f(); //demo //函数赋值给变量 var a = function()&#123;&#125; a(); //直接通过变量的名称调用函数 函数的两个特征1201 函数本质上是对象02 函数可以创建作用域 约定1234var add = function add(a,b)&#123;return a + b;&#125;; //命名函数表达式var add = function (a,b)&#123;return a + b;&#125;; //函数表达式,匿名函数 以上也称为使用字面量的方式来创建函数(或者是函数字面量)function add()&#123;&#125;; //函数声明 代码示例123456789101112131415&lt;script&gt; //01 函数声明 function demo01() &#123; &#125; //02 函数表达式(匿名函数) var demo02 = function () &#123; &#125;; //03 命名函数表达式 var demo03 = function demo03Test() &#123; &#125;; //04 打印name属性 console.log(demo01.name); //demo01 console.log(demo02.name); //demo02 (注意在火狐浏览器中打印出来的name属性为空) console.log(demo03.name); //demo03Test&lt;/script&gt; 函数回调回调函数(回调),当我们把某个函数作为参数传递给另一个函数的时候,这个函数就称为回调函数 函数回调的基本模式12345678910&lt;script&gt; function func(callBack) &#123; //处理其他的操作 callBack(); //调用回调函数 &#125; function demo() &#123; console.log(\"这是一个回调函数\"); &#125; func(demo); //注意调用函数的时候,参数是回调函数的引用(不要加括号);&lt;/script&gt; 函数回调解决this问题说明：如果回调函数是某个对象的方法,而该对象方法中使用了this指针那么该方法作为回调函数来使用的时候,需要注意this123456789101112131415161718192021222324252627//01 提供一个对象,该对象中永远showName方法var obj = &#123; name:\"默认的名字\", age:30, showName:function () &#123; console.log(this.name); &#125;, showAge:function () &#123; console.log(this.age); &#125;&#125;;//02 提供一个函数,该函数接受一个参数(函数引用)function demo(callBack,callBack_obj) &#123; //处理第一个参数传递对象方法字符串的形式 if(typeof callBack == 'string') &#123; callBack = callBack_obj[callBack]; &#125; if (typeof callBack == 'function') &#123; callBack.call(callBack_obj); &#125;&#125;//demo(obj.showName,obj);//demo(obj.showAge,obj);//传递字符串和对象来进行调用demo(\"showName\",obj); 代码说明：123（01）以上代码传入两个参数，分别为具体的回调函数，和该回调函数所属的对象（02）该函数的参数接受两种方式的回调传递（一种是直接传递函数引用，一种是直接以字符串的方式传递对象方法的字符串）（03）在函数内部对传入的回调参数做处理，修正this的问题 函数作为函数的返回值12① 使用闭包实现一个计数器(在该示例中setup函数的返回值为一个函数)② 通过调用返回值(一个函数),可以操作setup函数中的变量 123456789101112&lt;script&gt; var setup = function () &#123; var count = 0; return function () &#123; return count ++; &#125; &#125; var next = setup(); console.log(next()); //0 console.log(next()); //1 console.log(next()); //2&lt;/script&gt; 惰性函数定义说明：某个函数直到第一次使用的时候才被正确的定义,并且其具有向后惰性,执行更少的工作。应用场景:函数有一些初始化的准备工作要做,且只需要执行一次的情况。特点:能够更新自己(函数)的实现。缺点: 01 当重新定义自身的时候,已经添加到原始函数的任何属性都会丢失。 02 如何函数被赋值给了其他的变量或者是对象方法,那么在使用变量或者是对象方法调用时仍然会执行旧的函数体。代码示例123456789function foo() &#123; console.log(\"foo!\"); foo = function () &#123; console.log(\"new foo!\"); &#125;&#125;//函数的调用//foo(); //foo!//foo(); //new foo! 问题： ① 添加属性 ② 把函数赋值给新的变量 ③ 以对象的方法调用函数 当惰性函数定义在处理以上三种情况的时候，使用新的变量名调用或者是是以对象的方法来调用函数，那么该函数在执行的时候并不会更新自身，而是执行旧的函数体的内容 代码示例1234567891011121314151617181920212223242526272829&lt;script&gt; //01 声明函数foo function foo() &#123; console.log(\"foo!\"); foo = function () &#123; console.log(\"foo! foo!\"); &#125; &#125; //02 为foo函数对象添加属性 foo.description = \"foo函数的描述信息\"; //03 把foo函数赋值给其他的变量 var func = foo; //04 把foo函数赋值给对象中的方法 var obj = &#123; showFoo:foo &#125; //05 验证并演示输出 func(); //foo! func(); //foo! console.log(func.description); //foo函数的描述信息 //总结:01 如果把函数赋值给其他的变量,那么在以其他变量的方式调用时不会更新自身,还是执行旧的函数体 obj.showFoo(); //foo! obj.showFoo(); //foo! console.log(obj.showFoo.description); //foo函数的描述信息 //总结:02 如果把函数赋值给对象的方法,那么在以对象方法形式调用时不会更新自身,还是会执行旧的函数体。 foo(); //已经更新过foo函数 foo! foo! foo(); //已经更新过foo函数 foo! foo! console.log(foo.description); //undefined&lt;/script&gt; 即时函数 定义:在函数定义之后立即执行该函数。即时函数模式的组成: ① 使用函数表达式来定义函数(匿名函数,注意不能使用函数声明方式) ② 在函数表达式末尾添加一组(),表示立即执行当前函数。 ③ 将整个函数包装在()中,有两种方式` 即时函数的作用 01 用来将所有的代码包装到当前的作用域中,并且不会将任何的变量泄露到全局作用域中。 02 js中没有代码块作用域,而函数是js中唯一可以创建作用域的。 03 即时函数就是利用了函数创建作用域这一点,来实现对一些需要封装且不允许外部访问的操作。 即时函数的优点01 不会产生全局变量,在即时函数内部定义的所有变量都仅仅只是该函数的局部变量,不会造成全局变量污染问题。02 具有更好的封装性,外部无法访问到该函数内部的数据。 即时函数代码示例12345678//第一种写法(function () &#123; console.log(\"即时函数的第一种写法\");&#125;());//第二种写法(function () &#123; console.log(\"即时函数的第二种写法\");&#125;)(); 写法补充123456789(function (a) &#123; console.log(a); &#125;(20)); +function (b) &#123; console.log(b); &#125;(30); -function (b) &#123; console.log(b); &#125;(40); 即时函数的传参和返回值12345678910//01 接受参数 (function (str) &#123; console.log(str); //hello &#125;)(\"hello\"); //02 提供返回值并赋值给新的变量 var foo = (function () &#123; return 2 + 1; &#125;)(); console.log(foo); //3 即时对象初始化01 结构特征:12345① 提供一个对象,在该对象内部提供一个init初始化方法② 使用()把对象包装起来(让字面量变成表达式)③ 然后随即调用init方法,完成初始化操作。 02 基本结构({}).init(); 03 模式优点 在执行一次性的初始化任务时保护全局的命名空间。 代码示例1234567891011121314&lt;script&gt; (&#123; name:\"张三\", age:23, getDescript:function () &#123; console.log(\"名字:\" + this.name + \"年龄:\" + this.age); &#125;, //注意:在对象中访问对象的属性和方法都需要使用this.前缀 init:function () &#123; this.getDescript(); //其他的初始化处理 &#125; &#125;).init();&lt;/script&gt; 函数属性缓存思路说明 01 函数是对象，因此可以在函数上面添加属性和方法 02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果 03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value） 04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。 代码示例(单个参数)1234567891011121314var func = function (param) &#123; if (func.cache[param] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[param] = result + param; &#125; return func.cache[param];&#125;func.cache = &#123;&#125;; //空对象console.log(func(\"demo\")); //字符串democonsole.log(func(\"test\")); //字符串testconsole.log(func(\"demo\")); //字符串demo 直接使用属性缓存中的数据,而不再进行复杂的计算(可以提升性能) 代码示例（多个参数）12345678910111213var func = function () &#123; var key = JSON.stringify(Object.prototype.slice.call(arguments)); if (func.cache[key] == undefined) &#123; var result = \"字符串\"; //初始化值 //...对result做复杂的计算 func.cache[key] = result + key; &#125; return func.cache[key];&#125;func.cache = &#123;&#125;; //空对象func(\"123\",\"456\"); ////说明:如果传入的参数数量超过1,则可以将传入的参数序列化为一个json字符串作为参数处理。 代码说明：slice:返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.afanail.com/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.afanail.com/tags/简明教程/"}]},{"title":"JavaScript简明教程（5）","slug":"js-05","date":"2016-03-17T17:09:24.000Z","updated":"2017-07-22T03:52:37.000Z","comments":true,"path":"2016/03/18/js-05/","link":"","permalink":"http://www.afanail.com/2016/03/18/js-05/","excerpt":"JavaScript中有严格模式和非严格模式两种运行环境,本章节主要讲严格模式及非严格模式下函数和变量的区别,最后简单讲诉了JavaScript作用域。 变量和函数私有变量和函数 定义在构造函数内部而被this对象的变量,在外部无法访问到的变量和函数","text":"JavaScript中有严格模式和非严格模式两种运行环境,本章节主要讲严格模式及非严格模式下函数和变量的区别,最后简单讲诉了JavaScript作用域。 变量和函数私有变量和函数 定义在构造函数内部而被this对象的变量,在外部无法访问到的变量和函数 公有变量和方法 对外暴露接口,可以通过构造函数对象创建的对象访问的属性和方法 代码示例1234567891011121314151617function Car(type,number) &#123; this.type = type; //公共的属性 this.number = number; var city = \"广州\"; //私有变量 var getNumber = function () &#123; //私有函数 return number; &#125;; var getType = function () &#123; return type; &#125;; //能够访问私有变量和函数的方法 --- 特权方法 this.getDescription = function () &#123; console.log(getNumber() + getType() + city); &#125; &#125; var car = new Car(\"汽车\",\"201718\"); car.getDescription(); 说明：能够访问构造函数内部私有变量|函数的方法称之为特权方法 构造函数的问题构造函数本身是一个函数，在调用的时候有多种调用方式。12① new 构造函数（）调用② 构造函数（）调用 以上，第二种调用方式存在作用域安全的问题 作用域安全的构造函数12345678910111213141516171819202122&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; //容错处理 if (this instanceof Person) &#123; //设置实例属性和方法 this.name = name; this.showName = function () &#123; console.log(this.name); &#125; &#125;else &#123; return new Person(name); &#125; &#125; //02 创建对象 var p1 = new Person(\"zhangsan\"); var p2 = new Person(\"lisi\"); p1.showName(); p2.showName();&lt;/script&gt; 新的问题说明:上面的代码在使用借用构造函数方式继承的时候存在问题，无法创建出的对象，原因在于通过call或者是apply函数调用的时候，内部的this绑定的子类型中的对象，因此在使用instanceOf 判断的时候，结果为假。解决：可以设置让子类型（构造函数）的原型对象为父类型的一个实例。代码示例123456789101112131415161718192021222324252627282930&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; //容错处理 if (this instanceof Person) &#123; //设置实例属性和方法 this.name = name; this.showName = function () &#123; console.log(this.name); &#125; &#125;else &#123; return new Person(name); &#125; &#125; //02 创建对象 var p1 = new Person(\"zhangsan\"); var p2 = new Person(\"lisi\"); p1.showName(); p2.showName(); // 使用借用构造函数来实现继承 function Boy(name)&#123; Person.call(this,name); &#125; //需要结合原型继承来解决 instanceOf 实例对象检测的问题 Boy.prototype = new Person(); var boy = new Boy(\"测试的名字\"); boy.showName();&lt;/script&gt; 严格模式关键字 “use strict”;实现严格模式:只需要在脚本代码中添加上上述关键字即可。 关键字具体说明12345(1) 注意区分大小写，必须全部都是小写的(2) 注意空格，整个字符串总共10个字符(3) 单引号和双引号无所谓，但是需要有双引号(4) 必须写在作用域的最顶部，注意其位置(5) 可以加分号，也可以不加，但是必须是一个字符串 注意：以下的关键字写法均是错误的123\"USE strict\";\" use strict \";\"(\"USE strict\").toLowerCase();\" 严格模式使用注意12345678910111 所有的变量必须使用var 关键字声明2 不能使用delete关键字删除全局变量 ,以前默认删除失败,严格模式下直接报错3 在对象中不允许有同名的属性4 函数的参数必须唯一(不能出现同名的参数)5 arguments对象的行为不同,在非严格模式下修改形参的值会反映到arguments中,而严格模式下则相对独立6 禁用了argument.callee和caller函数,他们一个引用函数本身,一个引用调用函数7 不能在if语句中声明函数8 禁止使用eval和arguments作为标识符9 修正this的值,在严格模式下,函数this的值始终是指定的值,无论指定的是什么值。10 禁用了with语句11 去掉了JavaScript中的八进制字面量(以0开头的八进制字面量是无效的语法) 1 所有的变量都必须使用var关键字声明12a = 10; //错误的演示console.log(10); ② 不能使用delete关键字删除全局变量1234//在非严格模式下,删除失败(静默失败) 失败了不吭声,严格模式下直接报错var a = 10;delete a;console.log(a); ③ 在对象中不允许有同名的属性1234567//在非严格模式下,会使用后面的属性赋值作为最终值,在严格模式下则直接报错var obj = &#123; name:\"张三\", name:\"李四\"&#125;console.log(obj); ④ 函数的参数必须唯一(不能出现同名的参数)123456789101112//在非严格模式下,如果函数在定义的时候,使用了多个同名的参数,则在函数内部形参的实际值为最后一个传入的实参值//在严格模式下,直接报错// function func(a,a,a) &#123;// console.log(a);// console.log(arguments);// &#125;function func(a,b,c) &#123; console.log(a); console.log(arguments);&#125;func(1,2,3); arguments对象的行为不同说明：（1）严格模式下,在函数内部修改了对象的指向,对arguments的值不会产生影响（2）在严格模式下,形参的值和arguments的值是相互独立的,在函数内部修改了形参的值对arguments不受影响（3）在非严格模式下，修改了形参的值，arguments中的数据会跟着改变123456789101112131415161718 //测试引用类型的值作为函数的参数function funcName(obj) &#123; console.log(obj); console.log(arguments[0]); //在函数内部修改形参的值 obj = &#123;age:20&#125;; console.log(obj); console.log(arguments[0]); &#125; funcName(&#123;name:\"张三\"&#125;); //测试基本类型数据作为函数的参数 function fun(str) &#123; console.log(str); console.log(arguments[0]); str = \"hello\"; console.log(arguments[0]); &#125; fun(\"hi\"); ⑥ 禁用了argument.callee和caller函数说明：argument.callee是对函数自身的引用argument.calller是对调用函数的引用12345678var num = (function (n) &#123; if (n ==1) &#123; return 1; &#125; return arguments.callee(n-1) + n; &#125;)(10); console.log(num); //55 ⑦ 不能在if语句中声明函数123456789//如果在if语句中声明函数，则会产生语法错误 if (true) &#123; console.log(\"________\"); function demo() &#123; console.log(\"呵呵呵呵\"); &#125; demo(); &#125; ⑧ 禁止使用eval和argument作为标识符1234var eval = \"测试的字符串\";console.log(eval);var arguments = \"参数列表\";console.log(arguments); ⑨ 修正this的值12345678在严格模式下,函数this的值始终是指定的值,无论指定的是什么值var name = \"测试的name\";function demoTest() &#123; //在非严格模式下,打印出来的this为全局的对象window console.log(this); //在严格模式下打印出来的this为undefined&#125;demoTest(); ⑩ 禁用了with语句1234567var o = &#123;name:\"暂时干\",age:20&#125;; with(o) &#123; name = \"lisi\"; age = 48 &#125; console.log(o); 禁用了八进制123//以0开头的数据常常引起混乱//var num = 023; //2*8 + 3 ==&gt; 19//console.log(num); //19 书写格式1234501 必须使用单引号或者是双引号括住字符串02 必须使用小写,不能出现大写字符03 必须是10个字符04 字符串后面的分号可以省略05 必须写在当前作用域的最顶上 代码示例123456789101112&lt;script&gt; //\"use strict\"; //正确写法 //\"use strict\" //正确写法 分号可以省略 //'use strict'; //正确写法 可以使用单引号 //\"use strict\"; //错误写法 必须是10个字符 //\"use Strict\"; //错误写法 所有的字符都必须小写 \"use strict\"; a = 10; // \"use strict\"; //错误写法 必须写在当前作用域的顶端 b = 20; console.log(a);&lt;/script&gt; 作用范围12① 函数的顶部(只对当前的函数有效)② script标签的顶部,只对当前的标签有效,对页面中其他的script无效 代码示例12345678910111213141516 //位置01 对func01和func02都有效 //\"use strict\"; function func01() &#123; //位置02 对func01有效,对func02无效 //\"use strict\"; a = 10; console.log(a); &#125; function func02() &#123; //位置03 对func02有效,但对func01无效 //\"use strict\"; b = 20; console.log(b); &#125;func01(); func02(); 函数的几种调用方式123401 普通函数调用 内部的this指向全局对象window02 构造函数调用 内部的this指向新创建的对象03 对象的方法调用 内部的this指向调用的对象本身04 通过call 或者是apply方式调用(函数上下文),this指向的是当前的上下文对象 this丢失demo演示123456789101112&lt;script&gt; var obj = &#123; name:\"张三\", getName:function () &#123; console.log(this.name); &#125; &#125;; //以对象的方法来进行调用 obj.getName(); //张三 var getName = obj.getName; getName(); //以普通函数的方式调用,此时内部的this指向的是window对象 打印的是window.name 为空值&lt;/script&gt; 代码示例0212345678910111213141516&lt;script&gt; //01 获取页面中id值为demo的标签 //var div = document.getElementById('demo');// var getId = document.getElementById;// var div = getId('demo'); //会报错?// console.log(div); //借用apply来修正this document.getElementById = (function (func) &#123; return function () &#123; return func.apply(document,arguments); &#125; &#125;)(document.getElementById); var getId = document.getElementById; var div = getId('demo'); //会报错? console.log(div);&lt;/script&gt; 代码说明：12301 因为document.getElementById方法的内部实现中需要使用到this,这个this本来期望指向的是document对象02 当我们以document.getElementById来调用的时候,内部的this指向document对象03 但是当我们以getId的方式调用的时候,内部的this指向的是window对象(因为我们以普通的方式进行调用) 作用域变量其作用的范围就是它的作用域 块级作用域说明：JavaScript中没有块级作用域123456for (var i = 0; i &lt; 10; i++) &#123; var num = i; &#125; console.log(i); console.log(num); //说明:如果有块级作用域,则i和num打印的结果应该为undefined 词法作用域123词法作用域:在代码写好的那一刻,变量的作用域就已经确定的动态作用域:变量的作用域由执行时的环境所决定说明:在js中不是动态作用域,当调用的时候,是往上查找的,不会到其他函数的作用域中去查找 在JavaScript中唯一能够产生作用域的东西是函数代码演示123456789101112131415161718192021222324&lt;script&gt; var a = \"这是第一个a\"; function func01() &#123; console.log(a); //先在当前作用域中查找,如果没有则访问全局的作用域 &#125; function func02() &#123; var a = \"这是第二个a\"; func01() &#125; func01(); //打印结果为:这是第一个a func02(); //打印结果为:这是第一个a&lt;/script&gt;&lt;script&gt; var a = \"这是第一个a\"; function func02() &#123; var a = \"这是第二个a\"; func01() &#125; function func01() &#123; console.log(a); //先在当前作用域中查找,如果没有则访问全局的作用域 &#125; func01(); //打印结果为:这是第一个a func02(); //打印结果为:这是第一个a&lt;/script&gt; 词法作用域的规则1234① 在函数内部允许访问外部的变量② 只有函数可以限定作用域③ 作用域规则首先使用提升规则分析④ 如果当前作用域中有该变量,则不考虑外部作用域的同名变量 变量和函数提升JS中的代码执行分为两个步骤① 预解析JavaScript在预解析阶段,会对使用var关键字声明的变量和function声明的代码块进行提升操作,提升到当前作用域的顶端② 执行 代码提升的几种情况 01 函数提升123456&lt;script&gt; func(); function func() &#123; console.log(\"测试的函数\"); &#125;&lt;/script&gt; 02 变量提升1234567&lt;script&gt; console.log(a); //打印出来的结果为undefined var a = 10; //var a; //注意:只会对变量的声明进行提升 //console.log(a); //a = 10&lt;/script&gt; 03 函数同名情况提升12345678910111213141516171819&lt;script&gt; func01(); //打印last function func01() &#123; console.log(\"first\"); &#125; func01(); //打印last function func01() &#123; console.log(\"last\"); &#125; //模拟提升后的情况 function func01() &#123; console.log(\"first\"); &#125; function func01() &#123; console.log(\"last\"); &#125; func01(); func01();&lt;/script&gt; 说明：预处理的时候，同名的函数都会进行提升，但是后面的会覆盖掉前面的 04 变量名和函数同名的情况12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; console.log(a); //打印function function a() &#123; console.log(\"我是一个函数\"); &#125; var a = 20; console.log(a); //打印20 //变量和函数提升后的结果 错误// function a() &#123;// console.log(\"我是一个函数\");// &#125;// var a ;// console.log(a);// a = 20;// console.log(a); //变量和函数提升后的结果 正确 function a() &#123; console.log(\"我是一个函数\"); &#125; console.log(a); var a = 20; console.log(a);&lt;/script&gt;```js总结:如果出现变量和函数同名的情况,则在进行提升的时候,只会提升函数到当前作用域顶端而忽略变量的提升操作**变量的提升是分作用域的**示例代码01```js&lt;script&gt; console.log(a); //undefined var a = 10; //模拟提升 var a; console.log(a); //undefined a = 10;&lt;/script&gt; 示例代码0212345678910111213141516171819&lt;script&gt; var num = 10; function func() &#123; var num = 20; console.log(num); &#125; console.log(num); //10 func(); //20 //模拟提升 var num; function func() &#123; var num; num = 20; console.log(num); &#125; num = 10; console.log(num); //10 func(); //20&lt;/script&gt; 示例代码031234567891011121314151617var num = 10;function func() &#123; console.log(num); var num = 20;&#125;console.log(num); //10func(); //undefiend//模拟提升var num;function func() &#123; var num; console.log(num); num = 20;&#125;num = 10;console.log(num); //10func(); //undefiend 示例代码041234567891011121314151617var num = 10;function func() &#123; console.log(num); num = 20;&#125;console.log(num); //10func(); //10//模拟变量提升var num;function func() &#123; console.log(num); num = 20;&#125;num= 10;console.log(num); //10func(); //10console.log(num); //20 函数表达式的提升说明：在使用函数表达式方式创建函数的时候,整个函数表达式并不会进行提升,只会对var声明的变量提升1234567891011func();var func = function () &#123; console.log(\"会不会被调用\");&#125;//以上如上代码将报错//模拟提升的过程var func;func(); //找不到这个函数func = function () &#123; console.log(\"会不会被调用\");&#125; 作用域链01 在js中函数可以创建作用域 02 函数中又可以创建函数(即又可以开辟新的作用域) 03 函数内部的作用域可以访问外部的作用域 04 如果有多个函数嵌套,那么就会构成一个链式的访问结构,也就是作用域链 05 注意:函数内部的作用域可以访问外部的作用域,但是外部的作用域却不能访问内部的作用域 代码示例1234567891011121314151617&lt;script&gt; function f1() &#123; //f1---&gt;全局作用域 function f4() &#123; //f4--&gt;f1---&gt;全局作用域 function f5() &#123; &#125; &#125; &#125; function f2() &#123; //f2--&gt;全局作用域 function f6() &#123; &#125; &#125; function f3() &#123; &#125;&lt;/script&gt; 作用域链绘图说明 ① 先画出全局作用域线条，然后在上面添加全局作用域中的函数和变量，作为0级作用域链 ② 画出全局作用域中的函数的作用域线条，，然后在上面添加当前作用域中的函数和变量，作为1级作用域链 ③ 以此类推，直至完成 示例代码01123456789function f1() &#123; function f2() &#123; &#125; &#125; var a = 20; function f3() &#123; function f4() &#123; &#125; &#125; 图示 示例代码021234567891011121314function f1() &#123; function f2() &#123; function f5() &#123; var b = \"demo\"; &#125; &#125; &#125; var a = 20; function f3() &#123; var c = \"啊哈哈\"; function f4() &#123; var d = \"test\"; &#125; &#125; 图示 作用域注意点和变量搜索原则注意点 01 在获取值和设置值的时候都是访问变量 02 并非在函数内部写了变量,这个变量就属于当前函数,而是必须使用var 关键字声明的变量才属于当前函数 03 函数在声明的时候,里面的代码并不会执行,只有在函数调用的时候才会执行 04 声明函数时候的函数名,其实也是一个变量名,可以通过这个变量名来进行设置和赋值 05 注意:在变量内部使用var 关键字声明一个变量并不会把同名的全局变量覆盖掉 1234567var a = 10;function f1() &#123; var a = 20; //注意:该行代码并不会覆盖掉全局变量中的变量a console.log(a);&#125;f1(); //20console.log(a); //10 代码点评：12在函数中使用var关键字声明变量a并不会覆盖全局作用域中的a。注意需要同时考虑变量在当前作用域的提升以及访问变量时的搜索原则。 1234567function f1() &#123; console.log(1);&#125;var f1 = \"demo字符串\"; //该行代码会把f1函数覆盖掉f1 = \"demoTest字符串\";console.log(f1);//f1(); 代码点评:函数的名称也是变量，如果在代码中出现同名的变量，那么函数的实现会被覆盖掉 变量搜索原则 01 在使用变量的时候,首先在自己的作用域中查找 02 如果找到了就直接使用,如果没有找到,那么就到上一级作用域中去查找 03 重复上面的步骤,直到0级作用域,如果还是找不到那么就返回undefined(报错)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.afanail.com/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.afanail.com/tags/简明教程/"}]},{"title":"JavaScript简明教程（4）","slug":"js-04","date":"2016-03-05T05:26:28.000Z","updated":"2017-07-22T03:52:40.000Z","comments":true,"path":"2016/03/05/js-04/","link":"","permalink":"http://www.afanail.com/2016/03/05/js-04/","excerpt":"本章节主要讲解了原型链及相关方法。 原型链及相关属性方法简单说明原型链代码示例","text":"本章节主要讲解了原型链及相关方法。 原型链及相关属性方法简单说明原型链代码示例1234567891011121314151617&lt;script&gt; //01 提供Person构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置Person的原型对象 Person.prototype.showName = function () &#123; console.log(this.name); &#125; //03 创建Student构造函数 function Student(number) &#123; this.numer = number &#125; //04 设置Student的原型对象 Student.prototype = new Person();&lt;/script&gt; 原型链图示例 Object对象Object构造函数01 使用Object构造函数创建字符串对象12345678//01 创建字符串对象var str1 = new String(\"测试字符串\");var str2 = new Object(\"测试字符串\");var str3 = str1;//注意:对象比较相等(需要引用[地址]相等)console.log(str1 == str2); //falseconsole.log(str1 === str2); //falseconsole.log(str1 === str3); //true 02 使用Object构造函数创建数字对象12var num = new Object(10);console.log(typeof num); //object 03 使用Object构造函数创建布尔类型对象12var bool = new Object(true); console.log(typeof bool); //object js中所有的内置或自定义对象都继承自Object对象,几乎所有的对象都可以使用Object.prototype上面的属性和方法 Object.prototype01 因为js中所有的对象都继承自Obejct,都可以使用Object对象的原型属性和方法,因此不要轻易的扩展Object.prototype。02 Object.property中的属性和方法 ① constructor 指向原型相关联的构造函数，为Object ② hasOwnProperty 判断对象中是否拥有某个实例属性(不包括原型链上面的属性) ③ isPrototypeOf 校验某个对象是否是指定对象的原型对象(整条原型链) ④ propertyIsEnumerable 属性是否存在且可枚举(使用for循环可以遍历,即目标属性能否在for循环中显示出来) ⑤ toString() 返回一个描述目标对象的字符串,对象则返回[object object] toString(参数) 参数出可以传入一个用于进制数的参数,该参数的默认值为10(主要针对Number类型有效) ⑥ toLocaleString 同toString,但是会做一些本地化的处理。 ⑦ valueOf() 如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。 Date对象调用该方法会返回一个时间戳。 constructor说明：该属性指向创建该对象的构造函数，在这里为Object123456function Person() &#123; &#125; var p = new Person(); console.log(p.constructor); //function Person() &#123;&#125; console.log(Person.prototype.constructor); //function Person() &#123;&#125; console.log(Object.prototype.constructor); //function Object() &#123; [native code] &#125; hasOwnProperty说明：判断对象中是否拥有某个实例属性(不包括原型链上面的属性)12345678function Person() &#123; this.name = \"默认的姓名\"&#125;//检查对象中是否拥有指定的属性(实例属性)var p1 = new Person();p1.hasOwnProperty(\"name\"); //truep1.hasOwnProperty(\"age\"); //falsep1.hasOwnProperty(\"constructor\"); //对象的constructor是从原型对象上继承的 isPrototypeOf说明：校验某个对象是否是指定对象的原型对象(整条原型链);1234567891011121314&lt;script&gt; var obj = &#123; name:\"张三\", age:20, hello:function () &#123; console.log(\"hello\"); &#125;, showName:function () &#123; console.log(this.name); &#125; &#125; //属性是否存在且可以枚举 console.log(obj.propertyIsEnumerable(\"name\")); //true&lt;/script&gt; toString说明：返回一个描述目标对象的字符串,对象则返回[object object]12345678910111213&lt;script&gt; var obj = &#123;&#125;; console.log(obj.toString()); //打印[object Object] var arr = [1,2,3,4,5]; console.log(arr.toString()); //打印1,2,3,4,5 var num = 10; console.log(num.toString()); //10 var date = new Date(); console.log(date.toString()); //Mon Feb 13 2017 19:00:13 GMT+0800 (CST) //toString方法可以传入参数,在处理Number类型数据的时候,可以传入指定的进制 console.log(num.toString(2)); //1010 == 1*2*2*2+0*2*2+1*2+1*1 = 10 console.log(num.toString(3)); //101 == 1*3*3 + 0*3 + 1*1 = 10&lt;/script&gt; toLocaleString说明：作用同toString方法一致，但是会做一些本地化的处理. valueOf说明：① 如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。② 如果是Date类型，则返回时间戳。123456789&lt;script&gt; var obj = &#123;&#125;; console.log(obj + 1); //[object Object]1 //说明:如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。 var o = &#123;name:\"张三\"&#125;; console.log(o + 1); //[object Object]1 var date = new Date(); console.log(date.valueOf()); //1486984088998&lt;/script&gt; 静态成员和实例成员静态成员 定义在构造函数上面的成员(属性和方法) 实例成员 定义在实例对象上面的成员(属性和方法) 建议 ① 把工具类的方法写成静态方法 ② 把和对象相关的方法写成实例方法(成员) 代码示例12345678910111213141516&lt;script&gt; function Person() &#123; this.name = \"张三\"; //实例属性 this.showName = function () &#123; console.log(this.name); &#125;; &#125; //为Person构造函数添加静态成员 Person.des = \"描述信息\"; Person.add = function (msg) &#123; console.log(\"添加信息\" + msg); &#125;; Person.add(\"这是一个+操作\"); var p1 = new Person(); p1.showName();&lt;/script&gt; Function构造函数函数创建的几种方式 12301 函数声明02 字面量的方式创建03 使用new Function的形式创建 函数创建代码示例 12345678function func01() &#123; console.log(\"函数声明\"); &#125; var func02 = function () &#123; console.log(\"字面量方式创建\"); &#125; //使用Function构造函数创建 var func03 = new Function(); Function构造函数创建函数 参数说明:可以传入多个参数 最后一个参数:传入的最后一个参数为函数的函数体内容 其他参数:创建出来的函数的参数 如果只有一个参数,则表示这是该函数的函数体内容 传递参数的格式:以字符串的方式进行传参代码示例123456//需求01 使用Function构造函数创建一个函数对象,该函数执行一行打印操作var funcName01 = new Function(\"console.log('让我掉下眼泪的,不止昨夜的酒')\");funcName01();//需求02 使用Function构造函数创建一个函数对象,该函数需要接受两个参数,要求返回他们的和var funcName02 = new Function(\"a\",\"b\",\"return a + b;\");console.log(funcName02(10, 20)); //30 解决函数体代码过长的问题（1）使用转义字符，写在一行中（2）使用+操作符来拼接字符串（3）使用``操作符来管理字符串（4）使用模板先处理字符串，然后在js中获得模板中的内容 arguments、length和calleearguments参数说明：在js中的函数中，有两个隐藏的参数分别是this和arguments1234arguments 是一个类似数组的结构,可以通过下标来操作函数的参数,但并非数组类型的。在函数调用的时候,会将函数的所有参数都传入arguments对象中保存,因此我们可以通过操作arguments属性来操作参数形参的数量大于实参的数量,则依次传入,未传入的设置为undefined形参的数量小于实参的数量,则arguments中保存实际的值 length 函数内部的arguments数组拥有length属性,可以通过该属性获取用户调用时传入的实参的个数 函数本身有一个length属性,可以通过该属性来获取形式参数的个数 callee方法 函数内部的arguments对象中,有一个callee方法,该方法指向函数自身,常用于匿名函数的递归调用。 代码示例12345678910111213141516171819&lt;script&gt; function func() &#123; console.log(arguments); console.log(arguments.length); //调用函数时实际传入的参数数量 &#125; func(1,2,3,4,5); console.log(func.length); //预期的参数数量 —— 函数的形参数量 function func02(a,b) &#123; console.log(a, b); console.log(arguments); &#125; func02(1,2,3); //实参的数量 &gt; 形参的数量 则arguments保存实参的值 func02(1); //实参的数量 &lt; 形参的数量 则不足的补undefined //匿名函数调用 (function () &#123; //如果需要在该函数中调用自身,则可以使用arguments.callee方法 arguments.callee(); &#125;)();&lt;/script&gt; Function的应用01 数组去重123456789101112 var func = new Function(\"arr\",` var array = []; for(var i = 0 ; i&lt;arr.length; i++) &#123; if(array.indexOf(arr[i]) == -1) &#123; array.push(arr[i]); &#125; &#125; return array;`); console.log(func([1, 2, 3, 4, 5, 3, 4, 2]));; 02 返回传入函数中所有数据的最大值123456789101112var func = function () &#123; var maxNumber = arguments[0]; for(var i = 0;i&lt;arguments.length;i++) &#123; if (maxNumber &lt; arguments[i]) &#123; maxNumber = arguments[i]; &#125; &#125; return maxNumber;&#125;console.log(func(1, 2, 3, 45, 5, 6, 7, 8, 30, 21)); eval 简单说明eval 的基本使用eval函数用来讲字符串转换为JS的代码,并执行 eval 处理JSON数据代码示例123456&lt;script&gt; var jsonData = '&#123;\"name\":\"张三\",\"age\":18&#125;'; //把json的数据转换为对象 var obj = JSON.parse(jsonData); console.log(obj);&lt;/script&gt; 12345678910111213&lt;script&gt; var jsonData = '&#123;\"name\":\"张三\",\"age\":18&#125;'; //var obj = eval(jsonData); //注意:如果直接这样写代码则会报错 //正确的处理方式 //方式一 eval(\"var obj = \" + jsonData); console.log(obj); //方式二 //说明:使用eval来解析json格式字符串的时候,会将&#123;&#125;解析为代码块,而不是字面量 // 在使用的时候为了避免这种错误,需要在JSO的最外面加上(),如此则会把大括号当做一条语句来解析 var o = eval(\"(\"+jsonData+\")\"); console.log(o);&lt;/script&gt; eval 注意事项 ① eval函数本身功能强大,但它的特性也为程序带来了很大的不确定性,因此在开发中并不推荐使用。 ② eval函数是动态的执行代码,因此其效率不如直接执行静态脚本高。 eval和Function比较12相同点:都能够把字符串转换为Javascript的代码不同点:eval转换为js的代码之后马上就执行,而Function需要先创建函数,调用函数之后才会执行。 Function.prototype原型链关于Function和自定义构造函数的原型对象 Function.prototype 是一个空的函数 自定义构造函数的原型对象是一个空的对象 说明 Function也可以被当做是一个构造函数 通过new Function创建出来的函数,可以认为是Function的实例化对象。 Function的原型对象是一个空的函数,这个空的函数也是一个对象,它的原型对象是Object.prototype。 在JS中,Object的原型对象是所有对象的祖宗。 Function是构造函数,则其原型对象为空的函数 空的函数的原型对象为Object.prototype Function本身也是对象,则其构造函数为:function Function() { [native code] } 是自身 同Object类型 Object本身是构造函数,其原型对象是Object.prototype Object本身也是对象,其构造函数为:function Function() { [native code] 代码示例123456789101112131415//01 提供Person构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置Person的原型对象 Person.prototype.showName = function () &#123; console.log(this.name); &#125; //03 创建Student构造函数 function Student(number) &#123; this.numer = number &#125; //04 设置Student的原型对象 Student.prototype = new Person(); 完整的原型链示意图Object和Function的关系01 Object构造函数是通过Function构造函数实例化出来的02 Function构造函数也是通过Function构造函数实例化出来的 代码示例12345678&lt;script&gt; //检查对象是否是某个构造函数的实例 console.log(Function instanceof Function); console.log(Function instanceof Object); console.log(Object instanceof Object); console.log(Object instanceof Function); //注意:以上打印结果均为true&lt;/script&gt; 对象的拷贝操作浅拷贝如果对象中的属性是引用类型的值,那么存在数据共享问题,修改某个对象会对拷贝的对象产生影响代码示例123456789var o = &#123;name:\"张三\",car:&#123;number:\"2017\",type:\"火车\"&#125;&#125;;var obj = &#123;&#125;;//obj对象需要拷贝o对象中所有的属性for (var i in o )&#123; obj[i] = o[i];&#125;console.log(obj);o.car.type = \"飞船\";console.log(obj); 深拷贝 如果对象中的属性是值类型,那么就直接拷贝赋值 如果对象中的属性是引用类型,那么就再次调用拷贝方法,遍历对象 代码示例123456789101112131415161718192021222324252627 var o = &#123;name:\"张三\",car:&#123;number:\"2017\",type:\"火车\"&#125;&#125;; var obj = &#123;&#125;; function deepCopy(obj,tmp) &#123; tmp = tmp || &#123;&#125;; //如果没有传入,那么就创建一个空的对象 for(var i in obj) &#123; if (obj.hasOwnProperty(i)) //只拷贝实例属性 &#123; //判断是否是引用类型 if ((typeof obj[i]) == 'object') &#123; //重新调用拷贝方法 tmp[i] = Array.isArray(obj[i]) ? [] :&#123;&#125;; deepCopy(obj[i],tmp[i]); &#125;else &#123; //直接拷贝 tmp[i] = obj[i]; &#125; &#125; &#125; &#125;deepCopy(o,obj); console.log(obj); o.car.type = \"测试的类型\"; console.log(obj); console.log(o); 注意isArray的兼容性问题isArray是ECMA5中新推出的方法,需要处理兼容性问题123456if (Array.isArray != \"function\")&#123; Array.isArray = function (obj) &#123; return Object.prototype.toString.call(obj) == '[object Array]'; &#125;&#125; Number原型扩展小案例：在Number的原型对象上面定义一个新的方法add(),该方法接收一个参数,并将该参数与自身的值进行相加,然后进行返回。代码实现123456789Number.prototype.add = function (num) &#123; return this + num;&#125;var n = 10;console.log(n.add(3));//console.log(5.add(5)); 错误:解析器无法处理字面量的这种情况var num = new Number(50);console.log(num.add(20)); //70console.log((1).add(4)); //5 使用()把数字包起来 使用注意123（01）使用数字变量可以调用成功（02）使用数字表达式可以调用成功（03）直接使用数字字面量方式调用失败 js的语法解析器无法处理数字字面量这种情况。 With语句with语句简单介绍123with语句是js中一个强大但有争议的特性。with语句允许我们将一个对象的所有属性引用到当前的作用域允许我们无需使用拥有者对象的前缀，就可以直接对这些属性进行引用和赋值操作。 注意：ECMAScript5规范在严格模式下已经禁用了该语句，在开发中不推荐使用，但是要求能够看懂with的代码。 with语句内部细节说明： with语句会创建一个作用域，在该作用域内，在引用特定对象的属性时，可以不使用前缀。应用场景：对深层级对象的引用进行缩短。 在with作用域内部引用属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //[01] 测试with语句作用域内对对象属性的引用 //01 提供全局变量,名称为testValue var testValue = '测试使用的全局变量'; //02 提供对象,对象内部提供属性 var testObject = &#123; name:'对象的名称属性', testValue:'对象内部的属性' &#125;; //03 使用with语句引用 with(testObject) &#123; console.log(name); //对象的名称属性 console.log(testValue); //对象内部的属性 console.log(this); //window &#125; console.log(testValue); //测试使用的全局变量``` 总结：(1) 在with语句作用域内,对象属性的优先级绝对高于在更层级作用域内定义的同名变量(2) this(函数上下文)依然指向window,并不会收到with作用域的影响**在with作用域内进行赋值操作**```js //01 提供一个对象,在内部提供属性 var obj = &#123; name:'对象的内部属性', &#125; //02 with语句测试对对象属性的赋值操作 with(obj) &#123; name = '修正对象中name的值'; //在作用域内部添加变量(思考?该变量是添加为全局作用域还是当前obj对象的属性?) age = '25'; showName = function () &#123; console.log('name == ' + name); &#125;; &#125;; //测试修改对象属性操作 console.log(obj.name); //测试添加对象属性操作 console.log(obj.age); //undefined //obj.showName(); //obj.showName is not a function console.log('____________________'); console.log(this.name); //== name == window.name console.log(window.name); console.log(name); showName(); //==this.showName() ==window.showName() 总结：（1）在with作用域的内部我们可以使用无前缀引用对象的属性进行读取和赋值的操作 但是 不能使用无前缀的方式添加属性（2）如果使用无前缀的方式来添加属性[对不存在的属性进行赋值操作],那么属性将被添加到全局上下文[window|this]（3）可能产生的错误:意外的引入一个全局变量,而非为with作用域对象添加属性 with语句的问题（1）with作用域内操作优先级混乱（2）性能不好，会大大降低js代码的执行性能（3）ECMAScript5规定在严格模式下禁用with特性 with语句简化代码的替代方案使用即时调用函数来替代with语句，通过函数传参的方式使用更短的引用来替代冗长的引用前缀比使用with语句消除前缀的方式更好。123456789101112with(this.style)&#123; width = '200px'; height = '200px'; backgroundColor = '#ca3'; console.log(width); //要访问的本应该是外部的字符串变量 \"错误哈哈\",但是这里被解释为200px&#125;(function (s) &#123; s.width = '200px'; s.height = '200px'; s.backgroundColor = '#ca3';&#125;)(this.style); 使用面向过程的方式处理1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 bookList.push(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; console.log(obj); break; &#125; &#125; //修改操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; obj.author = \"泰戈尔-戈尔泰\" &#125; &#125; //删除操作 for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == \"飞鸟集\") &#123; //删除该对象 bookList.splice(i, 1); &#125; &#125; console.log(bookList);&lt;/script&gt; 使用函数来封装图书管理操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 function addBook(bookObj) &#123; bookList.push(bookObj); &#125; addBook(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 function getBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125; console.log(getBook(\"什么是批判\")); //修改操作 function updateBookData(name,authorName)&#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; obj.author = authorName; &#125; &#125; &#125; updateBookData(\"飞鸟集\",\"泰戈尔斯坦\"); //删除操作 function removeBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; //删除该对象 bookList.splice(i, 1); &#125; &#125; &#125; console.log(bookList);&lt;/script&gt; 数封装-复用形式12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; var bookList = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ]; //增加操作 function addBook(bookObj) &#123; bookList.push(bookObj); &#125; addBook(&#123;name:\"城堡\",author:\"卡夫卡\"&#125;); //查询操作 function getBook(name) &#123; for (var i = 0; i &lt; bookList.length; i++) &#123; var obj = bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125; console.log(getBook(\"什么是批判\")); //修改操作 function updateBookData(name,authorName)&#123; var obj = getBook(name); obj.author = authorName; &#125; updateBookData(\"飞鸟集\",\"泰戈尔斯坦\"); //删除操作 function removeBook(name) &#123; var obj = getBook(name); var index = bookList.indexOf(obj); bookList.splice(index,1); &#125; addBook(&#123;name:\"东京人\",author:\"川端康成\"&#125;); console.log(bookList);&lt;/script&gt; 面向对象的方式管理图书123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;scrip&gt; var obj = [ &#123;name:\"什么是批判\",author:\"福柯\"&#125;, &#123;name:\"飞鸟集\",author:\"泰戈尔\"&#125; ];泰 function BookManager() &#123; this.bookList = null; &#125; BookManager.prototype = &#123; constructor:BookManager, init:function (arr) &#123; this.bookList = arr || []; &#125;, addBook:function (bookObj) &#123; this.bookList.push(bookObj) &#125;, getBook:function (name) &#123; for (var i = 0; i &lt; this.bookList.length; i++) &#123; var obj = this.bookList[i]; if (obj.name == name) &#123; return obj; &#125; &#125; return null; &#125;, updateBookData:function (name,authorName)&#123; var obj = this.getBook(name); obj.author = authorName; &#125;, removeBook:function (name) &#123; var obj = this.getBook(name); var index = this.bookList.indexOf(obj); this.bookList.splice(index,1); &#125; &#125;; //01 创建对象 var YYManager = new BookManager(); YYManager.init(obj); console.log(YYManager.bookList); //02 演示添加操作 YYManager.addBook(&#123;name:\"花田半亩\",author:\"田维\"&#125;); console.log(YYManager.bookList); //03 演示查询操作 console.log(YYManager.getBook(\"花田半亩\")); //04 演示更新操作 YYManager.updateBookData(\"花田半亩\",\"甜田\"); console.log(YYManager.getBook(\"花田半亩\"));; //05 演示删除操作 YYManager.removeBook(\"什么是批判\"); console.log(YYManager.bookList); //02 创建第二个人的图书管理对象 var wulitaotaoMManager = new BookManager(); wulitaotaoMManager.init([&#123;name:\"装逼速成\",author:\"六扇门\"&#125;]); console.log(wulitaotaoMManager.bookList);&lt;/script&gt; 总结01 提供构造函数，在构造函数内部设置实例化属性02 把常用的操作提取成对象的实例方法，写在原型对象身上03 提供init方法，用于初始化数据04 注意：如果切断了原型对象那么需要修正内部的构造器属性指向","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.afanail.com/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.afanail.com/tags/简明教程/"}]},{"title":"JavaScript简明教程（3）","slug":"js-3","date":"2016-02-18T03:55:29.000Z","updated":"2017-07-22T03:52:44.000Z","comments":true,"path":"2016/02/18/js-3/","link":"","permalink":"http://www.afanail.com/2016/02/18/js-3/","excerpt":"关于继承，通俗说子继父业。在JavaScript中，Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。 继承相关方法在讲继承之前，我们必须先了解一些相关的方法。 hasOwnProperty和in属性操作in关键字作用：用来检查对象中是否存在某个属性(不区分实例属性和原型属性)。语法：“属性名” in 对象。代码示例:","text":"关于继承，通俗说子继父业。在JavaScript中，Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。 继承相关方法在讲继承之前，我们必须先了解一些相关的方法。 hasOwnProperty和in属性操作in关键字作用：用来检查对象中是否存在某个属性(不区分实例属性和原型属性)。语法：“属性名” in 对象。代码示例:12345678910111213141516&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125; //03 创建对象 var p1 = new Person(); //04 使用in关键字判断对象中是否存在以下属性:name age sayHello console.log(\"age\" in p1); //false console.log(\"name\" in p1); //true console.log(\"sayHello\" in p1); //true&lt;/script&gt; 对象的hasOwnProperty方法作用：用来检查对象中是否存在指定的属性(只检查实例属性)语法：对象.hasOwnProperty(“属性名”)代码示例123456789101112131415161718&lt;script&gt; //01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125; Person.prototype.des = \"默认的描述信息\"; //03 创建对象 var p1 = new Person(); //04 使用hasOwnProperty方法判断该属性是否是对象的实例属性 console.log(p1.hasOwnProperty(\"age\")); //false console.log(p1.hasOwnProperty(\"name\")); //true console.log(p1.hasOwnProperty(\"sayHello\")); //false console.log(p1.hasOwnProperty(\"des\")); //false&lt;/script&gt; 判断某对象中存在且只存在某个原型属性123function isProperty(obj, property) &#123; return !obj.hasOwnProperty(property) &amp;&amp; (property in obj); &#125; constructor构造器属性说明 使用构造函数创建对象,则 原型对象中的constructor属性指向对应的构造函数 实例对象中的constructor指向对应的构造函数,其中这里的constructor就是从原型中获取的即constructor时实例对象中的原型属性,而非实例属性 代码验证123456789101112131415//01 提供一个构造函数 function Person(name) &#123; this.name = name; &#125; //02 设置构造函数的原型对象的属性 Person.prototype.sayHello = function () &#123; console.log(\"hello\"); &#125;; Person.prototype.des = \"默认的描述信息\"; //03 创建对象 var p1 = new Person(); function isProperty(obj, property) &#123; return !obj.hasOwnProperty(property) &amp;&amp; (property in obj); &#125; console.log(isProperty(p1, \"constructor\")); //true isprotoTypeOf和instanceisprotoTypeOf作用：判断是否是某个实例对象的原型对象语法:构造函数.protoType.isPrototypeOf(对象)用法示例123456789&lt;script&gt; function Person() &#123;&#125; function Dog() &#123;&#125; Person.prototype.name = \"嘿嘿\"; var p1 = new Person(); console.log(Person.prototype.isPrototypeOf(p1));//rue console.log(Object.prototype.isPrototypeOf(p1));//true console.log(Dog.prototype.isPrototypeOf(p1));//false&lt;/script&gt; instance作用：用于检查对象是否是某个构造函数(类型)的实例语法：对象 instance 构造函数注意：所有的对象都是Object构造函数（类型）的实例用法示例12345678&lt;script&gt; var arr = [1,2,3]; console.log(arr instanceof Array); //true console.log(Array instanceof Object); //true console.log(arr instanceof Object); //true //instanceOf在判断的时候,算上整条原型链 //arr 是Array 和Object 任何一个类的示例&lt;/script&gt; 继承继承基本概念继承：即通过一定的方式实现让某个类型A获取另外一个类型B的属性或方法。其中类型A称之为子类型，类型B称之为父类型或超类型。 javaScript中的继承Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。继承有两种方式：接口继承和实现继承，在js中只支持实现继承，实现继承主要依赖原型链来完成。JavaScript中实现继承的几种方式：说明:其他语言中继承通常通过类来实现，js中没有类的概念，js中的继承是某个对象继承另外一个对象，是基于对象的。123401 原型式继承02 原型链继承03 经典继承(借用构造函数)04 组合继承 原型式继承原型链继承的方式A1234567891011121314151617&lt;script&gt; //01 提供一个构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置原型对象的属性 Person.prototype.className = \"逍遥派1班\"; //03 使用构造函数来创建原型对象 var p1 = new Person(\"张三\",10); var p2 = new Person(\"李四\",20); //04 打印p1和p2对象中的className属性 console.log(p1.className); console.log(p2.className); //结论:对象p1和p2继承了构造函数原型对象中的属性className //但是这并不是严格意义上的继承&lt;/script&gt; 原型链继承的方式B1234567891011121314151617181920&lt;script&gt; //01 提供一个构造函数 function Person(name,age) &#123; this.name = name; this.age = age; &#125; //02 设置原型对象的属性 Person.prototype = &#123; constructor:Person, className:\"逍遥派1班\" &#125;; //03 使用构造函数来创建原型对象 var p1 = new Person(\"张三\",10); var p2 = new Person(\"李四\",20); //04 打印p1和p2对象中的className属性 console.log(p1.className); console.log(p2.className); //结论:对象p1和p2继承了构造函数原型对象中的属性className //注意:使用原型替换的方式实现继承的时候,原有原型对象中的属性和方法会丢失&lt;/script&gt; 原型链继承的方式C1234567891011121314151617181920212223//01 提供超类型|父类型构造函数function SuperClass() &#123; this.name = 'SuperClass的名称'; this.showName = function () &#123; console.log(this.name); &#125;&#125;//02 设置父类型的原型属性和原型方法SuperClass.prototype.info = 'SuperClass的信息';SuperClass.prototype.showInfo = function () &#123; console.log(this.info);&#125;;//03 提供子类型function SubClass() &#123;&#125;//04 设置继承(原型对象继承)SubClass.prototype = SuperClass.prototype;SubClass.prototype.constructor = SubClass;var sub = new SubClass();console.log(sub.name); //undefinedconsole.log(sub.info); //SuperClass的信息sub.showInfo(); //SuperClass的信息sub.showName(); //sub.showName is not a function 点评：上面的方法可以可以继承超类型中的原型属性和原型方法，但是无法继承实例属性和实例方法 原型链继承实现思想：利用原型（链）让一个对象继承另一个对象的属性和方法实现本质：重写原型对象 原型链123456① 每个构造函数都有原型对象② 每个对象都有自己的构造函数③ 每个构造函数的原型都是一个对象④ 那么这个构造函数的原型对象也有自己的构造函数⑤ 那么这个构造函数的原型对象的构造函数也有自己的原型对象以上形成一个链式的结构,称之为原型链 原型链中的属性搜索原则12345当访问某个对象的成员的时候,会先在自身中查找,如果找到则直接使用如果在自身中没有找到,则去当前创建当前对象的构造函数的原型对象中查找,如果找到了则直接使用如果在该原型对象中没有找到,则继续查找原型对象的原型对象(创建该原型对象的构造函数所对应的原型对象),如果找到则直接使用如果在原型对象的原型对象中也没有找到,则继续向上搜索....直到Object的原型对象,若还是没有,则返回undefined(属性)或报错(方法)。 基本写法·代码示例1234567891011121314151617181920212223//01 提供超类型|父类型function SuperClass() &#123; this.name = 'SuperClass的名称'; this.showName = function () &#123; console.log(this.name); &#125;&#125;//02 设置父类型的原型属性和原型方法SuperClass.prototype.info = 'SuperClass的信息';SuperClass.prototype.showInfo = function () &#123; console.log(this.info);&#125;;//03 提供子类型function SubClass() &#123;&#125;//04 设置继承(原型对象继承)SubClass.prototype = new SuperClass();SubClass.prototype.constructor = SubClass;var sub = new SubClass();console.log(sub.name); //SuperClass的名称console.log(sub.info); //SuperClass的信息sub.showInfo(); //SuperClass的信息sub.showName(); //SuperClass的名称 点评：可以继承父类型中的原型属性|原型方法,以及实例属性和实例方法 注意点① 确定原型和实例的关系 instanceof + isPrototypeOf()② 注意重写原型对象的位置，必须先实现原型继承，然后再设置子对象的原型属性和原型方法③ 完成继承之后，不能使用字面量的方式来创建原型[因为会切断原型] 问题① 父对象的实例属性会转换为子类型原型的原型属性，而如果父类型是实例属性是引用类型则会存在共享问题② 在创建子类型的实例时，不能向父类型的构造函数中传递参数1234567891011121314151617//01 提供父对象的构造函数function SuperType() &#123; //02 在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈'];&#125;;//03 提供子对象的构造函数function SubType() &#123;&#125;;//04 设置原型继承SubType.prototype = new SuperType();//05 创建父对象构造函数的实例对象,并对内部的实例化属性进行修改var subDemo1 = new SubType();var subDemo2 = new SubType();alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈subDemo1.family.push('爷爷','奶奶');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶 经典继承（借用构造函数）经典继承又称为借用构造函数|伪造继承 基本思想在子类型构造函数的内部调用超类型|父类型构造函数说明：需要借助call|apply方法代码示例1234567891011121314151617181920212223242526//01 提供父类型(对象)的构造函数 function SuperType(name) &#123; //02 在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈']; //实例属性 this.name = name; &#125;; SuperType.prototype.info = '父类型的原型属性'; //03 提供子类型（对象）的构造函数 function SubType() &#123; //经典继承|借用构造函数|伪造对象继承 //SuperType.call(this); //构造参数传递参数 SuperType.call(this,'张老汉'); &#125;; //04 创建父类型的实例对象,并对内部的实例化属性进行修改 var subDemo1 = new SubType(); var subDemo2 = new SubType(); alert(subDemo1.info); //undefined alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈 alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈 subDemo1.family.push('爷爷','奶奶'); alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶 alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈 //测试构造函数传递参数 alert(subDemo1.name); 点评：能够继承父类型的实例属性,但是无法继承父类型的原型属性和原型方法 经典继承的优点① 解决实例对象共享问题，通过调用父对象的构造函数来实现每个子类型（对象）的实例对象均拥有一份父类型实例属性和方法的副本② 可以在调用call方法的时候向构造函数传递参数 经典继承的问题① 冒充继承的方法无法实现函数的重用② 无法继承父对象的原型属性和原型方法 组合继承组合继承|伪经典继承 基本思想① 使用原型链实现对原型属性和方法的继承② 通过伪造(冒充)构造函数来实现对实例属性的继承代码示例1234567891011121314151617181920212223242526272829//01 提供父类型的构造函数function SuperType(name) &#123; //在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈']; //实例属性 this.name = name;&#125;;//原型方法SuperType.prototype.showName = function () &#123; console.log(this.name);&#125;//02 提供子类型的构造函数function SubType(name) &#123; //冒充|伪造 构造参数传递参数 SuperType.call(this,name);&#125;;SubType.prototype = SuperType.prototype;//SubType.prototype = new SuperType();//02 创建父类型的实例对象,并对内部的实例化属性进行修改var subDemo1 = new SubType('张三');var subDemo2 = new SubType('张四');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈subDemo1.family.push('爷爷','奶奶');alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈//测试构造函数传递参数subDemo1.showName(); //张三subDemo2.showName(); //张四 基本包装类型基本类型：字符串 + 数值 + null + undefined + 布尔值为了便于操作基本类型，ECMAScript提供了三个特殊的引用类型：Boolean + Number + String。上述类型和其他的引用类型类似，同时也具备与各自的基本类型相应的特殊行为，每当我们读取一个基本类型的值的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。123var str = '测试字符串';console.log(str.length); //5console.log(str.substring(2)); //字符串 思考：属性和方法本是对象的特征，字符串如何能够拥有length属性以及其他类似subString等方法，内部怎么实现的？基本类型值并不是对象，因此从逻辑上讨论他们不应该有属性和方法。 内部的具体处理:123（1）创建String类型的一个实例对象（2）在实例对象上面读取指定的属性（length）,调用指定的方法（subString）（3）销毁该对象 NumberNumber是与数字值相对应的引用类型。创建Number类型的对象：var num = new Number(10); String String是字符串的对象包装类型。创建字符串类型的对象：var str = new String(‘hello World’); BooleanBoolean是与布尔值对象的引用类型。可以通过调用Boolean构造函数传递参数来创建boolean类型的对象。var bool = new Boolean(true); 基本包装类型的代码示例1234567891011121314//001 Stringvar str = '测试字符串';console.log(str.length); //5console.log(str.substring(2)); //字符串//002 Numbervar num = new Number(10);console.log(num); //Number &#123;[[PrimitiveValue]]: 10&#125;console.log(typeof num); //objectconsole.log(typeof 10); //number//003 Booleanvar bool = new Boolean(true);console.log(bool); //Boolean &#123;[[PrimitiveValue]]: true&#125;console.log(typeof bool); //objectconsole.log(typeof true); //boolean 基本包装类型的注意点[1] 对象还是基本数据类型值？对象：通过new 调用构造函数创建出来的是对象基本数据类型值：直接通过字面量方式赋值|通过省略new关键字调用构造函数方式创建的是基本数据类型值。12345ex: var str1 = new String('hello'); var str2 = 'hello'; var str3 = String('hello'); 说明：以上代码中，str1是对象，而str2和str3是字符串（基本数据类型值） [2] 相等问题基本类型值判断相等=&gt;值相等引用类型值判断相等=&gt;值相等且引用相等对象是引用类型，因此在判断相等的时候有诸多的注意点和容易出错的地方123456789101112131415161718ex var str1 = '这是一个字符串'; //基本数据类型 var str2 = String('这是一个字符串'); //基本数据类型 console.log(str1 == str2); //true 相等 var str3 = new String('这是一个字符串'); //引用类型-对象 console.log(str1 == str3); //true //值相等 console.log(str2 == str3); //true //值相等 console.log(str1 === str3); //false //值相等,但是引用不相等 console.log(str2 === str3); //false //值相等,但是引用不相等 //判断下面的变量是否相等 var num1 = 10; //基本数据类型 var num2 = new Number(10); //对象 console.log(num1 == num2); //true console.log(num1 === num2); //false var bool1 = true; var bool2 = new Boolean(true); console.log(bool1 == bool2); //true console.log(bool1 === bool2); //false","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.afanail.com/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.afanail.com/tags/简明教程/"}]},{"title":"可能是最简单的js原型继承","slug":"js原型继承","date":"2016-02-08T07:35:45.000Z","updated":"2017-07-22T03:52:27.000Z","comments":true,"path":"2016/02/08/js原型继承/","link":"","permalink":"http://www.afanail.com/2016/02/08/js原型继承/","excerpt":"JavaScript是一门奇妙的弱类型语言，原型继承与其它语言的类继承有所区别，下面通过一个简单的例子展示js的原型继承。 你有对象吗？你有对象吗？没有，赶紧就new一个吧！首先，创建构造函数Parent然后，new出一个Parent的实例对象child此时，构造函数Parent拥有以下属性aString、aNumber、anObject,构造函数Parent的原型对象有aFunction方法。","text":"JavaScript是一门奇妙的弱类型语言，原型继承与其它语言的类继承有所区别，下面通过一个简单的例子展示js的原型继承。 你有对象吗？你有对象吗？没有，赶紧就new一个吧！首先，创建构造函数Parent然后，new出一个Parent的实例对象child此时，构造函数Parent拥有以下属性aString、aNumber、anObject,构造函数Parent的原型对象有aFunction方法。12345678910function Parent() &#123; this.aString = 'string'; this.aNumber = 'number'; this.anObject = 'object'&#125;Parent.prototype = &#123; constructor: Parent, aFunction: function()&#123; alert('i am function'); &#125; 然后，new出一个Parent的实例对象child1var child = new Parent(); 简单的原型继承图如下： #~~~~# 实现继承实例对象默认拥有构造函数本身的属性和方法。但是，要知道构造函数荷构造函数的原型对象是俩个不同的函数（对象），原型对象拥有的属性和方法可以被实例化对象所共享。也就是说实例对象child此时拥有属性aString、aNumber、anObject，this指向实例对象。child本身并没有aFunction方法。但是你调用此方法时，却发现能调用，这是怎么回事呢？1child.aFunction(); 这就是我们所说的原型对象原拥有的属性和方法可以被实例化对象所共享的原因。通过简单的例子，希望能帮到你，如果想深入学习javascript，请深戳MDZ开发者","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.afanail.com/tags/javascript/"},{"name":"原型继承机制","slug":"原型继承机制","permalink":"http://www.afanail.com/tags/原型继承机制/"}]},{"title":"JavaScript简明教程（2）","slug":"js-02","date":"2016-02-01T05:15:15.000Z","updated":"2017-07-22T03:52:48.000Z","comments":true,"path":"2016/02/01/js-02/","link":"","permalink":"http://www.afanail.com/2016/02/01/js-02/","excerpt":"面向对象方法被人谈论了二十多年了，直到今天，我们还一直在谈对象。 面向对象编程面向层过程和面向对象编程01 面向对象编程和面向过程编程是一种编程思想,和具体的语言关系不大。02 面向过程编程和面向对象编程的主要区别","text":"面向对象方法被人谈论了二十多年了，直到今天，我们还一直在谈对象。 面向对象编程面向层过程和面向对象编程01 面向对象编程和面向过程编程是一种编程思想,和具体的语言关系不大。02 面向过程编程和面向对象编程的主要区别1234567891011121314151617181920面向过程编程: 关注点在于解决问题需要的每一个详细的步骤 示例: 自己洗衣服的过程 ① 收集需要洗的脏衣服 ② 准备洗衣粉、洗衣液等 ③ 把衣服放到一个盆里 ④ 接水 ⑤ 把洗衣粉放到盆里 ⑥ 摩擦,摩擦,不断的摩擦 ⑦ 把洗好的衣服用清水冲洗干净 ⑧ 尽量把把洗好的衣服的水分拧干 ⑨ 晾晒 面向对象编程: 关注点在于解决问题需要的对象身上 示例: 使用洗衣机洗衣服的过程 ① 收集需要洗的脏衣服 ② 找到合适的洗衣机 ③ 设定洗衣服和烘干的程序 03 面向过程和面向对象他们的区别就类似于自己洗衣服和使用洗衣机洗衣服|自己做饭吃和去餐馆吃饭 面向对象编程的相关概念01 对象 什么是对象? 所有的一切都是对象,在开发中有一项重要的工作就是对象的划分。一般来说,我们所指的对象是某个具体的事物,而非泛泛的类别。02 对象的特征(静态描述信息) 所谓特征就是一些特定的描述信息 如:学生(性别、年龄、班级、专业、籍贯、家庭住址) 如:汽车(颜色、车牌、品牌、价格等)03 对象的行为(动态特性) 如:人(吃饭、睡觉、玩游戏、奔跑、运动等) 如:狗(吃、睡、咬人、叫、流口水)04 js中的对象 键-值对(key-value)的集合。05 现实生活中的对象和js对象的对应关系 静态的描述信息 - js对象中的属性(属性就是定义在对象内部的变量) 动态的行为特征 - js对象中的方法(方法就是定义在对象内部的函数)06 代码示例：12345678910111213141516171819202122232425 var zhangsan = &#123; name:\"张三\", sex:\"男\", age:18, address:\"天上人间1号公馆\", eat:function () &#123; console.log('能吃'); &#125;, sleep:function () &#123; console.log(\"能睡\"); &#125;, say:function () &#123; console.log(\"能说话\"); &#125;, run:function () &#123; console.log(\"能运动\"); &#125;, song:function () &#123; console.log(\"能唱歌\"); &#125; &#125;; //打印对象的属性并调用相关的方法console.log(zhangsan.name,zhangsan.age,zhangsan.address); zhangsan.say(); zhangsan.sleep(); 面向对象的三大特性面向对象的三大特性:封装、继承、多态01 封装:复用|信息隐蔽代码示例123456789101112131415161718192021//01 封装的简单说明//001 观察以下杂乱无关的语句,它们仅仅只是一堆无意义的全局变量var name = \"乘风波浪会有时\";var actors = [\"彭于晏\",\"邓超\"];var showTime = \"2016-1-28 - 2016-2-28\";var director = \"韩寒\";var type = \"喜剧\";var play = function () &#123; //播放......&#125;;//002 把上面的变量封装到对象中(更具有意义)var film = &#123; name:\"乘风破浪会有时\", actors:[\"彭于晏\",\"邓超\"], showTime:\"2016-1-28 - 2016-2-28\", director:\"韩寒\", type:\"喜剧\", play:function () &#123; //播放...... &#125;&#125; 02 继承:获取已经存在的对象已有属性和方法的一种方式(获取他人已有财富和资源的一种方式)。代码示例123456789101112131415//继承的简单示例//001 创建一个空的对象var nullObj = &#123;&#125;;// 上面的对象film拥有了很多的属性和方法//002 设法让nullObj拥有film中所有的属性和方法//方法一:自己重新写一遍//方法二:通过某种方式来获得,比如遍历该对象,然后完成赋值for(var k in film)&#123; nullObj[k] = film[k];&#125;for(var k in nullObj)&#123; console.log(nullObj[k]);&#125; 03 多态(polymorphism) 多态:polymorphism = poly(复数) + morph(形态) + ism 多用于强类型语言中，JavaScript具备与生俱来的多态特性。 多态表现为: ① 同一操作,作用于不同的对象,会产生不同的解释和行为。 ② 隐藏不同。 创建对象的方法字面量方式创建对象基本写法123456789var book1 = &#123; name:\"声名狼藉者的生活\", price:42.00, author:\"福柯\", press:\"北京大学出版社\", read:function () &#123; console.log(\"我的书名为:声名狼藉者的的生活,作者为福柯....\"); &#125; &#125;; 存在的问题[01] 代码复用性差[02] 如果要创建大量的同类型对象，则需要些大量重复性代码 内置构造函数创建对象JS中的内置构造函数123456789StringNumberBoolean 注意：(区别于string number boolean)DateArrayFunctionObjectRegExp 基本写法12345678var book1 = new Object();book1.name = \"声名狼藉者的生活\";book1.price = 42.00;book1.author = \"福柯\";book1.press = \"北京大学出版社\";book1.read = function () &#123; console.log(\"我的书名为:声名狼藉者的的生活,作者为福柯....\");&#125;; 问题01 创建的对象无法复用,复用性差02 如果需要创建多个同类型的对象,如(书籍)则需要写大量重复的代码,代码的冗余度高 工厂函数创建对象基本写法12345678910111213141516171819202122function createBookNew (name,price,author,press) &#123; var book = new Object(); book.name = name; book.price = price; book.author = author; book.press = press; book.read = function () &#123; console.log(\"我的书名为:\"+book.name+\",作者为\"+book.author+\"....\"); &#125;; return book;&#125;//使用工厂函数来创建对象var book1 = createBookNew(\"声名狼藉者的的生活\",\"42.00\",\"福柯\",\"北京大学出版社\");var book2 = createBookNew(\"人性的枷锁\",\"49.00\",\"毛姆\",\"华东师范大学出版社\");var book3 = createBookNew(\"悟空传\",\"28.00\",\"今何在\",\"湖南文艺出版社\");//打印对象的属性,调用对象的方法console.log(book1.name);console.log(book2.name);console.log(book3.name);book1.read();book2.read();book3.read(); 工厂函数说明:001 工厂函数方式创建对象其本质是对内置构造函数创建对象的过程进行了封装002 适用于大规模“批量生产”同类型的对象1234567891011121314function createBook (name,price,author,press) &#123; //001 参数 = 原料 var book = new Object(); //002 创建对象并设置对象的属性和方法 = 对原料进行加工 book.name = name; book.price = price; book.author = author; book.press = press; book.read = function () &#123; console.log(\"我的书名为:\"+book.name+\",作者为\"+book.author+\"....\"); &#125;; //003 把处理好的对象返回给我们 == 产品出厂 return book;&#125; 封装思路:使用函数把固定不变的部分封装起来，变化的部分提取为函数的参数。工厂函数创建对象的实现过程:① 提供一个创建对象的函数（参数）② 在该函数内部使用new 关键字和Object构造器创建对象③ 设置对象的属性④ 设置对象的方法⑤ 返回对象 自定义构造函数创建对象基本写法123456789101112131415function 构造函数名(参数1,参数2,参数3...) &#123; //设置对象的属性 this.属性01 = 参数1; this.属性02 = 参数2; //设置对象的方法 this.方法01 = function () &#123; //..... &#125;; this.方法02 = function () &#123; //..... &#125;&#125;//自定义构造函数方式创建对象var 对象01 = new 构造函数名(实参01,实参02,实参03...);var 对象02 = new 构造函数名(实参01,实参02,实参03...); 代码示例12345678910111213141516171819function CreateBook (name,price,author,press) &#123; this.name = name; this.price = price; this.author = author; this.press = press; this.read = function () &#123; console.log(\"我的书名为:\"+this.name+\",作者为\"+this.author+\"....\"); &#125;;&#125;var b1 = new CreateBook(\"声名狼藉者的的生活\",\"42.00\",\"福柯\",\"北京大学出版社\");var b2 = new CreateBook(\"人性的枷锁\",\"49.00\",\"毛姆\",\"华东师范大学出版社\");var b3 = new CreateBook(\"悟空传\",\"28.00\",\"今何在\",\"湖南文艺出版社\");//打印对象的属性,并调用对象的方法测试console.log(b1.author);console.log(b2.author);console.log(b3.author);b1.read();b2.read();b3.read(); 构造函数与new关键字:new关键字的作用：用于创建对象（Object类型）。构造函数和普通函数的区别：函数的首字母大写。构造函数的作用:用于完成对象的初始化。 自定义构造函数和简单工厂函数的对比：1234① 函数的首字母大写(用于区别构造函数和普通函数)② 创建对象的过程是由new关键字实现③ 在构造函数内部会自动的创建新对象,并赋值给this指针④ 自动返回创建出来的对象 构造函数的执行过程① 使用new关键字创建对象② 把新创建出来的对象赋值给this③ 在构造函数内部,使用this为新创建出来的对象设置属性和方法④ 默认返回新创建的对象(普通函数如果不显示的return则默认返回undefined)。 构造函数的返回值01 如果在构造函数中没有显示的return,则默认返回的是新创建出来的对象02 如果在构造函数中显示的return,则依照具体的情况处理 [01] return 的是对象,则直接返回该对象,取而代之本该默认返回的新对象 [02] return 的是null或基本数据类型值,则返回新创建的对象 构造函数方式创建对象存在的问题每次创建对象,都会重新创建函数，那么如果创建的对象数量很多,而对象方法内部的实现一模一样,则造成了资源浪费。 构造函数的使用注意函数传值：可以把构造函数的对象方法抽取为参数。代码示例：1234567891011121314151617//001 创建一个构造函数function Person(name,age,toDoSomeThing) &#123; //002 在构造函数内部设置对象的属性和方法 this.name = name; this.age = age; this.sayName = function () &#123; console.log(this.name); &#125;; this.toDoSomeThing = toDoSomeThing;&#125;//003 使用构造函数创建对象var zhangsan = new Person(\"张三\",18,function () &#123; console.log(\"张三在读书\");&#125;);var lisi = new Person(\"李四\",20,function () &#123; console.log(\"李四在玩耍\");&#125;); 对象类型:01 检查对象的类型：instanceOf02 获取对象的类型：Object.prototype.toString.call(dog) 对象的构造器属性12345function Dog(name) &#123; this.name = name; this.color = \"黄色\"; &#125;console.log(dog.constructor); 属性的名称：constructor属性的作用：指向创建该对象的构造函数，类似于现实生活中所有的产品都标有生产厂家一样。 构造函数的调用01 构造函数可以像普通函数一样不通过new关键字直接调用02 在使用构造函数创建对象的时候，如果没有传递参数，则（）可以省略代码示例:1234567891011//01 创建构造函数function Person() &#123; this.name = \"张三\"; this.age = 20; this.sayName = function () &#123; console.log(this.name); &#125;&#125;//02 使用构造函数创建对象var p1 = new Person();var p2 = new Person; //说明:如果不需要传递参数,则在调用构造函数的时候()可以省略 this指向01 如果使用new 构造函数的方式调用，则this指向内部默认创建出来的空对象02 如果像调用普通函数一样调用构造函数，则this指向全局对象window(不要这样使用) 原型对象原型对象概念 在构造函数创建出来的时候,系统会默认帮构造函数创建并关联的一个新对象 自定义构造函数的原型对象默认是一个空对象。 原型对象的作用 构造函数中的原型对象中的属性和方法可以被使用该构造函数创建出来的对象使用。 即以自定义构造函数方式创建出来的所有对象,自动拥有和共享该构造函数的原型对象中的所有属性和方法。 如何访问构造函数的原型对象① 构造函数.protoType② 对象.__proto__（不推荐） 设置原型对象的属性和方法① 利用对象的动态特性来为构造函数的原型对象添加属性和方法② 替换原型对象 实例和实例化：实例化:通过构造函数创建具体对象的过程。实例:通过构造函数实例化出来的对象,我们称之为该构造函数的一个实例。注意:在说实例的时候,一定要指定是某个具体构造函数的实例。 原型的使用方法① 利用对象的动态特性给原型添加属性|方法，如果要添加的方法过多,则有大量重复代码。② 直接替换原型对象：01 替换前后创建的对象所指向的原型对象不一致02 替换原型对象会切断和之前的原型对象之间的关系 原型对象的使用注意1234567① 访问属性:构造函数创建出来的对象在访问属性的时候,会先在实例内查找,如果没有找到则进一步到对应的原型对象中查找。② 设置属性:在使用点语法进行赋值的时候,无法操作到对应的原型对象,如果该属性在对象中已经存在，则修改该属性的值。如果该属性在对象中尚未存在,则新增该属性。③ 设置原型对象的属性:[01] 设置原型对象的属性,只能通过构造函数.Prototype的方式替换原型对象的方式设置。[02] 如果原型对象的属性是值类型，那么只能通过Person.prototype.属性的方式修改其值。如果原型对象的属性是引用类型,那么可以通过对象名.引用对象.属性名的方式设置修改： (001) 使用构造函数创建出来的多个对象的原型对象中的该属性指向的是同一块数据。 (002) 某个对象对该原型对象属性进行了修改会影响到其他的对象。 __proto__属性说明：__proto__是一个非标准属性,即ECMAScript中并不包含该属性,这只是某些浏览器为了方便开发人员开发和调试而提供的一个属性,不具备通用性。建议:在调试的时候可以使用该属性,但不能出现在正式的代码中。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.afanail.com/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.afanail.com/tags/简明教程/"}]},{"title":"JavaScript简明教程（1）","slug":"01","date":"2016-01-15T08:36:35.000Z","updated":"2017-07-22T03:54:59.000Z","comments":true,"path":"2016/01/15/01/","link":"","permalink":"http://www.afanail.com/2016/01/15/01/","excerpt":"JavaScript与Java没有半毛钱关系，网景公司员工Brendan Eich用了10天时间设计了JavaScript语言。 JavaScript的范围JavaScript的范围：BOM + DOM + ECMAScript BOM简单说明123456BOM即Browser Object Mode,浏览器对象模型。BOM提供了独立于内容而与浏览器窗口进行交互的对象。BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。因为BOM主要用于管理窗口与窗口之间的通信，因此其核心对象是window。BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C。BOM结构体系","text":"JavaScript与Java没有半毛钱关系，网景公司员工Brendan Eich用了10天时间设计了JavaScript语言。 JavaScript的范围JavaScript的范围：BOM + DOM + ECMAScript BOM简单说明123456BOM即Browser Object Mode,浏览器对象模型。BOM提供了独立于内容而与浏览器窗口进行交互的对象。BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。因为BOM主要用于管理窗口与窗口之间的通信，因此其核心对象是window。BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C。BOM结构体系 DOM简单说明12345DOM即Document Object Model，文档对象模型。当网页被加载时，浏览器会创建页面的文档对象模型，即DOM。DOM(文档对象模型)被构造为对象的树。DOM由一系列相关的对象构成，引申为Document对象。DOM的标准化组织是W3C。 ECMAScript简单说明123456789ECMAScript指代JavaScript的核心语法。JavaScript 由 Brendan Eich 发明。JavaScript于1995 年出现在 Netscape 中于 1997 年被 ECMA（一个标准协会）采纳。语法核心：变量基本数据类型对象类型结构(循环|条件|判断)面向对象 javascript语法javascript数据类型基本类型（简单数据类型） * string * number * boolean * undefined * null 复杂类型（复杂数据类型） * Object * Array * Date * RegExp * Function * String * Number * Boolean * null * Math javascript部分操作符的说明一元操作符只能够操作一个值的操作符叫做一元操作符。① 递增和递减操作符:12345678910[01] 前置型,递增和递减操作在包含他们的语句被求值之前就执行。[02] 后置型,递增和递减操作在包含他们的语句被求值之后才执行。var num1 = 2;var num2 = 20;var num3 = --num1 + num2; //21var num4 = num1 + num2; //21var num1 = 2;var num2 = 20;var num3 = num1-- + num2; //22var num4 = num1 + num2; //21 ② 一元加和减操作符:一元加操作符对结果不会有任何的影响。一元减操作符主要用于表示负数。 位操作符01 按位非(NOT):使用 ~ 表示，执行按位非的结果就是返回数值的反码。操作数的负值减去1。123var num1 = 25;var num2 = -num1 - 1; //-26consol.log(~num1) //-26 02 按位与(AND):使用&amp;表示，操作两个操作数。只要有0就为0。03 按位或(OR):使用|表示，操作两个操作数。只要有1就为1。04 按位异或(XOR):使用 ^ 表示，操作两个操作数。相同则为0，不同则为1。05 左移|右移(|有符号|无符号)。 布尔操作符 布尔操作符一共有三个，分别是：非、与、或。 01 逻辑非，符号：！ 说明：取反，可应用于任何值，！！相当于没有操作。02 逻辑与，符号：&amp;&amp; 说明：两个值都为真的时候，结果为真。属于短路操作，如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。03 逻辑或，符号：||说明：两个值只要有一个为真，那么结果为真。属于短路操作，如果第一个操作数为真，那么就不会再对第二个操作数求值了。技巧：可以利用逻辑或短路操作的特点来避免为变量赋null或undefined值。123var myObject = refObject || backupObject;//如果refObject的值不是null,那么它的值将被赋值给myObject//如果是null,那么就将backupObject的值赋值给myObject。 乘性操作符乘 *除 /模 % 加性操作符加 +减 - 说明：上述五种操作符在操作数为非数值的时候内部会执行自动的类型转换。 关系操作符大于 &gt;小于 &lt;小于等于 &lt;=大于等于 &gt;=说明：返回布尔类型的值，要么为false，要么为true。 相等操作符01 相等和不相等[先转换再比较]，符号是 == 和！=比较的规则:[01] 如果操作数中有布尔值，则先转换为数值再比较。[02] 如果是字符串和数值比较，则先将字符串转换为数值再比较。[03] 如果是对象和其他类型的值比较，则先调用对象的valueOf方法，然后用得到的基本类型值去比较。[04] null和undefined是相等的。[05] NaN和NaN不相等。[06] 如果两个操作符都是对象，则比较他们是不是同一个对象，如果指向的是同一个对象则返回true，否则返回false。02 全等和不全等[仅比较不转换],符号是===和!==比较的规则:[01] null和undefined是不全等的，因为它们是不同类型的值。[02] 类型相同，且值相等，则返回true，否则返回false。 条件操作符符号：表达式1 ? 字面量1 ：字面量2说明：如果表达式1的结果为true，则使用字面量1，否则使用字面量2。 赋值操作符符号：=、+=、-=、*=、&lt;&lt;=等等说明：使用赋值操作符对性能而言，没有任何的提升，只是简化了赋值操作而已。 值类型和引用类型01 值类型和引用类型简单说明值类型主要有：12345数值字符串布尔类型undefinednull 引用类型主要有：123对象（Object类型）数组（Array）函数 (Function) 值类型：保存为简单的数据值，赋值只是简单的数据值的复制引用类型:保存为对象，其本质是指向内存位置的引用(地址)，赋值是对地址的复制值类型代码示例1234567var num1 = 10;var num2 = num1; //把num1的值复制一份给num2,num1和num2的值相等,除此之外没有任何其他关系console.log(num1,num2); //10,10console.log(num1 == num2); //truenum2 = 20; //修改num2的值为20,不会对num1产生任何的影响console.log(num1,num2); //10,20console.log(num1 == num2); //false 引用类型代码示例12345678910111213var arr1 = [1,2,3];var arr2 = arr1;console.log(arr1,arr2); //[1,2,3],[1,2,3]console.log(arr1 == arr2); //truevar arr3 = [1,2,3];console.log(arr3); //[1,2,3]console.log(arr1 == arr3,arr2 == arr3); //false,false/** * 代码说明: * arr1和arr2在比较的时候,值相等(都是[1,2,3]),且引用相等(都指向堆中同一块数据),因此arr1和arr2相等 * arr3和arr1以及arr2比较的时候,值相等([1,2,3]),但是引用不相等(arr3指向的是堆中另外一块数据),因此不等 * 总结:引用类型在比较相等的时候,只有值和引用都相等才相等 * */ 02 值类型和引用类型的赋值赋值操作(=):把当前变量存储的值复制一份给接收的变量。值类型的赋值:把当前变量存储的值(具体的数据)复制一份给接收的变量。引用类型的赋值:把当前变量存储的值(具体数据的引用即地址)复制一份给接收的变量。12345678//引用类型使用注意 console.log(arr1,arr2); //[1,2,3],[1,2,3]; console.log(arr1 == arr2); //true arr1.push(4); console.log(arr1,arr2); //[1,2,3,4],[1,2,3,4] /** * 代码说明:因为arr1和arr2内部的引用指向的是同一块数据,所以修改了arr1会对arr2也产生影响 * */ 03 值类型和引用类型作为函数参数处理形参:占位用的参数,用来接收数据的参数而已。实参:实际传递的参数。函数的调用:在函数调用的时候,函数默认会把实参的值赋值给形参。值类型作为参数：在函数内部对形参变量进行修改不会影响到实参的值。引用类型作为参数：在函数内部对形参变量进行修改会影响到实参的值，因为他们的引用指向同一个对象。04 值类型和引用类型的相关图示基本类型的赋值12var str1 = \"hello zhangsan\";var str2 = str1; 引用类型的结构和赋值123456789var car = &#123; color:\"黑色\", number:\"B99\"&#125;;var p1 = &#123; name:\"王宝宝\", age:30, car:car&#125;; 12345var obj1 = &#123; name:\"lisi\", age:18 &#125;; var obj2 = obj1; 对象的动态特性在js中可以动态的对对象属性进行增加、修改和删除；代码示例12345678910111213141516171819//01 创建对象var obj = &#123; name:\"刘德华\", age:60&#125;;//02 动态的为对象添加属性obj.height = \"180cm\";console.log(obj.height);//03 动态的为对象添加方法obj.maiMeng = function () &#123; console.log(\"华仔会卖萌噢\");&#125;;obj.maiMeng();//04 修改属性的值:如果设置的属性以前不存在,那么就是添加,如果设置的属性已经存在了,那么就是修改obj.name = \"王宝强\";console.log(obj.name)//05 删除属性delete obj.name;console.log(obj.name); //undefined 访问对象的方法01 可以使用点语法访问02 可以使用[]语法访问，注意对象的属性必须是字符串 关键字in和delete的使用01 in关键字01 判断属性是否存在于对象中，注意所有的key都是字符串02 for in循环中 遍历对象的 键代码示例12345678910var obj = &#123; name:\"张三\", age:18&#125;;for(k in obj)&#123; console.log(k,obj[k]);&#125;//检测obj对象中是否存在name这个属性console.log(\"name\" in obj); 注意：in关键字操作数组的时候检测的是索引值并非数组元素02 delete关键字01 删除对象的属性02 删除未使用var声明的变量03 返回值为boolean类型，true则表示是否删除成功注意1201 删除的属性如果不存在，返回true02 删除的如果是原型中的属性，返回true 但是删除不成功 循环和分支循环结构1234forwhiledo...whilefor..in 分支结构12if...else..swith..case break和continue对比break:终止循环，循环中后面的代码不再执行continue:结束当前循环，循环后面的代码不再执行，继续下一次循环 调试工具的使用开启调试窗口 windows 平台: f12; Mac: option+command+i;调试窗口介绍 指针: 选择页面中的元素 手机: 使用移动端界面调试 Elements: 查看页面 DOM 树 Console: 控制台(注意, 控制台与该页面是一个整体, 在控制台中的任何操作, 会影响到页面) Source: 代码调试调试工具的使用 逐过程运行, 一次运行一个函数 单步运行(逐步运行), 一次运行一句, 如果是函数, 进入函数体内运行 继续运行. 从当前状态运行下去, 直到出现断点, 如果没有断点则运行结束设置断点技巧 逐步与逐过程混合 断点加继续运行 条件断点(右键添加 add contitional breakpoint)利用 watch 监视窗口可以查看对象成员 异常处理常见的异常分类运行环境的多样性导致的异常（浏览器）语法错误，代码错误异常的特征:一旦代码出现异常，后面的代码就不会再执行异常捕获使用try-catch语句捕获异常123456try&#123; //这里写可能出现异常的代码&#125;catch(e)&#123; //这里的e就是捕获的异常对象 //可以在这里写，出现异常后的处理代码&#125; 异常捕获语句执行的过程为：01 代码正常运行, 如果在try中出现了错误, try 里面出现错误的语句后面的代码都不再执行, 直接跳转到 catch 中02 在catch中处理错误信息03 继续执行后面的代码04 如果 try 中没有出现错误, 那么不走 catch 直接执行后面的代码捕获异常的优点：通过try-catch语句进行异常捕获之后，代码将会继续执行，而不会中断。注意：语法错误异常用try-catch语句无法捕获，因为在预解析阶段，语法错误会直接检测出来，而不会等到运行的时候才报错。try..catch使用示例1234567891011121314151617//01 try ... catch结构的使用//a(); 若直接调用则爆出:Uncaught ReferenceError: a is not defined错误//在开发中,我们对于可能会报错或者是发生异常的代码用try结构进行处理try&#123; a(); //如果发生异常,那么至少不会到正程序中断&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest();//结论:使用try...catch结构,如果发生了异常,那么不会影响后面代码的执行,且我们可以在发生异常信息之后做出具体的处理 手动抛出异常案例：自己写的一个函数，需要一个参数，如果用户不传参数，此时想直接给用户抛出异常，就需要了解如何抛出异常。抛出异常使用throw关键字，语法如下：手动抛出异常信息（字符串）:123456789101112131415try&#123; //a(); //如果发生异常,那么至少不会到正程序中断 //不使用系统默认的异常信息,尝试手动抛出 throw \"对不起,您调用了尚未定义的方法\";&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest(); 手动抛出异常信息（对象）:1234567891011121314151617181920212223try&#123; //a(); //如果发生异常,那么至少不会到正程序中断 //不使用系统默认的异常信息,尝试手动抛出 throw &#123; errMsg:\"具体的错误信息提示\", errCode:\"指定错误类型的代号,如1001等\" &#125;;&#125;catch(e)&#123; //如果try语句中发生了异常,那么会执行此处的代码块 //参数e.为具体的异常信息,可以打印进行查看 console.log(e); //在try语句中抛出的错误信息是什么,那么得到的异常信息就是什么 //如果抛出的是字符串,那么得到的就是字符串 //如果抛出的是对象,那么此处得到的就是对象 console.log(e.errMsg); console.log(e.errCode);&#125;function functionTest() &#123; console.log(\"functionTest\");&#125;;functionTest(); 异常捕获语句的完整模式异常捕获语句的完整模式为try-catch-finally123456789101112131415try&#123; //在执行的时候可能发生异常的代码 b();&#125;catch (e)&#123; //如果try代码块中的代码在执行中发生了异常,那么就会执行该代码块的代码 //通过打印e对象可以查看具体的异常信息 console.log(e); //打印异常信息&#125;finally &#123; //不论try语句中的代码是否会发生异常,都一定会执行此处的代码块 //一般在前端开发中很少使用,常用语后台开发的资源释放工作 console.log(\"无论如何总要执行的代码\");&#125; finally中的代码，不管是否发生异常，都会执行。一般用在后端语言中，用来释放资源，JavaScript中很少会用到。 DOM操作获取元素操作123getElementByIdgetElementsByTagNamegetElementsByClassName 元素节点操作1234567appendChildinsertBeforeremoveChildreplaceChildcloneNodecreateElementcreateTextNode（创建文本节点） 属性节点操作123getAttributesetAttributeremoveAttribute 常用DOM属性1234classNameinnerHTMLinnerText/textContent valuechildren 代码示例12345678910111213141516//0 获取页面中指定的标签,并设置其样式 var divID = document.getElementById(\"divId\"); divID.style.backgroundColor = \"pink\"; divID.style.height = \"40px\"; divID.style.width = \"200px\"; //01 创建新的标签 var div = document.createElement(\"div\"); //02 设置标签的样式 div.style.backgroundColor = \"red\"; div.style.height = \"100px\"; div.style.width = \"300px\"; div.style.fontSize = \"20\"; //03 设置标签的内容 div.innerText = \"这是一个自己创建的标签\"; //04 把标签插入到页面中 document.body.appendChild(div);","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.afanail.com/tags/JavaScript/"},{"name":"简明教程","slug":"简明教程","permalink":"http://www.afanail.com/tags/简明教程/"}]},{"title":"12年逗比如我","slug":"12年怀旧","date":"2016-01-08T13:27:45.000Z","updated":"2017-07-22T03:54:56.000Z","comments":true,"path":"2016/01/08/12年怀旧/","link":"","permalink":"http://www.afanail.com/2016/01/08/12年怀旧/","excerpt":"12年写的乱七八遭，拿出来怀旧，权当笑话，笑笑更开心！ 一周大一秀欢迎收听一周大一秀，观众朋友们大家好。好学生就是我，我就是曾大贤。欢迎收听本节目，请大家用热烈的掌声欢迎我们今天的主角出场。他就是人见人爱，花见花开，俗称一朵海棠压梨花的帅哥。没错，你猜对了，好学生就是我，我就是曾大贤。接下来请大家千万把耳屎勾干净了，洗耳恭听嘛，哈哈。","text":"12年写的乱七八遭，拿出来怀旧，权当笑话，笑笑更开心！ 一周大一秀欢迎收听一周大一秀，观众朋友们大家好。好学生就是我，我就是曾大贤。欢迎收听本节目，请大家用热烈的掌声欢迎我们今天的主角出场。他就是人见人爱，花见花开，俗称一朵海棠压梨花的帅哥。没错，你猜对了，好学生就是我，我就是曾大贤。接下来请大家千万把耳屎勾干净了，洗耳恭听嘛，哈哈。大学就是围墙啊，在外面的人都想跳进来，在里面的人都想跳出去。曾哥我真的是深深的有感触啊！此事从五百年前说起，曾哥在一个夜黑风高的晚上，血腥的风放肆嘲笑满街的横尸遍野。曾哥右持AK_47，左携一篮子地雷，嘴叼雪茄【此音乐响起上海滩】，在千军万马中杀了出来。就这样，千军万马来相见，曾哥突破了大学这道围墙，杀进了大学【此时音乐响起天空之城】。进了大学这道墙，曾哥欣喜若狂，因为按照传说，就可以不费吹灰之力拥有一切，以后开宝马，住洋房，娶洋妞都不用愁了。以为到了世外桃源，曾哥很高兴地把AK_47丢进了河里，把一篮子地雷也扔了进去【此时音乐响起乌鸦的惨叫声】，只留下嘴刁着的那根雪茄，用来扮酷讨女孩子欢心。 故事到这里，相信大家都能猜到后果了，很遗憾广告时间到了，请大家不要走开，广告之后更精彩【好敌真好，广州好敌】。欢迎大家继续收听一周大一秀，好学生就是我，我就是曾大贤。曾大贤接下来何去何从，精彩不容错过。曾大贤被传说给传说了，接下来的日子里，他就只能做这些事了，哎【MUSIC阿里路亚】 摸黑起床，叫兽整队，准备抗战。有的时候还没来得及刷牙洗脸，就匆匆忙忙赶去与英语口语决一死战。战罢方休，一个馒头一个大饼是战利品。军纪如律令，又赶忙去找营地，生怕触犯律令，有时不得不一边啃着个窝窝头一边找赶上军队去扎营。糊糊涂涂的坐在营里，听叫兽讲那些讲那些似懂非懂的军事理论知识，时间很快到了中午。战友总在催，不走快点，就要吃剩饭，呜呜，排队打饭订餐，弄得曾哥连吃饭的心情都没有了。好不容易吃完了午饭，曾哥本想舒舒服服睡上一觉，怎知社团活动来风急。曾哥可怜的午休时间那，就这么被无情的摧残了。 俗话说，中午不睡，下午崩溃。果不其然，曾哥整个下午都崩溃掉了【音乐伤不起啊伤不起】。顶着乏意，毫无生机。曾哥恹恹欲睡，却又不敢入睡。闭着眼睛也能跟着叫兽打军体拳，曾哥实在是太强大了！ 时间一晃而过，本来打算美美的洗个澡的，可是时间急迫啊。七点就要站岗放哨，又是军纪如律令，所以洗澡这事给挂了。一来省些水资源，二来嘛省钱，你懂的，哈哈。终于曾哥下岗了，夜生活真正开始了。手机上网畅无线，莺歌电影嗨翻天十一二点不算晚，就看你的肾好不好，额滴肾啊，哈哈。 大学生活就是沙场点兵，而曾哥却总还能打怪兽。一部手机可以有几多个怪兽，曾哥说菲尔普斯专用山寨机，就是牛。曾哥追师姐也真是牛，来一个杀一个，来两个杀一双。可是你懂的，曾哥最终还是情伤了【音乐响起我是个容易受伤的男人】，因为长得太帅了没办法，不知道选那一个啊。【音乐响起请你不要迷恋哥，嫂子会打你的】 曾哥受伤了，曾哥想家了。【音乐响起常回家看看】曾哥哭了【音乐男人哭吧哭吧不是罪】，曾哥想到了AK_47，想到了地雷，但只剩嘴里那根烟了，杀不回去了。 还好，周末给了曾哥继续下去的理由。叫兽说，睡觉是对周末的最起码的尊重。曾哥一向是守法的孩子，所以周末有事没事要找曾哥的孩子，请留言，曾哥已睡死，哈哈。 当然这是不可能的事，因为叫兽还说过，来到洛阳，你不去外面转转，就可惜了。河山大好，洛阳正好。老师说到曾哥就做到，所以周末成了曾哥的旅游时间。一个地方总会有一个地方的好，洛阳正是个好地方。大学你所在的城市，你对他有了解多少呢？嘿嘿，趁周末完，像曾哥一样，出去转转吧，别待在宿舍当懒虫。音乐响起许嵩的【河山大好：电脑看太久了脖子也会酸，数字时代貌似把生活节奏加快，也让人变得行动迟缓起来。忙忙忙，忙不出个所以然，地球就算累了它照样会公转自转。叹叹叹，弹指一挥人生苦短，终点不明沿途风景要好好看。你可以隐隐的期待，途中佳缘的带来，保持一个浪漫的心态，活着就不算坏】。 感谢大家一路相伴，本期节目到此结束。曾哥究竟会在大学有何作为呢？","categories":[],"tags":[{"name":"娱乐","slug":"娱乐","permalink":"http://www.afanail.com/tags/娱乐/"},{"name":"怀旧","slug":"怀旧","permalink":"http://www.afanail.com/tags/怀旧/"}]},{"title":"五分钟学会简单使用git","slug":"五分钟学会简单使用git","date":"2016-01-02T16:00:00.000Z","updated":"2017-07-22T03:54:41.000Z","comments":true,"path":"2016/01/03/五分钟学会简单使用git/","link":"","permalink":"http://www.afanail.com/2016/01/03/五分钟学会简单使用git/","excerpt":"五分钟，简单入门。学会之后可以愉快的管理你的文件啦。 简单使用git 其实很简单，有多简单呢？ 1. git init 初始化一个仓库； 2. git add . 添加文件到暂存区； 3. git commit -m&apos;messeage&apos; 提交至版本库； 4. git push origin master 推送至远程仓库；","text":"五分钟，简单入门。学会之后可以愉快的管理你的文件啦。 简单使用git 其实很简单，有多简单呢？ 1. git init 初始化一个仓库； 2. git add . 添加文件到暂存区； 3. git commit -m&apos;messeage&apos; 提交至版本库； 4. git push origin master 推送至远程仓库； 分支管理什么是平衡分支？实际工作中一般新建平衡分支用于开发调试等，然后再合并到主分支。 1.git checkout -b dev 新建dev分支并切换到dev分支。 相当于：git branch dev 创建dev分支； git checkout dev 切换到dev分支； 2. 开发或者调试结束后 git add * 添加所有文件到暂存区； git commit -m&apos;messeage&apos; 提交至版本库； 3.git checkout master 切换到主分支； git merge dev 合并分支； git branch -d dev 删除分支； 解决冲突什么是冲突？同一份文件同一个地方被不同的协作者修改了，最后一个推送至远程的会产生冲突。 解决冲突：git pull 更新本地仓库 打开冲突文件，找到冲突部分，协调修改。 1 TODO 2 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 3 我修改的 4 ======= 5 协作者修改的 6 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 经过协调，修改为 1 TODO 2 经过协调修改的 到这里，你已经基本上掌握了git的使用了，想再深入了解，请点击git Pro中文","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://www.afanail.com/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"http://www.afanail.com/tags/版本控制/"}]},{"title":"我的世界，如果少了一个你","slug":"你好，世界","date":"2016-01-01T10:23:07.000Z","updated":"2017-07-22T03:54:45.000Z","comments":true,"path":"2016/01/01/你好，世界/","link":"","permalink":"http://www.afanail.com/2016/01/01/你好，世界/","excerpt":"如果说人的一生都有规律可以追寻，那是不是可以按照规律活下去，我的世界从此也就不会少一个你。 这一天生日在遥远的海洋上，夕阳无限好。摇摇曳曳，余光随着波浪，尽情摇摆。海面像往常一样平静。这是这座小城第824年历史的纪念日，历史悠久，耐人探索。吃完晚饭六点多，一家人来到海边散步。女儿已经5岁了，扎着小尾辫子。一手牵着妈妈，一手牵着爸爸，唱着上课老师教的歌曲。忽然，不知道那里逃出来的狗，灰棕灰，气势汹汹.这可不得了，这冲着人去咬。猝不及防，小女孩被狗咬伤了。没想到，意外总是这么意外。今天是小女孩的五岁生日。","text":"如果说人的一生都有规律可以追寻，那是不是可以按照规律活下去，我的世界从此也就不会少一个你。 这一天生日在遥远的海洋上，夕阳无限好。摇摇曳曳，余光随着波浪，尽情摇摆。海面像往常一样平静。这是这座小城第824年历史的纪念日，历史悠久，耐人探索。吃完晚饭六点多，一家人来到海边散步。女儿已经5岁了，扎着小尾辫子。一手牵着妈妈，一手牵着爸爸，唱着上课老师教的歌曲。忽然，不知道那里逃出来的狗，灰棕灰，气势汹汹.这可不得了，这冲着人去咬。猝不及防，小女孩被狗咬伤了。没想到，意外总是这么意外。今天是小女孩的五岁生日。 恶狗来袭就这样，小女孩的生日那天是在医院度过的。小女孩的爸爸–冯孔，在一家国企上班，刚到而立之年。小女孩的妈妈–翁玲，是一名教师。而这个小女孩，叫冯孔玲。刚才那狗，明显是冲着小女孩去的。冯孔和翁玲明显疏忽了。只见那狗一个纵身飞跃，咬着小女孩的大腿不放。这可得了，冯孔先是一愣，眼眉一紧，使出吃奶力气撩开那狗。可是那狗也是凶残，一个转身，又一个飞跃，獠牙再现，冯孔也中招了。在医院，翁玲余惊未去。要不是刚才在路上恰巧有消防队路过，恐怕今天是在劫难逃。翁玲陷入了深深的沉思，想起了7年前发生的事情。 时光回到十年前。 那时候冯孔还在上大学，而翁玲刚考上大学。翁玲认识冯孔是汉语言学院的迎新晚会上。在那时候发生了很多事，翁玲和冯孔能够走到一起，很多事情就显得不可思议。往事历历在目，宛如昨日。那时候的天还很蓝，水也比较清澈。人们都过着自认为比较舒服的日子。翁玲是独生女，从小比较娇惯些。如果能够回到十年前，翁玲恐怕做梦都想改变这一切吧！可是如果改变这一切，可能她就再也见不到她的先生了。也许生活就是这么安排的，让人苦笑不得。回到迎新晚回上，翁玲是女子舞蹈团体的领队，那时候在男生多，女生少的学校，不知道有多少人在追求着翁玲。为了这一场迎新晚回的表演，翁玲已经连续排练了一个多月。队里的一个女生，叫秦岚。是河南驻马店的一个小村庄，能够得到这个机会，一方面是翁琳的帮助，一方面是自己确实热爱舞蹈。没有人知道为什么这次晚回为什么学校这么看重，按照以前的规矩，提取一个星期排练就可以说是相当重视了。可是这一次不同，在老早的时候，就提取预知舞蹈队选拔，准备晚回演出。可以看出，这是晚回最重要的节目，没有之一。那个时候能当上舞蹈队队长，与翁琳队爸爸不无关系，论实际能力，队里大三的魏若筠才是不二人选。说起翁玲的老爸，是这学校的教学主任，当初选拔队长的时候，魏若筠可是持主流声音。毕竟在队里是最有资历的，也是最有实力的。而且在社团的历史上，还没有出现大一就当选队长团长这样的先例。为什么翁玲在大一的时候就能够当选舞蹈队的队长呢？其实说来也是巧，当初在竞选的时候，由于都知道魏若筠会当选，所有基本上没有人去竞选，因为大家打从心底里佩服魏若筠。舞蹈队的事情她可是无论细巨，都很上心很负责。所以，最后竞选的名单只有翁琳和魏若筠。为什么翁玲会去竞选这个舞蹈队的队长呢？这个说来也巧。在她刚入学的那一天，各大社团都有迎接新生的活动，因为翁玲的爸爸是这个学校的教学主任，所以对这个学校的一切，一切貌似都了如指掌。当初会报名舞蹈队，完全是她老爸的安排。管社团的团委老师与翁玲老爸是校友，所以就算翁玲没有报名加入舞蹈队，她也是队里的一名队员了。翁玲是十分不愿意被安排的，从小到大，都是这样，每一次父母都没有征询过自己的意见，每一次都像个乖乖女。 正所谓初生牛犊不怕虎， “您好，请问事13号病人的家属吗？”一旁的护士小姐端着记录板，轻声细语般：“请跟我到这边来办理相关手续，谢谢！”。翁玲收回思绪，赶紧随着护士去处理相关事宜。","categories":[],"tags":[{"name":"sad story","slug":"sad-story","permalink":"http://www.afanail.com/tags/sad-story/"},{"name":"updating","slug":"updating","permalink":"http://www.afanail.com/tags/updating/"}]}]}