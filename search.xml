<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Perl项目实现前后端分离???]]></title>
      <url>/2017/08/14/Perl%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB???/</url>
      <content type="html"><![CDATA[<p>昨天逛StackOverflow，发现ruby项目也能实现前后端分离。那么Perl项目应该也可以实现前后端分离吧？当然这只是我个人的猜想，毕竟才看完Perl语言入门这本书。intermediate perl 也才看了几章，上代码仓库<a href="https://github.com/zhengjingfa/perl-learning" target="_blank" rel="external">perl-learning</a>。<br>Perl的正则表达式无比强大，用过的人都知道好。这几天一直在改一些小需求，发现Perl与angular有一些相似之处。Perl项目我看见最早的代码标注时间是2004年，真是有年份的代码。在小规模的项目里，Perl显然很容易上手。但是在比较大的项目，上手Perl就相对新手来说比较不友好了。为什么呢？先看一份最简单的Perl文件，只是作为说明用途，不能用于生产环境。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">"common.pl"</span>;</div><div class="line"><span class="keyword">require</span> <span class="string">"base.pl"</span>;</div><div class="line"><span class="comment">#...</span></div><div class="line"><span class="keyword">use</span> Socket;</div><div class="line"><span class="keyword">use</span> MD5;</div><div class="line"><span class="comment">#...</span></div><div class="line"><span class="comment"># 调用common.pl文件里写好的HTMLHEADER方法，生成HTML头部</span></div><div class="line">&amp;HTMLHEADER();</div><div class="line"></div><div class="line"><span class="keyword">print</span> qq! </div><div class="line">&lt;script&gt;</div><div class="line"> function demo()&#123;</div><div class="line">   console.log(<span class="string">'this is a test demo'</span>);</div><div class="line"> &#125;</div><div class="line"> demo();</div><div class="line">&lt;<span class="regexp">/script&gt;!</span></div><div class="line">     </div><div class="line"></div><div class="line"></div><div class="line">print qq`</div><div class="line">&lt;h1&gt;this is test head title&lt;/h1&gt;</div><div class="line"><span class="string">`;</span></div><div class="line">$sql = "select * from table";</div><div class="line"># 调用连接数据库函数</div><div class="line">&amp;db_connect();</div><div class="line">$db-&gt;ct_execute($sql);</div><div class="line">while($db-&gt;ct_results($restype) == CS_SUCCEED) &#123;</div><div class="line">	if ($restype==CS_ROW_RESULT)	&#123;</div><div class="line">		while(@row = $db-&gt;ct_fetch)	&#123;</div><div class="line">				if ($row[1] eq "0") &#123;</div><div class="line">        	print qq`&lt;<span class="keyword">link</span> href=<span class="string">"demo.css"</span> rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> /&gt;<span class="string">`;	</span></div><div class="line">        &#125;</div><div class="line">        elsif ($row[1] eq "1") &#123;</div><div class="line">        	print qq`&lt;<span class="keyword">link</span> href=<span class="string">"test.css"</span> rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> /&gt;<span class="string">`;</span></div><div class="line">        &#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#...</div><div class="line"># 调用common.pl文件里写好的HTMLHEADER方法，生成HTML尾部</div><div class="line">&amp;FOOTER();</div></pre></td></tr></table></figure></p>
<p>我们再来看一下一份最简单的angular文件，只作说明，不能用于生产环境。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!doctype html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">ng-app</span>=<span class="string">"app"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span></span></div><div class="line">        <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 指令 属性方式 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">app-head-bar</span> <span class="attr">text</span>=<span class="string">"公司职位"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">app-company</span> <span class="attr">com</span>=<span class="string">"company"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">app-position-class</span> <span class="attr">com</span>=<span class="string">"company"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"vendor/angular/angular.min.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>把Perl的函数当成angular的指令，触类旁通。回归主题，再来说为什么Perl大项目对新手不友好。因为Perl可以内嵌太多语言了，html css js sql 等等，刚一接触肯定比较晕。所以从开始写Perl需求的时候，就一直在想能不能像ruby项目那样去实现前后端分离，让Perl程序少掺杂一些前端语言。所以还需要深入学习后台，站在更远的视野去看待问题。</p>
]]></content>
      
        
        <tags>
            
            <tag> Perl </tag>
            
            <tag> angular </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端工程自动化]]></title>
      <url>/2017/07/30/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>因为我是自动化方向出身的，对自动化算是有一些认识，前端领域虽然发展飞快，但是应用普及速度却不尽人意，前阵子腾讯开源了<a href="https://github.com/Tencent/ncnn" target="_blank" rel="external">ncnn</a>,这是要实现自动化编程的节奏啊！但是现在国内好多对前端的看法还是停留在美工的层面，这科技差距就像北上广深和大西北，令人唏嘘！其实做软件开发的无所谓前后端，眼界也不能局限于某一个领域。回到话题，为什么要前端自动化？因为前端重要啊！在这个颜控的社会，前端好比外貌，后端好比内在。这也是为什么前端在现在大部分公司大概占技术团队三分之一席位的事实。<a id="more"></a><br>什么是前端工程自动化？腾讯的<a href="https://github.com/Tencent/WeFlow" target="_blank" rel="external">WeFlow</a>工作流程解释的很清楚。简言之就是帮助我们自动去做某事,更高效高简洁更优化更有体验。从<code>grunt</code>到<code>gulp</code>，再从<code>gulp</code>到<code>webpack</code>,也就是短短俩三年的时间。前端技术日新月异，框架和工具层出不穷。但是归根结底还是<code>HTML</code>、<code>CSS</code>、<code>JavaScript</code>，万变不离其中，还是以打好基础为主。虽然<code>JavaScript</code>能作为后端语言替代<code>Java</code>、<code>PHP</code>等后台语言，但是至今市场份额少还是有原因的。<br>我们从零开始搭建一个最简单前端项目来展示前端工程自动化。首先新建一个项目<code>znsq</code>。<img src="/assets/img/project.png" alt="">引入<code>gulpfile.js</code>（项目核心脚本）文件，实现热更新，压缩图片压缩文件等功能。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * gulpfile.js</div><div class="line"> * author: zhengjingfa</div><div class="line"> * date: 2017.04.21</div><div class="line"> * email: zjfapk@163.com</div><div class="line"> */</div><div class="line"><span class="comment">// 定义目录</span></div><div class="line"><span class="keyword">var</span> app = &#123;  </div><div class="line">    <span class="attr">srcPath</span>:<span class="string">'src/'</span>,</div><div class="line">    <span class="attr">buildPath</span>:<span class="string">'build/'</span>,</div><div class="line">    <span class="attr">distPath</span>:<span class="string">'dist/'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*1.引入gulp与gulp插件   使用时，要去下载这些插件*/</span></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</div><div class="line"><span class="keyword">var</span> less = <span class="built_in">require</span>(<span class="string">'gulp-less'</span>);</div><div class="line"><span class="keyword">var</span> cssmin = <span class="built_in">require</span>(<span class="string">'gulp-cssmin'</span>);</div><div class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</div><div class="line"><span class="keyword">var</span> concat = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>);</div><div class="line"><span class="keyword">var</span> connect = <span class="built_in">require</span>(<span class="string">'gulp-connect'</span>);</div><div class="line"><span class="keyword">var</span> imagemin = <span class="built_in">require</span>(<span class="string">'gulp-imagemin'</span>);</div><div class="line"><span class="keyword">var</span> open = <span class="built_in">require</span>(<span class="string">'open'</span>);</div><div class="line"></div><div class="line"><span class="comment">/*把bower下载的前端框架放到我们项目当中*/</span></div><div class="line">gulp.task(<span class="string">'lib'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">   gulp.src(<span class="string">'bower_components/**/*.js'</span>)</div><div class="line">       .pipe(gulp.dest(app.buildPath+<span class="string">'lib'</span>))</div><div class="line">       .pipe(gulp.dest(app.distPath+<span class="string">'lib'</span>))</div><div class="line">       .pipe(connect.reload()) <span class="comment">//当内容发生改变时， 重新加载。</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">/*2.定义任务 把所有html文件移动另一个位置*/</span></div><div class="line">gulp.task(<span class="string">'html'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">/*要操作哪些文件 确定源文件地址*/</span></div><div class="line">    gulp.src(app.srcPath+<span class="string">'**/*.html'</span>)  <span class="comment">/*src下所有目录下的所有.html文件*/</span></div><div class="line">        .pipe(gulp.dest(app.buildPath)) <span class="comment">//gulp.dest 要把文件放到指定的目标位置</span></div><div class="line">        .pipe(gulp.dest(app.distPath))</div><div class="line">        .pipe(connect.reload()) <span class="comment">//当内容发生改变时， 重新加载。</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">/*3.执行任务 通过命令行。gulp 任务名称*/</span></div><div class="line"><span class="comment">/*定义编译less任务  下载对应的插件 gulp-less</span></div><div class="line">* 把less文件转成css放到build</div><div class="line">* */</div><div class="line">gulp.task(<span class="string">'less'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    gulp.src(app.srcPath+<span class="string">'style/index.less'</span>)</div><div class="line">        .pipe(less())</div><div class="line">        .pipe(gulp.dest(app.buildPath+<span class="string">'css/'</span>))</div><div class="line">        <span class="comment">/*经过压缩，放到dist目录当中*/</span></div><div class="line">        .pipe(cssmin())</div><div class="line">        .pipe(gulp.dest(app.distPath+<span class="string">'css/'</span>))</div><div class="line">        .pipe(connect.reload())</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">/*合并js*/</span></div><div class="line">gulp.task(<span class="string">'js'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">   gulp.src(app.srcPath+<span class="string">'js/**/*.js'</span>)</div><div class="line">       .pipe(concat(<span class="string">'index.js'</span>))</div><div class="line">       .pipe(gulp.dest(app.buildPath+<span class="string">'js/'</span>))</div><div class="line">       .pipe(uglify())</div><div class="line">       .pipe(gulp.dest(app.distPath+<span class="string">'js'</span>))</div><div class="line">       .pipe(connect.reload())</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">/*压缩图片*/</span></div><div class="line">gulp.task(<span class="string">'image'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">     gulp.src(app.srcPath+<span class="string">'images/**/*'</span>)</div><div class="line">         .pipe(gulp.dest(app.buildPath+<span class="string">'images'</span>))</div><div class="line">         .pipe(imagemin())</div><div class="line">         .pipe(gulp.dest(app.distPath+<span class="string">'images'</span>))</div><div class="line">         .pipe(connect.reload())</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">/*同时执行多个任务 [其它任务的名称]</span></div><div class="line">* 当前bulid时，会自动把数组当中的所有任务给执行了。</div><div class="line">* */</div><div class="line">gulp.task(<span class="string">'build'</span>,[<span class="string">'less'</span>,<span class="string">'html'</span>,<span class="string">'js'</span>,<span class="string">'image'</span>,<span class="string">'lib'</span>]);</div><div class="line"></div><div class="line"><span class="comment">/*定义server任务</span></div><div class="line">* 搭建一个服务器。设置运行的构建目录</div><div class="line">* */</div><div class="line">gulp.task(<span class="string">'server'</span>,[<span class="string">'build'</span>],<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">/*设置服务器*/</span></div><div class="line">    connect.server(&#123;</div><div class="line">        <span class="attr">root</span>:[app.buildPath],<span class="comment">//要运行哪个目录</span></div><div class="line">        livereload:<span class="literal">true</span>,  <span class="comment">//是否热更新。</span></div><div class="line">        port:<span class="number">9999</span>  <span class="comment">//端口号</span></div><div class="line">    &#125;)</div><div class="line">    <span class="comment">/*监听哪些任务*/</span></div><div class="line">    gulp.watch(<span class="string">'bower_components/**/*'</span>,[<span class="string">'lib'</span>]);</div><div class="line">    gulp.watch(app.srcPath+<span class="string">'**/*.html'</span>,[<span class="string">'html'</span>]);</div><div class="line">    gulp.watch(app.srcPath+<span class="string">'js/**/*.js'</span>,[<span class="string">'js'</span>]);</div><div class="line">    gulp.watch(app.srcPath+<span class="string">'images/**/*'</span>,[<span class="string">'image'</span>]);</div><div class="line">    gulp.watch(app.srcPath+<span class="string">'style/**/*.less'</span>,[<span class="string">'less'</span>]);</div><div class="line"></div><div class="line">    <span class="comment">//通过浏览器把指定的地址 （http://localhost:9999）</span></div><div class="line">    open(<span class="string">'http://localhost:9999'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">/*定义默认任务</span></div><div class="line">* 直接执行gulp 会调用的任务</div><div class="line">* */</div><div class="line">gulp.task(<span class="string">'default'</span>,[<span class="string">'server'</span>]);</div></pre></td></tr></table></figure></p>
<p>通过<code>npm init</code>初始化<code>package.json</code>文件，把项目依赖的<code>gulp</code>插件写入，所需要的插件在<code>&quot;devDependencies&quot;</code>里。然后再把项目所需的文件根据<code>gulpfile.js</code>文件搭建好。如图<img src="/assets/img/pathname.png" alt=""><br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// package.json</div><div class="line">&#123;</div><div class="line">  "name": "znsq",</div><div class="line">  "version": "1.0.0",</div><div class="line">  "description": "",</div><div class="line">  "main": "index.js",</div><div class="line">  "scripts": &#123;</div><div class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</div><div class="line">  &#125;,</div><div class="line">  "author": "",</div><div class="line">  "license": "ISC",</div><div class="line">  "devDependencies": &#123;</div><div class="line">    "gulp": "^3.9.1",</div><div class="line">    "gulp-concat": "^2.6.1",</div><div class="line">    "gulp-connect": "^5.0.0",</div><div class="line">    "gulp-cssmin": "^0.1.7",</div><div class="line">    "gulp-imagemin": "^3.2.0",</div><div class="line">    "gulp-less": "^3.3.0",</div><div class="line">    "gulp-uglify": "^2.1.2",</div><div class="line">    "open": "0.0.5"</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行<code>npm install</code>，下载插件。执行<code>bower install</code>,下载项目所需类库框架。此时项目目录<img src="/assets/img/filename.png" alt=""><br>然后打开终端，切换到项目目录下，运行命令<code>gulp</code>之后，浏览器会自动打开本地端口<code>localhost:9999</code>。此时项目目录<img src="/assets/img/termial.png" alt="">基本上到此已经实现了一个小的工作流程，其中跳过了<code>nvm</code>、<code>npm</code>等可能需要一些时间折腾的部分。下一个话题准备分享一下如何为<code>jQuery</code>贡献自己开发的插件，如何开发自己的<code>jQuery</code>插件，如何自己开发一个类<code>jQuery</code>库，前提是时间允许，囧。</p>
]]></content>
      
        
        <tags>
            
            <tag> front-end </tag>
            
            <tag> auto </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IE7-hack-respond]]></title>
      <url>/2017/07/22/IE7-hack-respond/</url>
      <content type="html"><![CDATA[<p>最近收到了几笔打赏，先谢谢这些不知名的小伙伴，然后我关闭打赏功能啦，写博客是为了记录个人的学习工作生活，并没有什么其他用途，哈哈。<br>现在兼容IE系列的应该很少见了，不过如果客户有需求，还是要考虑兼容的，相比前几年要兼容IE6，最近一俩年所接手的项目需求都是兼容IE9+，所以没有办法体会到前人对兼容各种浏览器所做出的努力与付出。首先来说一下项目的需求，要求兼容IE7，并且实现响应式，而且大屏幕和小屏幕的功能不尽相同，大屏幕是pc端尺寸，小屏幕规定在270px~600px之间。<a id="more"></a>兼容IE7+就不要考虑用CSS3的媒介属性了，而且需求时间5天不借助框架情况下实现一套响应式网站，考虑到业务的复杂程度，有点不太现实。你看我的博客换了个响应式的主题，今天改了一天的bug,而且还是用了别人写好的框架，这还是一个简单的业务需求少的网站，可见做一个比较拿的出手的响应式网站是需要费周折的。响应式虽然很火，由于种种原因，也不见得有多少大公司在用，几乎所有都是分成移动、PC俩套来做。先说一下IE7浏览器方面的hack，下面这种hack肯定不少见，特别是在一些大型的网站，一个网页大部分都是这种hack。不过随着技术的更新，相信会出现更好的解决的方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!--[<span class="keyword">if</span> lt IE <span class="number">9</span>]&gt;</div><div class="line">&lt;script type="text/javascript" src="js/html5shiv.min.js"&gt;&lt;/script&gt;</div><div class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"js/respond.min.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure></p>
<h3 id="IE7-hack"><a href="#IE7-hack" class="headerlink" title="IE7 hack"></a>IE7 hack</h3><p>在IE7下要实现弹性布局,肯定不能使用flexbox布局。古老版本的flexbox布局出现了。当然这只是简单的实现某一部分的功能，肯定不能媲美真正的弹性布局。完整的代码如下，利用浮动以及<code>BFC</code>原理实现了这一功能，兼容IE6+。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!doctype html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span></span></div><div class="line"> <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>flexbox另一种方式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line">.dfcont&#123;</div><div class="line">  border:1px solid red;</div><div class="line">  box-sizing:border-box;</div><div class="line">  padding:8px;</div><div class="line">        &#125;</div><div class="line">.fl&#123;</div><div class="line">   float:left;</div><div class="line">   border:1px solid pink;</div><div class="line">   background:#fff;</div><div class="line">   padding:12px;</div><div class="line">   line-height:26px;</div><div class="line">        &#125;</div><div class="line">.fr&#123;</div><div class="line">   float:right;</div><div class="line">   border:1px solid yellow;</div><div class="line">   padding:12px;</div><div class="line">   line-height:26px;</div><div class="line">        &#125;</div><div class="line">.dfafter&#123;</div><div class="line">   line-height:32px;</div><div class="line">   margin-top:12px;</div><div class="line">   text-align:left;</div><div class="line">   background:blue;</div><div class="line">   overflow:hidden;</div><div class="line">        &#125;</div><div class="line">.clearfix&#123;*zoom:1;&#125;</div><div class="line">.clearfix:after&#123;</div><div class="line">    content:"";</div><div class="line">    display:block;</div><div class="line">    clear:both;</div><div class="line">        &#125;</div><div class="line">.dfinner&#123;</div><div class="line">    margin:0 12px;</div><div class="line">    background:darkseagreen;</div><div class="line">    white-space:nowrap;</div><div class="line">    overflow:hidden;</div><div class="line">    text-overflow:ellipsis;</div><div class="line">        &#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dfcont clearfix"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fl"</span>&gt;</span></div><div class="line">我浮动到左边<span class="tag">&lt;<span class="name">Br</span>/&gt;</span></div><div class="line">因为脱离文档流所以不受父元素控制<span class="tag">&lt;<span class="name">br</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fr"</span>&gt;</span></div><div class="line">我浮动到右边<span class="tag">&lt;<span class="name">Br</span>/&gt;</span></div><div class="line">同样也不受父元素控制。<span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dfafter"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dfinner"</span>&gt;</span></div><div class="line">我是浮动元素后面内容,我要实现flex特性的功能。</div><div class="line">我是flex的古老版实现方式。</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>IE7下input的placeholder属性完全失效，亲测最好的解决方法如下,前提条件是项目引用到jQuery库。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">&lt;!--[<span class="keyword">if</span> lt IE <span class="number">10</span>]&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></div><div class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  $(<span class="string">"input[type!='password'],textarea"</span>).bind(&#123;</div><div class="line">     <span class="string">"focus"</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> placeholderVal = $(<span class="keyword">this</span>).attr(<span class="string">"placeholder"</span>);</div><div class="line">        <span class="keyword">var</span> realVal = $(<span class="keyword">this</span>).val();</div><div class="line">        <span class="keyword">if</span>($.trim(realVal)==placeholderVal)&#123;</div><div class="line">            $(<span class="keyword">this</span>).val(<span class="string">""</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;,</div><div class="line">     <span class="string">"blur"</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> placeholderVal = $(<span class="keyword">this</span>).attr(<span class="string">"placeholder"</span>);</div><div class="line">        <span class="keyword">var</span> realVal = $(<span class="keyword">this</span>).val();</div><div class="line">        <span class="keyword">if</span>($.trim(realVal)==<span class="string">""</span>)&#123;</div><div class="line">            $(<span class="keyword">this</span>).val(placeholderVal);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">     $(<span class="string">"input[type!='password'],textarea"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">i,n</span>)</span>&#123;</div><div class="line">     $(<span class="keyword">this</span>).val($(<span class="keyword">this</span>).attr(<span class="string">"placeholder"</span>));</div><div class="line">            &#125;);</div><div class="line">     $(<span class="string">"input[type='password']"</span>).bind(&#123;</div><div class="line">     <span class="string">"focus"</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> placeholderVal = $(<span class="keyword">this</span>).attr(<span class="string">"placeholder"</span>);</div><div class="line">        <span class="keyword">var</span> realVal = $(<span class="keyword">this</span>).val();</div><div class="line">            <span class="keyword">if</span>($.trim(realVal)==placeholderVal)&#123;</div><div class="line">            <span class="keyword">var</span> copy_this = $(<span class="keyword">this</span>).clone(<span class="literal">true</span>,<span class="literal">true</span>);</div><div class="line">            $(copy_this).attr(<span class="string">"type"</span>,<span class="string">"password"</span>);</div><div class="line">            $(copy_this).insertAfter($(<span class="keyword">this</span>));</div><div class="line">            $(<span class="keyword">this</span>).remove();</div><div class="line">            $(copy_this).val(<span class="string">""</span>);</div><div class="line">            $(copy_this).focus();</div><div class="line">                    &#125;</div><div class="line">                &#125;,</div><div class="line">        <span class="string">"blur"</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">var</span> placeholderVal = $(<span class="keyword">this</span>).attr(<span class="string">"placeholder"</span>);</div><div class="line">            <span class="keyword">var</span> realVal = $(<span class="keyword">this</span>).val();</div><div class="line">            <span class="keyword">if</span>($.trim(realVal)==<span class="string">""</span>)&#123;</div><div class="line">            <span class="keyword">var</span> copy_this = $(<span class="keyword">this</span>).clone(<span class="literal">true</span>,<span class="literal">true</span>);</div><div class="line">               $(copy_this).attr(<span class="string">"type"</span>,<span class="string">"text"</span>);</div><div class="line">               $(copy_this).insertAfter($(<span class="keyword">this</span>));</div><div class="line">               $(<span class="keyword">this</span>).remove();</div><div class="line">               $(copy_this).val(placeholderVal);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            $(<span class="string">"input[type='password']"</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">i,n</span>)</span>&#123;</div><div class="line">                <span class="keyword">var</span> placeHolderVal = $(<span class="keyword">this</span>).attr(<span class="string">"placeholder"</span>);</div><div class="line">                <span class="keyword">var</span> copy_this = $(<span class="keyword">this</span>).clone(<span class="literal">true</span>,<span class="literal">true</span>);</div><div class="line">                $(copy_this).attr(<span class="string">"type"</span>,<span class="string">"text"</span>);</div><div class="line">                $(copy_this).insertAfter($(<span class="keyword">this</span>));</div><div class="line">                $(<span class="keyword">this</span>).remove();</div><div class="line">                $(copy_this).val(placeHolderVal);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure></p>
<p>IE7下的<code>inline-block</code>、<code>fixed</code>均有问题，具体的hack如下,<code>fixed</code>解决方法过几天再贴上。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.box &#123;</div><div class="line">  display: inline-block;</div><div class="line">  *display:inline; </div><div class="line">  *zoom:1;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>IE7的hack多种多样，以上几种只是常见的，具体可以上<a href="http://caniuse.com/" target="_blank" rel="external">caniuse</a>查看搜索，如果你有更好更多的hack，欢迎补充。有的时候写样式用了一天，但是调试兼容用了俩天，这实属颠倒本质，没想到兼容性的问题也真的是令人头疼的问题。</p>
<h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>实现响应式有很多种方法，现在最常用的是CSS3的媒介查询，配合<code>respond.js</code>是可以实现兼容IE6+的。但是为什么一开始就不考虑用这个技术呢，首先兼容IE6+并不是全部都支持，还有一些无法功能全部支持，其次需求时间不允许(耦合性强)。那有没有更好的方法呢？肯定是有的。一是用jQuery的load方法，通过判断屏幕尺寸大小加载不同的页面。二是通过js来实现响应式。三是通过判断浏览器的屏幕尺寸，设置浏览器的<code>window.location.href</code>属性值。这三种方式我都亲自测试过，最后个人感觉最有效的方式是通过设置浏览器的<code>window.location.href</code>属性值。第一种方法实质是ajax获取页面内容，存在不安全隐患，如xss攻击，第二种方法要写过多的js脚步来实现。第三种的核心代码如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">browserRedirective</span>(<span class="params">url1,url2</span>) </span>&#123;</div><div class="line"><span class="comment">// 获取浏览器宽度</span></div><div class="line">  <span class="keyword">var</span> browserWidth = <span class="built_in">document</span>.documentElement.clientWidth ? <span class="built_in">document</span>.documentElement.clientWidth : <span class="built_in">document</span>.body.clientWidth;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (browserWidth &gt; <span class="number">270</span> &amp;&amp; browserWidth &lt; <span class="number">600</span> )&#123;</div><div class="line">    <span class="built_in">window</span>.location.href = url1;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 如果是当前路径，返回。</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.location.pathname.indexOf()&gt;<span class="number">-1</span>)&#123;</div><div class="line">      <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">window</span>.location.href = url2;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过这种方法，将俩个页面独立为俩个URL，不再考虑响应式之间的耦合性，方便以后各个屏幕尺寸之间的功能扩展。如果你有更好的方法，欢迎补充。忙碌的一周过去了，关于Perl的学习，持续关注<a href="https://github.com/zhengjingfa/perl-learning" target="_blank" rel="external">perl-learning</a><br>下一步的计划是利用空闲时间开发个人微信公众号以及个人小程序，O(∩_∩)O谢谢支持！</p>
]]></content>
      
        
        <tags>
            
            <tag> IE 兼容性 </tag>
            
            <tag> js实现响应式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[perl-learning]]></title>
      <url>/2017/07/15/perl-learning/</url>
      <content type="html"><![CDATA[<p>perl 是一门编程语言。因为工作上的原因需要用到perl，这才对perl有了了解。相对JS而言，perl貌似更简单易用。同为脚本语言，perl风靡一时，当下肯定没有JS热门。更多的是用在生信等领域，而JS是随着web2.0的兴起而逐渐壮大，你看ES7都快出来了。先来看一下perl的最基本入门程序。<br><a id="more"></a><br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"><span class="keyword">print</span> <span class="string">"Hello,world!\n"</span></div><div class="line"><span class="comment">=pod</span></div><div class="line">larry 推出了Perl</div><div class="line"> 1 Itermediate Perl</div><div class="line"> 2 Mastering Perl</div><div class="line"> 3 Programming perl</div><div class="line"> 额外练习 《Learning Perl Student Workbook》</div><div class="line">=cut</div></pre></td></tr></table></figure></p>
<p>其中 <code>#!/usr/bin/perl</code>，意思为perl脚本的默认存放位置是“/usr/bin/perl”；<br>比较新奇的是perl的多行注释：</p>
<pre><code>=pod、=cut只能在行首
以=开头，以cut结尾
=后面要紧接一个字符，=cut后面可以不用
</code></pre><p>关于perl的更多知识，入门推荐 <code>Learning Perl</code>,之后按书籍顺序：</p>
<pre><code>1 Itermediate Perl
2 Mastering Perl
3 Programming perl
</code></pre><p>让我们再来看一个perl文件， <code>Heredoc</code>技巧。        </p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"><span class="comment">=pod Heredoc</span></div><div class="line">一种在命令行和程序语言里定义一个字串的方法。</div><div class="line">注意点： 1.必须后接分号；</div><div class="line">2.END可以用任何语言代替，必须保证开始结束标识一致；</div><div class="line">3.开始标识不带引号与带引号的作用一样，会解析转义；</div><div class="line">4.结束标识必须占一行。必须行首开始。</div><div class="line">5.当内容需要内嵌引号的时候，不需要加转义字符，本身对单双引号转义；</div><div class="line">=cut</div><div class="line"></div><div class="line">$a = <span class="number">10</span>;</div><div class="line">$var = &lt;&lt; <span class="string">"eof"</span>;</div><div class="line">这是一个Here文档实例，使用双引号。</div><div class="line">“可以输入双引号”，‘可以输入单引号’；</div><div class="line">可以在这里输入字符串和变量；</div><div class="line">例如： a = $a;</div><div class="line"><span class="keyword">eof</span></div><div class="line"><span class="keyword">print</span> <span class="string">"$var\n"</span>;</div><div class="line"></div><div class="line">$var = &lt;&lt; <span class="string">'dfc'</span>;</div><div class="line">这是一个单引号的例子；</div><div class="line">a = $a;</div><div class="line">dfc</div><div class="line"><span class="keyword">print</span> <span class="string">"$var\n"</span>;</div><div class="line"></div><div class="line"><span class="comment"># perl Heredoc变量可以重复,例如上面的$var;</span></div><div class="line"></div><div class="line"><span class="comment"># perl 用反斜线来转义</span></div><div class="line">$res = <span class="string">"zjf"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"$res\n"</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">'$res\n'</span>;</div><div class="line"></div><div class="line"><span class="comment"># perl标识符与其他编程语言一样；</span></div></pre></td></tr></table></figure>
<p>这也是比较新奇的技巧。<br>在我学习perl的过程，我会把学习代码放到仓库<a href="https://github.com/zhengjingfa/perl-learning" target="_blank" rel="external">perl-learning</a>，欢迎莅临指导。</p>
]]></content>
      
        
        <tags>
            
            <tag> perl </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[教你如何巧妙解决网页乱码]]></title>
      <url>/2017/06/28/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E5%B7%A7%E5%A6%99%E8%A7%A3%E5%86%B3%E7%BD%91%E9%A1%B5%E4%B9%B1%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>约定俗成不是好的标准，却是近似好的标准。</p>
<p>我们编写好的html文件，在浏览器显示往往会乱码，这就是编码格式的问题。在约定情况下，通常默认<code>utf-8</code>编码格式。但是，有一些有一定历史的公司，比如网易，我们可以看到它的编码格式是简体中文，也就是国标编码2312,简称<code>gb2312</code>。<br><a id="more"></a><br><img src="/assets/img/网易编码gb2312.png" alt="网易页面简体中文编码格式"></p>
<p>如果你这个时候把编码格式设置为其它的呢？相信你会看到一些似懂非懂的文字。我就比较好奇试了一下。</p>
<p><img src="/assets/img/网易编码繁体.png" alt="网易页面繁体中文编码格式"></p>
<p>结果不出意料，果然乱码了。从这个小细节，我们引出了一个问题。当前后台没有约定编码格式（可能是新来的傻傻的认为编码格式都是<code>utf-8</code>），这时候编码格式就不一样了。就像上面出现的情况一样。可能你会像我一样去修改html文件的meta标签，设置chartset与后台一样的编码格式，然后再返回给后台，但是你会发现居然没有什么毛线效果，该乱码还是乱码。然后我们百度、谷歌的方法也不一定有用，这个时候你会怀疑是不是遇到了什么天大的难题了。</p>
<p>其实解决的方法很简单，简单到我们都没有想到。在webstrom下，右下角有个很明显的 <code>utf-8</code> 可选项，点击它，如下图所示。选择你们约定好的编码格式，这个问题也就到此为止了。<br><img src="/assets/img/设置编码格式.png" alt="设置编码格式"></p>
<p>其实这只是一个很小的细节，但是引发出来的问题还是不少的，比如网页上的某个标签的编码格式与整体的页面不一致该如何设置，在IE6浏览器的环境下又该如何设置，这些可能都是我们会遇到的问题。你都知道怎么解决吗？</p>
<p>诚然，好的规范需要共同约定，需要共同遵守！</p>
]]></content>
      
        
        <tags>
            
            <tag> 编码格式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[抓住17年的尾巴]]></title>
      <url>/2017/06/17/%E6%8A%93%E4%BD%8F17%E5%B9%B4%E7%9A%84%E5%B0%BE%E5%B7%B4/</url>
      <content type="html"><![CDATA[<p> 17年也要结束了，一切来的那么快。年前的计划是否实现了,这显然没有那么重要了。还有半年的时间，切忌不要等到赶着时间去抓17年的尾巴。<br> <a id="more"></a></p>
<h3 id="new-Date"><a href="#new-Date" class="headerlink" title="new Date"></a>new Date</h3><p> 关于工作，就像标题一样，一切都是新的时间对象。跳槽来到了一家只有我一个前端的公司，所以一切几乎等同于从零开始。对一个东西有很深感情，很多不是因为一见钟情，很多不是因为互相喜欢，而是从一开始到结束，从浅到深，慢慢培养的感情。而我们似乎都急于求成，感情上如此，生活亦是。</p>
<h3 id="once-super"><a href="#once-super" class="headerlink" title="once super"></a>once super</h3><p> 一个人的团队可以干些什么？这似乎是一道双向的数据绑定题。首先，赋予我们极大的自由，可以运用自己热衷并且擅长的技术，可以调动自己的创造性，极大可能的挖掘自己的潜能。从前端代码规范，前端工程自动化，前端技术选型，似乎可以任君胡作非为一番了。前人栽树，后人乘凉。还是要妥当才好。团队不可能永远一个人，你不是一个人在战斗。你只是暂时一个人代表一个团队在战斗。你会慢慢喜欢上你从无到有的团队的，请坚信这一点。单枪匹马与千军万马孰优孰劣一目了然。</p>
<h3 id="make-kludeg"><a href="#make-kludeg" class="headerlink" title="make kludeg"></a>make kludeg</h3><p> 然而，一切有想象中的那么自由吗？往往限制自己的就是我们自己。你似乎已经忘记团队的存在了，这才是多么可怕的事情。所以事情没有想的那么容易。但是也没有想象中的那么困难。这个流动性大的环境下，时刻做好准备才是硬道理。你看前端框架更新多快，就知道流动性有多大了。所以真的有必要去重构之前的一些代码吗？还是标注<code>kludeg</code>让接下来的开发者谨慎注意某些复杂的代码片段。有一些10几年的老项目，存在是有它的道理的。新的东西不一定好，旧的东西不一定会被淘汰。往往要看当权者如何折中了。不要为了前端而前端，好像就是这个理。</p>
<h3 id="web-browser"><a href="#web-browser" class="headerlink" title="web browser"></a>web browser</h3><p> 我曾经是一度的希望，会不会有个大神上的大神，出来一统前端，破解今日百家争艳的局面。更希望哪个web browser能够并购所有browser，IE也行，Chrome也罢。这样就不会有兼容性，就不会有纷呈复杂的前端技术了。现在想想，才知道自己那时候是多么幼稚。也正是因为如此，前端才变得更具挑战性，未来才更加不确定性，更加富有往各种方向发展的可能性。想想垄断，是多么可怕的词。如今的局面，可能都是最好的安排。</p>
<h3 id="catch-17end"><a href="#catch-17end" class="headerlink" title="catch 17end"></a>catch 17end</h3><p> 不管什么局面，都是时间的积累造就的，没有人能够一蹴而就。生活如此，感情亦是。太快了，反而更需要花时间沉淀。Because，one day, when you review your code and project, you would doubt that how stupid to gulp this.</p>
<p> 本来今天想早点睡觉的，没想到又快到凌晨1点多了，黑眼圈也是需要时间积累的，大概我的黑眼圈就是这样来的吧。刚好今天是父亲节，好久没有给父亲打电话了。想一想，应该是从来没有给父亲打过真正意义上的电话。父亲实在太辛苦了，一个人要赚钱养8口人的大家庭。我们兄弟姐妹从来与父亲不来电，不谈心事，不谈生活，不谈其它，因为是母亲承担了这些孩子成长上琐碎的事情。我们心里都明白，父亲是知道孩子成长道路上琐碎的事情的，甚至比母亲还上心。可是生活造就了一切，有的人就是默默无闻的付出，得到的也不是掷地有声的回报。但是，这默默无闻付出的背后，你可曾知道这也是无时无刻幸福与满足交织涌向心头，胜过千倍万倍娇弱做作的我爱你！</p>
]]></content>
      
        
        <tags>
            
            <tag> 工作计划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[less小技巧]]></title>
      <url>/2017/06/16/less%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p>后端转前端，或者UI转前端，往往会写不好css，有没有一种可以像写函数式编程那样对方法来编写css，答案是有的，比如less、sass、stylus等。</p>
<h1 id="什么是less？"><a href="#什么是less？" class="headerlink" title="什么是less？"></a>什么是less？</h1><p>  这里不多说，请看中文网介绍<a href="http://lesscss.cn/" target="_blank" rel="external">less中文网</a>。<br>  <a id="more"></a><br>  我个人对less、sass、stylus对理解，简单对概括为：让css更接近编程语言。  </p>
<p>  less是最容易上手对，如果你使用less一段时间，发现会爱不释手。因为它更接近编程思维，优点多多。</p>
<h1 id="less技巧"><a href="#less技巧" class="headerlink" title="less技巧"></a>less技巧</h1><ol>
<li><p>就拿移动端来举例子，我们常用像素单位rem,可以很好的适配各种机型的屏幕。首先通过设置js让html元素的字体大小随着屏幕大小的改变而改变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> font = <span class="built_in">window</span>.screen.width / <span class="number">10</span> + <span class="string">'px'</span>;</div><div class="line">   <span class="built_in">console</span>.log(font);</div><div class="line">   <span class="built_in">document</span>.getElementsByTagName(<span class="string">'html'</span>)[<span class="number">0</span>].style.fontSize = font;</div></pre></td></tr></table></figure>
<ol>
<li>通过less的unit函数转化属性值的单位，定义函数<code>.fs</code>、<code>.w</code>…  </li>
</ol>
<p><code>@px</code>是一个变量也是一个参数,我们可以在调用它的时候给它传递实际参数。下面是移动开发时候经常使用的函数，仅供参考。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*把像素转成rem</span></div><div class="line"> 375/10  = 37.5</div><div class="line"> 375 它是ipone6的屏幕宽度</div><div class="line">*/</div><div class="line"><span class="comment">//默认是20px</span></div><div class="line"><span class="selector-class">.fs</span>(<span class="variable">@px</span>:<span class="number">20px</span>)&#123;</div><div class="line">  <span class="attribute">font-size</span>: unit(<span class="variable">@px</span>/<span class="number">37.5</span>,rem);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.w</span>(<span class="variable">@px</span>)&#123;</div><div class="line">  <span class="attribute">width</span>: unit(<span class="variable">@px</span>/<span class="number">37.5</span>,rem);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.h</span>(<span class="variable">@px</span>)&#123;</div><div class="line">  <span class="attribute">height</span>: unit(<span class="variable">@px</span>/<span class="number">37.5</span>,rem);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.lh</span>(<span class="variable">@px</span>)&#123;</div><div class="line">  <span class="attribute">line-height</span>: unit(<span class="variable">@px</span>/<span class="number">37.5</span>,rem);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.pl</span>(<span class="variable">@px</span>)&#123;</div><div class="line">  <span class="attribute">padding-left</span>: unit(<span class="variable">@px</span>/<span class="number">37.5</span>,rem);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.pr</span>(<span class="variable">@px</span>)&#123;</div><div class="line">  <span class="attribute">padding-right</span>: unit(<span class="variable">@px</span>/<span class="number">37.5</span>,rem);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.pt</span>(<span class="variable">@px</span>)&#123;</div><div class="line">  <span class="attribute">padding-top</span>: unit(<span class="variable">@px</span>/<span class="number">37.5</span>,rem);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.pb</span>(<span class="variable">@px</span>)&#123;</div><div class="line">  <span class="attribute">padding-bottom</span>: unit(<span class="variable">@px</span>/<span class="number">37.5</span>,rem);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.mt</span>(<span class="variable">@px</span>)&#123;</div><div class="line">  <span class="attribute">margin-top</span>:unit(<span class="variable">@px</span>/<span class="number">37.5</span>,rem);;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.mb</span>(<span class="variable">@px</span>)&#123;</div><div class="line">  <span class="attribute">margin-bottom</span>:unit(<span class="variable">@px</span>/<span class="number">37.5</span>,rem);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.ml</span>(<span class="variable">@px</span>)&#123;</div><div class="line">  <span class="attribute">margin-left</span>:unit(<span class="variable">@px</span>/<span class="number">37.5</span>,rem);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.mr</span>(<span class="variable">@px</span>)&#123;</div><div class="line">  <span class="attribute">margin-right</span>:unit(<span class="variable">@px</span>/<span class="number">37.5</span>,rem);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.top</span>(<span class="variable">@px</span>)&#123;</div><div class="line">  <span class="attribute">top</span>:unit(<span class="variable">@px</span>/<span class="number">37.5</span>,rem);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.bottom</span>(<span class="variable">@px</span>)&#123;</div><div class="line">  <span class="attribute">bottom</span>:unit(<span class="variable">@px</span>/<span class="number">37.5</span>,rem);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.left</span>(<span class="variable">@px</span>)&#123;</div><div class="line">  <span class="attribute">left</span>:unit(<span class="variable">@px</span>/<span class="number">37.5</span>,rem);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.right</span>(<span class="variable">@px</span>)&#123;</div><div class="line">  <span class="attribute">right</span>:unit(<span class="variable">@px</span>/<span class="number">37.5</span>,rem);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.padding</span>(<span class="variable">@tb</span>,<span class="variable">@lr</span>)&#123;</div><div class="line">  <span class="attribute">padding</span>: unit(<span class="variable">@tb</span>/<span class="number">37.5</span>,rem) unit(<span class="variable">@lr</span>/<span class="number">37.5</span>,rem);;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.fl</span>&#123;</div><div class="line">  <span class="attribute">float</span>: left;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.fr</span>&#123;</div><div class="line">  <span class="attribute">float</span>: right;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.clearfix</span>&#123;</div><div class="line">  <span class="attribute">clear</span>: both;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="可复用属性"><a href="#可复用属性" class="headerlink" title="可复用属性"></a>可复用属性</h1><p>提取重复属性，定义一个函数。可在内部和外部调用。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line"><span class="comment">//不会被编译</span></div><div class="line"><span class="selector-tag">btn</span> () &#123;</div><div class="line"><span class="attribute">background</span>: <span class="number">#000</span>;</div><div class="line"><span class="attribute">color</span>: <span class="number">#888</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">header</span> &#123;</div><div class="line"><span class="comment">//内部调用</span></div><div class="line">  <span class="selector-tag">btn</span>;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">footer</span>&#123;</div><div class="line"><span class="comment">// 外部调用</span></div><div class="line">  <span class="selector-tag">div</span> &gt; <span class="selector-tag">btn</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于less的技巧还有很多很多，这里只是简单提了一下。孰能生巧，多用就会了。sass、stylus其实跟less都一样，语法也很相似。当你学会less，你就基本掌握了sass、stylus，何乐而不为呢？</p>
]]></content>
      
        
        <tags>
            
            <tag> css </tag>
            
            <tag> less </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[NBA总决赛G3]]></title>
      <url>/2017/06/08/NBA%E6%80%BB%E5%86%B3%E8%B5%9BG3/</url>
      <content type="html"><![CDATA[<p>今天的比赛可能是整个系列赛最精彩的一场了。双方教练斗智斗勇，场上球员各显神通。最终勇士队以118-113击败骑士队涉险过关。<br><a id="more"></a><br>回到主场，这是骑士必须拿下的比赛，而勇士也是有备而来，双方球员必须使出浑身解数，争取拿下比赛。前俩场，库里和杜兰特发挥特别出色。克莱汤普森由于身担防守欧文的重责，进攻端发挥有所失常。依靠勇士强大的整体，勇士前俩场刀不血刃的拿下了比赛。  </p>
<p>第三场比赛，骑士明显有了针对性的调整，从场上球员的站队以及跑位，可以看到库里明显被夹击了。骑士队的战术执行的很坚决，一方面三分线外夹击库里，一方面协防杜兰特，限制勇士俩大进攻点的发挥。克莱汤普森受益于骑士队的战术，当库里和杜兰特被对方狠狠的盯死的时候，汤普森多出了很多的空位，所以汤普森今天的爆发是意料之中的。  </p>
<p>再说说今天骑士队的詹姆斯，上半场火力全开，得了27分，14投11中，4篮板3助攻。特别是第一节的詹姆斯，10投9中。几乎一个人对抗整支勇士队。真所谓吕布战群英，精彩绝伦。下半场勇士队立马就走出了调整，多次让杜兰特去防守詹姆斯，可是没想到，欧文这时候站了出来，各种不可思议的突破，各种鬼魅的神仙球。借助欧文神奇的发挥，第三节骑士队终于实现了比分的反超。  </p>
<p>进入比赛关键的第四节，勇士队先排上替补阵容，保证主力队员的休息时间。这是骑士队必须拿下的比赛，主力球员是要战斗到最后时刻了。比分一直是骑士领先，勇士队替补阵容很好的完成的战术作用。比赛还剩下最后的6分钟左右的时间时候，科尔令旗一挥，勇士队熟悉的<code>死亡五小</code>上阵。最厉害的总是最后出场的，果不其然，勇士队慢慢的缩小了比分。</p>
<p>直到比赛还剩下48秒左右，勇士队111：113落后骑士队俩分，杜兰特控球从后场到前场，当所有人都以为勇士队会叫暂停布置一次成功的战术都时候。杜兰特做出了一个令人想不到的选择，顶着詹姆斯的防守，双眼紧紧盯着篮筐，无视詹姆斯，仿佛全世界只有篮球、篮筐，还有那投出篮球一刻在空中划过的闪耀全世界的弧线，当球坠入篮筐那一刻，杀神降临，杜兰特归位。在这历史的一刻，杜兰特用行动证明了他的价值，证明了他可能才是这个星球上打篮球最好的人。  </p>
<p>最终比赛的数据：<a href="http://nba.stats.qq.com/nbascore/?mid=1470069" target="_blank" rel="external">腾讯NBA数据库</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[愿世间没有。。。]]></title>
      <url>/2017/05/29/%E6%84%BF%E4%B8%96%E9%97%B4%E6%B2%A1%E6%9C%89.../</url>
      <content type="html"><![CDATA[<p>活了大概五分之一的人生以上，从来没有一天像今天这样的心情。如果可以，愿世间没有。。。<a id="more"></a></p>
<p>我爷爷属牛。原谅我不知道今年多少岁，只是最接近百岁的那一只牛。很多人不理解为什么人会老，为什么人会死。就像人一样，为什么会是人。可能这就是一直以来的不可违背的伦理。这个世界千千万万人，如果有那么一个俩个人，不为人知的一直活在我们不知道的空间里。监视着我们，直到我们快老去，我们快不为人知。那个一直不为人知的一俩个人，会不会出来跟你说：“嘿！欢迎来到不为人知的世界！这个世界无比真挚的欢迎来自人间的你！“。如果存在这样的事情，那么不为人知就显得有一些廉价了。我们都相信这个世界的确有这么一俩个人，谁敢说不是呢？如果可以，愿世间没有这样不为人知的一俩个人！</p>
<p>记得我在很小的时候，我是什么都不懂。每天跟着爷爷，有糖吃，特别喜欢粘着爷爷。农村的街道很宽很干净很少人，爷爷的自行车很高很稳很响亮。”玲玲玲“，那时候的车玲显得格外悦耳，格外动听。我就坐在车头，是那个白白胖胖的无所畏惧的无敌小小子。那时候的天空很蓝，白云很白，清风很轻，人也格外舒坦。爷爷骑着车，在乡间田园的路上，有小草野花，有流水小船，有深处人家。哼着歌，响着铃铛，喀拉拉，无比轻盈的轮滑，留下一道道岁月的痕迹，让我去追寻，去回忆。如果可以，愿世间没有追寻，没有回忆。</p>
<p>不知道我是从什么时候开始懂事，可能是体毛初长的时候，也可能是情窦初开的时候。一瞬间，也可能是所有瞬间堆积成的一瞬间，反正在不知不觉的某一刻，我们就开始懂事了。明白了爸妈为什么早出晚回，明白了爷爷奶奶为什么还下地干活。农村的五伏天，天天热辣，天天背朝黄天。没有空调，没有风扇，只有夏天的树，芭蕉做的扇。我喜欢芭蕉扇，喜欢夏天的树，一直一直。爷爷说，夏天是收割的季节，天气要热些好，稻谷才好晒些，最怕这个季节的风台了。咱们农民是靠天靠地吃饭，要感谢有现在的天和地。我有些懂事了，认为爷爷说的对。如果可以，愿世间没有天地，我们可以靠自己。</p>
<p>后来，我长大了。我也不知道什么时候长大的，可能是第一次失恋，可能是第一次初恋。无所谓了，反正你的年龄决定你长大了。我离开了家，上了高中，集体宿舍。都是农村的娃娃，显得特别好相处。这是我们镇最好的高中，也是我们镇最坏的高中，也是我们镇唯一的高中。我在这里度过了三年，改变了我许多。人都是慢慢变化的，我也是。在这里，有很多学生，我只认识我宿舍的，我班级的，还有一俩个我心底里默默喜欢的女生。我们读书不老好，打篮球却是十分热爱，逃课打篮球是经常的事情。更有甚者，有年级默认的联盟，有球队。这太影响我了，我默默长大了。高考了，为了高考而高考了。老师都说一本是好的，二本也是好的。但是专业呢？没有人敢和你说读那个专业是好的，敷衍一句兴趣吧。导致很多人读了十几年书，专业是最后一刻才确定的，也有乱写的，比如我。那么问题来了，这样往往会出事的，事实却是如此。我很茫。爷爷说，娃娃，没事的，抗日我也抗过了，去吧，河南并不老远！好好读就是了！如果可以，愿世间没有距离，没有远离。</p>
<p>再后来，我上了大学。但是我却没有好好读。或者说，好好读不如读好好。浪费了大把青春时光。想追回，不知谈何说起。我爱我的大学，虽然自知无力去爱。总会有人说重来一次怎样怎样，还是这样。你不是不相信科学，而是有一种力量叫做冥冥之中的注定。失去的就是失去的，也许会回来，也许回不来，而我们还执拗个啥，执拗个啥。放不下的，却是最远久的过。过去的，却是最降近的未来。最悲哀的是，在这最将近的未来，你不知道执拗个啥，执拗个啥！如果可以，愿世间没有失去，唯有珍惜！</p>
<p>端午节，爷爷身体不好，百岁将近。人是不都有这么一刻，年轻的时候不知道为什么，年老的时候也不知道为什么，人就是会这样子！？我们拼搏，我们奋斗，我们努力，我们终究只是时间的产物，一刻一秒，若有若无，化作灰烬。如果可以，愿世间没有时间，只有永恒！</p>
<p>我还是那个我，你也是。只不过我们多了一个理由，去拥有更美好的世界！那就是，如果可以，你也可以！！！</p>
]]></content>
      
        
        <tags>
            
            <tag> -随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES7--大势所趋]]></title>
      <url>/2017/05/26/ES7-%E5%A4%A7%E5%8A%BF%E6%89%80%E8%B6%8B/</url>
      <content type="html"><![CDATA[<p>最快的是，技术的更新；最慢的是，更新的应用。</p>
<p>也许你已经厌烦JavaScript的回调，虽然快，但是异步。<br>老司机可能会发现JavaScript貌似很在意一个问题，那就是如何解决异步。<br><a id="more"></a><br>一开始我们写回调函数callback，总是深深的被包含在花括号中，无法自拔。这种嵌套的结构一来不易于代码的维护，二来容易出错。相信经历过的人都知道。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//伪代码</span></div><div class="line">&#123;&#123;&#123;&#123;callback()&#125;&#125;&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>直到有一天，承诺（promise）出现了，生成器（generator）出现了。这里的promise，让异步可以以同步的方式实现。教程有很多，这里不细讲了，总之写起来很麻烦。反正我是觉得写起来比生成器麻烦。</p>
<p>其实JavaScript的生成器很大程度上借鉴了Python的生成器，学过Python的人都知道。但是生成器不是用来解决异步的，但是生成器却能用来解决异步。生成器更像一种语法糖，把你返回的值存储起来，直到调用才暴露出来，这也是它能解决异步的原因之一。</p>
<p>现在，你去看很多源码的时候，好奇的发现async和await，这俩货究竟是什么东西啊？<br>紧跟标题，大势所趋的ES7。借用koa中最常见的代码块来看<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (ctx.request.path === <span class="string">'/error'</span>) &#123;</div><div class="line">        ctx.response.body = <span class="string">'ERROR page'</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">await</span> next();</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这里的async相当于middleware，await的作用是调用下一个middleware。如果之前对回调了解不是很深刻，可能会比较蒙，await通过next（）调用回调，解决了异步。当然，我在这里解释的也不是很清楚，如果想深入了解，可上<a href="https://github.com/" target="_blank" rel="external">GitHub</a>。</p>
]]></content>
      
        
        <tags>
            
            <tag> ES7 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Google I/O 2017 for front-end development]]></title>
      <url>/2017/05/19/Google-I-O-2017-for-front-end-development/</url>
      <content type="html"><![CDATA[<p>不知道下一年，世界又会是哪个科技引领潮流。</p>
<h1 id="web-component"><a href="#web-component" class="headerlink" title="web component"></a>web component</h1><p>Twitter和来自印度的Ola，现场展示了<code>modern mobile webApp</code>。虽然组件化的框架<code>polymer</code>从15年开始已经发布，但是polymer框架2.0现在才进入预发布状态。<code>work box</code>的出现很大程度上弥补了<code>server work</code>的不足。so will polymer be a competitor to react? 好吧，welcome back  polymer! React is a JavaScript framwork for rendering HTML! React is not certainly not Web Components.<br><a id="more"></a><br>add webApp to home screen, 然后和native app做对比，从数据流量，媒介，手机流畅度等方面介绍webApp。<code>progressive web app</code>越来越受欢迎。未来web领域可能与VR结合，但是未来一起不可预料，又可以想象。</p>
<p><code>front-end developers</code> 现在可以让自己的website试用谷歌的 <code>AMP-bind</code> and <code>PWA</code>接口。这无疑给<code>front-end developer</code>多一种新的选择去构建自己的<code>progressive web app</code>。</p>
<p>看完第一场演讲，深觉印度的IT行业发展之快。感触良多，未来不可预料，又可以想象！</p>
]]></content>
      
        
        <tags>
            
            <tag> Google I/O 2017 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Webpack2.x踩坑与总结]]></title>
      <url>/2017/02/12/webpack-%E4%B9%8B%E8%B7%AF/</url>
      <content type="html"><![CDATA[<p>本地安装npm包后如何在命令行运行</p>
<p>在npm安装包的时候，如果使用全局安装，即npm install <packagename> -g，则在安装完成后可以在终端运行作为命令去运行，但是如果是本地安装的包npm install –save-dev <packagename>，则无法这样直接运行。那么如何运行本地安装的包呢？首先进入项目目录（即package.json所在目录），然后使用以下命令即可运行：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node_modules/.bin/<span class="xml"><span class="tag">&lt;<span class="name">packageName</span>&gt;</span></span></div></pre></td></tr></table></figure></packagename></packagename></p>
<a id="more"></a>
<p>除了可以这样在命令行运行外，还可以在文件中运行<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//index.js</span></div><div class="line"><span class="keyword">let</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line">webpack();</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node index.js</div></pre></td></tr></table></figure>
<p>webpack1.x升级2.x</p>
<p>1.module.loaders改成了module.rules<br>旧的loaders被新的rules取代，后者允许配置loader以及其他更多项。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>: &#123;</div><div class="line"> <span class="attr">loaders</span>: [</div><div class="line"> rules: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</div><div class="line">     <span class="attr">loaders</span>: [</div><div class="line">     use: [</div><div class="line">        &#123;</div><div class="line">          <span class="attr">loader</span>: <span class="string">"style-loader"</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">          <span class="attr">loader</span>: <span class="string">"css-loader"</span>,</div><div class="line">         <span class="attr">query</span>: &#123;</div><div class="line">         <span class="attr">options</span>: &#123;</div><div class="line">            <span class="attr">modules</span>: <span class="literal">true</span></div><div class="line">          &#125;</div><div class="line">      ]</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">      <span class="attr">test</span>: <span class="regexp">/\.jsx$/</span>,</div><div class="line">      <span class="attr">loader</span>: <span class="string">"babel-loader"</span>, <span class="comment">// Do not use "use" here</span></div><div class="line">      options: &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上写法中，Rule.loader是Rule.use: [ { loader } ]的简写。</p>
<p>2.链式调用loaders<br>在webpack1.x中loaders可以链式调用，在2.x中依旧有该特性，使用rule.use配置项，use中设置一个loaders的数组而在1.x中使用!连接各个loader，旧版写法只有在使用旧的module.loaders时有效。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>: &#123;</div><div class="line"> <span class="attr">loaders</span>: &#123;</div><div class="line"> <span class="attr">rules</span>: &#123;</div><div class="line">    <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</div><div class="line">   <span class="attr">loader</span>: <span class="string">"style-loader!css-loader!less-loader"</span></div><div class="line">   use: [</div><div class="line">     <span class="string">"style-loader"</span>,</div><div class="line">     <span class="string">"css-loader"</span>,</div><div class="line">     <span class="string">"less-loader"</span></div><div class="line">   ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.取消在模块中自动添加-loader后缀<br>webpack2.x中不再添加-loader<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>: &#123;</div><div class="line">  <span class="attr">rules</span>: [</div><div class="line">    &#123;</div><div class="line">      <span class="attr">use</span>: [</div><div class="line">       <span class="string">"style"</span>,</div><div class="line">       <span class="string">"style-loader"</span>,</div><div class="line">       <span class="string">"css"</span>,</div><div class="line">       <span class="string">"css-loader"</span>,</div><div class="line">       <span class="string">"less"</span>,</div><div class="line">       <span class="string">"less-loader"</span>,</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据官方说法，做出这样更改的原因是省略-loader会对新手造成误解，所以去掉这个功能，如果想打开这个旧的功能，可以配置resolveLoader.moduleExtensions，但是并不推荐这么做。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">resolveLoader: &#123;</div><div class="line">   <span class="attr">moduleExtensions</span>: [<span class="string">"-loader"</span>]</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>4.使用options配置loader<br>在webpack1.x中可以通过webpack.config.js的自定义属性来配置loader，这在webpack2.x中无法执行<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123; </div><div class="line">  ...</div><div class="line">  module: &#123; </div><div class="line">    <span class="attr">use</span>: [&#123; </div><div class="line">      <span class="attr">test</span>: <span class="regexp">/\.tsx?$/</span>,</div><div class="line">      <span class="attr">loader</span>: <span class="string">'ts-loader'</span></div><div class="line">    &#125;]</div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// does not work with webpack 2</span></div><div class="line">  ts: &#123; <span class="attr">transpileOnly</span>: <span class="literal">false</span> &#125; </div><div class="line">&#125;</div><div class="line"><span class="comment">//webpack2 use options</span></div><div class="line"><span class="built_in">module</span>.exports = &#123; </div><div class="line">  ...</div><div class="line">  module: &#123; </div><div class="line">    <span class="attr">use</span>: [&#123; </div><div class="line">      <span class="attr">test</span>: <span class="regexp">/\.tsx?$/</span>,</div><div class="line">      <span class="attr">loader</span>: <span class="string">'ts-loader'</span></div><div class="line">      options:  &#123; <span class="attr">transpileOnly</span>: <span class="literal">false</span> &#125;</div><div class="line">    &#125;]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>webpack插件的使用</p>
<p>webpack-dev-server1.x升级2.x</p>
<p>1.在CLI使用的时候，–inline默认开启，无需在输入命令时添加</p>
<p>2.删除contentBase用proxy代替</p>
<p>3.减少控制台无用输出，在1.x中，当我们停掉服务器后，控制台会一直输出错误信息，但是在2.x中只会输出[WDS] Disconnected!</p>
<p>extract-text-webpack-plugin</p>
<p>在使用webpack将vue_spa打包后，并不会出现css，因为css被打包入build.js，如果从vue组件中抽离出css，需要安装插件extract-text-webpack-plugin，在使用的时候需要配合v2版本的才可以使用（如果使用了webpack2，则对应的插件版本都需要用v2版本）。具体配置如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>:&#123;</div><div class="line">  <span class="attr">rules</span>:[</div><div class="line">    &#123;</div><div class="line">      <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>,</div><div class="line">      <span class="attr">loader</span>: <span class="string">'vue'</span>,</div><div class="line">      <span class="attr">options</span>: &#123;</div><div class="line">        <span class="attr">loaders</span>:&#123;</div><div class="line">          <span class="attr">css</span>: extractTextPlugin.extract(&#123;</div><div class="line">            <span class="attr">loader</span>: <span class="string">'css-loader'</span>,</div><div class="line">            <span class="attr">fallbackLoader</span>: <span class="string">'vue-style-loader'</span></div><div class="line">          &#125;)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;,</div><div class="line"><span class="attr">plugins</span>: [</div><div class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</div><div class="line">  <span class="keyword">new</span> extractTextPlugin(&#123;</div><div class="line">    <span class="attr">filename</span>:<span class="string">'/style.css'</span>,</div><div class="line">    <span class="attr">allChunks</span>:<span class="literal">true</span></div><div class="line">  &#125;)</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>在options中：<br>options.loader: string | object | loader[] (必填项) 这里的 loader(s) 用于将资源转换为css导出模块<br>options.fallbackLoader: string | object | loader[] 当css没有被导出的时候这里的 loader(s) 会被使用 （即当在plugins模块中设置allChunks:false的时候）<br>在plugins中：<br>filename：可以设置被导出的css文件的路径以及名字<br>allChunks：从所有附加块中提取（默认情况下，它只从初始块中提取）<br>html-webpack-plugin<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">plugins: [</div><div class="line">  <span class="keyword">new</span> htmlWwebpackPlugin(&#123;</div><div class="line">    <span class="attr">filename</span>: <span class="string">'assets/admin.html'</span></div><div class="line">  &#125;),</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>title：用于生成文档的document<br>filename：要注入的html文件，默认为index.html。可以自定义（例如：assets/admin.html）<br>inject：<br>true | ‘head’ | ‘body’ | false<br>将资源注入所给的template或templateContent，当设置为 true 或者 ‘body’，所有的资源会被注入到body底部。而head则会将js放到headelement<br>favicon: 在输出的html中添加favicon<br>hash: true | false 如果为true，则将一个唯一的webpack编译散列附加到所有包含的脚本和CSS文件。这对缓存清除很有用。<br>cache: true | false 如果为true（默认），尝试仅在更改后才发出文件。<br>是否要更换preset？<br>webpack2.x默认支持es6的模块，所以在编译时候没有必要将它们先转换为CommonJS模块再处理，所以在github中出现了babel-preset-es2015-webpack，但是这个模块我在使用的时候出现了Cannot remove ‘babel-plugin-transform-es2015-modules-commonjs’ from the plugin list.的问题，根据babel-preset-es2015-webpack中的叙述以及issues#14可知，babel-preset-es2015已经支持不转换模块中的import和export，只需要设置.babelrc<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"presets"</span>: [</div><div class="line">        [</div><div class="line">            <span class="string">"es2015"</span>,</div><div class="line">            &#123;</div><div class="line">                <span class="string">"modules"</span>: <span class="literal">false</span></div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用CommonsChunkPlugin将第三方库单独打包</p>
<p>很多情况下我们会引入第三方库，但是默认情况下，webpack会将第三方库与我们自己写的js一起打包进生成文件中，为了让第三方库与我们自己写的js分开，webpack2.x内置一个插件CommonsChunkPlugin，它可以让webpack在打包的时候将我们自己写的js与第三方库分开，具体用法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">entry:&#123;</div><div class="line">  <span class="attr">app</span>: <span class="string">'./src/main.js'</span>,</div><div class="line">  <span class="attr">vendor</span>: [</div><div class="line">    <span class="string">'lodash'</span>,</div><div class="line">    <span class="string">'axios'</span>,</div><div class="line">    <span class="string">'vue'</span>,</div><div class="line">    <span class="string">'vue-router'</span></div><div class="line">  ]</div><div class="line">&#125;,</div><div class="line"><span class="attr">output</span>: &#123;</div><div class="line">  <span class="attr">path</span>: path.resolve(__dirname + <span class="string">'/dist'</span>),</div><div class="line">  <span class="attr">publicPath</span>: <span class="string">'/dist'</span>,</div><div class="line">  <span class="attr">filename</span>: <span class="string">'[name].js'</span></div><div class="line">&#125;,</div><div class="line"><span class="attr">plugins</span>: [</div><div class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">      <span class="attr">name</span>:<span class="string">'vendor'</span></div><div class="line">    &#125;)</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>这里需要注意一点，这里在在输出的时候需要使用filename: ‘[name].js’，否则会报错。</p>
<p>原文出处：<a href="http://mrzhang123.github.io/2017/02/07/webpack2/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">Webpack2.x踩坑与总结</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript简明教程（全）]]></title>
      <url>/2016/12/29/javaScript%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B%EF%BC%88%E5%85%A8%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>JavaScript与Java没有半毛钱关系，网景公司员工Brendan Eich用了10天时间设计了JavaScript语言。</p>
<h1 id="JavaScript的范围"><a href="#JavaScript的范围" class="headerlink" title="JavaScript的范围"></a>JavaScript的范围</h1><p><strong>JavaScript的范围：BOM + DOM + ECMAScript</strong></p>
<h2 id="BOM简单说明"><a href="#BOM简单说明" class="headerlink" title="BOM简单说明"></a>BOM简单说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">BOM即Browser Object Mode,浏览器对象模型。</div><div class="line">BOM提供了独立于内容而与浏览器窗口进行交互的对象。</div><div class="line">BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。</div><div class="line">因为BOM主要用于管理窗口与窗口之间的通信，因此其核心对象是window。</div><div class="line">BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C。</div><div class="line">BOM结构体系</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="DOM简单说明"><a href="#DOM简单说明" class="headerlink" title="DOM简单说明"></a>DOM简单说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">DOM即Document Object Model，文档对象模型。</div><div class="line">当网页被加载时，浏览器会创建页面的文档对象模型，即DOM。</div><div class="line">DOM(文档对象模型)被构造为对象的树。</div><div class="line">DOM由一系列相关的对象构成，引申为Document对象。</div><div class="line">DOM的标准化组织是W3C。</div></pre></td></tr></table></figure>
<h2 id="ECMAScript简单说明"><a href="#ECMAScript简单说明" class="headerlink" title="ECMAScript简单说明"></a>ECMAScript简单说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ECMAScript指代JavaScript的核心语法。</div><div class="line">JavaScript 由 Brendan Eich 发明。</div><div class="line">JavaScript于1995 年出现在 Netscape 中于 1997 年被 ECMA（一个标准协会）采纳。</div><div class="line">语法核心：</div><div class="line">变量</div><div class="line">基本数据类型</div><div class="line">对象类型</div><div class="line">结构(循环|条件|判断)</div><div class="line">面向对象</div></pre></td></tr></table></figure>
<h1 id="javascript语法"><a href="#javascript语法" class="headerlink" title="javascript语法"></a>javascript语法</h1><h2 id="javascript数据类型"><a href="#javascript数据类型" class="headerlink" title="javascript数据类型"></a>javascript数据类型</h2><p>基本类型（简单数据类型）</p>
<pre><code>* string
* number
* boolean
* undefined
* null
</code></pre><p>复杂类型（复杂数据类型）</p>
<pre><code>* Object
* Array
* Date
* RegExp
* Function
* String
* Number
* Boolean
* null
* Math
</code></pre><h2 id="javascript部分操作符的说明"><a href="#javascript部分操作符的说明" class="headerlink" title="javascript部分操作符的说明"></a>javascript部分操作符的说明</h2><h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h3><p>只能够操作一个值的操作符叫做一元操作符。<br>① 递增和递减操作符:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[<span class="number">01</span>] 前置型,递增和递减操作在包含他们的语句被求值之前就执行。</div><div class="line">[<span class="number">02</span>] 后置型,递增和递减操作在包含他们的语句被求值之后才执行。</div><div class="line"><span class="keyword">var</span> num1  = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> num2  = <span class="number">20</span>;</div><div class="line"><span class="keyword">var</span> num3 = --num1 + num2;	<span class="comment">//21</span></div><div class="line"><span class="keyword">var</span> num4 = num1 + num2;		<span class="comment">//21</span></div><div class="line"><span class="keyword">var</span> num1  = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> num2  = <span class="number">20</span>;</div><div class="line"><span class="keyword">var</span> num3 = num1-- + num2;	<span class="comment">//22</span></div><div class="line"><span class="keyword">var</span> num4 = num1 + num2;		<span class="comment">//21</span></div></pre></td></tr></table></figure></p>
<p>② 一元加和减操作符:<br>一元加操作符对结果不会有任何的影响。<br>一元减操作符主要用于表示负数。</p>
<h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><p>01 按位非(NOT):使用 ~ 表示，执行按位非的结果就是返回数值的反码。<strong>操作数的负值减去1</strong>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="number">25</span>;</div><div class="line"><span class="keyword">var</span> num2 = -num1 - <span class="number">1</span>;	<span class="comment">//-26</span></div><div class="line">consol.log(~num1)		<span class="comment">//-26</span></div></pre></td></tr></table></figure></p>
<p>02 按位与(AND):使用&amp;表示，操作两个操作数。<strong>只要有0就为0</strong>。<br>03 按位或(OR):使用|表示，操作两个操作数。<strong>只要有1就为1</strong>。<br>04 按位异或(XOR):使用 ^ 表示，操作两个操作数。<strong>相同则为0，不同则为1</strong>。<br>05 左移|右移(|有符号|无符号)。</p>
<h3 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h3><p> 布尔操作符一共有三个，分别是：非、与、或。<br> 01 逻辑非，符号：！<br> 说明：取反，可应用于任何值，！！相当于没有操作。<br>02 逻辑与，符号：&amp;&amp;<br> 说明：两个值都为真的时候，结果为真。属于短路操作，如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。<br>03 逻辑或，符号：||<br>说明：两个值只要有一个为真，那么结果为真。属于短路操作，如果第一个操作数为真，那么就不会再对第二个操作数求值了。<br>技巧：可以利用逻辑或短路操作的特点来避免为变量赋null或undefined值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObject = refObject || backupObject;</div><div class="line"><span class="comment">//如果refObject的值不是null,那么它的值将被赋值给myObject</span></div><div class="line"><span class="comment">//如果是null,那么就将backupObject的值赋值给myObject。</span></div></pre></td></tr></table></figure></p>
<h3 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h3><p>乘 *<br>除 /<br>模 %</p>
<h3 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h3><p>加 +<br>减 -<br> <strong>说明：上述五种操作符在操作数为非数值的时候内部会执行自动的类型转换。</strong></p>
<h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>大于 &gt;<br>小于 &lt;<br>小于等于 &lt;=<br>大于等于 &gt;=<br>说明：返回布尔类型的值，要么为false，要么为true。</p>
<h3 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h3><p>01 相等和不相等[先转换再比较]，符号是 == 和！=<br><strong>比较的规则</strong>:<br>[01] 如果操作数中有布尔值，则先转换为数值再比较。<br>[02] 如果是字符串和数值比较，则先将字符串转换为数值再比较。<br>[03] 如果是对象和其他类型的值比较，则先调用对象的valueOf方法，然后用得到的基本类型值去比较。<br>[04] null和undefined是相等的。<br>[05] NaN和NaN不相等。<br>[06] 如果两个操作符都是对象，则比较他们是不是同一个对象，如果指向的是同一个对象则返回true，否则返回false。<br>02 全等和不全等[仅比较不转换],符号是<code>===</code>和<code>!==</code><br><strong>比较的规则</strong>:<br>[01] null和undefined是不全等的，因为它们是不同类型的值。<br>[02] 类型相同，且值相等，则返回true，否则返回false。</p>
<h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><p>符号：表达式1 ? 字面量1 ：字面量2<br>说明：如果表达式1的结果为true，则使用字面量1，否则使用字面量2。</p>
<h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h3><p>符号：=、+=、-=、*=、&lt;&lt;=等等<br>说明：使用赋值操作符对性能而言，没有任何的提升，只是简化了赋值操作而已。</p>
<h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><p><strong>01 值类型和引用类型简单说明</strong><br>值类型主要有：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">数值</div><div class="line">字符串</div><div class="line">布尔类型</div><div class="line"><span class="literal">undefined</span></div><div class="line"><span class="literal">null</span></div></pre></td></tr></table></figure></p>
<p>引用类型主要有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">对象（Object类型）</div><div class="line">数组（Array）</div><div class="line">函数 (Function)</div></pre></td></tr></table></figure></p>
<p><strong>值类型</strong>：保存为简单的数据值，赋值只是简单的数据值的复制<br><strong>引用类型</strong>:保存为对象，其本质是指向内存位置的引用(地址)，赋值是对地址的复制<br><strong>值类型代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> num2 = num1;    <span class="comment">//把num1的值复制一份给num2,num1和num2的值相等,除此之外没有任何其他关系</span></div><div class="line"><span class="built_in">console</span>.log(num1,num2);     <span class="comment">//10,10</span></div><div class="line"><span class="built_in">console</span>.log(num1 == num2);  <span class="comment">//true</span></div><div class="line">num2 = <span class="number">20</span>;          <span class="comment">//修改num2的值为20,不会对num1产生任何的影响</span></div><div class="line"><span class="built_in">console</span>.log(num1,num2);     <span class="comment">//10,20</span></div><div class="line"><span class="built_in">console</span>.log(num1 == num2);  <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p><strong>引用类型代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> arr2 = arr1;</div><div class="line"><span class="built_in">console</span>.log(arr1,arr2);             <span class="comment">//[1,2,3],[1,2,3]</span></div><div class="line"><span class="built_in">console</span>.log(arr1 == arr2);          <span class="comment">//true</span></div><div class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="built_in">console</span>.log(arr3);                  <span class="comment">//[1,2,3]</span></div><div class="line"><span class="built_in">console</span>.log(arr1 == arr3,arr2 == arr3); <span class="comment">//false,false</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 代码说明:</div><div class="line"> * arr1和arr2在比较的时候,值相等(都是[1,2,3]),且引用相等(都指向堆中同一块数据),因此arr1和arr2相等</div><div class="line"> * arr3和arr1以及arr2比较的时候,值相等([1,2,3]),但是引用不相等(arr3指向的是堆中另外一块数据),因此不等</div><div class="line"> * 总结:引用类型在比较相等的时候,只有值和引用都相等才相等</div><div class="line"> * */</div></pre></td></tr></table></figure></p>
<p><strong>02 值类型和引用类型的赋值</strong><br>赋值操作(=):把当前变量存储的值复制一份给接收的变量。<br>值类型的赋值:把当前变量存储的值(具体的数据)复制一份给接收的变量。<br>引用类型的赋值:把当前变量存储的值(具体数据的引用即地址)复制一份给接收的变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//引用类型使用注意</span></div><div class="line">  <span class="built_in">console</span>.log(arr1,arr2);         <span class="comment">//[1,2,3],[1,2,3];</span></div><div class="line">  <span class="built_in">console</span>.log(arr1 == arr2);      <span class="comment">//true</span></div><div class="line">  arr1.push(<span class="number">4</span>);</div><div class="line">  <span class="built_in">console</span>.log(arr1,arr2);         <span class="comment">//[1,2,3,4],[1,2,3,4]</span></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 代码说明:因为arr1和arr2内部的引用指向的是同一块数据,所以修改了arr1会对arr2也产生影响</div><div class="line">   * */</div></pre></td></tr></table></figure></p>
<p><strong>03 值类型和引用类型作为函数参数处理</strong><br><code>形参</code>:占位用的参数,用来接收数据的参数而已。<br><code>实参</code>:实际传递的参数。<br><code>函数的调用</code>:在函数调用的时候,函数默认会把实参的值赋值给形参。<br><strong>值类型作为参数</strong>：在函数内部对形参变量进行修改不会影响到实参的值。<br><strong>引用类型作为参数</strong>：在函数内部对形参变量进行修改会影响到实参的值，因为他们的引用指向同一个对象。<br><strong>04 值类型和引用类型的相关图示</strong><br><strong>基本类型的赋值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str1 = <span class="string">"hello zhangsan"</span>;</div><div class="line"><span class="keyword">var</span> str2 = str1;</div></pre></td></tr></table></figure></p>
<p><img src="/assets/img/03.png" alt="p1对象的存储结构图"><br><strong>引用类型的结构和赋值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> car = &#123;</div><div class="line">    <span class="attr">color</span>:<span class="string">"黑色"</span>,</div><div class="line">    <span class="attr">number</span>:<span class="string">"B99"</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> p1 = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"王宝宝"</span>,</div><div class="line">    <span class="attr">age</span>:<span class="number">30</span>,</div><div class="line">    <span class="attr">car</span>:car</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><img src="/assets/img/01.png" alt="p1对象的存储结构图"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">       <span class="attr">name</span>:<span class="string">"lisi"</span>,</div><div class="line">       <span class="attr">age</span>:<span class="number">18</span></div><div class="line">   &#125;;</div><div class="line">   <span class="keyword">var</span> obj2 = obj1;</div></pre></td></tr></table></figure></p>
<p><img src="/assets/img/02.png" alt="obj1和obj2的存储结构图"></p>
<h2 id="对象的动态特性"><a href="#对象的动态特性" class="headerlink" title="对象的动态特性"></a>对象的动态特性</h2><p>在js中可以动态的对对象属性进行增加、修改和删除；<br><strong>代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 创建对象</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"刘德华"</span>,</div><div class="line">    <span class="attr">age</span>:<span class="number">60</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//02 动态的为对象添加属性</span></div><div class="line">obj.height = <span class="string">"180cm"</span>;</div><div class="line"><span class="built_in">console</span>.log(obj.height);</div><div class="line"><span class="comment">//03 动态的为对象添加方法</span></div><div class="line">obj.maiMeng = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"华仔会卖萌噢"</span>);</div><div class="line">&#125;;</div><div class="line">obj.maiMeng();</div><div class="line"><span class="comment">//04 修改属性的值:如果设置的属性以前不存在,那么就是添加,如果设置的属性已经存在了,那么就是修改</span></div><div class="line">obj.name = <span class="string">"王宝强"</span>;</div><div class="line"><span class="built_in">console</span>.log(obj.name)</div><div class="line"><span class="comment">//05 删除属性</span></div><div class="line"><span class="keyword">delete</span> obj.name;</div><div class="line"><span class="built_in">console</span>.log(obj.name);  <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p><strong>访问对象的方法</strong><br>01 可以使用点语法访问<br>02 可以使用[]语法访问，注意对象的属性必须是字符串</p>
<h2 id="关键字in和delete的使用"><a href="#关键字in和delete的使用" class="headerlink" title="关键字in和delete的使用"></a>关键字in和delete的使用</h2><p><strong>01 in关键字</strong><br>01 判断属性是否存在于对象中，注意所有的key都是字符串<br>02 for in循环中  遍历对象的 键<br><strong>代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"张三"</span>,</div><div class="line">    <span class="attr">age</span>:<span class="number">18</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">for</span>(k <span class="keyword">in</span> obj)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">console</span>.log(k,obj[k]);</div><div class="line">&#125;</div><div class="line"><span class="comment">//检测obj对象中是否存在name这个属性</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> obj);</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：in关键字操作数组的时候检测的是索引值并非数组元素<br><strong>02 delete关键字</strong><br>01 删除对象的属性<br>02 删除未使用var声明的变量<br>03 返回值为boolean类型，true则表示是否删除成功<br><strong>注意</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">01 删除的属性如果不存在，返回true</div><div class="line">02 删除的如果是原型中的属性，返回true 但是删除不成功</div></pre></td></tr></table></figure></p>
<h2 id="循环和分支"><a href="#循环和分支" class="headerlink" title="循环和分支"></a>循环和分支</h2><p><strong>循环结构</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span></div><div class="line"><span class="keyword">while</span></div><div class="line"><span class="keyword">do</span>...while</div><div class="line"><span class="keyword">for</span>..in</div></pre></td></tr></table></figure></p>
<p><strong>分支结构</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>...else..</div><div class="line">swith..case</div></pre></td></tr></table></figure></p>
<p><strong>break和continue对比</strong><br>break:终止循环，循环中后面的代码不再执行<br>continue:结束当前循环，循环后面的代码不再执行，继续下一次循环</p>
<h2 id="调试工具的使用"><a href="#调试工具的使用" class="headerlink" title="调试工具的使用"></a>调试工具的使用</h2><p><strong>开启调试窗口</strong><br>    windows 平台: f12; Mac: option+command+i;<br><strong>调试窗口介绍</strong><br>    指针: 选择页面中的元素<br>    手机: 使用移动端界面调试<br>    Elements: 查看页面 DOM 树<br>    Console: 控制台(注意, 控制台与该页面是一个整体, 在控制台中的任何操作, 会影响到页面)<br>    Source: 代码调试<br><strong>调试工具的使用</strong><br>    逐过程运行, 一次运行一个函数<br>    单步运行(逐步运行), 一次运行一句, 如果是函数, 进入函数体内运行<br>    继续运行. 从当前状态运行下去, 直到出现断点, 如果没有断点则运行结束<br><strong>设置断点技巧</strong><br>    逐步与逐过程混合<br>    断点加继续运行<br>    条件断点(右键添加 add contitional breakpoint)<br><strong>利用 watch 监视窗口可以查看对象成员</strong></p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><strong>常见的异常分类</strong><br>运行环境的多样性导致的异常（浏览器）<br>语法错误，代码错误<br>异常的特征:一旦代码出现异常，后面的代码就不会再执行<br><strong>异常捕获</strong><br>使用try-catch语句捕获异常<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="comment">//这里写可能出现异常的代码</span></div><div class="line">&#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">    <span class="comment">//这里的e就是捕获的异常对象</span></div><div class="line">    <span class="comment">//可以在这里写，出现异常后的处理代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>异常捕获语句执行的过程为：<br>01 代码正常运行, 如果在try中出现了错误, try 里面出现错误的语句后面的代码都不再执行, 直接跳转到 catch 中<br>02 在catch中处理错误信息<br>03 继续执行后面的代码<br>04 如果 try 中没有出现错误, 那么不走 catch 直接执行后面的代码<br>捕获异常的优点：通过try-catch语句进行异常捕获之后，代码将会继续执行，而不会中断。<br>注意：语法错误异常用try-catch语句无法捕获，因为在预解析阶段，语法错误会直接检测出来，而不会等到运行的时候才报错。<br><strong>try..catch使用示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 try ... catch结构的使用</span></div><div class="line"><span class="comment">//a();  若直接调用则爆出:Uncaught ReferenceError: a is not defined错误</span></div><div class="line"><span class="comment">//在开发中,我们对于可能会报错或者是发生异常的代码用try结构进行处理</span></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    a();    <span class="comment">//如果发生异常,那么至少不会到正程序中断</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(e)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//如果try语句中发生了异常,那么会执行此处的代码块</span></div><div class="line">    <span class="comment">//参数e.为具体的异常信息,可以打印进行查看</span></div><div class="line">    <span class="built_in">console</span>.log(e);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionTest</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"functionTest"</span>);</div><div class="line">&#125;;</div><div class="line">functionTest();</div><div class="line"><span class="comment">//结论:使用try...catch结构,如果发生了异常,那么不会影响后面代码的执行,且我们可以在发生异常信息之后做出具体的处理</span></div></pre></td></tr></table></figure></p>
<p><strong>手动抛出异常</strong><br>案例：自己写的一个函数，需要一个参数，如果用户不传参数，此时想直接给用户抛出异常，就需要了解如何抛出异常。<br>抛出异常使用throw关键字，语法如下：<br>手动抛出异常信息（字符串）:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="comment">//a();    //如果发生异常,那么至少不会到正程序中断</span></div><div class="line">    <span class="comment">//不使用系统默认的异常信息,尝试手动抛出</span></div><div class="line">    <span class="keyword">throw</span> <span class="string">"对不起,您调用了尚未定义的方法"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(e)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//如果try语句中发生了异常,那么会执行此处的代码块</span></div><div class="line">    <span class="comment">//参数e.为具体的异常信息,可以打印进行查看</span></div><div class="line">    <span class="built_in">console</span>.log(e);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionTest</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"functionTest"</span>);</div><div class="line">&#125;;</div><div class="line">functionTest();</div></pre></td></tr></table></figure></p>
<p>手动抛出异常信息（对象）:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="comment">//a();    //如果发生异常,那么至少不会到正程序中断</span></div><div class="line">    <span class="comment">//不使用系统默认的异常信息,尝试手动抛出</span></div><div class="line">    <span class="keyword">throw</span> &#123;</div><div class="line">        <span class="attr">errMsg</span>:<span class="string">"具体的错误信息提示"</span>,</div><div class="line">        <span class="attr">errCode</span>:<span class="string">"指定错误类型的代号,如1001等"</span></div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(e)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//如果try语句中发生了异常,那么会执行此处的代码块</span></div><div class="line">    <span class="comment">//参数e.为具体的异常信息,可以打印进行查看</span></div><div class="line">    <span class="built_in">console</span>.log(e);</div><div class="line">    <span class="comment">//在try语句中抛出的错误信息是什么,那么得到的异常信息就是什么</span></div><div class="line">    <span class="comment">//如果抛出的是字符串,那么得到的就是字符串</span></div><div class="line">    <span class="comment">//如果抛出的是对象,那么此处得到的就是对象</span></div><div class="line">    <span class="built_in">console</span>.log(e.errMsg);</div><div class="line">    <span class="built_in">console</span>.log(e.errCode);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionTest</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"functionTest"</span>);</div><div class="line">&#125;;</div><div class="line">functionTest();</div></pre></td></tr></table></figure></p>
<p><strong>异常捕获语句的完整模式</strong><br>异常捕获语句的完整模式为try-catch-finally<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="comment">//在执行的时候可能发生异常的代码</span></div><div class="line">    b();</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (e)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//如果try代码块中的代码在执行中发生了异常,那么就会执行该代码块的代码</span></div><div class="line">    <span class="comment">//通过打印e对象可以查看具体的异常信息</span></div><div class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//打印异常信息</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">//不论try语句中的代码是否会发生异常,都一定会执行此处的代码块</span></div><div class="line">    <span class="comment">//一般在前端开发中很少使用,常用语后台开发的资源释放工作</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"无论如何总要执行的代码"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>finally中的代码，不管是否发生异常，都会执行。一般用在后端语言中，用来释放资源，JavaScript中很少会用到。</p>
<h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><p>获取元素操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getElementById</div><div class="line">getElementsByTagName</div><div class="line">getElementsByClassName</div></pre></td></tr></table></figure></p>
<p>元素节点操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">appendChild</div><div class="line">insertBefore</div><div class="line">removeChild</div><div class="line">replaceChild</div><div class="line">cloneNode</div><div class="line">createElement</div><div class="line">createTextNode（创建文本节点）</div></pre></td></tr></table></figure></p>
<p>属性节点操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getAttribute</div><div class="line">setAttribute</div><div class="line">removeAttribute</div></pre></td></tr></table></figure></p>
<p>常用DOM属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">className</div><div class="line">innerHTML</div><div class="line">innerText/textContent value</div><div class="line">children</div></pre></td></tr></table></figure></p>
<p><strong>代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//0 获取页面中指定的标签,并设置其样式</span></div><div class="line">    <span class="keyword">var</span> divID = <span class="built_in">document</span>.getElementById(<span class="string">"divId"</span>);</div><div class="line">    divID.style.backgroundColor = <span class="string">"pink"</span>;</div><div class="line">    divID.style.height = <span class="string">"40px"</span>;</div><div class="line">    divID.style.width = <span class="string">"200px"</span>;</div><div class="line">    <span class="comment">//01 创建新的标签</span></div><div class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">    <span class="comment">//02 设置标签的样式</span></div><div class="line">    div.style.backgroundColor = <span class="string">"red"</span>;</div><div class="line">    div.style.height = <span class="string">"100px"</span>;</div><div class="line">    div.style.width = <span class="string">"300px"</span>;</div><div class="line">    div.style.fontSize = <span class="string">"20"</span>;</div><div class="line">    <span class="comment">//03 设置标签的内容</span></div><div class="line">    div.innerText = <span class="string">"这是一个自己创建的标签"</span>;</div><div class="line">    <span class="comment">//04 把标签插入到页面中</span></div><div class="line">    <span class="built_in">document</span>.body.appendChild(div);</div></pre></td></tr></table></figure></p>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><blockquote>
<p>面向对象方法被人谈论了二十多年了，直到今天，我们还一直在谈对象。</p>
</blockquote>
<h2 id="面向层过程和面向对象编程"><a href="#面向层过程和面向对象编程" class="headerlink" title="面向层过程和面向对象编程"></a>面向层过程和面向对象编程</h2><p>01 面向对象编程和面向过程编程是一种编程思想,和具体的语言关系不大。<br>02 面向过程编程和面向对象编程的主要区别<br><!-- more --><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">面向过程编程:</div><div class="line">     关注点在于解决问题需要的每一个详细的步骤</div><div class="line">     示例:</div><div class="line">         自己洗衣服的过程</div><div class="line">         ① 收集需要洗的脏衣服</div><div class="line">         ② 准备洗衣粉、洗衣液等</div><div class="line">         ③ 把衣服放到一个盆里</div><div class="line">         ④ 接水</div><div class="line">         ⑤ 把洗衣粉放到盆里</div><div class="line">         ⑥ 摩擦,摩擦,不断的摩擦</div><div class="line">         ⑦ 把洗好的衣服用清水冲洗干净</div><div class="line">         ⑧ 尽量把把洗好的衣服的水分拧干</div><div class="line">         ⑨ 晾晒</div><div class="line"> 面向对象编程:</div><div class="line">     关注点在于解决问题需要的对象身上</div><div class="line">     示例:</div><div class="line">         使用洗衣机洗衣服的过程</div><div class="line">         ① 收集需要洗的脏衣服</div><div class="line">         ② 找到合适的洗衣机</div><div class="line">         ③ 设定洗衣服和烘干的程序</div></pre></td></tr></table></figure></p>
<p>03 面向过程和面向对象他们的区别就类似于自己洗衣服和使用洗衣机洗衣服|自己做饭吃和去餐馆吃饭</p>
<h2 id="面向对象编程的相关概念"><a href="#面向对象编程的相关概念" class="headerlink" title="面向对象编程的相关概念"></a>面向对象编程的相关概念</h2><p>01 对象<br>    什么是对象? 所有的一切都是对象,在开发中有一项重要的工作就是对象的划分。一般来说,我们所指的对象是某个具体的事物,而非泛泛的类别。<br>02 对象的特征(静态描述信息)<br>    所谓特征就是一些特定的描述信息<br>    如:学生(性别、年龄、班级、专业、籍贯、家庭住址)<br>    如:汽车(颜色、车牌、品牌、价格等)<br>03 对象的行为(动态特性)<br>    如:人(吃饭、睡觉、玩游戏、奔跑、运动等)<br>    如:狗(吃、睡、咬人、叫、流口水)<br>04 js中的对象<br>    键-值对(key-value)的集合。<br>05 现实生活中的对象和js对象的对应关系<br>    静态的描述信息 - js对象中的属性(属性就是定义在对象内部的变量)<br>    动态的行为特征 - js对象中的方法(方法就是定义在对象内部的函数)<br>06 代码示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">var</span> zhangsan = &#123;</div><div class="line">            <span class="attr">name</span>:<span class="string">"张三"</span>,</div><div class="line">            <span class="attr">sex</span>:<span class="string">"男"</span>,</div><div class="line">            <span class="attr">age</span>:<span class="number">18</span>,</div><div class="line">            <span class="attr">address</span>:<span class="string">"天上人间1号公馆"</span>,</div><div class="line">            <span class="attr">eat</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'能吃'</span>);</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">sleep</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"能睡"</span>);</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">say</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"能说话"</span>);</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">run</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"能运动"</span>);</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">song</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"能唱歌"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//打印对象的属性并调用相关的方法</span></div><div class="line"><span class="built_in">console</span>.log(zhangsan.name,zhangsan.age,zhangsan.address);</div><div class="line">        zhangsan.say();</div><div class="line">        zhangsan.sleep();</div></pre></td></tr></table></figure></p>
<h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><p>面向对象的三大特性:封装、继承、多态<br>01 封装:复用|信息隐蔽<br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 封装的简单说明</span></div><div class="line"><span class="comment">//001 观察以下杂乱无关的语句,它们仅仅只是一堆无意义的全局变量</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"乘风波浪会有时"</span>;</div><div class="line"><span class="keyword">var</span> actors = [<span class="string">"彭于晏"</span>,<span class="string">"邓超"</span>];</div><div class="line"><span class="keyword">var</span> showTime = <span class="string">"2016-1-28 - 2016-2-28"</span>;</div><div class="line"><span class="keyword">var</span> director = <span class="string">"韩寒"</span>;</div><div class="line"><span class="keyword">var</span> type = <span class="string">"喜剧"</span>;</div><div class="line"><span class="keyword">var</span> play = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//播放......</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//002 把上面的变量封装到对象中(更具有意义)</span></div><div class="line"><span class="keyword">var</span> film  = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"乘风破浪会有时"</span>,</div><div class="line">    <span class="attr">actors</span>:[<span class="string">"彭于晏"</span>,<span class="string">"邓超"</span>],</div><div class="line">    <span class="attr">showTime</span>:<span class="string">"2016-1-28 - 2016-2-28"</span>,</div><div class="line">    <span class="attr">director</span>:<span class="string">"韩寒"</span>,</div><div class="line">    <span class="attr">type</span>:<span class="string">"喜剧"</span>,</div><div class="line">    <span class="attr">play</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//播放......</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>02 继承:获取已经存在的对象已有属性和方法的一种方式(获取他人已有财富和资源的一种方式)。<br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//继承的简单示例</span></div><div class="line"><span class="comment">//001 创建一个空的对象</span></div><div class="line"><span class="keyword">var</span> nullObj = &#123;&#125;;</div><div class="line"><span class="comment">// 上面的对象film拥有了很多的属性和方法</span></div><div class="line"><span class="comment">//002 设法让nullObj拥有film中所有的属性和方法</span></div><div class="line"><span class="comment">//方法一:自己重新写一遍</span></div><div class="line"><span class="comment">//方法二:通过某种方式来获得,比如遍历该对象,然后完成赋值</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> film)</div><div class="line">&#123;</div><div class="line">    nullObj[k] = film[k];</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> nullObj)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">console</span>.log(nullObj[k]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>03 多态(polymorphism)<br>    多态:polymorphism = poly(复数) + morph(形态) + ism<br>    多用于强类型语言中，JavaScript具备与生俱来的多态特性。<br>    多态表现为:<br>        ① 同一操作,作用于不同的对象,会产生不同的解释和行为。<br>        ② 隐藏不同。</p>
<h1 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h1><h2 id="字面量方式创建对象"><a href="#字面量方式创建对象" class="headerlink" title="字面量方式创建对象"></a>字面量方式创建对象</h2><p>基本写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span>  book1 = &#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"声名狼藉者的生活"</span>,</div><div class="line">        <span class="attr">price</span>:<span class="number">42.00</span>,</div><div class="line">        <span class="attr">author</span>:<span class="string">"福柯"</span>,</div><div class="line">        <span class="attr">press</span>:<span class="string">"北京大学出版社"</span>,</div><div class="line">        <span class="attr">read</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"我的书名为:声名狼藉者的的生活,作者为福柯...."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>存在的问题<br>[01] 代码复用性差<br>[02] 如果要创建大量的同类型对象，则需要些大量重复性代码</p>
<h2 id="内置构造函数创建对象"><a href="#内置构造函数创建对象" class="headerlink" title="内置构造函数创建对象"></a>内置构造函数创建对象</h2><p>JS中的内置构造函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span></div><div class="line"><span class="built_in">Number</span></div><div class="line"><span class="built_in">Boolean</span></div><div class="line">    注意：(区别于string number boolean)</div><div class="line"><span class="built_in">Date</span></div><div class="line"><span class="built_in">Array</span></div><div class="line"><span class="built_in">Function</span></div><div class="line"><span class="built_in">Object</span></div><div class="line"><span class="built_in">RegExp</span></div></pre></td></tr></table></figure></p>
<p>基本写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">book1.name = <span class="string">"声名狼藉者的生活"</span>;</div><div class="line">book1.price = <span class="number">42.00</span>;</div><div class="line">book1.author = <span class="string">"福柯"</span>;</div><div class="line">book1.press = <span class="string">"北京大学出版社"</span>;</div><div class="line">book1.read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"我的书名为:声名狼藉者的的生活,作者为福柯...."</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>问题<br>01 创建的对象无法复用,复用性差<br>02 如果需要创建多个同类型的对象,如(书籍)则需要写大量重复的代码,代码的冗余度高</p>
<h2 id="工厂函数创建对象"><a href="#工厂函数创建对象" class="headerlink" title="工厂函数创建对象"></a>工厂函数创建对象</h2><p>基本写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBookNew</span> (<span class="params">name,price,author,press</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> book = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    book.name = name;</div><div class="line">    book.price = price;</div><div class="line">    book.author = author;</div><div class="line">    book.press = press;</div><div class="line">    book.read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"我的书名为:"</span>+book.name+<span class="string">",作者为"</span>+book.author+<span class="string">"...."</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> book;</div><div class="line">&#125;</div><div class="line"><span class="comment">//使用工厂函数来创建对象</span></div><div class="line"><span class="keyword">var</span> book1 = createBookNew(<span class="string">"声名狼藉者的的生活"</span>,<span class="string">"42.00"</span>,<span class="string">"福柯"</span>,<span class="string">"北京大学出版社"</span>);</div><div class="line"><span class="keyword">var</span> book2 = createBookNew(<span class="string">"人性的枷锁"</span>,<span class="string">"49.00"</span>,<span class="string">"毛姆"</span>,<span class="string">"华东师范大学出版社"</span>);</div><div class="line"><span class="keyword">var</span> book3 = createBookNew(<span class="string">"悟空传"</span>,<span class="string">"28.00"</span>,<span class="string">"今何在"</span>,<span class="string">"湖南文艺出版社"</span>);</div><div class="line"><span class="comment">//打印对象的属性,调用对象的方法</span></div><div class="line"><span class="built_in">console</span>.log(book1.name);</div><div class="line"><span class="built_in">console</span>.log(book2.name);</div><div class="line"><span class="built_in">console</span>.log(book3.name);</div><div class="line">book1.read();</div><div class="line">book2.read();</div><div class="line">book3.read();</div></pre></td></tr></table></figure></p>
<p><strong>工厂函数说明</strong>:<br>001 工厂函数方式创建对象其本质是对内置构造函数创建对象的过程进行了封装<br>002 适用于大规模“批量生产”同类型的对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBook</span> (<span class="params">name,price,author,press</span>) </span>&#123;</div><div class="line">    <span class="comment">//001 参数 = 原料</span></div><div class="line">    <span class="keyword">var</span> book = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    <span class="comment">//002 创建对象并设置对象的属性和方法 = 对原料进行加工</span></div><div class="line">    book.name = name;</div><div class="line">    book.price = price;</div><div class="line">    book.author = author;</div><div class="line">    book.press = press;</div><div class="line">    book.read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"我的书名为:"</span>+book.name+<span class="string">",作者为"</span>+book.author+<span class="string">"...."</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//003 把处理好的对象返回给我们 == 产品出厂</span></div><div class="line">    <span class="keyword">return</span> book;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>封装思路</strong>:<br>使用函数把固定不变的部分封装起来，变化的部分提取为函数的参数。<br><strong>工厂函数创建对象的实现过程</strong>:<br>① 提供一个创建对象的函数（参数）<br>② 在该函数内部使用new 关键字和Object构造器创建对象<br>③ 设置对象的属性<br>④ 设置对象的方法<br>⑤ 返回对象</p>
<h2 id="自定义构造函数创建对象"><a href="#自定义构造函数创建对象" class="headerlink" title="自定义构造函数创建对象"></a>自定义构造函数创建对象</h2><p>基本写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> 构造函数名(<span class="params">参数<span class="number">1</span>,参数<span class="number">2</span>,参数<span class="number">3.</span>..</span>) </span>&#123;</div><div class="line">    <span class="comment">//设置对象的属性</span></div><div class="line">    <span class="keyword">this</span>.属性<span class="number">01</span> = 参数<span class="number">1</span>;</div><div class="line">    <span class="keyword">this</span>.属性<span class="number">02</span> = 参数<span class="number">2</span>;</div><div class="line">    <span class="comment">//设置对象的方法</span></div><div class="line">    <span class="keyword">this</span>.方法<span class="number">01</span> = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//.....</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.方法<span class="number">02</span> = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//.....</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//自定义构造函数方式创建对象</span></div><div class="line"><span class="keyword">var</span> 对象<span class="number">01</span> = <span class="keyword">new</span> 构造函数名(实参<span class="number">01</span>,实参<span class="number">02</span>,实参<span class="number">03.</span>..);</div><div class="line"><span class="keyword">var</span> 对象<span class="number">02</span> = <span class="keyword">new</span> 构造函数名(实参<span class="number">01</span>,实参<span class="number">02</span>,实参<span class="number">03.</span>..);</div></pre></td></tr></table></figure></p>
<p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateBook</span> (<span class="params">name,price,author,press</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.price = price;</div><div class="line">    <span class="keyword">this</span>.author = author;</div><div class="line">    <span class="keyword">this</span>.press = press;</div><div class="line">    <span class="keyword">this</span>.read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"我的书名为:"</span>+<span class="keyword">this</span>.name+<span class="string">",作者为"</span>+<span class="keyword">this</span>.author+<span class="string">"...."</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> CreateBook(<span class="string">"声名狼藉者的的生活"</span>,<span class="string">"42.00"</span>,<span class="string">"福柯"</span>,<span class="string">"北京大学出版社"</span>);</div><div class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> CreateBook(<span class="string">"人性的枷锁"</span>,<span class="string">"49.00"</span>,<span class="string">"毛姆"</span>,<span class="string">"华东师范大学出版社"</span>);</div><div class="line"><span class="keyword">var</span> b3 = <span class="keyword">new</span> CreateBook(<span class="string">"悟空传"</span>,<span class="string">"28.00"</span>,<span class="string">"今何在"</span>,<span class="string">"湖南文艺出版社"</span>);</div><div class="line"><span class="comment">//打印对象的属性,并调用对象的方法测试</span></div><div class="line"><span class="built_in">console</span>.log(b1.author);</div><div class="line"><span class="built_in">console</span>.log(b2.author);</div><div class="line"><span class="built_in">console</span>.log(b3.author);</div><div class="line">b1.read();</div><div class="line">b2.read();</div><div class="line">b3.read();</div></pre></td></tr></table></figure></p>
<p><strong>构造函数与new关键字</strong>:<br>new关键字的作用：用于创建对象（Object类型）。<br>构造函数和普通函数的区别：函数的首字母大写。<br>构造函数的作用:用于完成对象的初始化。</p>
<p><strong>自定义构造函数和简单工厂函数的对比</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">① 函数的首字母大写(用于区别构造函数和普通函数)</div><div class="line">② 创建对象的过程是由new关键字实现</div><div class="line">③ 在构造函数内部会自动的创建新对象,并赋值给this指针</div><div class="line">④ 自动返回创建出来的对象</div></pre></td></tr></table></figure></p>
<p><strong>构造函数的执行过程</strong><br>① 使用new关键字创建对象<br>② 把新创建出来的对象赋值给this<br>③ 在构造函数内部,使用this为新创建出来的对象设置属性和方法<br>④ 默认返回新创建的对象(普通函数如果不显示的return则默认返回undefined)。</p>
<p><strong>构造函数的返回值</strong><br>01 如果在构造函数中没有显示的return,则默认返回的是新创建出来的对象<br>02 如果在构造函数中显示的return,则依照具体的情况处理</p>
<pre><code>[01] return 的是对象,则直接返回该对象,取而代之本该默认返回的新对象
[02] return 的是null或基本数据类型值,则返回新创建的对象
</code></pre><p><strong>构造函数方式创建对象存在的问题</strong><br>每次创建对象,都会重新创建函数，那么如果创建的对象数量很多,而对象方法内部的实现一模一样,则造成了资源浪费。</p>
<p><strong>构造函数的使用注意</strong><br>函数传值：可以把构造函数的对象方法抽取为参数。代码示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//001 创建一个构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,toDoSomeThing</span>) </span>&#123;</div><div class="line">    <span class="comment">//002 在构造函数内部设置对象的属性和方法</span></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.toDoSomeThing = toDoSomeThing;</div><div class="line">&#125;</div><div class="line"><span class="comment">//003 使用构造函数创建对象</span></div><div class="line"><span class="keyword">var</span> zhangsan = <span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">18</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"张三在读书"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> lisi = <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"李四在玩耍"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>对象类型</strong>:<br>01 检查对象的类型：<code>instanceOf</code><br>02 获取对象的类型：<code>Object.prototype.toString.call(dog)</code></p>
<p><strong>对象的构造器属性</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.color = <span class="string">"黄色"</span>;</div><div class="line">    &#125;</div><div class="line"><span class="built_in">console</span>.log(dog.constructor);</div></pre></td></tr></table></figure></p>
<p>属性的名称：<code>constructor</code><br>属性的作用：指向创建该对象的构造函数，类似于现实生活中所有的产品都标有生产厂家一样。</p>
<p><strong>构造函数的调用</strong><br>01 构造函数可以像普通函数一样不通过new关键字直接调用<br>02 在使用构造函数创建对象的时候，如果没有传递参数，则（）可以省略<br>代码示例:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 创建构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"张三"</span>;</div><div class="line">    <span class="keyword">this</span>.age = <span class="number">20</span>;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//02 使用构造函数创建对象</span></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person;    <span class="comment">//说明:如果不需要传递参数,则在调用构造函数的时候()可以省略</span></div></pre></td></tr></table></figure></p>
<p><strong>this指向</strong><br>01 如果使用new 构造函数的方式调用，则this指向内部默认创建出来的空对象<br>02 如果像调用普通函数一样调用构造函数，则this指向全局对象window(<code>不要这样使用</code>)</p>
<h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><p><strong>原型对象概念</strong></p>
<pre><code>在构造函数创建出来的时候,系统会默认帮构造函数创建并关联的一个新对象
自定义构造函数的原型对象默认是一个空对象。  
</code></pre><p><strong>原型对象的作用</strong></p>
<pre><code>构造函数中的原型对象中的属性和方法可以被使用该构造函数创建出来的对象使用。
即以自定义构造函数方式创建出来的所有对象,自动拥有和共享该构造函数的原型对象中的所有属性和方法。
</code></pre><p><strong>如何访问构造函数的原型对象</strong><br>① <code>构造函数.protoType</code><br>② <code>对象.__proto__（不推荐）</code></p>
<p><strong>设置原型对象的属性和方法</strong><br>① <code>利用对象的动态特性来为构造函数的原型对象添加属性和方法</code><br>② <code>替换原型对象</code></p>
<p><strong>实例和实例化</strong>：<br><code>实例化</code>:通过构造函数创建具体对象的过程。<br><code>实例</code>:通过构造函数实例化出来的对象,我们称之为该构造函数的一个实例。<br>注意:在说实例的时候,一定要指定是某个具体构造函数的实例。</p>
<p><strong>原型的使用方法</strong><br>① 利用对象的动态特性给原型添加属性|方法，如果要添加的方法过多,则有大量重复代码。<br>② 直接替换原型对象：<br>01 替换前后创建的对象所指向的原型对象不一致<br>02 替换原型对象会切断和之前的原型对象之间的关系</p>
<p><strong>原型对象的使用注意</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">① 访问属性:构造函数创建出来的对象在访问属性的时候,会先在实例内查找,如果没有找到则进一步到对应的原型对象中查找。</div><div class="line">② 设置属性:在使用点语法进行赋值的时候,无法操作到对应的原型对象,如果该属性在对象中已经存在，则修改该属性的值。如果该属性在对象中尚未存在,则新增该属性。</div><div class="line">③ 设置原型对象的属性:</div><div class="line">[<span class="number">01</span>] 设置原型对象的属性,只能通过构造函数.Prototype的方式替换原型对象的方式设置。</div><div class="line">[<span class="number">02</span>] 如果原型对象的属性是值类型，那么只能通过Person.prototype.属性的方式修改其值。如果原型对象的属性是引用类型,那么可以通过对象名.引用对象.属性名的方式设置修改：</div><div class="line">            (<span class="number">001</span>) 使用构造函数创建出来的多个对象的原型对象中的该属性指向的是同一块数据。</div><div class="line">            (<span class="number">002</span>) 某个对象对该原型对象属性进行了修改会影响到其他的对象。</div></pre></td></tr></table></figure></p>
<p><code>__proto__</code>属性说明：<code>__proto__</code>是一个非标准属性,即ECMAScript中并不包含该属性,这只是某些浏览器为了方便开发人员开发和调试而提供的一个属性,不具备通用性。建议:在调试的时候可以使用该属性,但不能出现在正式的代码中。</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><blockquote>
<p>关于继承，通俗说子继父业。在JavaScript中，Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。</p>
</blockquote>
<h2 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h2><p>在讲继承之前，我们必须先了解一些相关的方法。</p>
<h3 id="hasOwnProperty和in属性操作"><a href="#hasOwnProperty和in属性操作" class="headerlink" title="hasOwnProperty和in属性操作"></a>hasOwnProperty和in属性操作</h3><p><strong>in关键字</strong><br>作用：用来检查对象中是否存在某个属性(不区分实例属性和原型属性)。语法：“属性名” in 对象。代码示例:<br><!-- more --><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02 设置构造函数的原型对象的属性</span></div><div class="line">    Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//03 创建对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="comment">//04 使用in关键字判断对象中是否存在以下属性:name age sayHello</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"age"</span> <span class="keyword">in</span> p1);       <span class="comment">//false</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> p1);      <span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"sayHello"</span> <span class="keyword">in</span> p1);  <span class="comment">//true</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>对象的hasOwnProperty方法</strong><br>作用：用来检查对象中是否存在指定的属性(只检查实例属性)<br>语法：对象.hasOwnProperty(“属性名”)<br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02 设置构造函数的原型对象的属性</span></div><div class="line">    Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</div><div class="line">    &#125;</div><div class="line">    Person.prototype.des = <span class="string">"默认的描述信息"</span>;</div><div class="line">    <span class="comment">//03 创建对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="comment">//04 使用hasOwnProperty方法判断该属性是否是对象的实例属性</span></div><div class="line">    <span class="built_in">console</span>.log(p1.hasOwnProperty(<span class="string">"age"</span>));       <span class="comment">//false</span></div><div class="line">    <span class="built_in">console</span>.log(p1.hasOwnProperty(<span class="string">"name"</span>));      <span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(p1.hasOwnProperty(<span class="string">"sayHello"</span>));  <span class="comment">//false</span></div><div class="line">    <span class="built_in">console</span>.log(p1.hasOwnProperty(<span class="string">"des"</span>));       <span class="comment">//false</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>判断某对象中存在且只存在某个原型属性</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isProperty</span>(<span class="params">obj, property</span>) </span>&#123;</div><div class="line">       <span class="keyword">return</span> !obj.hasOwnProperty(property) &amp;&amp; (property <span class="keyword">in</span> obj);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h3 id="constructor构造器属性"><a href="#constructor构造器属性" class="headerlink" title="constructor构造器属性"></a>constructor构造器属性</h3><p><strong>说明</strong><br>  使用构造函数创建对象,则</p>
<pre><code>原型对象中的constructor属性指向对应的构造函数
实例对象中的constructor指向对应的构造函数,其中这里的constructor就是从原型中获取的即constructor时实例对象中的原型属性,而非实例属性
</code></pre><p><strong>代码验证</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提供一个构造函数</span></div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">       <span class="keyword">this</span>.name = name;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//02 设置构造函数的原型对象的属性</span></div><div class="line">   Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</div><div class="line">   &#125;;</div><div class="line">   Person.prototype.des = <span class="string">"默认的描述信息"</span>;</div><div class="line">   <span class="comment">//03 创建对象</span></div><div class="line">   <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">isProperty</span>(<span class="params">obj, property</span>) </span>&#123;</div><div class="line">       <span class="keyword">return</span> !obj.hasOwnProperty(property) &amp;&amp; (property <span class="keyword">in</span> obj);</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">console</span>.log(isProperty(p1, <span class="string">"constructor"</span>));    <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h3 id="isprotoTypeOf和instance"><a href="#isprotoTypeOf和instance" class="headerlink" title="isprotoTypeOf和instance"></a>isprotoTypeOf和instance</h3><p><strong>isprotoTypeOf</strong><br>作用：判断是否是某个实例对象的原型对象<br>语法:构造函数.protoType.isPrototypeOf(对象)<br>用法示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    Person.prototype.name = <span class="string">"嘿嘿"</span>;</div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(p1));<span class="comment">//rue</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(p1));<span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(Dog.prototype.isPrototypeOf(p1));<span class="comment">//false</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>instance</strong><br>作用：用于检查对象是否是某个构造函数(类型)的实例<br>语法：对象 instance 构造函数<br>注意：所有的对象都是Object构造函数（类型）的实例<br>用法示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">    <span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>);      <span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);   <span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Object</span>);     <span class="comment">//true</span></div><div class="line">    <span class="comment">//instanceOf在判断的时候,算上整条原型链</span></div><div class="line">    <span class="comment">//arr 是Array 和Object 任何一个类的示例</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h2><h3 id="继承基本概念"><a href="#继承基本概念" class="headerlink" title="继承基本概念"></a>继承基本概念</h3><p><strong>继承</strong>：即通过一定的方式实现让某个类型A获取另外一个类型B的属性或方法。其中类型A称之为子类型，类型B称之为父类型或超类型。</p>
<p><strong>javaScript中的继承</strong><br>Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。<br>继承有两种方式：接口继承和实现继承，在js中只支持实现继承，实现继承主要依赖原型链来完成。<br><strong>JavaScript中实现继承的几种方式</strong>：<br>说明:其他语言中继承通常通过类来实现，js中没有类的概念，js中的继承是某个对象继承另外一个对象，是基于对象的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">01 原型式继承</div><div class="line">02 原型链继承</div><div class="line">03 经典继承(借用构造函数)</div><div class="line">04 组合继承</div></pre></td></tr></table></figure></p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p><strong>原型链继承的方式A</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02 设置原型对象的属性</span></div><div class="line">    Person.prototype.className = <span class="string">"逍遥派1班"</span>;</div><div class="line">    <span class="comment">//03 使用构造函数来创建原型对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">10</span>);</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>);</div><div class="line">    <span class="comment">//04 打印p1和p2对象中的className属性</span></div><div class="line">    <span class="built_in">console</span>.log(p1.className);</div><div class="line">    <span class="built_in">console</span>.log(p2.className);</div><div class="line">    <span class="comment">//结论:对象p1和p2继承了构造函数原型对象中的属性className</span></div><div class="line">    <span class="comment">//但是这并不是严格意义上的继承</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>原型链继承的方式B</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02 设置原型对象的属性</span></div><div class="line">    Person.prototype = &#123;</div><div class="line">        <span class="attr">constructor</span>:Person,</div><div class="line">        <span class="attr">className</span>:<span class="string">"逍遥派1班"</span></div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//03 使用构造函数来创建原型对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">10</span>);</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>);</div><div class="line">    <span class="comment">//04 打印p1和p2对象中的className属性</span></div><div class="line">    <span class="built_in">console</span>.log(p1.className);</div><div class="line">    <span class="built_in">console</span>.log(p2.className);</div><div class="line">    <span class="comment">//结论:对象p1和p2继承了构造函数原型对象中的属性className</span></div><div class="line">    <span class="comment">//注意:使用原型替换的方式实现继承的时候,原有原型对象中的属性和方法会丢失</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>原型链继承的方式C</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提供超类型|父类型构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'SuperClass的名称'</span>;</div><div class="line">    <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//02 设置父类型的原型属性和原型方法</span></div><div class="line">SuperClass.prototype.info = <span class="string">'SuperClass的信息'</span>;</div><div class="line">SuperClass.prototype.showInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.info);</div><div class="line">&#125;;</div><div class="line"><span class="comment">//03 提供子类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="comment">//04 设置继承(原型对象继承)</span></div><div class="line">SubClass.prototype = SuperClass.prototype;</div><div class="line">SubClass.prototype.constructor = SubClass;</div><div class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> SubClass();</div><div class="line"><span class="built_in">console</span>.log(sub.name);          <span class="comment">//undefined</span></div><div class="line"><span class="built_in">console</span>.log(sub.info);          <span class="comment">//SuperClass的信息</span></div><div class="line">sub.showInfo();                 <span class="comment">//SuperClass的信息</span></div><div class="line">sub.showName();                 <span class="comment">//sub.showName is not a function</span></div></pre></td></tr></table></figure></p>
<p>点评：上面的方法可以可以继承超类型中的原型属性和原型方法，但是无法继承实例属性和实例方法</p>
<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>实现思想：利用原型（链）让一个对象继承另一个对象的属性和方法<br>实现本质：重写原型对象</p>
<p><strong>原型链</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">① 每个构造函数都有原型对象</div><div class="line">② 每个对象都有自己的构造函数</div><div class="line">③ 每个构造函数的原型都是一个对象</div><div class="line">④ 那么这个构造函数的原型对象也有自己的构造函数</div><div class="line">⑤ 那么这个构造函数的原型对象的构造函数也有自己的原型对象</div><div class="line">以上形成一个链式的结构,称之为原型链</div></pre></td></tr></table></figure></p>
<p><strong>原型链中的属性搜索原则</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">当访问某个对象的成员的时候,会先在自身中查找,如果找到则直接使用</div><div class="line">如果在自身中没有找到,则去当前创建当前对象的构造函数的原型对象中查找,如果找到了则直接使用</div><div class="line">如果在该原型对象中没有找到,则继续查找原型对象的原型对象(创建该原型对象的构造函数所对应的原型对象),如果找到则直接使用</div><div class="line">如果在原型对象的原型对象中也没有找到,则继续向上搜索....</div><div class="line">直到Object的原型对象,若还是没有,则返回undefined(属性)或报错(方法)。</div></pre></td></tr></table></figure></p>
<p><strong>基本写法·代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提供超类型|父类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'SuperClass的名称'</span>;</div><div class="line">    <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//02 设置父类型的原型属性和原型方法</span></div><div class="line">SuperClass.prototype.info = <span class="string">'SuperClass的信息'</span>;</div><div class="line">SuperClass.prototype.showInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.info);</div><div class="line">&#125;;</div><div class="line"><span class="comment">//03 提供子类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="comment">//04 设置继承(原型对象继承)</span></div><div class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass();</div><div class="line">SubClass.prototype.constructor = SubClass;</div><div class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> SubClass();</div><div class="line"><span class="built_in">console</span>.log(sub.name);          <span class="comment">//SuperClass的名称</span></div><div class="line"><span class="built_in">console</span>.log(sub.info);          <span class="comment">//SuperClass的信息</span></div><div class="line">sub.showInfo();                 <span class="comment">//SuperClass的信息</span></div><div class="line">sub.showName();                 <span class="comment">//SuperClass的名称</span></div></pre></td></tr></table></figure></p>
<p>点评：可以继承父类型中的原型属性|原型方法,以及实例属性和实例方法</p>
<p><strong>注意点</strong><br>① 确定原型和实例的关系 instanceof + isPrototypeOf()<br>② 注意重写原型对象的位置，必须先实现原型继承，然后再设置子对象的原型属性和原型方法<br>③ 完成继承之后，不能使用字面量的方式来创建原型[因为会切断原型]</p>
<p><strong>问题</strong><br>① 父对象的实例属性会转换为子类型原型的原型属性，而如果父类型是实例属性是引用类型则会存在共享问题<br>② 在创建子类型的实例时，不能向父类型的构造函数中传递参数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提供父对象的构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//02 在构造函数中中设置实例属性,该属性为引用类型</span></div><div class="line">    <span class="keyword">this</span>.family = [<span class="string">'哥哥'</span>,<span class="string">'姐姐'</span>,<span class="string">'爸爸'</span>,<span class="string">'妈妈'</span>];</div><div class="line">&#125;;</div><div class="line"><span class="comment">//03 提供子对象的构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="comment">//04 设置原型继承</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"><span class="comment">//05 创建父对象构造函数的实例对象,并对内部的实例化属性进行修改</span></div><div class="line"><span class="keyword">var</span> subDemo1 = <span class="keyword">new</span> SubType();</div><div class="line"><span class="keyword">var</span> subDemo2 = <span class="keyword">new</span> SubType();</div><div class="line">alert(subDemo1.family);      <span class="comment">//哥哥,姐姐,爸爸,妈妈</span></div><div class="line">alert(subDemo2.family);      <span class="comment">//哥哥,姐姐,爸爸,妈妈</span></div><div class="line">subDemo1.family.push(<span class="string">'爷爷'</span>,<span class="string">'奶奶'</span>);</div><div class="line">alert(subDemo1.family);    <span class="comment">//哥哥,姐姐,爸爸,妈妈,爷爷,奶奶</span></div><div class="line">alert(subDemo2.family);    <span class="comment">//哥哥,姐姐,爸爸,妈妈,爷爷,奶奶</span></div></pre></td></tr></table></figure></p>
<h3 id="经典继承（借用构造函数）"><a href="#经典继承（借用构造函数）" class="headerlink" title="经典继承（借用构造函数）"></a>经典继承（借用构造函数）</h3><p>经典继承又称为借用构造函数|伪造继承</p>
<p><strong>基本思想</strong><br>在子类型构造函数的内部调用超类型|父类型构造函数<br>说明：需要借助call|apply方法<br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提供父类型(对象)的构造函数</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">      <span class="comment">//02 在构造函数中中设置实例属性,该属性为引用类型</span></div><div class="line">      <span class="keyword">this</span>.family = [<span class="string">'哥哥'</span>,<span class="string">'姐姐'</span>,<span class="string">'爸爸'</span>,<span class="string">'妈妈'</span>];</div><div class="line">      <span class="comment">//实例属性</span></div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;;</div><div class="line">  SuperType.prototype.info = <span class="string">'父类型的原型属性'</span>;</div><div class="line">  <span class="comment">//03 提供子类型（对象）的构造函数</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">//经典继承|借用构造函数|伪造对象继承</span></div><div class="line">      <span class="comment">//SuperType.call(this);</span></div><div class="line">      <span class="comment">//构造参数传递参数</span></div><div class="line">      SuperType.call(<span class="keyword">this</span>,<span class="string">'张老汉'</span>);</div><div class="line">  &#125;;</div><div class="line">  <span class="comment">//04 创建父类型的实例对象,并对内部的实例化属性进行修改</span></div><div class="line">  <span class="keyword">var</span> subDemo1 = <span class="keyword">new</span> SubType();</div><div class="line">  <span class="keyword">var</span> subDemo2 = <span class="keyword">new</span> SubType();</div><div class="line">  alert(subDemo1.info);        <span class="comment">//undefined</span></div><div class="line">  alert(subDemo1.family);      <span class="comment">//哥哥,姐姐,爸爸,妈妈</span></div><div class="line">  alert(subDemo2.family);      <span class="comment">//哥哥,姐姐,爸爸,妈妈</span></div><div class="line">  subDemo1.family.push(<span class="string">'爷爷'</span>,<span class="string">'奶奶'</span>);</div><div class="line">  alert(subDemo1.family);    <span class="comment">//哥哥,姐姐,爸爸,妈妈,爷爷,奶奶</span></div><div class="line">  alert(subDemo2.family);    <span class="comment">//哥哥,姐姐,爸爸,妈妈</span></div><div class="line">  <span class="comment">//测试构造函数传递参数</span></div><div class="line">  alert(subDemo1.name);</div></pre></td></tr></table></figure></p>
<p>点评：能够继承父类型的实例属性,但是无法继承父类型的原型属性和原型方法</p>
<p><strong>经典继承的优点</strong><br>① 解决实例对象共享问题，通过调用父对象的构造函数来实现每个子类型（对象）的实例对象均拥有一份父类型实例属性和方法的副本<br>② 可以在调用call方法的时候向构造函数传递参数</p>
<p><strong>经典继承的问题</strong><br>① 冒充继承的方法无法实现函数的重用<br>② 无法继承父对象的原型属性和原型方法</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承|伪经典继承</p>
<p><strong>基本思想</strong><br>① 使用原型链实现对原型属性和方法的继承<br>② 通过伪造(冒充)构造函数来实现对实例属性的继承<br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提供父类型的构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="comment">//在构造函数中中设置实例属性,该属性为引用类型</span></div><div class="line">    <span class="keyword">this</span>.family = [<span class="string">'哥哥'</span>,<span class="string">'姐姐'</span>,<span class="string">'爸爸'</span>,<span class="string">'妈妈'</span>];</div><div class="line">    <span class="comment">//实例属性</span></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//原型方法</span></div><div class="line">SuperType.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="comment">//02 提供子类型的构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="comment">//冒充|伪造 构造参数传递参数</span></div><div class="line">    SuperType.call(<span class="keyword">this</span>,name);</div><div class="line">&#125;;</div><div class="line">SubType.prototype = SuperType.prototype;</div><div class="line"><span class="comment">//SubType.prototype = new SuperType();</span></div><div class="line"><span class="comment">//02 创建父类型的实例对象,并对内部的实例化属性进行修改</span></div><div class="line"><span class="keyword">var</span> subDemo1 = <span class="keyword">new</span> SubType(<span class="string">'张三'</span>);</div><div class="line"><span class="keyword">var</span> subDemo2 = <span class="keyword">new</span> SubType(<span class="string">'张四'</span>);</div><div class="line">alert(subDemo1.family);    <span class="comment">//哥哥,姐姐,爸爸,妈妈</span></div><div class="line">alert(subDemo2.family);      <span class="comment">//哥哥,姐姐,爸爸,妈妈</span></div><div class="line">subDemo1.family.push(<span class="string">'爷爷'</span>,<span class="string">'奶奶'</span>);</div><div class="line">alert(subDemo1.family);    <span class="comment">//哥哥,姐姐,爸爸,妈妈,爷爷,奶奶</span></div><div class="line">alert(subDemo2.family);    <span class="comment">//哥哥,姐姐,爸爸,妈妈</span></div><div class="line"><span class="comment">//测试构造函数传递参数</span></div><div class="line">subDemo1.showName();    <span class="comment">//张三</span></div><div class="line">subDemo2.showName();    <span class="comment">//张四</span></div></pre></td></tr></table></figure></p>
<h3 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><p>基本类型：字符串 + 数值 + null + undefined + 布尔值<br>为了便于操作基本类型，ECMAScript提供了三个特殊的引用类型：<code>Boolean + Number + String</code>。<br>上述类型和其他的引用类型类似，同时也具备与各自的基本类型相应的特殊行为，每当我们读取一个基本类型的值的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'测试字符串'</span>;</div><div class="line"><span class="built_in">console</span>.log(str.length);            <span class="comment">//5</span></div><div class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">2</span>));      <span class="comment">//字符串</span></div></pre></td></tr></table></figure></p>
<p><code>思考</code>：属性和方法本是对象的特征，字符串如何能够拥有length属性以及其他类似subString等方法，内部怎么实现的？<br>基本类型值并不是对象，因此从逻辑上讨论他们不应该有属性和方法。 内部的具体处理:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">（<span class="number">1</span>）创建<span class="built_in">String</span>类型的一个实例对象</div><div class="line">（<span class="number">2</span>）在实例对象上面读取指定的属性（length）,调用指定的方法（subString）</div><div class="line">（<span class="number">3</span>）销毁该对象</div></pre></td></tr></table></figure></p>
<p><strong>Number</strong><br>Number是与数字值相对应的引用类型。<br>创建Number类型的对象：var num = new Number(10);</p>
<p><strong> String </strong><br>String是字符串的对象包装类型。<br>创建字符串类型的对象：var str = new String(‘hello World’);</p>
<p><strong>Boolean</strong><br>Boolean是与布尔值对象的引用类型。<br>可以通过调用Boolean构造函数传递参数来创建boolean类型的对象。<br>var bool = new Boolean(true);</p>
<p><strong>基本包装类型的代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//001 String</span></div><div class="line"><span class="keyword">var</span> str = <span class="string">'测试字符串'</span>;</div><div class="line"><span class="built_in">console</span>.log(str.length);            <span class="comment">//5</span></div><div class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">2</span>));      <span class="comment">//字符串</span></div><div class="line"><span class="comment">//002 Number</span></div><div class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</div><div class="line"><span class="built_in">console</span>.log(num);                   <span class="comment">//Number &#123;[[PrimitiveValue]]: 10&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);            <span class="comment">//object</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">10</span>);             <span class="comment">//number</span></div><div class="line"><span class="comment">//003 Boolean</span></div><div class="line"><span class="keyword">var</span> bool = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</div><div class="line"><span class="built_in">console</span>.log(bool);                  <span class="comment">//Boolean &#123;[[PrimitiveValue]]: true&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bool);           <span class="comment">//object</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);           <span class="comment">//boolean</span></div></pre></td></tr></table></figure></p>
<p><strong>基本包装类型的注意点</strong><br>[1] 对象还是基本数据类型值？<br>对象：通过new 调用构造函数创建出来的是对象<br>基本数据类型值：直接通过字面量方式赋值|通过省略new关键字调用构造函数方式创建的是基本数据类型值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ex:</div><div class="line">    <span class="keyword">var</span> str1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello'</span>);</div><div class="line">    <span class="keyword">var</span> str2 = <span class="string">'hello'</span>;</div><div class="line">    <span class="keyword">var</span> str3 = <span class="built_in">String</span>(<span class="string">'hello'</span>);</div><div class="line">    说明：以上代码中，str1是对象，而str2和str3是字符串（基本数据类型值）</div></pre></td></tr></table></figure></p>
<p>[2] 相等问题<br>基本类型值判断相等=&gt;值相等<br>引用类型值判断相等=&gt;值相等且引用相等<br>对象是引用类型，因此在判断相等的时候有诸多的注意点和容易出错的地方<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ex</div><div class="line">    <span class="keyword">var</span> str1 = <span class="string">'这是一个字符串'</span>;           <span class="comment">//基本数据类型</span></div><div class="line">    <span class="keyword">var</span> str2 = <span class="built_in">String</span>(<span class="string">'这是一个字符串'</span>);   <span class="comment">//基本数据类型</span></div><div class="line">    <span class="built_in">console</span>.log(str1 == str2);        <span class="comment">//true 相等</span></div><div class="line">    <span class="keyword">var</span> str3 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'这是一个字符串'</span>);  <span class="comment">//引用类型-对象</span></div><div class="line">    <span class="built_in">console</span>.log(str1 == str3);    <span class="comment">//true    //值相等</span></div><div class="line">    <span class="built_in">console</span>.log(str2 == str3);    <span class="comment">//true    //值相等</span></div><div class="line">    <span class="built_in">console</span>.log(str1 === str3); <span class="comment">//false //值相等,但是引用不相等</span></div><div class="line">    <span class="built_in">console</span>.log(str2 === str3); <span class="comment">//false //值相等,但是引用不相等</span></div><div class="line">    <span class="comment">//判断下面的变量是否相等</span></div><div class="line">    <span class="keyword">var</span> num1 = <span class="number">10</span>;                  <span class="comment">//基本数据类型</span></div><div class="line">    <span class="keyword">var</span> num2 = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);      <span class="comment">//对象</span></div><div class="line">    <span class="built_in">console</span>.log(num1 == num2);      <span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(num1 ===  num2);    <span class="comment">//false</span></div><div class="line">    <span class="keyword">var</span> bool1 = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">var</span> bool2 = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</div><div class="line">    <span class="built_in">console</span>.log(bool1 == bool2);    <span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(bool1 === bool2);   <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<h1 id="原型链及相关属性方法简单说明"><a href="#原型链及相关属性方法简单说明" class="headerlink" title="原型链及相关属性方法简单说明"></a>原型链及相关属性方法简单说明</h1><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><strong>代码示例</strong><br><!-- more --><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供Person构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02 设置Person的原型对象</span></div><div class="line">    Person.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//03 创建Student构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">number</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.numer = number</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//04 设置Student的原型对象</span></div><div class="line">    Student.prototype = <span class="keyword">new</span> Person();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>原型链图示例</strong><br><img src="/assets/img/Snip20170213_10.png" alt="原型"></p>
<h2 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h2><p><strong>Object构造函数</strong><br>01 使用Object构造函数创建字符串对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 创建字符串对象</span></div><div class="line"><span class="keyword">var</span> str1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"测试字符串"</span>);</div><div class="line"><span class="keyword">var</span> str2 = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">"测试字符串"</span>);</div><div class="line"><span class="keyword">var</span> str3 = str1;</div><div class="line"><span class="comment">//注意:对象比较相等(需要引用[地址]相等)</span></div><div class="line"><span class="built_in">console</span>.log(str1 == str2);      <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(str1 === str2);     <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(str1 === str3);     <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>02 使用Object构造函数创建数字对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">10</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);    <span class="comment">//object</span></div></pre></td></tr></table></figure></p>
<p>03 使用Object构造函数创建布尔类型对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bool = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="literal">true</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> bool);   <span class="comment">//object</span></div></pre></td></tr></table></figure></p>
<p><strong>js中所有的内置或自定义对象都继承自Object对象,几乎所有的对象都可以使用Object.prototype上面的属性和方法</strong></p>
<h2 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h2><p>01 因为js中所有的对象都继承自Obejct,都可以使用Object对象的原型属性和方法,因此不要轻易的扩展Object.prototype。<br>02 Object.property中的属性和方法</p>
<pre><code>① constructor 指向原型相关联的构造函数，为Object
② hasOwnProperty 判断对象中是否拥有某个实例属性(不包括原型链上面的属性)
③ isPrototypeOf  校验某个对象是否是指定对象的原型对象(整条原型链)
④ propertyIsEnumerable 属性是否存在且可枚举(使用for循环可以遍历,即目标属性能否在for循环中显示出来)
⑤ toString() 返回一个描述目标对象的字符串,对象则返回[object object]
   toString(参数) 参数出可以传入一个用于进制数的参数,该参数的默认值为10(主要针对Number类型有效)
⑥ toLocaleString 同toString,但是会做一些本地化的处理。
⑦ valueOf()  如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。
   Date对象调用该方法会返回一个时间戳。
</code></pre><p><strong>constructor</strong><br>说明：该属性指向创建该对象的构造函数，在这里为Object<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line">   <span class="built_in">console</span>.log(p.constructor);                     <span class="comment">//function Person() &#123;&#125;</span></div><div class="line">   <span class="built_in">console</span>.log(Person.prototype.constructor);      <span class="comment">//function Person() &#123;&#125;</span></div><div class="line">   <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.constructor);      <span class="comment">//function Object() &#123; [native code] &#125;</span></div></pre></td></tr></table></figure></p>
<p><strong>hasOwnProperty</strong><br>说明：判断对象中是否拥有某个实例属性(不包括原型链上面的属性)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"默认的姓名"</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//检查对象中是否拥有指定的属性(实例属性)</span></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">p1.hasOwnProperty(<span class="string">"name"</span>);  <span class="comment">//true</span></div><div class="line">p1.hasOwnProperty(<span class="string">"age"</span>);   <span class="comment">//false</span></div><div class="line">p1.hasOwnProperty(<span class="string">"constructor"</span>);   <span class="comment">//对象的constructor是从原型对象上继承的</span></div></pre></td></tr></table></figure></p>
<p><strong>isPrototypeOf</strong><br>说明：校验某个对象是否是指定对象的原型对象(整条原型链);<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> obj = &#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"张三"</span>,</div><div class="line">        <span class="attr">age</span>:<span class="number">20</span>,</div><div class="line">        <span class="attr">hello</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">showName</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//属性是否存在且可以枚举</span></div><div class="line">    <span class="built_in">console</span>.log(obj.propertyIsEnumerable(<span class="string">"name"</span>));      <span class="comment">//true</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>toString</strong><br>说明：返回一个描述目标对象的字符串,对象则返回[object object]<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    <span class="built_in">console</span>.log(obj.toString());  <span class="comment">//打印[object Object]</span></div><div class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">    <span class="built_in">console</span>.log(arr.toString());    <span class="comment">//打印1,2,3,4,5</span></div><div class="line">    <span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line">    <span class="built_in">console</span>.log(num.toString());               <span class="comment">//10</span></div><div class="line">    <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">    <span class="built_in">console</span>.log(date.toString());           <span class="comment">//Mon Feb 13 2017 19:00:13 GMT+0800 (CST)</span></div><div class="line">    <span class="comment">//toString方法可以传入参数,在处理Number类型数据的时候,可以传入指定的进制</span></div><div class="line">    <span class="built_in">console</span>.log(num.toString(<span class="number">2</span>));       <span class="comment">//1010  == 1*2*2*2+0*2*2+1*2+1*1 = 10</span></div><div class="line">    <span class="built_in">console</span>.log(num.toString(<span class="number">3</span>));       <span class="comment">//101   == 1*3*3 + 0*3 + 1*1 = 10</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>toLocaleString</strong><br>说明：作用同toString方法一致，但是会做一些本地化的处理.</p>
<p><strong>valueOf</strong><br>说明：<br>① 如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。<br>② 如果是Date类型，则返回时间戳。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    <span class="built_in">console</span>.log(obj + <span class="number">1</span>);       <span class="comment">//[object Object]1</span></div><div class="line">    <span class="comment">//说明:如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。</span></div><div class="line">    <span class="keyword">var</span>  o = &#123;<span class="attr">name</span>:<span class="string">"张三"</span>&#125;;</div><div class="line">    <span class="built_in">console</span>.log(o + <span class="number">1</span>); <span class="comment">//[object Object]1</span></div><div class="line">    <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">    <span class="built_in">console</span>.log(date.valueOf());        <span class="comment">//1486984088998</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="静态成员和实例成员"><a href="#静态成员和实例成员" class="headerlink" title="静态成员和实例成员"></a>静态成员和实例成员</h2><p><strong>静态成员</strong><br>    定义在构造函数上面的成员(属性和方法)</p>
<p><strong>实例成员</strong><br>    定义在实例对象上面的成员(属性和方法)</p>
<p><strong>建议</strong></p>
<pre><code>① 把工具类的方法写成静态方法
② 把和对象相关的方法写成实例方法(成员)
</code></pre><p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = <span class="string">"张三"</span>;   <span class="comment">//实例属性</span></div><div class="line">        <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//为Person构造函数添加静态成员</span></div><div class="line">    Person.des = <span class="string">"描述信息"</span>;</div><div class="line">    Person.add = <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"添加信息"</span> + msg);</div><div class="line">    &#125;;</div><div class="line">    Person.add(<span class="string">"这是一个+操作"</span>);</div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    p1.showName();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<h2 id="Function构造函数"><a href="#Function构造函数" class="headerlink" title="Function构造函数"></a>Function构造函数</h2><p><strong>函数创建的几种方式</strong><br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">01</span> 函数声明</div><div class="line"><span class="number">02</span> 字面量的方式创建</div><div class="line"><span class="number">03</span> 使用<span class="keyword">new</span> <span class="built_in">Function</span>的形式创建</div></pre></td></tr></table></figure></p>
<p> <strong>函数创建代码示例</strong><br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func01</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"函数声明"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> func02 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"字面量方式创建"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//使用Function构造函数创建</span></div><div class="line">  <span class="keyword">var</span> func03 = <span class="keyword">new</span> <span class="built_in">Function</span>();</div></pre></td></tr></table></figure></p>
<p><strong>Function构造函数创建函数</strong><br>  参数说明:可以传入多个参数<br>  最后一个参数:<code>传入的最后一个参数为函数的函数体内容</code><br>  其他参数:创建出来的函数的参数<br>  如果只有一个参数,则表示这是该函数的函数体内容<br>  传递参数的格式:以字符串的方式进行传参<br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//需求01 使用Function构造函数创建一个函数对象,该函数执行一行打印操作</span></div><div class="line"><span class="keyword">var</span> funcName01 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"console.log('让我掉下眼泪的,不止昨夜的酒')"</span>);</div><div class="line">funcName01();</div><div class="line"><span class="comment">//需求02 使用Function构造函数创建一个函数对象,该函数需要接受两个参数,要求返回他们的和</span></div><div class="line"><span class="keyword">var</span> funcName02 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"return a + b;"</span>);</div><div class="line"><span class="built_in">console</span>.log(funcName02(<span class="number">10</span>, <span class="number">20</span>));    <span class="comment">//30</span></div></pre></td></tr></table></figure></p>
<p><strong>解决函数体代码过长的问题</strong><br>（1）使用转义字符，写在一行中<br>（2）使用+操作符来拼接字符串<br>（3）使用``操作符来管理字符串<br>（4）使用模板先处理字符串，然后在js中获得模板中的内容</p>
<h2 id="arguments、length和callee"><a href="#arguments、length和callee" class="headerlink" title="arguments、length和callee"></a>arguments、length和callee</h2><p><strong>arguments参数</strong><br>说明：在js中的函数中，有两个隐藏的参数分别是this和arguments<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">arguments</span> 是一个类似数组的结构,可以通过下标来操作函数的参数,但并非数组类型的。</div><div class="line">在函数调用的时候,会将函数的所有参数都传入<span class="built_in">arguments</span>对象中保存,因此我们可以通过操作<span class="built_in">arguments</span>属性来操作参数</div><div class="line">形参的数量大于实参的数量,则依次传入,未传入的设置为<span class="literal">undefined</span></div><div class="line">形参的数量小于实参的数量,则<span class="built_in">arguments</span>中保存实际的值</div></pre></td></tr></table></figure></p>
<p><strong>length</strong></p>
<pre><code>函数内部的arguments数组拥有length属性,可以通过该属性获取用户调用时传入的实参的个数

函数本身有一个length属性,可以通过该属性来获取形式参数的个数
</code></pre><p><strong>callee方法</strong></p>
<pre><code>函数内部的arguments对象中,有一个callee方法,该方法指向函数自身,常用于匿名函数的递归调用。
</code></pre><p><strong>代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div><div class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);  <span class="comment">//调用函数时实际传入的参数数量</span></div><div class="line">    &#125;</div><div class="line">    func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</div><div class="line">    <span class="built_in">console</span>.log(func.length);           <span class="comment">//预期的参数数量 —— 函数的形参数量</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func02</span>(<span class="params">a,b</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(a, b);</div><div class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div><div class="line">    &#125;</div><div class="line">    func02(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);  <span class="comment">//实参的数量 &gt; 形参的数量 则arguments保存实参的值</span></div><div class="line">    func02(<span class="number">1</span>);      <span class="comment">//实参的数量 &lt; 形参的数量 则不足的补undefined</span></div><div class="line">    <span class="comment">//匿名函数调用</span></div><div class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//如果需要在该函数中调用自身,则可以使用arguments.callee方法</span></div><div class="line">        <span class="built_in">arguments</span>.callee();</div><div class="line">    &#125;)();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<h2 id="Function的应用"><a href="#Function的应用" class="headerlink" title="Function的应用"></a>Function的应用</h2><p><strong>01 数组去重</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">var</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"arr"</span>,<span class="string">`</span></div><div class="line">    var array = [];</div><div class="line">    for(var i = 0 ; i&lt;arr.length; i++)</div><div class="line">    &#123;</div><div class="line">        if(array.indexOf(arr[i]) == -1)</div><div class="line">        &#123;</div><div class="line">            array.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return array;</div><div class="line">`);</div><div class="line">    <span class="built_in">console</span>.log(func([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>]));;</div></pre></td></tr></table></figure></p>
<p><strong>02 返回传入函数中所有数据的最大值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> maxNumber = <span class="built_in">arguments</span>[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (maxNumber &lt; <span class="built_in">arguments</span>[i])</div><div class="line">        &#123;</div><div class="line">            maxNumber = <span class="built_in">arguments</span>[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxNumber;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">30</span>, <span class="number">21</span>));</div></pre></td></tr></table></figure></p>
<h2 id="eval-简单说明"><a href="#eval-简单说明" class="headerlink" title="eval 简单说明"></a>eval 简单说明</h2><p><strong>eval 的基本使用</strong><br>eval函数用来讲字符串转换为JS的代码,并执行</p>
<p><strong>eval 处理JSON数据代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> jsonData = <span class="string">'&#123;"name":"张三","age":18&#125;'</span>;</div><div class="line">    <span class="comment">//把json的数据转换为对象</span></div><div class="line">    <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(jsonData);</div><div class="line">    <span class="built_in">console</span>.log(obj);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> jsonData = <span class="string">'&#123;"name":"张三","age":18&#125;'</span>;</div><div class="line">    <span class="comment">//var obj = eval(jsonData); //注意:如果直接这样写代码则会报错</span></div><div class="line">    <span class="comment">//正确的处理方式</span></div><div class="line">    <span class="comment">//方式一</span></div><div class="line">    <span class="built_in">eval</span>(<span class="string">"var obj = "</span> + jsonData);</div><div class="line">    <span class="built_in">console</span>.log(obj);</div><div class="line">    <span class="comment">//方式二</span></div><div class="line">    <span class="comment">//说明:使用eval来解析json格式字符串的时候,会将&#123;&#125;解析为代码块,而不是字面量</span></div><div class="line">    <span class="comment">// 在使用的时候为了避免这种错误,需要在JSO的最外面加上(),如此则会把大括号当做一条语句来解析</span></div><div class="line">    <span class="keyword">var</span> o = <span class="built_in">eval</span>(<span class="string">"("</span>+jsonData+<span class="string">")"</span>);</div><div class="line">    <span class="built_in">console</span>.log(o);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p><strong>eval 注意事项</strong></p>
<pre><code>① eval函数本身功能强大,但它的特性也为程序带来了很大的不确定性,因此在开发中并不推荐使用。
② eval函数是动态的执行代码,因此其效率不如直接执行静态脚本高。
</code></pre><p><strong>eval和Function比较</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">相同点:都能够把字符串转换为Javascript的代码</div><div class="line">不同点:eval转换为js的代码之后马上就执行,而Function需要先创建函数,调用函数之后才会执行。</div></pre></td></tr></table></figure></p>
<h2 id="Function-prototype原型链"><a href="#Function-prototype原型链" class="headerlink" title="Function.prototype原型链"></a>Function.prototype原型链</h2><p><strong>关于Function和自定义构造函数的原型对象</strong></p>
<pre><code>Function.prototype 是一个空的函数
自定义构造函数的原型对象是一个空的对象
</code></pre><p>说明</p>
<pre><code>Function也可以被当做是一个构造函数
通过new Function创建出来的函数,可以认为是Function的实例化对象。
Function的原型对象是一个空的函数,这个空的函数也是一个对象,它的原型对象是Object.prototype。
在JS中,Object的原型对象是所有对象的祖宗。

Function是构造函数,则其原型对象为空的函数
        空的函数的原型对象为Object.prototype
Function本身也是对象,则其构造函数为:function Function() { [native code] }  是自身
同Object类型
Object本身是构造函数,其原型对象是Object.prototype
Object本身也是对象,其构造函数为:function Function() { [native code]
</code></pre><p><strong>代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提供Person构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02 设置Person的原型对象</span></div><div class="line">    Person.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//03 创建Student构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">number</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.numer = number</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//04 设置Student的原型对象</span></div><div class="line">    Student.prototype = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure></p>
<p><strong>完整的原型链示意图</strong><br><img src="/assets/img/Snip20170213_12.png" alt="原型"><br><strong>Object和Function的关系</strong><br>01 Object构造函数是通过Function构造函数实例化出来的<br>02 Function构造函数也是通过Function构造函数实例化出来的</p>
<p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//检查对象是否是某个构造函数的实例</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);</div><div class="line">    <span class="comment">//注意:以上打印结果均为true</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="对象的拷贝操作"><a href="#对象的拷贝操作" class="headerlink" title="对象的拷贝操作"></a>对象的拷贝操作</h2><p><strong>浅拷贝</strong><br>如果对象中的属性是引用类型的值,那么存在数据共享问题,修改某个对象会对拷贝的对象产生影响<br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"张三"</span>,<span class="attr">car</span>:&#123;<span class="attr">number</span>:<span class="string">"2017"</span>,<span class="attr">type</span>:<span class="string">"火车"</span>&#125;&#125;;</div><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="comment">//obj对象需要拷贝o对象中所有的属性</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> o )&#123;</div><div class="line">    obj[i]  = o[i];</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(obj);</div><div class="line">o.car.type = <span class="string">"飞船"</span>;</div><div class="line"><span class="built_in">console</span>.log(obj);</div></pre></td></tr></table></figure></p>
<p><strong>深拷贝</strong></p>
<pre><code>如果对象中的属性是值类型,那么就直接拷贝赋值
如果对象中的属性是引用类型,那么就再次调用拷贝方法,遍历对象
</code></pre><p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"张三"</span>,<span class="attr">car</span>:&#123;<span class="attr">number</span>:<span class="string">"2017"</span>,<span class="attr">type</span>:<span class="string">"火车"</span>&#125;&#125;;</div><div class="line"> <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj,tmp</span>) </span>&#123;</div><div class="line">     tmp = tmp || &#123;&#125;;    <span class="comment">//如果没有传入,那么就创建一个空的对象</span></div><div class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)</div><div class="line">     &#123;</div><div class="line">         <span class="keyword">if</span> (obj.hasOwnProperty(i))   <span class="comment">//只拷贝实例属性</span></div><div class="line">         &#123;</div><div class="line">             <span class="comment">//判断是否是引用类型</span></div><div class="line">             <span class="keyword">if</span> ((<span class="keyword">typeof</span> obj[i]) == <span class="string">'object'</span>)</div><div class="line">             &#123;</div><div class="line">                 <span class="comment">//重新调用拷贝方法</span></div><div class="line">                 tmp[i] = <span class="built_in">Array</span>.isArray(obj[i]) ? [] :&#123;&#125;;</div><div class="line">                 deepCopy(obj[i],tmp[i]);</div><div class="line">             &#125;<span class="keyword">else</span></div><div class="line">             &#123;</div><div class="line">                 <span class="comment">//直接拷贝</span></div><div class="line">                 tmp[i] = obj[i];</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line">deepCopy(o,obj);</div><div class="line"> <span class="built_in">console</span>.log(obj);</div><div class="line"> o.car.type = <span class="string">"测试的类型"</span>;</div><div class="line"> <span class="built_in">console</span>.log(obj);</div><div class="line"> <span class="built_in">console</span>.log(o);</div></pre></td></tr></table></figure></p>
<p><strong>注意isArray的兼容性问题</strong><br>isArray是ECMA5中新推出的方法,需要处理兼容性问题<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray != <span class="string">"function"</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) == <span class="string">'[object Array]'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Number原型扩展"><a href="#Number原型扩展" class="headerlink" title="Number原型扩展"></a>Number原型扩展</h2><p>小案例：在Number的原型对象上面定义一个新的方法add(),该方法接收一个参数,并将该参数与自身的值进行相加,然后进行返回。<br>代码实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span> + num;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> n = <span class="number">10</span>;</div><div class="line"><span class="built_in">console</span>.log(n.add(<span class="number">3</span>));</div><div class="line"><span class="comment">//console.log(5.add(5));  错误:解析器无法处理字面量的这种情况</span></div><div class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">50</span>);</div><div class="line"><span class="built_in">console</span>.log(num.add(<span class="number">20</span>));       <span class="comment">//70</span></div><div class="line"><span class="built_in">console</span>.log((<span class="number">1</span>).add(<span class="number">4</span>));        <span class="comment">//5 使用()把数字包起来</span></div></pre></td></tr></table></figure></p>
<p>使用注意<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">（01）使用数字变量可以调用成功</div><div class="line">（02）使用数字表达式可以调用成功</div><div class="line">（03）直接使用数字字面量方式调用失败</div></pre></td></tr></table></figure></p>
<p>js的语法解析器无法处理数字字面量这种情况。</p>
<h2 id="With语句"><a href="#With语句" class="headerlink" title="With语句"></a>With语句</h2><p><strong>with语句简单介绍</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">with语句是js中一个强大但有争议的特性。</div><div class="line">with语句允许我们将一个对象的所有属性引用到当前的作用域</div><div class="line">允许我们无需使用拥有者对象的前缀，就可以直接对这些属性进行引用和赋值操作。</div></pre></td></tr></table></figure></p>
<p><code>注意</code>：ECMAScript5规范在严格模式下已经禁用了该语句，在开发中不推荐使用，但是要求能够看懂with的代码。</p>
<p><strong>with语句内部细节</strong><br><code>说明</code>： with语句会创建一个作用域，在该作用域内，在引用特定对象的属性时，可以不使用前缀。<br>应用场景：<code>对深层级对象的引用进行缩短</code>。</p>
<p><strong>在with作用域内部引用属性</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">//[01] 测试with语句作用域内对对象属性的引用</span></div><div class="line">    <span class="comment">//01 提供全局变量,名称为testValue</span></div><div class="line">    <span class="keyword">var</span> testValue = <span class="string">'测试使用的全局变量'</span>;</div><div class="line">    <span class="comment">//02 提供对象,对象内部提供属性</span></div><div class="line">    <span class="keyword">var</span> testObject = &#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">'对象的名称属性'</span>,</div><div class="line">        <span class="attr">testValue</span>:<span class="string">'对象内部的属性'</span></div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//03 使用with语句引用</span></div><div class="line">    <span class="keyword">with</span>(testObject)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">console</span>.log(name);          <span class="comment">//对象的名称属性</span></div><div class="line">        <span class="built_in">console</span>.log(testValue);     <span class="comment">//对象内部的属性</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);          <span class="comment">//window</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(testValue);         <span class="comment">//测试使用的全局变量</span></div><div class="line"><span class="string">``</span><span class="string">`   </span></div><div class="line">总结：</div><div class="line">(1) 在with语句作用域内,对象属性的优先级绝对高于在更层级作用域内定义的同名变量</div><div class="line">(2) this(函数上下文)依然指向window,并不会收到with作用域的影响</div><div class="line"></div><div class="line">**在with作用域内进行赋值操作**</div><div class="line">`<span class="string">``</span>js</div><div class="line">   <span class="comment">//01 提供一个对象,在内部提供属性</span></div><div class="line">    <span class="keyword">var</span> obj = &#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">'对象的内部属性'</span>,</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02 with语句测试对对象属性的赋值操作</span></div><div class="line">    <span class="keyword">with</span>(obj)</div><div class="line">    &#123;</div><div class="line">        name = <span class="string">'修正对象中name的值'</span>;</div><div class="line">        <span class="comment">//在作用域内部添加变量(思考?该变量是添加为全局作用域还是当前obj对象的属性?)</span></div><div class="line">        age = <span class="string">'25'</span>;</div><div class="line">        showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'name == '</span> + name);</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//测试修改对象属性操作</span></div><div class="line">    <span class="built_in">console</span>.log(obj.name);</div><div class="line">    <span class="comment">//测试添加对象属性操作</span></div><div class="line">    <span class="built_in">console</span>.log(obj.age);             <span class="comment">//undefined</span></div><div class="line">    <span class="comment">//obj.showName();                 //obj.showName is not a function    console.log('____________________');</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//== name == window.name</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.name);</div><div class="line">    <span class="built_in">console</span>.log(name);</div><div class="line">    showName();             <span class="comment">//==this.showName() ==window.showName()</span></div></pre></td></tr></table></figure></p>
<p>总结：<br>（1）在with作用域的内部我们可以使用无前缀引用对象的属性进行读取和赋值的操作 但是 不能使用无前缀的方式添加属性<br>（2）如果使用无前缀的方式来添加属性[对不存在的属性进行赋值操作],那么属性将被添加到全局上下文[window|this]<br>（3）可能产生的错误:意外的引入一个全局变量,而非为with作用域对象添加属性</p>
<p><strong>with语句的问题</strong><br>（1）with作用域内操作优先级混乱<br>（2）性能不好，会大大降低js代码的执行性能<br>（3）ECMAScript5规定在严格模式下禁用with特性</p>
<p><strong>with语句简化代码的替代方案</strong><br>使用即时调用函数来替代with语句，通过函数传参的方式使用更短的引用来替代冗长的引用前缀比使用with语句消除前缀的方式更好。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span>(<span class="keyword">this</span>.style)</div><div class="line">&#123;</div><div class="line">    width = <span class="string">'200px'</span>;</div><div class="line">    height = <span class="string">'200px'</span>;</div><div class="line">    backgroundColor = <span class="string">'#ca3'</span>;</div><div class="line">    <span class="built_in">console</span>.log(width); <span class="comment">//要访问的本应该是外部的字符串变量 "错误哈哈",但是这里被解释为200px</span></div><div class="line">&#125;</div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</div><div class="line">    s.width = <span class="string">'200px'</span>;</div><div class="line">    s.height = <span class="string">'200px'</span>;</div><div class="line">    s.backgroundColor = <span class="string">'#ca3'</span>;</div><div class="line">&#125;)(<span class="keyword">this</span>.style);</div></pre></td></tr></table></figure></p>
<p><strong>使用面向过程的方式处理</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> bookList = [</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"什么是批判"</span>,<span class="attr">author</span>:<span class="string">"福柯"</span>&#125;,</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"飞鸟集"</span>,<span class="attr">author</span>:<span class="string">"泰戈尔"</span>&#125;</div><div class="line">    ];</div><div class="line">    <span class="comment">//增加操作</span></div><div class="line">    bookList.push(&#123;<span class="attr">name</span>:<span class="string">"城堡"</span>,<span class="attr">author</span>:<span class="string">"卡夫卡"</span>&#125;);</div><div class="line">    <span class="comment">//查询操作</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bookList.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> obj = bookList[i];</div><div class="line">        <span class="keyword">if</span> (obj.name == <span class="string">"飞鸟集"</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">console</span>.log(obj);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//修改操作</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bookList.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> obj = bookList[i];</div><div class="line">        <span class="keyword">if</span> (obj.name == <span class="string">"飞鸟集"</span>)</div><div class="line">        &#123;</div><div class="line">            obj.author = <span class="string">"泰戈尔-戈尔泰"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//删除操作</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bookList.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> obj = bookList[i];</div><div class="line">        <span class="keyword">if</span> (obj.name == <span class="string">"飞鸟集"</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//删除该对象</span></div><div class="line">            bookList.splice(i, <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(bookList);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>使用函数来封装图书管理操作</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> bookList = [</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"什么是批判"</span>,<span class="attr">author</span>:<span class="string">"福柯"</span>&#125;,</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"飞鸟集"</span>,<span class="attr">author</span>:<span class="string">"泰戈尔"</span>&#125;</div><div class="line">    ];</div><div class="line">    <span class="comment">//增加操作</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addBook</span>(<span class="params">bookObj</span>) </span>&#123;</div><div class="line">        bookList.push(bookObj);</div><div class="line">    &#125;</div><div class="line">    addBook(&#123;<span class="attr">name</span>:<span class="string">"城堡"</span>,<span class="attr">author</span>:<span class="string">"卡夫卡"</span>&#125;);</div><div class="line">    <span class="comment">//查询操作</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getBook</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bookList.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> obj = bookList[i];</div><div class="line">            <span class="keyword">if</span> (obj.name == name)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">return</span> obj;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(getBook(<span class="string">"什么是批判"</span>));</div><div class="line">    <span class="comment">//修改操作</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">updateBookData</span>(<span class="params">name,authorName</span>)</span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bookList.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> obj = bookList[i];</div><div class="line">            <span class="keyword">if</span> (obj.name == name)</div><div class="line">            &#123;</div><div class="line">                obj.author = authorName;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    updateBookData(<span class="string">"飞鸟集"</span>,<span class="string">"泰戈尔斯坦"</span>);</div><div class="line">   <span class="comment">//删除操作</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeBook</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bookList.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> obj = bookList[i];</div><div class="line">            <span class="keyword">if</span> (obj.name == name)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">//删除该对象</span></div><div class="line">                bookList.splice(i, <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(bookList);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>数封装-复用形式</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> bookList = [</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"什么是批判"</span>,<span class="attr">author</span>:<span class="string">"福柯"</span>&#125;,</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"飞鸟集"</span>,<span class="attr">author</span>:<span class="string">"泰戈尔"</span>&#125;</div><div class="line">    ];</div><div class="line">    <span class="comment">//增加操作</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addBook</span>(<span class="params">bookObj</span>) </span>&#123;</div><div class="line">        bookList.push(bookObj);</div><div class="line">    &#125;</div><div class="line">    addBook(&#123;<span class="attr">name</span>:<span class="string">"城堡"</span>,<span class="attr">author</span>:<span class="string">"卡夫卡"</span>&#125;);</div><div class="line">    <span class="comment">//查询操作</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getBook</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bookList.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> obj = bookList[i];</div><div class="line">            <span class="keyword">if</span> (obj.name == name)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">return</span> obj;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(getBook(<span class="string">"什么是批判"</span>));</div><div class="line">    <span class="comment">//修改操作</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">updateBookData</span>(<span class="params">name,authorName</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> obj = getBook(name);</div><div class="line">        obj.author = authorName;</div><div class="line">    &#125;</div><div class="line">    updateBookData(<span class="string">"飞鸟集"</span>,<span class="string">"泰戈尔斯坦"</span>);</div><div class="line">    <span class="comment">//删除操作</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeBook</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> obj = getBook(name);</div><div class="line">        <span class="keyword">var</span> index = bookList.indexOf(obj);</div><div class="line">        bookList.splice(index,<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    addBook(&#123;<span class="attr">name</span>:<span class="string">"东京人"</span>,<span class="attr">author</span>:<span class="string">"川端康成"</span>&#125;);</div><div class="line">    <span class="built_in">console</span>.log(bookList);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>面向对象的方式管理图书</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">&lt;scrip&gt;</div><div class="line">    <span class="keyword">var</span> obj = [</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"什么是批判"</span>,<span class="attr">author</span>:<span class="string">"福柯"</span>&#125;,</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"飞鸟集"</span>,<span class="attr">author</span>:<span class="string">"泰戈尔"</span>&#125;</div><div class="line">    ];</div><div class="line">泰    <span class="function"><span class="keyword">function</span> <span class="title">BookManager</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.bookList = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">   BookManager.prototype = &#123;</div><div class="line">        <span class="attr">constructor</span>:BookManager,</div><div class="line">        <span class="attr">init</span>:<span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.bookList = arr || [];</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">addBook</span>:<span class="function"><span class="keyword">function</span> (<span class="params">bookObj</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.bookList.push(bookObj)</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">getBook</span>:<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.bookList.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> obj = <span class="keyword">this</span>.bookList[i];</div><div class="line">            <span class="keyword">if</span> (obj.name == name)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">return</span> obj;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;,</div><div class="line">        <span class="attr">updateBookData</span>:<span class="function"><span class="keyword">function</span> (<span class="params">name,authorName</span>)</span>&#123;</div><div class="line">            <span class="keyword">var</span> obj = <span class="keyword">this</span>.getBook(name);</div><div class="line">            obj.author = authorName;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">removeBook</span>:<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> obj = <span class="keyword">this</span>.getBook(name);</div><div class="line">            <span class="keyword">var</span> index = <span class="keyword">this</span>.bookList.indexOf(obj);</div><div class="line">            <span class="keyword">this</span>.bookList.splice(index,<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//01 创建对象</span></div><div class="line">    <span class="keyword">var</span> YYManager = <span class="keyword">new</span> BookManager();</div><div class="line">    YYManager.init(obj);</div><div class="line">    <span class="built_in">console</span>.log(YYManager.bookList);</div><div class="line">    <span class="comment">//02 演示添加操作</span></div><div class="line">    YYManager.addBook(&#123;<span class="attr">name</span>:<span class="string">"花田半亩"</span>,<span class="attr">author</span>:<span class="string">"田维"</span>&#125;);</div><div class="line">    <span class="built_in">console</span>.log(YYManager.bookList);</div><div class="line">    <span class="comment">//03 演示查询操作</span></div><div class="line">    <span class="built_in">console</span>.log(YYManager.getBook(<span class="string">"花田半亩"</span>));</div><div class="line">    <span class="comment">//04 演示更新操作</span></div><div class="line">    YYManager.updateBookData(<span class="string">"花田半亩"</span>,<span class="string">"甜田"</span>);</div><div class="line">    <span class="built_in">console</span>.log(YYManager.getBook(<span class="string">"花田半亩"</span>));;</div><div class="line">    <span class="comment">//05 演示删除操作</span></div><div class="line">    YYManager.removeBook(<span class="string">"什么是批判"</span>);</div><div class="line">    <span class="built_in">console</span>.log(YYManager.bookList);</div><div class="line">    <span class="comment">//02 创建第二个人的图书管理对象</span></div><div class="line">    <span class="keyword">var</span> wulitaotaoMManager = <span class="keyword">new</span> BookManager();</div><div class="line">    wulitaotaoMManager.init([&#123;<span class="attr">name</span>:<span class="string">"装逼速成"</span>,<span class="attr">author</span>:<span class="string">"六扇门"</span>&#125;]);</div><div class="line">    <span class="built_in">console</span>.log(wulitaotaoMManager.bookList);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>总结<br>01 提供构造函数，在构造函数内部设置实例化属性<br>02 把常用的操作提取成对象的实例方法，写在原型对象身上<br>03 提供init方法，用于初始化数据<br>04 注意：如果切断了原型对象那么需要修正内部的构造器属性指向</p>
<h1 id="变量和函数"><a href="#变量和函数" class="headerlink" title="变量和函数"></a>变量和函数</h1><blockquote>
<p>JavaScript中有严格模式和非严格模式两种运行环境,本章节主要讲严格模式及非严格模式下函数和变量的区别,最后简单讲诉了JavaScript作用域。</p>
</blockquote>
<p><strong>私有变量和函数</strong></p>
<pre><code>定义在构造函数内部而被this对象的变量,在外部无法访问到的变量和函数
</code></pre><!-- more -->
<p><strong>公有变量和方法</strong></p>
<pre><code>对外暴露接口,可以通过构造函数对象创建的对象访问的属性和方法
</code></pre><p><strong>代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">type,number</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.type = type;   <span class="comment">//公共的属性</span></div><div class="line">        <span class="keyword">this</span>.number = number;</div><div class="line">        <span class="keyword">var</span> city = <span class="string">"广州"</span>;                <span class="comment">//私有变量</span></div><div class="line">        <span class="keyword">var</span> getNumber = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;       <span class="comment">//私有函数</span></div><div class="line">            <span class="keyword">return</span> number;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">var</span> getType = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> type;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//能够访问私有变量和函数的方法 --- 特权方法</span></div><div class="line">        <span class="keyword">this</span>.getDescription = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(getNumber() + getType() + city);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> car = <span class="keyword">new</span> Car(<span class="string">"汽车"</span>,<span class="string">"201718"</span>);</div><div class="line">    car.getDescription();</div></pre></td></tr></table></figure></p>
<p>说明：能够访问构造函数内部私有变量|函数的方法称之为特权方法</p>
<p><strong>构造函数的问题</strong><br>构造函数本身是一个函数，在调用的时候有多种调用方式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">① <span class="keyword">new</span> 构造函数（）调用</div><div class="line">② 构造函数（）调用</div></pre></td></tr></table></figure></p>
<p>以上，第二种调用方式存在作用域安全的问题</p>
<p><strong>作用域安全的构造函数</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="comment">//容错处理</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//设置实例属性和方法</span></div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02  创建对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">"zhangsan"</span>);</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">"lisi"</span>);</div><div class="line">    p1.showName();</div><div class="line">    p2.showName();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>新的问题</strong><br><code>说明</code>:上面的代码在使用借用构造函数方式继承的时候存在问题，无法创建出的对象，原因在于通过call或者是apply函数调用的时候，内部的this绑定的子类型中的对象，因此在使用instanceOf 判断的时候，结果为假。<br><code>解决</code>：可以设置让子类型（构造函数）的原型对象为父类型的一个实例。<br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="comment">//容错处理</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//设置实例属性和方法</span></div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02  创建对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">"zhangsan"</span>);</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">"lisi"</span>);</div><div class="line">    p1.showName();</div><div class="line">    p2.showName();</div><div class="line">    <span class="comment">// 使用借用构造函数来实现继承</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Boy</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">        Person.call(<span class="keyword">this</span>,name);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//需要结合原型继承来解决 instanceOf 实例对象检测的问题</span></div><div class="line">    Boy.prototype = <span class="keyword">new</span> Person();</div><div class="line">    <span class="keyword">var</span> boy = <span class="keyword">new</span> Boy(<span class="string">"测试的名字"</span>);</div><div class="line">    boy.showName();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><p>关键字 <code>“use strict”</code>;<br><strong>实现严格模式</strong>:只需要在脚本代码中添加上上述关键字即可。 关键字具体说明<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>) 注意区分大小写，必须全部都是小写的</div><div class="line">(<span class="number">2</span>) 注意空格，整个字符串总共<span class="number">10</span>个字符</div><div class="line">(<span class="number">3</span>) 单引号和双引号无所谓，但是需要有双引号</div><div class="line">(<span class="number">4</span>) 必须写在作用域的最顶部，注意其位置</div><div class="line">(<span class="number">5</span>) 可以加分号，也可以不加，但是必须是一个字符串</div></pre></td></tr></table></figure></p>
<p>注意：以下的关键字写法均是错误的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"USE strict"</span>;</div><div class="line"><span class="string">" use strict "</span>;</div><div class="line"><span class="string">"("</span>USE strict<span class="string">").toLowerCase();"</span></div></pre></td></tr></table></figure></p>
<h2 id="严格模式使用注意"><a href="#严格模式使用注意" class="headerlink" title="严格模式使用注意"></a>严格模式使用注意</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> 所有的变量必须使用<span class="keyword">var</span> 关键字声明</div><div class="line"><span class="number">2</span> 不能使用<span class="keyword">delete</span>关键字删除全局变量 ,以前默认删除失败,严格模式下直接报错</div><div class="line"><span class="number">3</span> 在对象中不允许有同名的属性</div><div class="line"><span class="number">4</span> 函数的参数必须唯一(不能出现同名的参数)</div><div class="line"><span class="number">5</span> <span class="built_in">arguments</span>对象的行为不同,在非严格模式下修改形参的值会反映到<span class="built_in">arguments</span>中,而严格模式下则相对独立</div><div class="line"><span class="number">6</span> 禁用了argument.callee和caller函数,他们一个引用函数本身,一个引用调用函数</div><div class="line"><span class="number">7</span> 不能在<span class="keyword">if</span>语句中声明函数</div><div class="line"><span class="number">8</span> 禁止使用<span class="built_in">eval</span>和<span class="built_in">arguments</span>作为标识符</div><div class="line"><span class="number">9</span> 修正<span class="keyword">this</span>的值,在严格模式下,函数<span class="keyword">this</span>的值始终是指定的值,无论指定的是什么值。</div><div class="line"><span class="number">10</span> 禁用了<span class="keyword">with</span>语句</div><div class="line"><span class="number">11</span> 去掉了JavaScript中的八进制字面量(以<span class="number">0</span>开头的八进制字面量是无效的语法)</div></pre></td></tr></table></figure>
<p><strong>1 所有的变量都必须使用var关键字声明</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">10</span>;             <span class="comment">//错误的演示</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">10</span>);</div></pre></td></tr></table></figure></p>
<p><strong>② 不能使用delete关键字删除全局变量</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在非严格模式下,删除失败(静默失败)   失败了不吭声,严格模式下直接报错</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">delete</span> a;</div><div class="line"><span class="built_in">console</span>.log(a);</div></pre></td></tr></table></figure></p>
<p><strong>③ 在对象中不允许有同名的属性</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在非严格模式下,会使用后面的属性赋值作为最终值,在严格模式下则直接报错</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"张三"</span>,</div><div class="line">    <span class="attr">name</span>:<span class="string">"李四"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj);</div></pre></td></tr></table></figure></p>
<p><strong>④ 函数的参数必须唯一(不能出现同名的参数)</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在非严格模式下,如果函数在定义的时候,使用了多个同名的参数,则在函数内部形参的实际值为最后一个传入的实参值</span></div><div class="line"><span class="comment">//在严格模式下,直接报错</span></div><div class="line"><span class="comment">//    function func(a,a,a) &#123;</span></div><div class="line"><span class="comment">//        console.log(a);</span></div><div class="line"><span class="comment">//        console.log(arguments);</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a,b,c</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</div></pre></td></tr></table></figure></p>
<p><strong>arguments对象的行为不同</strong><br>说明：<br>（1）严格模式下,在函数内部修改了对象的指向,对arguments的值不会产生影响<br>（2）在严格模式下,形参的值和arguments的值是相互独立的,在函数内部修改了形参的值对arguments不受影响<br>（3）在非严格模式下，修改了形参的值，arguments中的数据会跟着改变<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">//测试引用类型的值作为函数的参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(obj);</div><div class="line">       <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">       <span class="comment">//在函数内部修改形参的值</span></div><div class="line">       obj = &#123;<span class="attr">age</span>:<span class="number">20</span>&#125;;</div><div class="line">       <span class="built_in">console</span>.log(obj);</div><div class="line">       <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">   &#125;</div><div class="line">   funcName(&#123;<span class="attr">name</span>:<span class="string">"张三"</span>&#125;);</div><div class="line">   <span class="comment">//测试基本类型数据作为函数的参数</span></div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(str);</div><div class="line">       <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">       str = <span class="string">"hello"</span>;</div><div class="line">       <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">   &#125;</div><div class="line">   fun(<span class="string">"hi"</span>);</div></pre></td></tr></table></figure></p>
<p><strong>⑥ 禁用了argument.callee和caller函数</strong><br>说明：<br>argument.callee是对函数自身的引用<br>argument.calller是对调用函数的引用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = (<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n ==<span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">arguments</span>.callee(n<span class="number">-1</span>) + n;</div><div class="line">    &#125;)(<span class="number">10</span>);</div><div class="line">    <span class="built_in">console</span>.log(num);       <span class="comment">//55</span></div></pre></td></tr></table></figure></p>
<p><strong>⑦ 不能在if语句中声明函数</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果在if语句中声明函数，则会产生语法错误</span></div><div class="line">  <span class="keyword">if</span> (<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"________"</span>);</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"呵呵呵呵"</span>);</div><div class="line">        &#125;</div><div class="line">        demo();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><strong>⑧ 禁止使用eval和argument作为标识符</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">eval</span> = <span class="string">"测试的字符串"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>);</div><div class="line"><span class="keyword">var</span> <span class="built_in">arguments</span> = <span class="string">"参数列表"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div></pre></td></tr></table></figure></p>
<p><strong>⑨ 修正this的值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">在严格模式下,函数<span class="keyword">this</span>的值始终是指定的值,无论指定的是什么值</div><div class="line"><span class="keyword">var</span> name = <span class="string">"测试的name"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demoTest</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//在非严格模式下,打印出来的this为全局的对象window</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">//在严格模式下打印出来的this为undefined</span></div><div class="line">&#125;</div><div class="line">demoTest();</div></pre></td></tr></table></figure></p>
<p><strong>⑩ 禁用了with语句</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"暂时干"</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;;</div><div class="line">  <span class="keyword">with</span>(o)</div><div class="line">  &#123;</div><div class="line">      name = <span class="string">"lisi"</span>;</div><div class="line">      age = <span class="number">48</span></div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(o);</div></pre></td></tr></table></figure></p>
<p><strong>禁用了八进制</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//以0开头的数据常常引起混乱</span></div><div class="line"><span class="comment">//var num = 023;     //2*8 + 3 ==&gt; 19</span></div><div class="line"><span class="comment">//console.log(num); //19</span></div></pre></td></tr></table></figure></p>
<p><strong>书写格式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">01 必须使用单引号或者是双引号括住字符串</div><div class="line">02 必须使用小写,不能出现大写字符</div><div class="line">03 必须是10个字符</div><div class="line">04 字符串后面的分号可以省略</div><div class="line">05 必须写在当前作用域的最顶上</div></pre></td></tr></table></figure></p>
<p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//"use strict";   //正确写法</span></div><div class="line">    <span class="comment">//"use strict"    //正确写法     分号可以省略</span></div><div class="line">    <span class="comment">//'use strict';   //正确写法     可以使用单引号</span></div><div class="line">    <span class="comment">//"use  strict";    //错误写法   必须是10个字符</span></div><div class="line">    <span class="comment">//"use Strict";     //错误写法   所有的字符都必须小写</span></div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line">    a = <span class="number">10</span>;</div><div class="line">    <span class="comment">//    "use strict";           //错误写法 必须写在当前作用域的顶端</span></div><div class="line">    b = <span class="number">20</span>;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>作用范围</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">① 函数的顶部(只对当前的函数有效)</div><div class="line">② script标签的顶部,只对当前的标签有效,对页面中其他的script无效</div></pre></td></tr></table></figure></p>
<p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//位置01       对func01和func02都有效</span></div><div class="line"> <span class="comment">//"use strict";</span></div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">func01</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="comment">//位置02   对func01有效,对func02无效</span></div><div class="line">     <span class="comment">//"use strict";</span></div><div class="line">     a = <span class="number">10</span>;</div><div class="line">     <span class="built_in">console</span>.log(a);</div><div class="line"> &#125;</div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">func02</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="comment">//位置03 对func02有效,但对func01无效</span></div><div class="line">    <span class="comment">//"use strict";</span></div><div class="line">     b = <span class="number">20</span>;</div><div class="line">     <span class="built_in">console</span>.log(b);</div><div class="line"> &#125;</div><div class="line">func01();</div><div class="line"> func02();</div></pre></td></tr></table></figure></p>
<p><strong>函数的几种调用方式</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">01</span> 普通函数调用 内部的<span class="keyword">this</span>指向全局对象<span class="built_in">window</span></div><div class="line"><span class="number">02</span> 构造函数调用 内部的<span class="keyword">this</span>指向新创建的对象</div><div class="line"><span class="number">03</span> 对象的方法调用 内部的<span class="keyword">this</span>指向调用的对象本身</div><div class="line"><span class="number">04</span> 通过call 或者是apply方式调用(函数上下文),<span class="keyword">this</span>指向的是当前的上下文对象</div></pre></td></tr></table></figure></p>
<p><strong>this丢失demo演示</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> obj = &#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"张三"</span>,</div><div class="line">        <span class="attr">getName</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//以对象的方法来进行调用</span></div><div class="line">    obj.getName();  <span class="comment">//张三</span></div><div class="line">    <span class="keyword">var</span> getName = obj.getName;</div><div class="line">    getName();  <span class="comment">//以普通函数的方式调用,此时内部的this指向的是window对象  打印的是window.name 为空值</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>代码示例02</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 获取页面中id值为demo的标签</span></div><div class="line">    <span class="comment">//var div = document.getElementById('demo');</span></div><div class="line"><span class="comment">//    var getId = document.getElementById;</span></div><div class="line"><span class="comment">//    var div = getId('demo');        //会报错?</span></div><div class="line"><span class="comment">//    console.log(div);</span></div><div class="line">    <span class="comment">//借用apply来修正this</span></div><div class="line">    <span class="built_in">document</span>.getElementById = (<span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">           <span class="keyword">return</span> func.apply(<span class="built_in">document</span>,<span class="built_in">arguments</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;)(<span class="built_in">document</span>.getElementById);</div><div class="line">    <span class="keyword">var</span> getId = <span class="built_in">document</span>.getElementById;</div><div class="line">    <span class="keyword">var</span> div = getId(<span class="string">'demo'</span>);        <span class="comment">//会报错?</span></div><div class="line">    <span class="built_in">console</span>.log(div);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>代码说明：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">01</span> 因为<span class="built_in">document</span>.getElementById方法的内部实现中需要使用到<span class="keyword">this</span>,这个<span class="keyword">this</span>本来期望指向的是<span class="built_in">document</span>对象</div><div class="line"><span class="number">02</span> 当我们以<span class="built_in">document</span>.getElementById来调用的时候,内部的<span class="keyword">this</span>指向<span class="built_in">document</span>对象</div><div class="line"><span class="number">03</span> 但是当我们以getId的方式调用的时候,内部的<span class="keyword">this</span>指向的是<span class="built_in">window</span>对象(因为我们以普通的方式进行调用)</div></pre></td></tr></table></figure></p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>变量其作用的范围就是它的作用域</p>
<p><strong>块级作用域</strong><br>说明：JavaScript中没有块级作用域<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">       <span class="keyword">var</span> num = i;</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">console</span>.log(i);</div><div class="line">   <span class="built_in">console</span>.log(num);</div><div class="line">   <span class="comment">//说明:如果有块级作用域,则i和num打印的结果应该为undefined</span></div></pre></td></tr></table></figure></p>
<p><strong>词法作用域</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">词法作用域:在代码写好的那一刻,变量的作用域就已经确定的</div><div class="line">动态作用域:变量的作用域由执行时的环境所决定</div><div class="line">说明:在js中不是动态作用域,当调用的时候,是往上查找的,不会到其他函数的作用域中去查找</div></pre></td></tr></table></figure></p>
<p><strong>在JavaScript中唯一能够产生作用域的东西是函数</strong><br>代码演示<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    var a = "这是第一个a";</div><div class="line">    function func01() &#123;</div><div class="line">        console.log(a);         //先在当前作用域中查找,如果没有则访问全局的作用域</div><div class="line">    &#125;</div><div class="line">    function func02() &#123;</div><div class="line">        var a = "这是第二个a";</div><div class="line">        func01()</div><div class="line">    &#125;</div><div class="line">    func01();       //打印结果为:这是第一个a</div><div class="line">    func02();       //打印结果为:这是第一个a</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    var a = "这是第一个a";</div><div class="line">    function func02() &#123;</div><div class="line">        var a = "这是第二个a";</div><div class="line">        func01()</div><div class="line">    &#125;</div><div class="line">    function func01() &#123;</div><div class="line">        console.log(a);         //先在当前作用域中查找,如果没有则访问全局的作用域</div><div class="line">    &#125;</div><div class="line">    func01();       //打印结果为:这是第一个a</div><div class="line">    func02();       //打印结果为:这是第一个a</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p><strong>词法作用域的规则</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">① 在函数内部允许访问外部的变量</div><div class="line">② 只有函数可以限定作用域</div><div class="line">③ 作用域规则首先使用提升规则分析</div><div class="line">④ 如果当前作用域中有该变量,则不考虑外部作用域的同名变量</div></pre></td></tr></table></figure></p>
<h2 id="变量和函数提升"><a href="#变量和函数提升" class="headerlink" title="变量和函数提升"></a>变量和函数提升</h2><p><strong>JS中的代码执行分为两个步骤</strong><br>① 预解析<br>JavaScript在预解析阶段,会对使用var关键字声明的变量和function声明的代码块进行提升操作,提升到当前作用域的顶端<br>② 执行</p>
<p><strong>代码提升的几种情况</strong></p>
<p><strong>01 函数提升</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    func();</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"测试的函数"</span>);</div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>02 变量提升</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="built_in">console</span>.log(a);     <span class="comment">//打印出来的结果为undefined</span></div><div class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line">    <span class="comment">//var a;                //注意:只会对变量的声明进行提升</span></div><div class="line">    <span class="comment">//console.log(a);</span></div><div class="line">    <span class="comment">//a = 10</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>03 函数同名情况提升</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    func01();                   <span class="comment">//打印last</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func01</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"first"</span>);</div><div class="line">    &#125;</div><div class="line">    func01();                   <span class="comment">//打印last</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func01</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"last"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//模拟提升后的情况</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func01</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"first"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func01</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"last"</span>);</div><div class="line">    &#125;</div><div class="line">    func01();</div><div class="line">    func01();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>说明：<code>预处理的时候，同名的函数都会进行提升，但是后面的会覆盖掉前面的</code></p>
<p><strong>04 变量名和函数同名的情况</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="built_in">console</span>.log(a);                     <span class="comment">//打印function</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"我是一个函数"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</div><div class="line">    <span class="built_in">console</span>.log(a);                     <span class="comment">//打印20</span></div><div class="line">    <span class="comment">//变量和函数提升后的结果 错误</span></div><div class="line"><span class="comment">//    function a() &#123;</span></div><div class="line"><span class="comment">//        console.log("我是一个函数");</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line"><span class="comment">//    var a ;</span></div><div class="line"><span class="comment">//    console.log(a);</span></div><div class="line"><span class="comment">//    a = 20;</span></div><div class="line"><span class="comment">//    console.log(a);</span></div><div class="line">    <span class="comment">//变量和函数提升后的结果 正确</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"我是一个函数"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line"><span class="string">``</span><span class="string">`js</span></div><div class="line">总结:如果出现变量和函数同名的情况,则在进行提升的时候,只会提升函数到当前作用域顶端而忽略变量的提升操作</div><div class="line"></div><div class="line">**变量的提升是分作用域的**</div><div class="line">示例代码01</div><div class="line">`<span class="string">``</span>js</div><div class="line">&lt;script&gt;</div><div class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//undefined</span></div><div class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line">    <span class="comment">//模拟提升</span></div><div class="line">    <span class="keyword">var</span> a;</div><div class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//undefined</span></div><div class="line">    a = <span class="number">10</span>;</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>示例代码02<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> num = <span class="number">20</span>;</div><div class="line">        <span class="built_in">console</span>.log(num);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(num);   <span class="comment">//10</span></div><div class="line">    func();             <span class="comment">//20</span></div><div class="line">    <span class="comment">//模拟提升</span></div><div class="line">    <span class="keyword">var</span> num;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> num;</div><div class="line">        num = <span class="number">20</span>;</div><div class="line">        <span class="built_in">console</span>.log(num);</div><div class="line">    &#125;</div><div class="line">    num = <span class="number">10</span>;</div><div class="line">    <span class="built_in">console</span>.log(num);   <span class="comment">//10</span></div><div class="line">    func();             <span class="comment">//20</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p>示例代码03<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(num);</div><div class="line">    <span class="keyword">var</span> num = <span class="number">20</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(num);   <span class="comment">//10</span></div><div class="line">func();             <span class="comment">//undefiend</span></div><div class="line"><span class="comment">//模拟提升</span></div><div class="line"><span class="keyword">var</span> num;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num;</div><div class="line">    <span class="built_in">console</span>.log(num);</div><div class="line">    num = <span class="number">20</span>;</div><div class="line">&#125;</div><div class="line">num = <span class="number">10</span>;</div><div class="line"><span class="built_in">console</span>.log(num);   <span class="comment">//10</span></div><div class="line">func();             <span class="comment">//undefiend</span></div></pre></td></tr></table></figure></p>
<p>示例代码04<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(num);</div><div class="line">    num = <span class="number">20</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(num);   <span class="comment">//10</span></div><div class="line">func();             <span class="comment">//10</span></div><div class="line"><span class="comment">//模拟变量提升</span></div><div class="line"><span class="keyword">var</span> num;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(num);</div><div class="line">    num = <span class="number">20</span>;</div><div class="line">&#125;</div><div class="line">num= <span class="number">10</span>;</div><div class="line"><span class="built_in">console</span>.log(num);   <span class="comment">//10</span></div><div class="line">func();             <span class="comment">//10</span></div><div class="line"><span class="built_in">console</span>.log(num);   <span class="comment">//20</span></div></pre></td></tr></table></figure></p>
<p><strong>函数表达式的提升</strong><br>说明：在使用函数表达式方式创建函数的时候,整个函数表达式并不会进行提升,只会对var声明的变量提升<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func();</div><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"会不会被调用"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//以上如上代码将报错</span></div><div class="line"><span class="comment">//模拟提升的过程</span></div><div class="line"><span class="keyword">var</span> func;</div><div class="line">func();                 <span class="comment">//找不到这个函数</span></div><div class="line">func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"会不会被调用"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><pre><code>01 在js中函数可以创建作用域
02 函数中又可以创建函数(即又可以开辟新的作用域)
03 函数内部的作用域可以访问外部的作用域
04 如果有多个函数嵌套,那么就会构成一个链式的访问结构,也就是作用域链
05 注意:函数内部的作用域可以访问外部的作用域,但是外部的作用域却不能访问内部的作用域
</code></pre><p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//f1---&gt;全局作用域</span></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">//f4--&gt;f1---&gt;全局作用域</span></div><div class="line">            <span class="function"><span class="keyword">function</span> <span class="title">f5</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//f2--&gt;全局作用域</span></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f6</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<h1 id="作用域链绘图"><a href="#作用域链绘图" class="headerlink" title="作用域链绘图"></a>作用域链绘图</h1><p>说明</p>
<pre><code>① 先画出全局作用域线条，然后在上面添加全局作用域中的函数和变量，作为0级作用域链
② 画出全局作用域中的函数的作用域线条，，然后在上面添加当前作用域中的函数和变量，作为1级作用域链
③ 以此类推，直至完成
</code></pre><p>示例代码01<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><code>图示</code><br><img src="/assets/img/Snip20170217_4.png" alt=""></p>
<p>示例代码02<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="function"><span class="keyword">function</span> <span class="title">f5</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> b = <span class="string">"demo"</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> c = <span class="string">"啊哈哈"</span>;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> d = <span class="string">"test"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><code>图示</code><br><img src="/assets/img/Snip20170217_3.png" alt=""></p>
<h2 id="作用域注意点和变量搜索原则"><a href="#作用域注意点和变量搜索原则" class="headerlink" title="作用域注意点和变量搜索原则"></a>作用域注意点和变量搜索原则</h2><p><strong>注意点</strong></p>
<pre><code>01 在获取值和设置值的时候都是访问变量
02 并非在函数内部写了变量,这个变量就属于当前函数,而是必须使用var 关键字声明的变量才属于当前函数
03 函数在声明的时候,里面的代码并不会执行,只有在函数调用的时候才会执行
04 声明函数时候的函数名,其实也是一个变量名,可以通过这个变量名来进行设置和赋值
05 注意:在变量内部使用var 关键字声明一个变量并不会把同名的全局变量覆盖掉
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">var</span> a = <span class="number">20</span>;              <span class="comment">//注意:该行代码并不会覆盖掉全局变量中的变量a</span></div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">&#125;</div><div class="line">f1();               <span class="comment">//20</span></div><div class="line"><span class="built_in">console</span>.log(a);     <span class="comment">//10</span></div></pre></td></tr></table></figure>
<p>代码点评：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在函数中使用var关键字声明变量a并不会覆盖全局作用域中的a。</div><div class="line">注意需要同时考虑变量在当前作用域的提升以及访问变量时的搜索原则。</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f1 = <span class="string">"demo字符串"</span>;         <span class="comment">//该行代码会把f1函数覆盖掉</span></div><div class="line">f1 = <span class="string">"demoTest字符串"</span>;</div><div class="line"><span class="built_in">console</span>.log(f1);</div><div class="line"><span class="comment">//f1();</span></div></pre></td></tr></table></figure>
<p>代码点评:<br><code>函数的名称也是变量，如果在代码中出现同名的变量，那么函数的实现会被覆盖掉</code></p>
<p> <strong>变量搜索原则</strong></p>
<pre><code>01 在使用变量的时候,首先在自己的作用域中查找
02 如果找到了就直接使用,如果没有找到,那么就到上一级作用域中去查找
03 重复上面的步骤,直到0级作用域,如果还是找不到那么就返回undefined(报错)
</code></pre><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><blockquote>
<p>闭包是学习JavaScript的难点之一，因JavaScript是单线程，故回调使用频繁，本章节主要讲了闭包以及回调。</p>
</blockquote>
<p><strong>闭包简单说明</strong></p>
<pre><code>闭:关闭,封闭
包:包住,包裹
闭包:通过某种方式实现的一个封闭的、包裹的对外不公开的结构|空间
闭包的原理:变量的访问原则(即上一级的作用域无法访问下一级的作用域),其实函数本身就是闭包。
</code></pre><!-- more -->
<p><strong>闭包要解决的问题</strong></p>
<pre><code>提供一种间接的方式能够访问到函数内部的数据（变量）
</code></pre><p><strong>实现思路</strong></p>
<pre><code>01 我们需要能够在函数外部访问函数内部的变量，正常情况无法访问；
02 在函数内部如果新创建函数，那么安装作用域链的原则，这个新创建的内部函数能够访问到函数中的这些变量。
03 我们如果能够操作函数中新创建的函数，那么就能够操作函数中的变量（如访问和设置等）
04 如果要能够操作函数中新创建的函数，那么需要在函数中把新创建的函数返回。
05 调用函数，接收并得到其返回值（是一个函数）
06 调用返回值（函数），通过函数传参的方式来设置函数中的变量。
07 调用返回值（函数），通过在函数内部再次return的方式来访问函数中的变量。
</code></pre><p><strong>闭包的基本模式</strong></p>
<pre><code>在函数内部创建函数(内部函数),在这个内部函数中,可以操作外部函数中的变量
01 在函数(外部)中创建函数(内部函数),在该函数(内部函数)中操作外部函数中的变量
02 在外部函数中,把内部函数作为返回值返回
03 调用外部函数,并接收其返回值(是一个函数)
04 调用接收到的返回值(内部函数),来间接的操作外部函数中的变量
</code></pre><p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">        num = n;</div><div class="line">        <span class="built_in">console</span>.log(num);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> funcName = func();</div><div class="line">funcName(<span class="string">"哗啦哗啦"</span>);</div></pre></td></tr></table></figure></p>
<h2 id="闭包获取数据"><a href="#闭包获取数据" class="headerlink" title="闭包获取数据"></a>闭包获取数据</h2><p><strong>获取单个数据（考虑赋值）</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num = <span class="number">123</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (a !== <span class="literal">undefined</span>)</div><div class="line">        &#123;</div><div class="line">            num = a;</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">return</span> num;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f1 = func();</div><div class="line"><span class="keyword">var</span> x = f1(<span class="number">456</span>);</div><div class="line"><span class="keyword">var</span> y = f1();</div><div class="line"><span class="built_in">console</span>.log(x);</div><div class="line"><span class="built_in">console</span>.log(y);</div></pre></td></tr></table></figure></p>
<p>说明：上面的代码能够支持通过闭包对函数中的变量num进行访问（取值）或赋值的操作。</p>
<p><strong>获取多个数据（数组）</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"张学友"</span>;</div><div class="line">    <span class="keyword">var</span> age = <span class="number">40</span>;</div><div class="line">    <span class="keyword">return</span> [</div><div class="line">            <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> name;</div><div class="line">            &#125;,</div><div class="line">            <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> age;</div><div class="line">            &#125;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> foo = func();</div><div class="line"><span class="built_in">console</span>.log(foo[<span class="number">0</span>]());      <span class="comment">//张学友</span></div><div class="line"><span class="built_in">console</span>.log(foo[<span class="number">1</span>]());      <span class="comment">//40</span></div></pre></td></tr></table></figure></p>
<p>说明：上面的代码能够满足返回多个变量值的需求，但是要数组操作的方式并不常见，且和使用习惯不符合。</p>
<p><strong>利用对象返回并设置对个变量值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"张学友"</span>;</div><div class="line">    <span class="keyword">var</span> age = <span class="number">45</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">getName</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> name;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">getAge</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> age;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">setName</span>:<span class="function"><span class="keyword">function</span> (<span class="params">nameValue</span>) </span>&#123;</div><div class="line">            name = nameValue;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">setAge</span>:<span class="function"><span class="keyword">function</span> (<span class="params">ageValue</span>) </span>&#123;</div><div class="line">            age = ageValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> func = foo();</div><div class="line"><span class="built_in">console</span>.log(func.getName());        <span class="comment">//张学友</span></div><div class="line"><span class="built_in">console</span>.log(func.getAge());         <span class="comment">//45</span></div><div class="line">func.setName(<span class="string">"张三"</span>);</div><div class="line">func.setAge(<span class="number">30</span>);</div><div class="line"><span class="built_in">console</span>.log(func.getName());        <span class="comment">//张三</span></div><div class="line"><span class="built_in">console</span>.log(func.getAge());         <span class="comment">//30</span></div></pre></td></tr></table></figure></p>
<p><strong>闭包的作用</strong><br>最基本的作用:闭包中的变量更安全,只能通过特定的接口来访问<br>说明:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(1)创建一个私有的空间,保护数据,外界如果需要访问数据必须通过函数提供的指定方法</div><div class="line">(2)在这些指定的方法中,我们可以设置一些校验的逻辑,以保证对数据访问和设置的安全性</div></pre></td></tr></table></figure></p>
<h2 id="闭包的使用注意"><a href="#闭包的使用注意" class="headerlink" title="闭包的使用注意"></a>闭包的使用注意</h2><p><strong>进程和线程</strong></p>
<pre><code>进程指的是系统中正在运行的一个应用程序。
线程:一个进程中可以有一个或多个线程,线程是CPU调度的最小单位,是真正执行任务的。
多线程:一个中可能有多条线程,多条线程之间并发的执行多个不同的任务。
单线程:一个进程中只有一条线程,即同一时间只能执行一个操作,只能干一件事情。
</code></pre><p><strong>javascript是单线程的</strong></p>
<pre><code>js中的线程主要处理三块任务:
01 渲染任务
02 js的代码执行任务
03 js中的事件处理任务(如setTimeOut方法)
</code></pre><p><strong>javascript中代码的执行顺序</strong></p>
<p><code>01 先把主任务执行完毕(代码任务)</code><br><code>02 主任务执行完毕之后再执行次要的任务(包括setTimeOut方法等)</code></p>
<p><strong>关于setTimeOut函数</strong></p>
<pre><code>函数的作用:一次性定时器(用于延迟执行任务)
参数:
    第一个参数:要执行的任务
    第二个参数:要延迟执行的时间,时间的单位是毫秒
函数说明：
    01 至少在指定的时间后才能够执行回调函数
    02 因为要等主任务中的代码执行完毕之后,才回去检查setTimeOut的回调函数。
</code></pre><p><strong>通过闭包解决setTimeOut函数的问题</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line"></div><div class="line">        setTimeout((<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(j);</div><div class="line">            &#125;</div><div class="line">        &#125;)(i),<span class="number">10</span>);</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"----"</span>);</div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>函数的特殊之处</strong><br>函数的特殊之处在于,它本身是对象,且函数可以提供作用域。</p>
<pre><code>(01) 函数可以在运行时动态的创建,还可以在程序执行过程中创建。
(02) 函数可以赋值给变量,可以被扩展,甚至是删除。
(03) 函数可以作为其他函数的参数和返回值。
(04) 函数可以拥有自己的属性和方法。
注意:{} 块在js中不会创建作用域,哪怕是if或者是while语句中使用var关键字声明的变量也并非局部变量。
函数是可以通过（）调用并执行的对象。
</code></pre><p><strong>函数是第一型对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">01 函数可以像普通对象一样作为函数的参数</div><div class="line">02 函数可以像普通对象一样赋值给变量（函数表达式）</div><div class="line">03 函数可以像普通对象一个作为函数的返回值返回</div></pre></td></tr></table></figure></p>
<p><strong>代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//函数作为参数传递</span></div><div class="line">   setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">   &#125;,<span class="number">100</span>);</div><div class="line">   <span class="comment">//函数作为返回值</span></div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">           <span class="built_in">console</span>.log(<span class="string">"demo"</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">var</span> f = func();</div><div class="line">   f();                <span class="comment">//demo</span></div><div class="line">   <span class="comment">//函数赋值给变量</span></div><div class="line">   <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">   a();    <span class="comment">//直接通过变量的名称调用函数</span></div></pre></td></tr></table></figure></p>
<p><strong>函数的两个特征</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">01 函数本质上是对象</div><div class="line">02 函数可以创建作用域</div></pre></td></tr></table></figure></p>
<p><strong>约定</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a + b;&#125;; <span class="comment">//命名函数表达式</span></div><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a + b;&#125;;    <span class="comment">//函数表达式,匿名函数</span></div><div class="line">    以上也称为使用字面量的方式来创建函数(或者是函数字面量)</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;&#125;;   <span class="comment">//函数声明</span></div></pre></td></tr></table></figure></p>
<p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 函数声明</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">demo01</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;</div><div class="line">   <span class="comment">//02 函数表达式(匿名函数)</span></div><div class="line">    <span class="keyword">var</span> demo02 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//03 命名函数表达式</span></div><div class="line">    <span class="keyword">var</span> demo03 = <span class="function"><span class="keyword">function</span> <span class="title">demo03Test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//04 打印name属性</span></div><div class="line">    <span class="built_in">console</span>.log(demo01.name);   <span class="comment">//demo01</span></div><div class="line">    <span class="built_in">console</span>.log(demo02.name);   <span class="comment">//demo02 (注意在火狐浏览器中打印出来的name属性为空)</span></div><div class="line">    <span class="built_in">console</span>.log(demo03.name);   <span class="comment">//demo03Test</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>函数回调</strong><br>回调函数(回调),当我们把某个函数作为参数传递给另一个函数的时候,这个函数就称为回调函数</p>
<p><strong>函数回调的基本模式</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">callBack</span>) </span>&#123;</div><div class="line">        <span class="comment">//处理其他的操作</span></div><div class="line">        callBack();     <span class="comment">//调用回调函数</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"这是一个回调函数"</span>);</div><div class="line">    &#125;</div><div class="line">    func(demo); <span class="comment">//注意调用函数的时候,参数是回调函数的引用(不要加括号);</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>函数回调解决this问题</strong><br>说明：如果回调函数是某个对象的方法,而该对象方法中使用了this指针那么该方法作为回调函数来使用的时候,需要注意this<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提供一个对象,该对象中永远showName方法</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"默认的名字"</span>,</div><div class="line">    <span class="attr">age</span>:<span class="number">30</span>,</div><div class="line">    <span class="attr">showName</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">showAge</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//02 提供一个函数,该函数接受一个参数(函数引用)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">callBack,callBack_obj</span>) </span>&#123;</div><div class="line">    <span class="comment">//处理第一个参数传递对象方法字符串的形式</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> callBack == <span class="string">'string'</span>)</div><div class="line">    &#123;</div><div class="line">        callBack = callBack_obj[callBack];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callBack == <span class="string">'function'</span>)</div><div class="line">    &#123;</div><div class="line">        callBack.call(callBack_obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//demo(obj.showName,obj);</span></div><div class="line"><span class="comment">//demo(obj.showAge,obj);</span></div><div class="line"><span class="comment">//传递字符串和对象来进行调用</span></div><div class="line">demo(<span class="string">"showName"</span>,obj);</div></pre></td></tr></table></figure></p>
<p>代码说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">（01）以上代码传入两个参数，分别为具体的回调函数，和该回调函数所属的对象</div><div class="line">（02）该函数的参数接受两种方式的回调传递（一种是直接传递函数引用，一种是直接以字符串的方式传递对象方法的字符串）</div><div class="line">（03）在函数内部对传入的回调参数做处理，修正this的问题</div></pre></td></tr></table></figure></p>
<p><strong>函数作为函数的返回值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">① 使用闭包实现一个计数器(在该示例中setup函数的返回值为一个函数)</div><div class="line">② 通过调用返回值(一个函数),可以操作setup函数中的变量</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> setup = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> count ++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> next = setup();</div><div class="line">    <span class="built_in">console</span>.log(next());    <span class="comment">//0</span></div><div class="line">    <span class="built_in">console</span>.log(next());    <span class="comment">//1</span></div><div class="line">    <span class="built_in">console</span>.log(next());    <span class="comment">//2</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p><strong>惰性函数定义</strong><br>说明：某个函数直到第一次使用的时候才被正确的定义,并且其具有向后惰性,执行更少的工作。<br>应用场景:函数有一些初始化的准备工作要做,且只需要执行一次的情况。<br>特点:能够更新自己(函数)的实现。<br>缺点:<br>     01 当重新定义自身的时候,已经添加到原始函数的任何属性都会丢失。<br>     02 如何函数被赋值给了其他的变量或者是对象方法,那么在使用变量或者是对象方法调用时仍然会执行旧的函数体。<br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"foo!"</span>);</div><div class="line">    foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"new foo!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//函数的调用</span></div><div class="line"><span class="comment">//foo();  //foo!</span></div><div class="line"><span class="comment">//foo();  //new foo!</span></div></pre></td></tr></table></figure></p>
<p>问题：</p>
<pre><code>① 添加属性
② 把函数赋值给新的变量
③ 以对象的方法调用函数
当惰性函数定义在处理以上三种情况的时候，使用新的变量名调用或者是是以对象的方法来调用函数，那么该函数在执行的时候并不会更新自身，而是执行旧的函数体的内容
</code></pre><p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 声明函数foo</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"foo!"</span>);</div><div class="line">        foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"foo! foo!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02 为foo函数对象添加属性</span></div><div class="line">    foo.description = <span class="string">"foo函数的描述信息"</span>;</div><div class="line">    <span class="comment">//03 把foo函数赋值给其他的变量</span></div><div class="line">    <span class="keyword">var</span> func = foo;</div><div class="line">    <span class="comment">//04 把foo函数赋值给对象中的方法</span></div><div class="line">    <span class="keyword">var</span> obj = &#123;</div><div class="line">        <span class="attr">showFoo</span>:foo</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//05 验证并演示输出</span></div><div class="line">    func(); <span class="comment">//foo!</span></div><div class="line">    func(); <span class="comment">//foo!</span></div><div class="line">    <span class="built_in">console</span>.log(func.description);  <span class="comment">//foo函数的描述信息</span></div><div class="line">    <span class="comment">//总结:01 如果把函数赋值给其他的变量,那么在以其他变量的方式调用时不会更新自身,还是执行旧的函数体</span></div><div class="line">    obj.showFoo();  <span class="comment">//foo!</span></div><div class="line">    obj.showFoo();  <span class="comment">//foo!</span></div><div class="line">    <span class="built_in">console</span>.log(obj.showFoo.description);   <span class="comment">//foo函数的描述信息</span></div><div class="line">    <span class="comment">//总结:02 如果把函数赋值给对象的方法,那么在以对象方法形式调用时不会更新自身,还是会执行旧的函数体。</span></div><div class="line">    foo();  <span class="comment">//已经更新过foo函数 foo! foo!</span></div><div class="line">    foo();  <span class="comment">//已经更新过foo函数 foo! foo!</span></div><div class="line">    <span class="built_in">console</span>.log(foo.description);   <span class="comment">//undefined</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>即时函数</strong></p>
<p>定义:<code>在函数定义之后立即执行该函数。</code><br>即时函数模式的组成:<br>     ① 使用函数表达式来定义函数(匿名函数,注意不能使用函数声明方式)<br>     ② 在函数表达式末尾添加一组(),表示立即执行当前函数。<br>     ③ 将整个函数包装在()中,有两种方式`</p>
<p>即时函数的作用</p>
<pre><code>01 用来将所有的代码包装到当前的作用域中,并且不会将任何的变量泄露到全局作用域中。
02 js中没有代码块作用域,而函数是js中唯一可以创建作用域的。
03 即时函数就是利用了函数创建作用域这一点,来实现对一些需要封装且不允许外部访问的操作。
</code></pre><p>即时函数的优点<br>01 不会产生全局变量,在即时函数内部定义的所有变量都仅仅只是该函数的局部变量,不会造成全局变量污染问题。<br>02 具有更好的封装性,外部无法访问到该函数内部的数据。</p>
<p><strong>即时函数代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一种写法</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">"即时函数的第一种写法"</span>);</div><div class="line">&#125;());</div><div class="line"><span class="comment">//第二种写法</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"即时函数的第二种写法"</span>);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>写法补充<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(a);</div><div class="line">   &#125;(<span class="number">20</span>));</div><div class="line">   +<span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(b);</div><div class="line">   &#125;(<span class="number">30</span>);</div><div class="line">   -<span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(b);</div><div class="line">   &#125;(<span class="number">40</span>);</div></pre></td></tr></table></figure></p>
<p><strong>即时函数的传参和返回值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 接受参数</span></div><div class="line">   (<span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(str);           <span class="comment">//hello</span></div><div class="line">   &#125;)(<span class="string">"hello"</span>);</div><div class="line"></div><div class="line">   <span class="comment">//02 提供返回值并赋值给新的变量</span></div><div class="line">   <span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">2</span> + <span class="number">1</span>;</div><div class="line">   &#125;)();</div><div class="line">   <span class="built_in">console</span>.log(foo);           <span class="comment">//3</span></div></pre></td></tr></table></figure></p>
<p><strong>即时对象初始化</strong><br>01 结构特征:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">① 提供一个对象,在该对象内部提供一个init初始化方法</div><div class="line"></div><div class="line">② 使用()把对象包装起来(让字面量变成表达式)</div><div class="line"></div><div class="line">③ 然后随即调用init方法,完成初始化操作。</div></pre></td></tr></table></figure></p>
<p>02 基本结构<br><code>({}).init();</code></p>
<p>03 模式优点</p>
<pre><code>在执行一次性的初始化任务时保护全局的命名空间。
</code></pre><p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    (&#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"张三"</span>,</div><div class="line">        <span class="attr">age</span>:<span class="number">23</span>,</div><div class="line">        <span class="attr">getDescript</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"名字:"</span> + <span class="keyword">this</span>.name + <span class="string">"年龄:"</span> + <span class="keyword">this</span>.age);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//注意:在对象中访问对象的属性和方法都需要使用this.前缀</span></div><div class="line">        init:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.getDescript();</div><div class="line">            <span class="comment">//其他的初始化处理</span></div><div class="line">        &#125;</div><div class="line">    &#125;).init();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>函数属性缓存</strong><br>思路说明</p>
<pre><code>01 函数是对象，因此可以在函数上面添加属性和方法
02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果
03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value）
04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。
</code></pre><p>代码示例(单个参数)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">param</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (func.cache[param] == <span class="literal">undefined</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">var</span> result = <span class="string">"字符串"</span>; <span class="comment">//初始化值</span></div><div class="line">        <span class="comment">//...对result做复杂的计算</span></div><div class="line">        func.cache[param] = result + param;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> func.cache[param];</div><div class="line">&#125;</div><div class="line">func.cache = &#123;&#125;;    <span class="comment">//空对象</span></div><div class="line"><span class="built_in">console</span>.log(func(<span class="string">"demo"</span>));  <span class="comment">//字符串demo</span></div><div class="line"><span class="built_in">console</span>.log(func(<span class="string">"test"</span>));  <span class="comment">//字符串test</span></div><div class="line"><span class="built_in">console</span>.log(func(<span class="string">"demo"</span>));  <span class="comment">//字符串demo 直接使用属性缓存中的数据,而不再进行复杂的计算(可以提升性能)</span></div></pre></td></tr></table></figure></p>
<p>代码示例（多个参数）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> key = <span class="built_in">JSON</span>.stringify(<span class="built_in">Object</span>.prototype.slice.call(<span class="built_in">arguments</span>));</div><div class="line">    <span class="keyword">if</span> (func.cache[key] == <span class="literal">undefined</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">var</span> result = <span class="string">"字符串"</span>; <span class="comment">//初始化值</span></div><div class="line">        <span class="comment">//...对result做复杂的计算</span></div><div class="line">        func.cache[key] = result + key;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> func.cache[key];</div><div class="line">&#125;</div><div class="line">func.cache = &#123;&#125;;    <span class="comment">//空对象</span></div><div class="line">func(<span class="string">"123"</span>,<span class="string">"456"</span>);  <span class="comment">//</span></div><div class="line"><span class="comment">//说明:如果传入的参数数量超过1,则可以将传入的参数序列化为一个json字符串作为参数处理。</span></div></pre></td></tr></table></figure></p>
<p>代码说明：<br>slice:<code>返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素</code></p>
<h1 id="函数属性缓存"><a href="#函数属性缓存" class="headerlink" title="函数属性缓存"></a>函数属性缓存</h1><blockquote>
<p>很高兴你能看到这里，希望对你学习JavaScript有帮助。这是最后一章节，主要讲有关JavaScript的设计模式。</p>
</blockquote>
<p>思路说明</p>
<pre><code>01 函数是对象，因此可以在函数上面添加属性和方法
02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果
03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value）
04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。
</code></pre><!-- more -->
<p>代码示例(单个参数)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">param</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (func.cache[param] == <span class="literal">undefined</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">var</span> result = <span class="string">"字符串"</span>; <span class="comment">//初始化值</span></div><div class="line">        <span class="comment">//...对result做复杂的计算</span></div><div class="line">        func.cache[param] = result + param;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> func.cache[param];</div><div class="line">&#125;</div><div class="line">func.cache = &#123;&#125;;    <span class="comment">//空对象</span></div><div class="line"><span class="built_in">console</span>.log(func(<span class="string">"demo"</span>));  <span class="comment">//字符串demo</span></div><div class="line"><span class="built_in">console</span>.log(func(<span class="string">"test"</span>));  <span class="comment">//字符串test</span></div><div class="line"><span class="built_in">console</span>.log(func(<span class="string">"demo"</span>));  <span class="comment">//字符串demo 直接使用属性缓存中的数据,而不再进行复杂的计算(可以提升性能)</span></div></pre></td></tr></table></figure></p>
<p>代码示例（多个参数）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> key = <span class="built_in">JSON</span>.stringify(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</div><div class="line">    <span class="keyword">if</span> (func.cache[key] == <span class="literal">undefined</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">var</span> result = <span class="string">"字符串"</span>; <span class="comment">//初始化值</span></div><div class="line">        <span class="comment">//...对result做复杂的计算</span></div><div class="line">        func.cache[key] = result + key;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> func.cache[key];</div><div class="line">&#125;</div><div class="line">func.cache = &#123;&#125;;    <span class="comment">//空对象</span></div><div class="line">func(<span class="string">"123"</span>,<span class="string">"456"</span>);  <span class="comment">//</span></div><div class="line"><span class="comment">//说明:如果传入的参数数量超过1,则可以将传入的参数序列化为一个json字符串作为参数处理。</span></div></pre></td></tr></table></figure></p>
<p>代码说明：<br>slice:<code>返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素</code></p>
<h1 id="命名空间模式"><a href="#命名空间模式" class="headerlink" title="命名空间模式"></a>命名空间模式</h1><p>作用:<br>(1)有助于减少程序中所需要的全局变量的数量<br>(2)并且同时还有助于避免命名冲突或过长的名字前缀。<br> <strong>说明：JavaScript中并没有内置的命名空间</strong></p>
<h2 id="如何实现命名空间"><a href="#如何实现命名空间" class="headerlink" title="如何实现命名空间"></a>如何实现命名空间</h2><pre><code>可以为应用程序创建一个全局对象,然后将所有功能都添加到该全局对象中
从而在具有大量函数,对象和其他变量的情况下并不会污染全局范围。
</code></pre><p><strong>建议</strong></p>
<pre><code>全局命名空间的名称可以随便写,但建议使用项目的名称或者是APP的名称
按照习惯,通过程序员会约定以全部大写的方式来约定全局命名空间。
</code></pre><p><strong>命名空间模式的缺点</strong></p>
<pre><code>① 需要输入更多的字符,在每个变量和函数前面都需要附加上前缀,总体上增加了代码的体积。
② 仅有一个全局实例,意味着代码的任何部分都能够修改当前的实例。
③ 很长的前缀意味着需要花更长的时间来解析属性(变量|属性访问原则-就近原则)
</code></pre><p>代码示例（零散的代码）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line">    <span class="keyword">var</span> testDemo01 = <span class="string">"测试字符串01"</span>;</div><div class="line">    <span class="keyword">var</span> testDemo02 = <span class="string">"测试字符串02"</span>;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    obj.des = <span class="string">"描述信息"</span>;</div><div class="line">    obj.logDes = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(obj.des);</div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p>代码示例(命名空间模式)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个全局变量</span></div><div class="line">    <span class="keyword">var</span> MYAPP = &#123;&#125;;</div><div class="line">    <span class="comment">//02 处理构造函数</span></div><div class="line">    MYAPP.Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    MYAPP.Man = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    <span class="comment">//03 处理变量</span></div><div class="line">    MYAPP.array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line">    MYAPP.testDemo01 = <span class="string">"测试字符串01"</span>;</div><div class="line">    MYAPP.testDemo02 = <span class="string">"测试字符串02"</span>;</div><div class="line">    <span class="comment">//处理对象</span></div><div class="line">    MYAPP.obj = &#123;&#125;;</div><div class="line">    MYAPP.obj.des = <span class="string">"描述信息"</span>;</div><div class="line">    MYAPP.obj.logDes = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(obj.des);</div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<pre><code>01 在使用命名空间模式的时候,因为所有的变量和属性都添加到同一个全局对象下面,因此该全局对象下面可能有很多很多的属性。
02 而我们在添加属性的时候,很有可能该属性已经存在,这导致可能会覆盖掉之前的属性。
03 所以,在添加一个属性或者是创建一个命名空间之前,最好是先检查它是否已经存在。
04 但是如果每次添加属性都需要对属性进行检查则会产生代码冗余问题。
</code></pre><p>示例代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 不好的演示</span></div><div class="line"><span class="comment">//其他代码</span></div><div class="line"><span class="comment">//var MYAPP = &#123;&#125;;     //注意这是不安全的代码,因为有可能覆盖掉上下文中的代码</span></div><div class="line"><span class="comment">//02 在创建命名空间之前,先检查该命名空间是否存在</span></div><div class="line"><span class="comment">//    if (MYAPP == 'undefined')&#123;</span></div><div class="line"><span class="comment">//        var MYAPP = &#123;&#125;;</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line"><span class="comment">//03 更好的做法</span></div><div class="line"><span class="keyword">var</span> MYAPP = MYAPP || &#123;&#125;;        <span class="comment">//如果MYAPP为假,那么就返回&#123;&#125;并赋值给MYAPP</span></div><div class="line"><span class="comment">//04 添加属性时的检查问题</span></div><div class="line"><span class="comment">//假如现在需要添加一个name属性,那么在添加之前需要先检查该属性是否存在</span></div><div class="line"><span class="keyword">if</span> (MYAPP.name == <span class="string">'undefined'</span>)</div><div class="line">&#123;</div><div class="line">    MYAPP.name = <span class="string">"默认的名称"</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//假如要添加一个obJ属性</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> MYAPP.obj == <span class="string">'undefined'</span>)</div><div class="line">&#123;</div><div class="line">        MYAPP.obj = &#123;&#125;;</div><div class="line">&#125;</div><div class="line"><span class="comment">//假如要给MYAPP.obj添加属性,则</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> MYAPP.obj.des === <span class="string">"undefined"</span>)</div><div class="line">&#123;</div><div class="line">    MYAPP.obj.des = <span class="string">"对象的描述信息"</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(MYAPP.obj);</div></pre></td></tr></table></figure></p>
<p>代码说明：我们在添加属性或者是方法的时候,比较安全的做法是在添加之前先在当前环境中进行检查,以免覆盖但是我们的检查操作催生出了一个新的问题,就是重复代码过多,能否考虑把检查的过程抽取</p>
<p><strong>示例代码</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> MYAPP = MYAPP || &#123;&#125;;</div><div class="line">    MYAPP.namescape = <span class="function"><span class="keyword">function</span> (<span class="params">string</span>) </span>&#123;</div><div class="line">        <span class="comment">//split() 方法用于把一个字符串分割成字符串数组</span></div><div class="line">        <span class="keyword">var</span> parts = string.split(<span class="string">'.'</span>);</div><div class="line">        <span class="keyword">var</span> parent = MYAPP;</div><div class="line">        <span class="built_in">console</span>.log(parts);</div><div class="line">        <span class="comment">//先去掉最前面的冗余的全局变量</span></div><div class="line">        <span class="keyword">if</span>(parts[<span class="number">0</span>] == <span class="string">"MYAPP"</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//splice() 方法向/从数组中添加/删除项目,然后返回被删除的项目</span></div><div class="line">            <span class="comment">//parts.splice(0,1);</span></div><div class="line">            <span class="comment">//slice() 方法可从已有的数组中返回选定的元素</span></div><div class="line">            <span class="comment">//返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素</span></div><div class="line">            parts = parts.slice(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.log(parts,<span class="string">"处理之后的数组"</span>);</div><div class="line">        <span class="comment">//通过for循环来遍历结构</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; parts.length; i++) &#123;</div><div class="line">            <span class="comment">//检查属性,如果对应的属性不存在,那么就创建一个属性</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> parent[parts[i]] == <span class="string">'undefined'</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">//初始化为一个空的对象</span></div><div class="line">                parent[parts[i]] = &#123;&#125;;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//修正parent的值</span></div><div class="line">            parent = parent[parts[i]];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> parent;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//代码示例</span></div><div class="line">    <span class="keyword">var</span> testDemo01 = MYAPP.namescape(<span class="string">"MYAPP.test.testDemo01"</span>);</div><div class="line">    <span class="keyword">var</span> testDemo02 = MYAPP.namescape(<span class="string">"MYAPP.test.testDemo02"</span>);</div><div class="line">    <span class="built_in">console</span>.log(MYAPP);</div><div class="line">    <span class="comment">//忽略全面的前缀</span></div><div class="line">    MYAPP.namescape(<span class="string">"sadsa.sadjaldj.adada.test"</span>);</div><div class="line">    <span class="built_in">console</span>.log(MYAPP);</div><div class="line">    <span class="comment">//演示长命名空间的情况</span></div><div class="line">    MYAPP.namescape(<span class="string">"demo.testDemo.testDemos.ss.dd.qq.ddd.ffff.fff"</span>);</div><div class="line">    <span class="built_in">console</span>.log(MYAPP);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>补充说明<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">01</span> split() 方法用于把一个字符串分割成字符串数组</div><div class="line"><span class="number">02</span> splice() 方法向/从数组中添加/删除项目,然后返回被删除的项目</div><div class="line"><span class="number">03</span> slice() 方法可从已有的数组中返回选定的元素</div></pre></td></tr></table></figure></p>
<h1 id="设计模式简单说明"><a href="#设计模式简单说明" class="headerlink" title="设计模式简单说明"></a>设计模式简单说明</h1><pre><code>概念:设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案
    注意,设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案
起源:该属于源于建筑行业
历史:
    （1）由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学
    （2）四人帮著作《设计模式：可复用面向对象软件的基础》（Design Patterns - Elements of Reusable Object-Oriented Software）
    （3）Gang of Four:Erich Gamma + Richard Helm + Ralph Johnson +John Vlissides
优点:
    为了可重用代码、让代码更容易被他人理解、保证代码可靠性
</code></pre><h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><pre><code>创建型模式:工厂方法模式 + 抽象工厂模式 + 单例模式 + 建造者模式 + 原型模式
结构型模式:适配器模式 + 代理模式 + ...
行为型模式:观察者模式 + 命令模式 + ...
</code></pre><h2 id="单例模式的思想"><a href="#单例模式的思想" class="headerlink" title="单例模式的思想"></a>单例模式的思想</h2><pre><code>保证一个特定的类只有一个实例。
即当我们第二次创建新对象的时候,得到的应该是和第一次创建的对象一模一样的对象(同一个对象)
</code></pre><p><strong>其他语言中实现单例模式</strong></p>
<pre><code>在其它有Class的语言中,实现单例模式核心步骤是:
    01 在创建对象实例时候判断,该类的实例对象是否已经存在,如果已经存在,那么就直接返回
    02 如果不存在,那么就创建一个新的实例对象,并保存起来,下次创建实例对象的时候直接使用。
</code></pre><h2 id="JavaScript中的单例模式"><a href="#JavaScript中的单例模式" class="headerlink" title="JavaScript中的单例模式"></a>JavaScript中的单例模式</h2><pre><code>JavaScript是一门弱类型,动态,基于原型的语言,并没有类,只有对象。
在JavaScript中要实现单例模式有很多种方式。
最简单的方式:使用字面量的方式来创建对象,因为在JavaScript中对象之间永远不可能相等,除非他们是同一个对象。
</code></pre><p><strong>使用字面量方式创建的对象总是唯一的</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">script&gt;</div><div class="line">    <span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">"zhangsan"</span>&#125;;</div><div class="line">    <span class="keyword">var</span> obj2 = &#123;<span class="attr">name</span>:<span class="string">"zhangsan"</span>&#125;;</div><div class="line">    <span class="built_in">console</span>.log(obj1 == obj2);      <span class="comment">//false</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>使用new操作符创建对象实现单例</strong></p>
<pre><code>实现单例模式的几种途径
    ① 在代码中提供一个全局变量来存储创建出来的实例 缺点:该全局变量可能会被轻易的修改和覆盖
    ② 尝试在构造函数的静态成员中缓存实例属性。缺点:函数的静态属性在外部可以直接修改,容易导致实例对象的丢失。
    ③ 将实例对象包装在闭包中。优点是安全性较好,无法被轻易的修改,缺点是有额外闭包的开销。
</code></pre><p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">China</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">//创建对象</span></div><div class="line"><span class="keyword">var</span> china01 = <span class="keyword">new</span> China();</div><div class="line"><span class="keyword">var</span> china02 = <span class="keyword">new</span> China();</div><div class="line"><span class="comment">//思考:如果想要实现单例模式,那么最终的结果必要是china01 和china02是同一个对象,那么如何实现</span></div></pre></td></tr></table></figure></p>
<p><strong>实现方案(一)使用全局变量方式存储创建出来的实例对象</strong><br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个全局变量</span></div><div class="line">    <span class="keyword">var</span> instance;</div><div class="line">   <span class="comment">//02 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="literal">undefined</span>)</div><div class="line">        &#123;</div><div class="line">            instance = <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.name = <span class="string">"默认的名称"</span>;</div><div class="line">        <span class="keyword">this</span>.age = <span class="number">66</span>;</div><div class="line">        <span class="comment">//使用全局变量来接收内部创建出来的实例对象(this)</span></div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//03 使用构造函数创建对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p2);</div><div class="line">    <span class="built_in">console</span>.log(p1.name);</div><div class="line">    <span class="built_in">console</span>.log(p2.name);</div><div class="line">    p1.name = <span class="string">"修改之后的名称"</span>;</div><div class="line">    <span class="built_in">console</span>.log(p1.name);</div><div class="line">    <span class="built_in">console</span>.log(p2.name);</div><div class="line">    <span class="comment">//说明:在上面的方案中我们使用一个全局变量来接收实例对象的值,在构造函数内部也是通过判断这个全局变量来做一些其他的处理</span></div><div class="line">    instance = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> p3 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p3);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><code>说明：</code>这种方法确实可以实现单例模式,但是并不安全,因为全局变量可能会被轻易的修改或者是覆盖,因此不推荐这种方式。</p>
<p><strong>实现方案(二)通过构造函数静态属性来缓存实例对象</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//02 在内部判断构造函数的静态属性中是否拥有实例对象</span></div><div class="line">        <span class="comment">//如果拥有实例对象,那么就直接返回,否则就设置实例对象,并赋值给构造函数的静态属性</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> Person.instance == <span class="string">"object"</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> Person.instance;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//设置实例对象的属性和方法</span></div><div class="line">        <span class="keyword">this</span>.name = <span class="string">"默认的名称"</span>;</div><div class="line">        <span class="keyword">this</span>.age = <span class="number">66</span>;</div><div class="line">        <span class="comment">//03 把内部创建的实例化对象赋值给构造函数的静态属性</span></div><div class="line">        Person.instance = <span class="keyword">this</span>;</div><div class="line">        <span class="comment">//显示返回</span></div><div class="line">        <span class="comment">//return Person.instance;</span></div><div class="line">        <span class="comment">//隐式返回</span></div><div class="line">        <span class="comment">//return this;</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//04 创建实例对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p2);</div><div class="line">    Person.instance = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> p3 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p3);      <span class="comment">//false</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><code>说明：</code>在构造函数外部可以直接访问其静态成员(属性和方法),可能会导致实例对象的丢失。</p>
<p><strong>实现方案(二)通过闭包-惰性函数定义来实现</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//02 在函数内部使用私有变量来缓存实例</span></div><div class="line">        <span class="keyword">var</span> instance = <span class="keyword">this</span>;</div><div class="line">        <span class="comment">//03 设置实例对象的属性和方法</span></div><div class="line">        <span class="keyword">this</span>.name = <span class="string">"默认的姓名"</span>;</div><div class="line">        <span class="keyword">this</span>.age = <span class="number">66</span>;</div><div class="line">        <span class="comment">//04 使用惰性函数定义来更新构造函数的实现</span></div><div class="line">        <span class="comment">//通过一个闭包来返回缓存的实例对象</span></div><div class="line">        Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> instance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//05 创建对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p2);</div><div class="line">    <span class="comment">//代码说明:第一次调用原始构造函数的时候,它会像往常一样返回this(指向内部新创建的实例对象)</span></div><div class="line">    <span class="comment">//再后面调用的时候,它会执行更新后的构造函数,在这个新的函数实现中,我们通过闭包来访问了私有变量,并简单的返回。</span></div><div class="line">    <span class="comment">//这个instance私有变量存储的是第一次调用构造函数时创建出来的实例对象</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>新的问题</strong><br>01 因为内部使用惰性函数定义(重写构造函数会导致之前添加在构造函数中的属性丢失),所以存在属性丢失问题<br>02 在上面的代码中,体现在于创建对象前后设置的构造函数的原型对象丢失问题</p>
<p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> instance = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">this</span>.name = <span class="string">"默认的姓名"</span>;</div><div class="line">        <span class="keyword">this</span>.age = <span class="number">66</span>;</div><div class="line">        Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> instance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//设置构造函数的原型对象</span></div><div class="line">    Person.prototype.des = <span class="string">"描述信息"</span>;</div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="comment">//在创建第一个对象之后,设置原型对象</span></div><div class="line">    Person.prototype.someThing = <span class="string">"something"</span>;</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p2);</div><div class="line">    <span class="built_in">console</span>.log(p1.des);        <span class="comment">//描述信息</span></div><div class="line">    <span class="built_in">console</span>.log(p2.des);        <span class="comment">//描述信息</span></div><div class="line">    <span class="built_in">console</span>.log(p1.someThing);  <span class="comment">//undefined</span></div><div class="line">    <span class="built_in">console</span>.log(p2.someThing);  <span class="comment">//undefined</span></div><div class="line">    <span class="comment">//打印对象的构造函数</span></div><div class="line">    <span class="built_in">console</span>.log(p1.constructor.name);       <span class="comment">//Person</span></div><div class="line">    <span class="built_in">console</span>.log(p2.constructor.name);       <span class="comment">//Person</span></div><div class="line">    <span class="comment">//判断对象的构造函数</span></div><div class="line">    <span class="built_in">console</span>.log(p1.constructor == Person);  <span class="comment">//false</span></div><div class="line">    <span class="built_in">console</span>.log(p1.constructor == p2.constructor,<span class="string">"构造函数是否一致"</span>);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>解决问题的核心过程</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">01</span> 提供一个构造函数</div><div class="line"><span class="number">02</span> 在构造函数内部提供一个私有变量instance</div><div class="line"><span class="number">03</span> 重写构造函数,返回私有变量instance</div><div class="line"><span class="number">04</span> 把原有的原型对象赋值给新Person构造函数的原型对象</div><div class="line"><span class="number">05</span> 调用<span class="keyword">new</span> 构造函数方法创建一个实例化对象赋值给instance</div><div class="line"><span class="number">06</span> 修正instance实例的构造器属性,指向新的构造函数(注意:虽</div><div class="line">然重写了构造函数,但是instance的构造函数仍然是以前的Person)</div><div class="line"><span class="number">07</span> 设置实例属性和方法</div><div class="line"><span class="number">08</span> 返回instance对象</div><div class="line">代码示例</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//01 提供一个私有变量</span></div><div class="line">        <span class="keyword">var</span> instance;</div><div class="line">        <span class="comment">//02 重写构造函数</span></div><div class="line">        Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(instance);</div><div class="line">            <span class="comment">//console.log(instance.constructor);</span></div><div class="line">            <span class="keyword">var</span> t = <span class="keyword">this</span>;</div><div class="line">            <span class="built_in">console</span>.log(t);</div><div class="line">            <span class="keyword">return</span> instance;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//03 保留原型属性</span></div><div class="line">        Person.prototype = <span class="keyword">this</span>.__proto__;    <span class="comment">//这是一个空的对象</span></div><div class="line">        Person.lal = <span class="string">"lala"</span>;</div><div class="line">        <span class="comment">//04 创建并使用私有变量来接收实例对象</span></div><div class="line">        instance = <span class="keyword">new</span> Person();</div><div class="line">        <span class="comment">//05 修正构造函数指针</span></div><div class="line">        instance.constructor = Person;</div><div class="line">        <span class="comment">//06 设置实例属性和方法</span></div><div class="line">        instance.name = <span class="string">"默认的名字"</span>;</div><div class="line">        instance.age = <span class="number">66</span>;</div><div class="line">        <span class="comment">//07 返回私有变量</span></div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">   Person.haha = <span class="string">"哈哈"</span>;</div><div class="line">    <span class="comment">//设置构造函数的原型对象</span></div><div class="line">    Person.prototype.des = <span class="string">"描述信息"</span>;</div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="comment">//在创建第一个对象之后,设置原型对象</span></div><div class="line">    Person.prototype.someThing = <span class="string">"something"</span>;</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p2);</div><div class="line">    <span class="built_in">console</span>.log(p1.des);        <span class="comment">//描述信息</span></div><div class="line">    <span class="built_in">console</span>.log(p2.des);        <span class="comment">//描述信息</span></div><div class="line">    <span class="built_in">console</span>.log(p1.someThing);  <span class="comment">//something</span></div><div class="line">    <span class="built_in">console</span>.log(p2.someThing);  <span class="comment">//something</span></div><div class="line">    <span class="comment">//打印构造器属性</span></div><div class="line">    <span class="built_in">console</span>.log(p1.constructor == Person,<span class="string">"验证构造器指向"</span>);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p><strong>全局变量方式实现单例-改进版</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> Person;</div><div class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//01 提供一个局部变量instance</span></div><div class="line">        <span class="keyword">var</span> instance;</div><div class="line">        Person = <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (instance)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">return</span> instance;</div><div class="line">            &#125;</div><div class="line">            instance = <span class="keyword">this</span>;</div><div class="line">            <span class="keyword">this</span>.name = <span class="string">"默认的名字"</span>;</div><div class="line">            <span class="keyword">this</span>.age = <span class="number">66</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;)();</div><div class="line">    <span class="comment">//创建对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p2);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>说明：<code>通过即时函数来限定作用域,外部无法修改内部instance的值(现在是一个局部变量)</code></p>
<h1 id="工厂模式简单说明"><a href="#工厂模式简单说明" class="headerlink" title="工厂模式简单说明"></a>工厂模式简单说明</h1><pre><code>工厂模式的目的是用于创建对象,通常在类或者是类的静态方法中实现。
</code></pre><p><strong>工厂模式的目标</strong></p>
<pre><code>01 用一套方法去创建相似的目标。
02 在编译时不知道具体类型的情况下,为用户提供创建对象的接口
</code></pre><p><strong>工厂模式实现过程</strong></p>
<pre><code>01 提供一个父构造函数
02 在父构造函数的原型上添加共享的方法
03 在父构造函数身上提供一个静态方法(静态工厂方法)
    001 先获取参数(产品类型)
    002 判断构造函数是否存在(容错性处理)
    003 设置原型链继承:设置子构造函数的原型对象为父构造函数的一个实例对象(目的是为了让子构造函数创建的对象拥有父构造函数上面实例属性和原型属性)
    004 使用子构造函数创建实例对象
    005 返回新创建的实例对象
04 定义特定的工厂客户(静态方法)
05 通过父构造函数的静态工厂方法来创建产品对象
</code></pre><p><strong>代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个父构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">PhoneMaker</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    <span class="comment">//02 在父构造函数的原型上添加共享的方法</span></div><div class="line">    PhoneMaker.prototype.callPhoneDes = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"手机的特点是:  "</span> + <span class="keyword">this</span>.des);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//03 在父构造函数身上提供一个静态方法(静态工厂方法)</span></div><div class="line">    PhoneMaker.factory = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">        <span class="comment">//001 先获取参数(产品类型)</span></div><div class="line">        <span class="keyword">var</span> typeStr = type;</div><div class="line">        <span class="comment">//002 判断构造函数是否存在(容错性处理)</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> PhoneMaker[typeStr] !== <span class="string">'function'</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="string">"Error 对应的构造函数不存在,不能生产该种类型的产品"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//003 设置原型链继承</span></div><div class="line">        PhoneMaker[typeStr].prototype = <span class="keyword">new</span> PhoneMaker();</div><div class="line">        <span class="comment">//004 使用子构造函数创建实例对象</span></div><div class="line">        <span class="keyword">var</span> newPhone = <span class="keyword">new</span>  PhoneMaker[typeStr]();</div><div class="line">        <span class="comment">//005 返回新创建的实例对象</span></div><div class="line">        <span class="keyword">return</span> newPhone;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//定义特定的工厂客户(静态方法)</span></div><div class="line">    PhoneMaker.iphone = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.des = <span class="string">"最安全稳定的系统"</span>;</div><div class="line">    &#125;</div><div class="line">    PhoneMaker.oppo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.des = <span class="string">"充当五分钟,通话两小时"</span>;</div><div class="line">    &#125;</div><div class="line">    PhoneMaker.vivo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.des = <span class="string">"vivo手机,你的音乐手机"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//通过父构造函数的静态工厂方法来创建产品对象</span></div><div class="line">    <span class="keyword">var</span> vivo = PhoneMaker.factory(<span class="string">'vivo'</span>);</div><div class="line">    <span class="keyword">var</span> iphone = PhoneMaker.factory(<span class="string">'iphone'</span>);</div><div class="line">    <span class="keyword">var</span> oppo = PhoneMaker.factory(<span class="string">'oppo'</span>);</div><div class="line">    vivo.callPhoneDes();</div><div class="line">    oppo.callPhoneDes();</div><div class="line">    iphone.callPhoneDes();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p><strong>观察者模式</strong><br>观察者模式又名为发布-订阅者模式，它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。</p>
<p><strong>观察者模式的特点（优点）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">01 观察者模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案</div><div class="line">02 观察者模式可以取代对象之间硬性编码的通知机制，一个对象不再是显示的调用另外一个对象的接口，这种模式让两个对象松耦合的联系在一起，它们不需要清楚彼此的实现细节就能够相互通信。</div><div class="line">03 在这种设计模式中，不再是一个对象调用另外一个对象的方法，而是一个对象订阅另一个对象的特定活动并且在状态改变后获得通知</div></pre></td></tr></table></figure></p>
<p><strong>模型</strong><br>01 订阅者也称为<code>观察者</code><br>02 被观察的对象称为<code>发布者</code>或者是主题<br>03 当发生一个重要事件的时候，发布者将会通知所有订阅者并且经常以事件的形式来传递消息。<br>示例代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提取成公共的发行者对象</span></div><div class="line">    <span class="keyword">var</span> publisher = &#123;</div><div class="line">        <span class="attr">users</span>:&#123;</div><div class="line">            <span class="attr">default</span>:[]</div><div class="line">        &#125;,   <span class="comment">//所有的订阅者对象</span></div><div class="line">        addUser:<span class="function"><span class="keyword">function</span> (<span class="params">fn,type</span>) </span>&#123;</div><div class="line">            <span class="comment">//对订阅的类型进行判断</span></div><div class="line">            <span class="keyword">var</span> type = type || <span class="string">"default"</span>;</div><div class="line">            <span class="comment">//如果是新的订阅类型,那么我们需要做初始化的处理</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.users[type] == <span class="literal">undefined</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">this</span>.users[type] = [];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">this</span>.users[type].push(fn);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">removeUser</span>:<span class="function"><span class="keyword">function</span> (<span class="params">fn,type</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.tool(type,<span class="string">"removerUser"</span>,fn);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">publish</span>:<span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.tool(type,<span class="string">"publish"</span>);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">tool</span>:<span class="function"><span class="keyword">function</span> (<span class="params">type,funcType,fn</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> type = type || <span class="string">"default"</span>;</div><div class="line">            <span class="keyword">var</span> users = <span class="keyword">this</span>.users[type];</div><div class="line">            <span class="keyword">if</span> (users == <span class="literal">undefined</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"当前没有任何订阅者"</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; users.length; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (funcType == <span class="string">'publish'</span>)</div><div class="line">                &#123;</div><div class="line">                    users[i]()</div><div class="line">                &#125;<span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span> (users[i] == fn)</div><div class="line">                    &#123;</div><div class="line">                        users.splice(i, <span class="number">1</span>);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//02 提供一个工具函数,能够利用发行者对象的模板来快速创建新的发布者</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">makePaper</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> publisher) &#123;</div><div class="line">            <span class="keyword">if</span> (publisher.hasOwnProperty(i) &amp;&amp; <span class="keyword">typeof</span> publisher[i] == <span class="string">'function'</span>)</div><div class="line">            &#123;</div><div class="line">                o[i] = publisher[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        o.users = &#123;<span class="attr">default</span>:[]&#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//03 创建发布者</span></div><div class="line">    <span class="keyword">var</span> paper1 = &#123;</div><div class="line">        <span class="attr">day</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.publish();</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">month</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.publish(<span class="string">"month"</span>)</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">year</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.publish(<span class="string">"year"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//把某个对象编程一个发布者</span></div><div class="line">    makePaper(paper1);</div><div class="line">    <span class="comment">//04 创建订阅者(当发布者发布消息的时候,订阅者能够收到信息--自动调用订阅者的方法)</span></div><div class="line">    <span class="keyword">var</span> obj = &#123;</div><div class="line">        <span class="attr">lookDayNews</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"obj - 查看最新的日报信息"</span>);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">lookImageNews</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"obj - 查看图片信息"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//05 设置订阅</span></div><div class="line">    paper1.addUser(obj.lookDayNews);</div><div class="line">    paper1.addUser(obj.lookImageNews,<span class="string">'month'</span>);</div><div class="line">    paper1.day();</div><div class="line">    paper1.month();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>因本人能力有限，教程中难免出现疏忽，对此带来的不便敬请见谅。</p>
]]></content>
      
        
        <tags>
            
            <tag> 简明教程 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[有趣的Chrome DevTools]]></title>
      <url>/2016/11/11/%E6%9C%89%E8%B6%A3%E7%9A%84ChromeDevTools/</url>
      <content type="html"><![CDATA[<p>Chrome 自带开发者工具很有趣，怎么个有趣法呢？Chrome的JS控制台有很多很多神奇而且有趣的功能。此文仅例举其中几个，一起来看看吧。</p>
<p>我们调试的时候控制台总会有一大堆密密麻麻的代码时，请试着输入 clear() 然后回车，清空所有，回到原始界面。<br><a id="more"></a>    </p>
<h3 id="jq选择器"><a href="#jq选择器" class="headerlink" title="jq选择器"></a>jq选择器</h3><p>第一个有趣的事情就是获取页面上的DOM元素啦！<br>在控制台里通过jQuery选择器选取DOM元素.</p>
<p>如 <code>$(&#39;tagName&#39;) $(&#39;.class&#39;) $(&#39;#id&#39;)</code>等选择器。<br>其实是通过document.querySelector(‘’)返回第一个匹配的DOM元素。<br>通过 <code>$$(&#39;tagName&#39;) $$(&#39;.className&#39;)</code>两个<code>$$</code>符号来选择返回的一个相应的DOM数组。瞧：<br><img src="/assets/img/jquery选择器.png" alt="jquery选择器"></p>
<h3 id="获取DOM元素绑定事件"><a href="#获取DOM元素绑定事件" class="headerlink" title="获取DOM元素绑定事件"></a>获取DOM元素绑定事件</h3><p>其实也是一句代码搞定的事情，但是在调试的时候却非常有用。通过在控制台输入<code>getEventListeners($(&#39;selector&#39;))</code>返回数组对象的格式并且返回元素绑定的所有事件。然后通过<code>getEventListeners($(&#39;selector&#39;)).click[0].listener</code>获取元素绑定的click事件。<br><img src="/assets/img/调试.jpeg" alt="调试"></p>
<h3 id="Chrome编辑器"><a href="#Chrome编辑器" class="headerlink" title="Chrome编辑器"></a>Chrome编辑器</h3><p>如果浏览器可以编辑，要记得导出喔。在控制台轻轻输入一句代码，然后试着编辑页面，接下来就是奇迹发生的时候！赶快试一下吧！<br><img src="/assets/img/chrome编辑器.png" alt="Chrome编辑器"></p>
<h3 id="监测事件"><a href="#监测事件" class="headerlink" title="监测事件"></a>监测事件</h3><p>通过输入<code>monitorEvents($(&#39;selector&#39;))</code> 监测元素上绑定的所有事件，该元素某个事件被触发就会在控制台里显示出来。<code>monitorEvents($(&#39;selector&#39;),&#39;eventName&#39;)</code>监听元素上绑定的具体事件。第二个参数代表事件类型的名称。<code>monitorEvents($(&#39;selector&#39;),[&#39;eventName1&#39;,&#39;eventName3&#39;,….])</code>同时检测具体指定的多个事件类型。<br><code>unmonitorEvents($(&#39;selector&#39;))</code> 用来停止对某个元素的事件监测。</p>
<h3 id="表格形式输出数组"><a href="#表格形式输出数组" class="headerlink" title="表格形式输出数组"></a>表格形式输出数组</h3><p>先输入数组arr,然后通过输入<code>console.table(variableName)</code>以表格形式查看，<br>如下图：<br><img src="/assets/img/table.png" alt="table"></p>
<h3 id="检查元素"><a href="#检查元素" class="headerlink" title="检查元素"></a>检查元素</h3><p>你可以直接在控制台里输入下面的方法来检查元素<code>inspect($(&#39;selector&#39;))</code> 会检查所有匹配选择器的DOM元素，并返回所有选择器选择的DOM对象。<code>inspect($(&#39;img&#39;)[1])</code> 检查并返回页面上第2个img元素。<br><img src="/assets/img/检测.png" alt="jianche"><br>最后，Chrome DevTools是十分强大的调试工具，这只是冰上一角，深入了解请戳<a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank" rel="external">chrome-devtools</a></p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> Chrome DevTools </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Css简明教程]]></title>
      <url>/2016/11/05/css%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>Css简明教程，简洁明了。</p>
<h1 id="CSS基础概念"><a href="#CSS基础概念" class="headerlink" title="CSS基础概念"></a>CSS基础概念</h1><p>1.CSS的作用：修改样式<br><a id="more"></a><br>格式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;style type=”text/css”&gt;</div><div class="line">          选择器名称&#123;</div><div class="line">属性名称：属性对应的值；</div><div class="line">…</div><div class="line">&#125;</div><div class="line">&lt;<span class="regexp">/style&gt;</span></div></pre></td></tr></table></figure></p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="规定文字的属性"><a href="#规定文字的属性" class="headerlink" title="规定文字的属性"></a>规定文字的属性</h2><pre><code> （1）规定文字的样式的属性：
          font-style:normal(正常的，默认) italic（倾斜）
          快捷键：fsn→font-style:normal;
 （2）规定文字的粗线的属性： 
          font-weight:lighter（细线，默认）bold（加粗）
          取值：数字、单词
          快捷键：fwb→font-weight:bold;
 （3）规定文字的大小的属性：
          font-size:30px;
          取值：px（像素）
          快捷键：fz30→font-size:30px;
（4）规定文字的字体的属性：
          font-family:微软雅黑;
          快捷键：ff→font-family:”微软雅黑”;
</code></pre><p>注意点：<br>（1）如果取值是中文，需要用双引号或单引号括起来；<br>（2）设置的字体必须是用户电脑里已经安装的字体；<br>（3）如果设置的字体不存在，那么系统就会使用默认的字体来显示；<br>（4）如果不想用默认的字体来显示，可以给字体设置备选方案 font-family: “微软雅黑”，“宋体”…;<br>（5）如果想给中文和英文分别单独设置字体，但凡中文字体，里面都包含了英文；但凡英文字体，里面都不包含中文字体。<br>补充：企业开发中常用的是字体有：中文：宋体 黑体 微软雅黑；英文：Times New Roman  Arial；<br>简写：font: style  weight  size  family;<br>注意点：style和weight可以调换位置也可以省略，size和family不可以调换位置也不可以省略，size必须放在family后面，size和family必须放在所有属性后面</p>
<h2 id="规定文本的属性"><a href="#规定文本的属性" class="headerlink" title="规定文本的属性"></a>规定文本的属性</h2><p>（1）文本装饰属性：<code>text-decoration: ；</code><br>取值：underline（下划线）/line-through（删除线）/overline（上划线）、none（什么都没有，常用于超链接去除下划线）<br>（2）文本水平对齐属性：<code>text-align:  ；</code><br>取值：right（右）/center（居中）/left（左，默认）<br>（3）文本缩进属性：<code>text-indent: ；</code><br>取值：em</p>
<h2 id="颜色控制属性"><a href="#颜色控制属性" class="headerlink" title="颜色控制属性"></a>颜色控制属性</h2><p><code>color: ;</code><br>取值：<br>（1）英文<br>（2）<code>rgb（ , , ）</code>：rgb其实就是三原色，其中r（red）g（green）b（blue），rgb（0,0,0）表示黑色，rgb（255,255,255）表示白色，rgb（255,0,0）表示红色，rgb（0,255,0）表示绿色，rgb（0,0,255）表示蓝色<br>（3）rgba（ , , , ）：rgb其实就是三原色；a表示透明度，取值范围0-1，取值越小就越透明<br>（4）十六进制#：本质就是rgb，每两位表示一个颜色<br>（5）缩写十六进制：每个颜色的两位数都是一样的，那么就可以简写</p>
<h2 id="规定背景属性"><a href="#规定背景属性" class="headerlink" title="规定背景属性"></a>规定背景属性</h2><p>（1）规定背景颜色属性：<code>background-color:</code><br>取值：英文单词 、rgb、rgba、十六进制、缩写十六进制<br>注意点：同一个标签可以同时设置背景颜色和背景图片，如果颜色和图片同时存在，那么图片会覆盖颜色<br>（2）规定背景图片属性：<code>background-color: url(“”);</code><br>注意点：<br>图片地址必须放在url()中间，图片可以是本地地址也可以是网络上的地址<br>如果图片的大小没有背景大，那么它会自动的在水平和垂直方向平铺和填充<br>（3）规定背景图片平铺方式属性：<code>background-repeat:</code><br>取值：repeat:在水平和垂直方向上平铺，默认<br>repeat-x:水平方向上平铺<br>repeat-y:垂直方向上平铺<br>（4）背景定位属性： <code>background-position:水平方向 垂直方向；</code><br>取值：1.具体的方位名词：水平方向：left right center;垂直方向：top bottom center;<br>2.具体的像素： px<br>注意点：数字可以为负数<br><strong>如何让一张很大的图片无论何时都居中显示?</strong><br><code>background-position:center top;</code><br>（5）背景图片关联方式属性： <code>background-attachment：</code><br>取值：scroll 会随着滚动条而滚动，默认值<br>     fixed 不会随着滚动条而滚动<br>（6）背景尺寸属性：用于设置背景图片的大小 <code>background-size：</code>         取值：默认具体像素:background-size：px px;<br>第一个值宽度，第二个值高度<br>百分比：background-size：% %；<br>宽度的等比拉伸：background-size：auto px;<br>高度等比拉伸: background-size：px auto;<br>cover:告诉系统图片需要等比拉伸到宽度和高度都填满元素<br>contain：告诉系统图片需要等比拉伸到宽度或高度都填满元素</p>
<p>（7）规定背景图片的定位区域属性：告诉系统背景图片从哪个区域开始显示<br><code>background-origin：</code><br>取值：padding-box 默认，从padding区域开始显示<br>     border-box从border区域开始显示<br>     content-box从content区域开始显示<br>（8）规定背景的绘制区域属性：用于指定从哪个区域开始绘制背景<br><code>background-clip：</code><br>取值：border-box默认，从border开始显示<br>     padding-box 默认，从padding开始显示<br>     content-box从content区域开始显示<br>（9）多重背景图片：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">background:url(“”) no-repeat left top, </div><div class="line">url(“ ”) no-repeat right top, </div><div class="line">url(“”) no-repeat left bottom, </div><div class="line">url(“”) no-repeat right bottom;</div></pre></td></tr></table></figure></p>
<p>注意点：多张图片之间用逗号隔开，先添加的图片会盖住后添加的图片<br>编写多重背景图片时应分开来写<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">background-image:url(<span class="string">"images/animal1.png"</span>),url(<span class="string">"images/animal2.png"</span>),url(<span class="string">"images/animal3.png"</span>);</div><div class="line">background-repeat: no-repeat, no-repeat, no-repeat;</div><div class="line">background-position: left top, right top, left bottom;</div></pre></td></tr></table></figure></p>
<p>简写：快捷键是bg+<br>      background：背景颜色 背景图片 平铺方式 关联方式 定位方式；<br>注意点：background的属性任何一个都可以省略</p>
<p>（10）Vertical-align:<br>设置图片与盒子底部对齐 ：vertical-align: bottom;<br>设置图片与盒子顶部对齐： vertical-align: top;<br>            设置图片与文字基线对齐：vertical-align: baseline;<br>            设置图片顶部与文字顶部对齐：vertical-align: text-top;<br>            设置图片底部与文字底部对齐：vertical-align: text-bottom;<br>            设置图片与文字中线对齐： vertical-align: middle;</p>
<h2 id="规定边框的属性"><a href="#规定边框的属性" class="headerlink" title="规定边框的属性"></a>规定边框的属性</h2><p>（1.1）连写格式一：同时设置四条边框的宽度、样式、颜色<br>    border:边框的宽度  边框的样式  边框的颜色；</p>
<p>（1.2）连写格式二：分别设置四条边框的宽度、样式、颜色<br>border-top: 边框的宽度  边框的样式  边框的颜色；<br>border-right:边框的宽度  边框的样式  边框的颜色；<br>border- bottom:边框的宽度  边框的样式  边框的颜色；<br>border- left:边框的宽度  边框的样式  边框的颜色；<br>注意点：连写格式中颜色和宽度可以省略，但是样式不可以省略</p>
<p>（2.1）分开格式一：<br>（1）规定边框的样式的属性：<br>          格式：（同时设置四条边的样式）border-style:上 右 下 左 ；<br>取值：dashed（虚线）solid（实线）<br>注意点：设一个值（上下左右都是一样的）<br>          设两个值（上下）（左右）<br>          设三个值（上）（左右）（下）<br>          设四个值（上）（右）（下）（左）<br>（2）规定边框的宽度的属性：<br>格式：（同时设置四条边的宽度）：border-width:上 右 下 左 ；<br>（3）规定边框的颜色的属性：<br>  格式：（同时设置四条边的颜色）border-color:上 右 下 左；</p>
<p>（2.2）分开格式二：<br>（1）规定边框的样式的属性：<br>格式：（分别设置四条边的样式）<br>border-top-style： ；<br>                  border-light-style: ；<br>                  border-bottom-style: ；<br>                  border-left-style: ；<br>（2）规定边框的宽度的属性：<br>格式：（分别设置四条边的宽度）<br>border-top-width： ；<br>                  border-light-width: ；<br>                  border-bottom-width: ；<br>                  border-left-width: ；<br>（3）规定边框的颜色的属性：<br>格式：（分别设置四条边的颜色）<br>border-top-color： ；<br>                  border-light-color: ；<br>                  border-bottom-color: ；<br>                  border-left-color: ；</p>
<ol>
<li>border-radius：设置圆角属性<br>四个参数:左上,右上, 右下 左下, 省略值和它的对角一样<br> 分开写格式： border-top-left-radius: <pre><code>border-top-right-radius:
border-bottom-left-radius:
border-bottom-right-radius:   
</code></pre> 注意点：圆角的宽度=正方形的宽度一半就是圆<pre><code>圆角的宽度=长方形宽一半/高一半就是椭圆
圆角的宽度=长方形高就是半圆
圆角的宽度=正方形的边框宽度+宽度的一半就是圆环
</code></pre>4.border-image：<br>  分开写格式： border-image-source: 边框的图片的路径<br>border-image-slice: 设置裁剪的大小 如果是设置数字,则中间内容没有，想要中间也要有背景图片,则需要在最后添加一个参数为fill<br>border-image-width: 图片边框的宽度<br>border-image-outset: 边框图像区域超出边框的量<br>border-image-repeat: 图像边框是否应平铺(repeat)、自适应铺满(round)或拉伸(stretch)<h2 id="规定内边距的属性"><a href="#规定内边距的属性" class="headerlink" title="规定内边距的属性"></a>规定内边距的属性</h2>就是边框和内容之间的距离<br>注意点：给标签设置内边距后，标签的宽度和高度会发生变化，内边距也会有背景颜色<pre><code>（1）连写格式：padding: 上 右 下 左;
（2）分别设置格式：
              padding-top: ;
              padding-right: ;
              padding-bottom: ;
              padding-left: ;
</code></pre><h2 id="规定外边距的属性"><a href="#规定外边距的属性" class="headerlink" title="规定外边距的属性"></a>规定外边距的属性</h2>就是标签和标签之间的距离<br>注意点：外边距那一部分是没有背景颜色的<br> （1）连写格式：margin:上 右 下 左；<br> （2）分别设置格式：<pre><code>margin-top: ;
  margin-right: ;
  margin-bottom: ;
  margin-left: ;
</code></pre>外边距合并的现象：<br>  在默认布局的水平方向上，默认情况外边距是会叠加的<br>  在默认布局的垂直方向上，默认情况外边距是会合并的，谁的外边距比较大就听谁的<br>注意点：<br>1.如果两个盒子是嵌套关系，那么设置了里面有个盒子的顶部的外边距，外面一个盒子也会被顶下来<br>2.如果外面的盒子想保持不变，那么需要给外面的盒子添加一个边框属性<br>3.在企业开发中，一般情况下如果需要控制嵌套关系盒子之间的距离，应该首先考虑padding,其次再考虑margin,因为它本质上是控制兄弟关系之间的间隙的<br>4.在嵌套关系的盒子中，可以利用margin: 0 auto;方式让小盒子在大盒子中水平居中，并且margin: 0 auto;只对水平方向有效<br>margin: 0 auto;和text-align:center;的区别：<br>margin: 0 auto;让盒子中存储的文字和图片水平居中<br>text-align:center;让盒子水平居中<br>清除默认边距（外边距和内边距）：<br>企业开发中为了更好的控制盒子的宽高和计算盒子的宽高，在编写代码前第一件事先清楚默认边距<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">*&#123;</div><div class="line"><span class="attr">margin</span>:<span class="number">0</span>;</div><div class="line">padding:<span class="number">0</span>;&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>注意点：<br>通配符选择器会找到(遍历)当前界面中所有的标签，所以性能不好<br>企业开发中可以从这个网址中拷贝：<a href="http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css" target="_blank" rel="external">http://yui.yahooapis.com/3.18.1/build/cssreset/cssreset-min.css</a></p>
<h2 id="行高属性"><a href="#行高属性" class="headerlink" title="行高属性"></a>行高属性</h2><p>（行高可以撑起盒子的高度，有时可以省略盒子的高度）<br>   格式： line-height: ；<br>     要想一行文字在盒子中垂直居中那么只需要设置这行文字的行高等于盒子的高度即可<br>     如果是多行文字那么只能通过设置padding来让文字居中</p>
<h1 id="CSS盒子模型："><a href="#CSS盒子模型：" class="headerlink" title="CSS盒子模型："></a>CSS盒子模型：</h1><h2 id="什么是盒子模型"><a href="#什么是盒子模型" class="headerlink" title="什么是盒子模型"></a>什么是盒子模型</h2><p>CSS盒子模型只是一种形象的比喻，HTML中所有的标签都是盒子<br>结论；</p>
<pre><code>（1）在HTML中所有标签都可以设置宽度和高度
     宽度/高度 == 存放内容的区域
     内边距 ==内容与边框的距离
      边框 ==
     外边距 ==
（2）内容的宽度和高度：width/height
     元素的宽度和高度：
            宽度=左边框+左内边距+width+右内边距+右边框
            高度同理可证
     元素空间的宽度和高度：
            宽度=左外边距+左边框+左内边距+width+右内边距+右边框+右外边距
            高度同理可证
</code></pre><p>规律：1.增加了padding之后元素的宽高也会发生变化<br>        2.如果增加了padding之后还想继续保持元素的宽高，那么就必须减去内容的宽高<br>        1.增加了border之后元素的宽高也会发生变化<br>        2.如果增加了border之后还想继续保持元素的宽高，那么就必须减去内容的宽高</p>
<h2 id="盒子box-sizing属性"><a href="#盒子box-sizing属性" class="headerlink" title="盒子box-sizing属性"></a>盒子box-sizing属性</h2><p>   作用：保证盒子增加了padding和border后，盒子的宽度和高度不变<br>   取值：content-box：默认值，元素的宽高=边距+内边距+内容宽高<br>border-box；元素的宽高==width属性</p>
<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><h2 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h2><p>  作用：根据指定的标签名称，在当前界面中找到所有该名称的标签，然后设置属性<br>格式：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">标签名称&#123;</div><div class="line">属性：值；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意点：（1）标签选择器选中的是当前界面中的所有标签，而不能单独选中一个标签<br>         （2）标签选择器无论标签藏得多深都能选中<br>         （3）只要是HTML中是标签都可以做标签选择器</p>
<h2 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h2><p>作用：根据指定的id名称找到对应的标签，然后设置属性<br>格式：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#id名称&#123;</div><div class="line">属性：值；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   注意点：（1）每个HTML都有一个属性叫做id，也就是说每个标签都可以设置id<br>        （2）在一个界面中id的名称是不可以重复的<br>        （3）编写id选择器时一定要在id名称面前加上#<br>        （4）id的名称是由一定规范的：只能有字母/数字/下划线组成，并且不能以数字开头，企业开发过程中一般都是以字母开头的。Id名称不能是HTML标签的名称。<br>        （5）如果仅仅是为了设置样式，企业开发中一般不会使用id，因为在前端开发中id 是留给js使用的</p>
<h2 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h2><p>  作用：根据指定的类名称找到对应的标签，然后设置属性<br>格式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.类名&#123;</div><div class="line">属性：值；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  注意点：（1）每个HTML都有一个属性叫做class，也就是说每个标签都可以设置类名<br>         （2）在一个界面中class的名称是可以重复的<br>         （3）编写class选择器时一定要在类名称面前加上.<br>         （4）类的名称是由一定规范的：只能有字母/数字/下划线组成，并且不能以数字开头，企业开发过程中一般都是以字母开头的，不能是HTML标签的名称<br>        （5）类名是专门用来给某个特定的标签设置样式的<br>        （6）在HTML中每个标签是可以同时绑定多个类名<br>            格式：&lt;标签名称 class=”类名1  类名2 ……”&gt;</p>
<p>id选择器与class选择器的区别：<br>         （1）id相当于人的身份证不可以重复，class相当于人的名称可以重复<br>         （2）一个HTML标签名称只能绑定一个id名称，可以绑定多个class名称<br>         （3）id选择器是以#开头，class是以.开头<br>         （4）id一般是给js使用的，所有除非特殊情况，否则不要使用id去设置样式    </p>
<h2 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h2><p>  作用：找到指定的标签的所有后代标签，然后设置属性<br>格式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">标签名称<span class="number">1</span>  标签名称<span class="number">2</span>&#123;</div><div class="line">属性：值；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>先找到名称叫做标签名称1的标签，再在这个标签下去查找所有名称叫做标签名称2的标签，然后设置属性
  注意点：
  （1）后代选择器必须用空格隔开
  （2）后代不仅是儿子，也包括孙子等等，只要最终是放在指定标签的都是后代
  （3）后代选择器不仅仅可以使用标签名称，还可以使用其他选择器
</code></pre><h2 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h2><p>   作用：找到指定标签中所有特定的直接子元素，然后设置属性<br>格式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">标签名称<span class="number">1</span>&gt;标签名称<span class="number">2</span>&#123;</div><div class="line">属性：值；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>先找到名称叫做标签名称1的标签，然后再在这个标签下去查找所有直接子元素名称叫做标签名称2的标签，然后设置属性
     注意点：
     （1）子元素选择器之间需要用&gt;符号连接，并且不能有空格
     （2）子元素选择器只会查找儿子，不会查找其他被嵌套的标签
     （3）子元素选择器不仅仅可以使用标签名称，还可以使用其他选择器
</code></pre><p>后代选择器与子元素选择器的区别与联系：<br>               （1）后代选择器用空格作为连接符号，子元素选择器用&gt;作为连接符号<br>               （2）后代选择器会选中指定标签中所有的特定后代标签，子元素选择器只会选中指定标签中的所有特定标签中的直接标签<br>                （3）后代选择器和子元素选择器都可以使用标签名称/id名称/class名称作为选择器，都可以通过各自的连接符号一直延续下去<br>                （4）在企业开发中如果想选中所有特定的标签，那么就使用后代选择器，如果只想选中指定标签中的所有特定儿子标签，那就使用子元素选择器</p>
<h2 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h2><p>   作用：给所有选择器选中的标签中，相交的那部分设置属性<br>     格式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      选择器<span class="number">1</span>选择器<span class="number">2</span>&#123;</div><div class="line">属性：值；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>注意点：（1）选择器和选择器之间没有任何的连接符号
       （2）选择器可以使用标签名称/id名称/class名称
       （3）企业开发中用的比较少
</code></pre><h2 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h2><p>   作用：给所有选择器选中的标签设置属性<br>       格式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      选择器<span class="number">1</span>，选择器<span class="number">2</span>&#123;</div><div class="line">属性：值；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>注意点：（1）选择器和选择器之间必须用，来连接
       （2）选择器可以使用标签名称/id名称/class名称
</code></pre><h2 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器"></a>兄弟选择器</h2><p>1.相邻兄弟选择器：（CSS2）<br>作用：给指定选择器后面紧跟的那个选择器选中的标签设置属性<br>        格式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      选择器<span class="number">1</span>+选择器<span class="number">2</span>&#123;</div><div class="line">属性：值；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>注意点：（1）选择器和选择器之间必须用+来连接
      （2）选择器可以使用标签名称/id名称/class名称
      （3）相邻兄弟选择器只能选中紧跟其后的那个标签，不能选中隔开的标签
</code></pre><p>2.通用兄弟选择器：（CSS3）<br>作用：给指定选择器后面的所有选择器选中的所有标签设置属性<br>        格式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">      选择器<span class="number">1</span>~选择器<span class="number">2</span>&#123;</div><div class="line">属性：值；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>注意点：（1）选择器和选择器之间必须用~来连接
       （2）选择器可以使用标签名称/id名称/class名称
       （3）相邻兄弟选择器选中的是指定选择器后面某个选择器选中的所有标签，无论有没有隔开
</code></pre><h2 id="序选择器"><a href="#序选择器" class="headerlink" title="序选择器"></a>序选择器</h2><pre><code>1.同级别的第几个
 （1）first-child:选中同级别的第一个标签
 （2）last-child:选中同级别的最后一个标签
 （3）nth-child（n）:选中同级别中的第n个标签
 （4）nth-last-child（n）:选中同级别中的倒数第n个标签 
 （5）only-child：选中父元素中唯一的元素
 （6）nth-child(odd):选中同级别中的奇数行
 （7）nth-child(even):选中同级别中的偶数行
 （8）nth-child(xn+y):x、y用户自定义，n是计数器，从0开始递增 
</code></pre><p>注意点：不区别类型<br>     2.同类型的第几个<br>     （1）first-of-type:选中同级别中同类型的第一个标签<br>     （2）first-of-type:选中同级别中同类型的最后一个标签<br>     （3）nth-of-type（n）:选中同级别中同类型的第n个标签<br>     （4）nth-last-of-type（n）:选中同级别中同类型的倒数第n个标签<br>     （5）only-of-type：选中父元素中唯一类型的某个标签</p>
<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>作用：根据指定的属性名称找到对应标签，然后设置属性<br>（1）格式：[属性]<br>（2）格式：[属性=value]<br>（3）格式（属性的取值是以什么开头的）：<br>   [属性|=value] （CSS2）<br>   [属性^=value] （CSS3）<br> 两者之间的区别：CSS2中的只能找到以value开头，并且value是被-和其他内容隔开的，CSS3中的只要是以value开头的都可以找到<br>（4）格式（属性的取值是以什么结尾的）：<br>   [属性$=value] （CSS3）<br>（5）格式（属性的取值是否包含某个特定的值）：<br>   [属性~=value] （CSS2）<br>   [属性*=value] （CSS3）<br> 两者之间的区别：CSS2中的只能找到独立的单词，也就是包含value，并且是被空格隔开的，CSS3中的只要包含value就可以找到</p>
<h2 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h2><pre><code>作用：给当前界面上所有的标签设置属性
格式：*{ 属性：值；}
注意点：由于通配符选择器是给界面所有的标签设置属性，所以在设置之前会遍历所有的标签，如果标签比较多，那么性能就会比较差，所有一般在企业开发中不会使用它
</code></pre><h1 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h1><h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><pre><code>作用：给父元素设置一些属性，子元素也可以使用
注意点：（1）并不是所有的属性都可以继承，只有以color/font-/text-/line开头的属性可以继承。
</code></pre><p>1.不仅是儿子可以继承，后代都可以继承。<br>2.CSS继承性的特殊性：a标签的文字属性和下划线是不能继承的，h标签的文字大小是不能继承的<br>        应用场景：在企业开发中，一般用于设置网页的一些共性信息，例如网页的文字颜色，字体，大小等</p>
<h2 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h2><pre><code>作用：层叠性是CSS处理冲突的一种能力
注意点：层叠性只有在多个选择器选中“同一个标签”，又设置的 “相同属性”，才会发生层叠性
</code></pre><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><pre><code>作用：当多个选择器选中同一个标签，并且给同一个标签设置相同的属性时，如何层叠就由优先级来确定
优先级的判断方式：
（1）是否是直接选中（间接选中就是指继承）：如果是间接选中那么就是谁离目标标签比较近就听谁的
（2）相同选中器：如果都是直接选中并且是相同选中器那么谁写在后面就听谁的
（3）不同选择器：如果都是直接选中并且不是相同选中器，那么就按照选择器的优先级来层叠：id&gt;类&gt;标签&gt;通配符&gt;继承&gt;浏览器默认
</code></pre><h1 id="important属性"><a href="#important属性" class="headerlink" title="!important属性"></a>!important属性</h1><pre><code>作用：用于提升某个直接选中标签的选择器中的某个属性的优先级，可以将被指定的属性的优先级被提升为最高
</code></pre><p>注意点：（1）只能用于直接选中，不能用于间接选中<br>         （2）只能提升被指定的属性的优先级，其他属性的优先级不变<br>         （3）通配符选择器选中的标签也是直接选中</p>
<p>权重问题：<br>        作用：当多个选择器混合在一起使用时，我们可以通过计算权重来判断谁的优先级最高<br>        权重的计算规则：（1）首先先计算选择器中有多少个id，id多的选择器优先级最高<br>                       （2）如果id的个数一样，那么再看类名的个数，类名个数多的优先级最高<br>                       （3）如果类名的个数一样，那么再看标签名称的个数，标签个数多的优先级最高<br>                       （4）如果id个数一样，类名个数一样，标签名称个数一样，那么此时谁写在后面就听谁的，即优先级一样的时候，谁写在后面就听谁的<br>        注意点：只有选择器直接选中标签才需要计算权重</p>
<h1 id="CSS元素显示模式"><a href="#CSS元素显示模式" class="headerlink" title="CSS元素显示模式"></a>CSS元素显示模式</h1><p>1.div和span<br>         1.div<br>          作用:一般配合CSS完成网页的基本布局<br>         2.span<br>           作用：一般配合CSS修改网页中的一些局部信息<br>         两者区别：（1）div会单独占领一行，而span不会单独占领一行<br>                  （2）div是一个容器级的标签，而span是一个文本级的标签<br>         容器级标签和文本级标签的区别：<br>                   容器级的标签中科院嵌套其他所有的吧，而文本级的标签只能嵌套文字/图片/超链接标签<br>容器级的标签：div h u lol li dt dd……<br>      文本级的标签：span p buis e mind del……</p>
<p>2.块级元素、行内元素、行内块级元素<br>（1）块级元素：独占一行；如果没有设置宽度，那么默认和父元素一样宽；如果设置了宽度，就按照设置的宽度来显示<br>p div h ul oi li dt dd……<br>（2）行内元素：不会独占一行；如果没有设置宽度，那么默认和内容一样宽；行内元素是不可以设置宽度的<br>span buis strong em ins del……<br>（3）行内块级元素：为了能够让元素既能够不独占一行，又可以设置宽度和高度，那么就出现了块级行内元素</p>
<p>如何转换CSS元素的显示模式？<br>设置元素的display属性<br>取值：block  将元素转换为块级元素<br>inline   将元素转换为行内元素<br>inline-block  将元素转换为行内块级元素</p>
<h1 id="网页布局方式"><a href="#网页布局方式" class="headerlink" title="网页布局方式"></a>网页布局方式</h1><h2 id="网页元素排版"><a href="#网页元素排版" class="headerlink" title="网页元素排版"></a>网页元素排版</h2><p>网页的布局方式其实就是指浏览器是如何对网页的元素进行排版的<br>  （1）标准流（文档流/普通流）排版方式<br>浏览器的默认排版方式，有两种排版方式：<br>垂直排版：如果元素是块级元素，那么就会垂直排版<br>水平排版：如果元素是行内元素/行内块级元素，那么就会水平排版</p>
<p>  （2）浮动流排版方式<br>【1】浮动流是一种半脱离标准流的排版方式，只有水平排版方式，它只能设置某个元素向左对齐或向右对齐</p>
<pre><code>注意点：
（1）浮动流中是没有居中对齐的
（2）浮动流中是不可以使用margin:0 auto;
特点： 
（1）在浮动流中是不区分行内元素/块级元素/行内块级元素，无论是内元素/块级元素/行内块级元素都可以水平排版，都可以设置宽高
（2）浮动流中行内元素/块级元素/行内块级元素都可以设置宽高
</code></pre><p>【2】浮动元素脱标：</p>
<pre><code>当某一个元素浮动之后，那么这个元素看上去就像被从标准流中删除一样
脱标后的影响：如果前面一个元素浮动了，而后面一个元素没有浮动，那么这个时候前一个元素就会盖住后面一个元素
</code></pre><p>【3】浮动元素排序规则：</p>
<pre><code>（1）相同方向上的浮动元素，先浮动的元素会显示在前面，后浮动的元素会显示在后面
（2）不同方向上的浮动元素，左浮动找左浮动，有浮动找右浮动
（3）浮动元素浮动后的位置由浮动元素浮动之前在标准流中的位置来决定
</code></pre><p>【4】浮动元素贴靠方式：</p>
<pre><code>（1） 当父元素足够放下所有浮动元素的时候，那么浮动元素就会并列显示
（2）当父元素不够放下所有浮动元素的时候，那么就会从最后一个元素开始向前一个元素贴靠，一直往前贴，直到贴到父元素的边框，这是不管父元素够不够都会贴靠在那里
</code></pre><p>【5】浮动元素字围现象：<br>浮动元素不会挡住没有浮动元素中的文字, 没有浮动的文字会自动给浮动的元素让位置,这个就是浮动元素字围现象<br>【6】浮动元素高度问题：</p>
<pre><code>（1）在标准流中内容的高度是可以撑起父元素的高度
（2）在浮动流中浮动元素是不可以撑起父元素的高度
</code></pre><p>【7】清除浮动：</p>
<pre><code>《1》方式一：给前面一个元素设置高度
     注意点：在企业开发中，我们能不写高度就不写高度，所以这种方式用的比较少
《2》方式二：给后面一个元素添加clear属性
     取值：none:默认取值，按浮动元素的规则来排序(右浮动找右浮动,左浮动找左浮动)
          left:不要找前面的左浮动 
          right:不要找前面的右浮动
          both: 不要找前面的左浮动和右浮动
     注意点：当给某个元素添加clear属性之后，那么这个属性的margin属性就会失效
《3》方式三：隔墙法
           （1）外墙法：在两个盒子之间添加一个额外的块级元素，并且给这个块级元素添加clear:both;属性
            注意点：外墙法可以让第二个盒子使用margin-top属性，但不可以让第一个盒子使用margin-bottom属性。一般在企业开发中，是直接给额外添加的块级元素添加一个高度
           （2）内墙法：在第一个盒子中所有子元素最后添加一个额外的块级元素，并且给这个块级元素添加clear:both;属性
            注意点：内墙法可以让第二个盒子使用margin-top属性，也可以让第一个盒子使用margin-bottom属性。
           （3）区别：外墙法不能撑起第一个盒子的高度，而内墙法可以撑起第一个盒子的高度
《4》方式四：伪元素选择器：
           作用：给指定标签的内容前面添加一个子元素或者给指定标签的内容后面添加一个子元素
           （1）格式一:给指定标签的内容前面添加一个子元素
                    标签名称：：before{
                    属性名称：值；
                    content: ；
                    给指定添加的子元素中存储的内容
                    width: ;
                    height: ;
                    给指定添加的子元素的宽度和高度
                    display:block;
                    给指定添加的子元素的显示模式
                    visibility:hidden;
                    隐藏添加的子元素}
           （2）格式二：给指定标签的内容后面添加一个子元素
                     标签名称::after{
                    属性名称：值；
                    content: ；
                    设置添加的子元素的内容为空
                    height:0 ;
                    设置添加的子元素的高度为0
                    display:block;
                    设置添加的子元素为块级元素
                    visibility:hidden;
                    隐藏添加的子元素
                    clear:both;
                    }
                兼容IE6：给第一个盒子添加
                    .box1{*zoom:1;}
《5》 方式六：overflow:hidden;
           作用：（1）可以将超出标签范围的内容裁剪掉
                （2）可以清处浮动
                （3）可以通过overflow:hidden;让里面的盒子设置margin-top之后，外面的盒子不被顶下来
           注意点：可以让第二个盒子使用margin-top属性，也可以让第一个盒子使用margin-bottom属性
</code></pre><h2 id="定位流排版方式"><a href="#定位流排版方式" class="headerlink" title="定位流排版方式"></a>定位流排版方式</h2><p>《1》相对定位:相对于自己以前在标准流中的位置来移动<br>格式：position:relative<br>注意点：<br>不会脱离标准流的，会继续在标准流占用一定的空间<br>            需要配合 top right left bottom 来使用，但同一方向定位属性只能使用一个<br>            由于相对定位是不脱离标准流的，所以是区分块级元素/行内元素/行内块级元素<br>            由于相对定位是不脱离标准流的，并且相对定位的元素会占用标准流中的位置，所以当给相对定位元素设置margin/padding等属性会影响到标准流的布局<br>应用场景：用于对元素进行微调（想让多个盒子对齐时可以使用【想让多个盒子顶部对齐也可以使用浮动定位】}）<br>配合绝对定位来使用<br>《2》绝对定位：相对于body来定位<br>          格式：position：absolate<br>          定位的参考点规律：<br>默认情况下所有的绝对定位元素是相对于body来定位<br>如果绝对定位的元素有祖先元素，并且祖先元素也是定位流，那么这个绝对定位元素就会以定位流（相对定位/绝对定位/固定定位）的那个祖先元素作为参考点<br>如果绝对定位的元素有多个定位流的祖先元素，那么这个绝对定位流元素就会以离它最近的那个祖先元素作为参考点<br>         注意点：绝对定位是脱离标准流的，不区分块级元素/行内元素/行内块级元素<br>            需要配合 top right left bottom 来使用，但同一方向定位属性只能使用一个<br>            如果一个绝对定位的元素是以body作为参考点，那么其实是以网页首屏的宽度和高度作为参考点，而不是整个网页的宽度和高度作为参考点的<br>           一个绝对定位元素是会忽略祖先元素的padding<br>应用场景：用于对元素的微调,配合相对定位来使用</p>
<p>子绝父相（子元素用绝对定位，父元素用相对定位）<br>相对定位的弊端：不脱离标准流，会继续占用一定的空间，不利于布局界面<br>绝对定位的弊端：默认情况下绝对定位是以body作为参考点，不会随着浏览器的宽度高度的变化而变化</p>
<p>应用场景：当某一个元素覆盖在另一个元素上面时，需要用到定位流<br>绝对定位的水平居中问题：</p>
<pre><code>只需设置绝对定位元素的left:50%;
然后在设置绝对定位元素的margin-left:-元素宽度的一半px
</code></pre><p>《3》固定定位：固定定位和背景关联方式很像，背景定位可以让背景图片不随着滚动条而滚动，而固定定位可以让某个元素不随着滚动条而滚动<br>        格式：position:fixed;<br>        注意点：固定定位的元素是脱离标准流的，不会占用标准流的空间<br>               固定定位和绝对定位一样，不区分块级元素/行内元素/行内块级元素<br>        应用场景：导航条在网页顶部的固定位置,网页两侧的广告,底部返回顶部的按钮<br>《4》静态定位（默认状态）<br>     格式：position:static<br>定位流z-index:专门用于控制定位流的覆盖关系<br>       规律：默认情况下所有的元素都有一个z-index属性，取值为0<br>             默认情况下定位流元素覆盖标准流的元素<br>             默认情况下定位流的元素后遍写的覆盖先编写的，如果定位流元素中设置了z-index属性，那么谁的z-index比较大，谁就显示在上面<br>注意点：从父现象<br>          （1）如果两个元素父元素都没有设置z-index属性，那么谁的z-index比较大，谁就显示在上面<br>          （2）如果两个元素父元素都设置了z-index属性，那么子元素的z-index就会失效，谁的父元素z-index属性比较大，那么谁就会显示在上面</p>
<h1 id="a标签伪类选择器"><a href="#a标签伪类选择器" class="headerlink" title="a标签伪类选择器"></a>a标签伪类选择器</h1><p>   （1）作用：专门用来修改a标签不同状态的样式<br>   （2）状态：从未被访问过（默认状态）、被访问过状态、鼠标长按状态、鼠标悬停在上面状态<br>（3）格式：<br>a:link{color： ;}修改从未被访问过状态下的样式<br>              a:visited{color: ;}修改被访问过状态下的样式<br>              a:active{color: ;}修改鼠标长按状态下的样式<br>              a:hover{color: ;}修改鼠标悬停a标签上状态下的样式<br>    （4）注意点：<br>               a标签伪类选择器可以单独初中，也可以同时出现。同时出现需要严格准守爱恨原则（love  hatd）：a:link、a:visited、 a:hover、a:active<br>              如果默认状态和被访问过状态是一样的，可以简写a{color:}<br>              在企业开发中编写a标签伪类选择器最好写在标签选择器后面<br>              在企业开发中和a标签盒子相关属性都写在标签选择器中（显示模式/宽度/高度/padding/margin）<br>              在企业开发中和a标签文字/背景相关属性都写在伪类选择器中<br>（5）悬停在链接上背景颜色的改变：<br><a href="http://localhost:63342/HTML5学习代码/A标签伪类选择器.html" target="_blank" rel="external">http://localhost:63342/HTML5学习代码/A标签伪类选择器.html</a></p>
<h1 id="过渡模块"><a href="#过渡模块" class="headerlink" title="过渡模块"></a>过渡模块</h1><p>1.格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">选择器&#123;</div><div class="line">             transition-property:属性；</div><div class="line">             transition-duration:时间</div><div class="line">&#125;</div><div class="line"> 标签:hover&#123;</div><div class="line">属性：值；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.过渡三要素<br>：hover可以使用在任何标签上<br>transition-property: 告诉系统哪个属性需要执行过渡效果<br>            transition-duration:告诉系统过渡效果持续的时长<br>注意点：当多个属性需要同时执行过渡效果，用逗号隔开即可<br>3.其他属性；</p>
<pre><code>transition-delay:告诉系统延迟多久后再执行过渡动画
transition-timing-function:告诉系统过渡动画的运动速度
 取值：linear匀速
       ease逐渐慢下来
       ease-in加速
       ease-out减速
       ease-in-out先加速再减速
</code></pre><p>4.连写：transition：property duration timing-function delay；<br>注意点：如果多个属性需要同时执行过渡效果，用逗号隔开即可<br>          连写的时候可以省略后面两个参数，因为只有编写了前面两个参数就已经满足了过渡三要素<br>           如果多个属性运动的速度/延迟的时间/持续的时间都一样，那么可以简写为transition：all 值；<br>5.编写过渡套路：<br>先编写基本界面，再修改我们认为需要修改的属性，最后给被修改属性的那个元素添加过渡即可</p>
<h1 id="2D转换模式"><a href="#2D转换模式" class="headerlink" title="2D转换模式"></a>2D转换模式</h1><p>1.格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">选择器：hover&#123;transform: ；&#125;</div></pre></td></tr></table></figure></p>
<pre><code>取值：rotate(数字deg)  旋转多少度
      translate（ px, px） 平移
</code></pre><p>第一个值代表水平方向，第二个值代表垂直方向<br>              scale（  ,  ） 缩放<br>第一个值代表水平方向，第二个值代表垂直方向，取值1代表不变，大于1 代表放大，小鱼1代表缩小。如果水平垂直方向缩放都一样，可以简写为一个参数<br>注意点：如果父元素被缩放了，那么子元素也会被缩放<br>2.综合效果：<br>          transform: rotate(数字deg)  translate（ px） scale（  ,  ）；<br>注意点：需要用空格隔开。2D的转换会修改元素坐标系，所以旋转后再平移就不是水平平移了<br>3.形变中心点：<br>       格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">选择器&#123;：transform-origin： px  px；&#125;</div></pre></td></tr></table></figure></p>
<pre><code>第一个参数代表水平方向，第二个参数代表垂直方向
取值：像素、百分比、单词
</code></pre><p>默认情况下所有的元素都是以自己的中心点作为参考来旋转<br>4.旋转轴点：<br>（1）默认情况下所有的元素都是围绕Z轴进行旋转：<br>transform: rotateZ(数字deg)<br>（2）围绕X轴进行旋转：transform: rotateX(数字deg)<br>（3）围绕Y轴进行旋转：transform: rotateY(数字deg)<br>注意点：屏幕的原点在左上角  左上角transform: rotate(0% 0%)<br>中心点transform: rotate(50% 50%)<br>5.透视属性：近大远小<br>            perspective: px;<br>注意点：想看到近大远小的效果越明显那么像素值就设置越大，想看到近大远小的效果越模糊那么就像素设置越大<br>必须添加到需要呈现近大远小效果的元素的父元素上面</p>
<h1 id="盒子阴影和文字阴影"><a href="#盒子阴影和文字阴影" class="headerlink" title="盒子阴影和文字阴影"></a>盒子阴影和文字阴影</h1><p>1.盒子阴影：box-shadow:h-shadow v-shadow blur spread color inset;<br>h-shadow水平偏移<br>v-shadow垂直偏移<br>blur模糊度<br>spread阴影扩展<br>color阴影颜色<br>inset内外阴影<br>注意点：盒子阴影分内外阴影，默认是外阴影<br>        快速添加盒子阴影：box-shadow:h-shadow v-shadow blur，阴影颜色由盒子内容颜色决定<br>2.文字阴影：text-shadow:h-shadow  v-shadow  blur color<br>注意点：快速添加文字阴影test-shadow:h-shadow  v-shadow  blur，阴影颜色由文字颜色决定<br>3.翻转菜单<br><a href="http://localhost:63342/HTML5学习代码/翻转菜单.html" target="_blank" rel="external">http://localhost:63342/HTML5学习代码/翻转菜单.html</a></p>
<h1 id="动画模块"><a href="#动画模块" class="headerlink" title="动画模块"></a>动画模块</h1><p>1.动画与过渡的异同：<br>  不同点：过渡必须人为的触发才会执行动画<br>         动画不需要人为的触发就会执行动画<br>相同点：过渡与动画都是用来给元素添加动画的，都是系统新增的一些属性，都需要满足三要素才会有动画效果<br>2.动画三要素：<br>            （1）告诉系统需要执行哪个动画<br>            （2）告诉系统我们需要自己创建一个名称叫做xxx的动画<br>            （3）告诉系统动画持续的时长<br>3.格式一：（起始动画）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">        选择器&#123;</div><div class="line">animation-name: ；</div><div class="line">              animation-duration: ；</div><div class="line">         &#125;</div><div class="line">        @keyframes  动画名称&#123;</div><div class="line">form&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">to&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">格式二：（百分比）</div><div class="line">选择器&#123;</div><div class="line">animation-name: ；</div><div class="line">animation-duration: ；</div><div class="line">&#125;</div><div class="line">@keyframes  动画名称&#123;</div><div class="line">0%&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">25%&#123;</div><div class="line">                     </div><div class="line">&#125;</div><div class="line">50%&#123;</div><div class="line">&#125;</div><div class="line">75%&#123;</div><div class="line">&#125;</div><div class="line">100%&#123;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.其他属性：<br>            <1>animation-delay:告诉系统延迟多久后再执行动画<br>            <2>animation-timing-function:告诉系统动画的执行的速度<br>             取值：linear匀速<br>                   ease逐渐慢下来<br>                   ease-in加速<br>                   ease-out减速<br>                   ease-in-out先加速再减速<br>            <3>animation-iteration-count:告诉系统动画被播放的次数<br>            <4>animation-direction:告诉系统是否需要执行往返动画<br>              取值：normal:默认，执行完一次之后回到起点再执行下一次<br>                    alternate：执行完一次之后往回执行下一次<br>            <5>animation-play-state: : 告诉系统当前动画是否需要暂停<br>              取值:running: 执行动画<br>                   paused: 暂停动画<br> <6>动画的状态：等待状态 、开始状态 、结束状态<br>               animation-fill-mode:指定动画的等待状态和结束状态的样式<br>                取值：none:不做任何改变<br>                      forwords：让元素结束状态保持最后一帧的样式<br>                      backwordes：让元素等待状态时候显示动画的第一帧样式<br>                      both：让元素等待状态时候显示动画的第一帧样式，让元素结束状态保持最后一帧的样式<br>5.注意点：（1）动画中如果有和默认样式中同名的属性，会覆盖覆盖默认样式中的同名属性<br>         （2）在编写动画的时，固定不变的值写在前面，需要变化的值写在后面<br>6.连写格式：<br>animation：动画名称 动画时长 动画运动速度 延迟时间 执行次数 往返动画；<br>简写模式：animation：动画名称 动画时长 动画运动速度；</6></5></4></3></2></1></p>
<h1 id="3D转换模块"><a href="#3D转换模块" class="headerlink" title="3D转换模块"></a>3D转换模块</h1><p>1.2D和3D：<br>  2D就是一个平面，只有看到和高度，没有厚度<br>  3D就是一个立体，有宽度和高度，还有厚度<br>  默认情况下，所有元素都呈现2D展现的<br>2.如何让元素呈3D展现？<br>  和透视效果一样，想看到某个元素的3D效果，只需要给它的父元素添加一个transform-style属性，然后设置perspective-3d即可<br>3.正方体<br> 编写顺序：（先旋转再平移）上 后 下 前 左 右<br>4.长方体：先编写正方体然后再对上后下前四个面进行拉伸</p>
<h1 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h1><p>1.线性渐变：<br>直接设置渐变：background: linear-gradient(red,blue);<br>添加渐变方向：background: linear-gradient(to right, red,blue);<br>            可以根据角度设置渐变方向：background: linear-gradient(45deg,red,blue);<br>设置渐变到下一颜色的位置：background: linear-gradient(to right,red 30%,green 80%,blue);</p>
<p>2.径向渐变：<br>默认从中点开始扩散：background: radial-gradient(red,green,blue);<br>            大小范围,位置,颜色：background: radial-gradient(100px at center center,red,blue);<br>可以通过像素进行设置位置：background: radial-gradient(100px at 50px 50px,red,blue);<br>3.重复渐变：<br>             重复线性渐变：background: repeating-linear-gradient(to right,red 10%,blue 20%);<br>             重复径向渐变：background: repeating-radial-gradient(red 10%, blue 20%, yellow<br>公共的项目类写在第一个<br>小范围调整时，使用相对定位；大范围调整使用绝对定位<br>谷歌浏览最小字体是12px，如果想字体再小一些，可以使用缩放属性（inline-block）<br>在一个盒子中，如果一个元素添加了浮动，那么其他元素也要进行浮动，为了页面的稳定性<br>.webpictuer网页图片，谷歌独有图片，图片被压缩处理过，但图片清晰度不会改变，加载速度快</p>
<p>1.如果图片的宽度小于父元素的宽度, 那么可以使用text-align: center;来居中图片<br>2.如果图片的宽度大于父元素的宽度, 但是图片的宽度是已知的, 那么可以使用定位流 left:50%; margin-left: -图片宽度的一半;<br>3.如果图片的宽度大于父元素的宽度, 但是不知道图片的宽度, 那么可以使用给父元素添加text-align: center; 给图片添加margin: 0 -100%;</p>
]]></content>
      
        <categories>
            
            <category> Css简明教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 简明教程 </tag>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTML简明教程]]></title>
      <url>/2016/10/18/HTML%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>简单的概念，简洁明了。</p>
<h1 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h1><p>1.什么是浏览器？<br>功能：（1）将网页渲染出来让用户查看（2）并让用户与网页交互的一种软件<br>主流浏览器：IE（内核：Trident） 火狐（内核：Gecko） 谷歌（内核：Webkit/Blink） Safari（内核：Webkit） 欧朋（内核：Presto）<br>因为内核不同，所以渲染的网页有所不同<br><a id="more"></a><br>2.什么是服务器？<br>超级计算机，24小时不断电不关机，专门用于存储数据</p>
<p>3.什么是URL?<br>我们在浏览器的地址栏输入的就是URL，eg：<code>http://127.0.0.1:80/index.html</code><br>http:// URL协议类型<br>127.0.0.1 服务器IP地址<br>:80 服务器的端口号<br>/index.html 需要访问的资源名称</p>
<h1 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h1><p>1.HTML（超文本标记语言）<br>作用：专门用来描述文本语义的，也就是说告诉浏览器哪些是标题哪些是段落。<br>注意事项：HTML作用只有一个专门给文本添加语义的，不是用来修改文本样式的。<br><code>&lt;h1&gt;</code>标签的作用是告诉浏览器哪些文字是标题，即给指定文字添加标题语义的<br><code>.html</code>是纯文本文件</p>
<p>2.乱码问题：（1）基本上都保存为UTF-8:<code>&lt;meta charset=”UTF-8”&gt;</code><br>（2）保存网页的字符集和网页中指定的字符集设置为一致</p>
<p>3.DTD文档声明：不是HTML标签，必须在第一行，不区分大小<br><code>&lt;!DOCTYPE html&gt;</code>：HTML5的DTD文档声明是上下兼容的</p>
<h1 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h1><p>1.标签分类：<br>（1）    双标签<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;<span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span> &lt;title&gt;<span class="xml"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span> &lt;body&gt;<span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span>……</div></pre></td></tr></table></figure></p>
<pre><code>单标签  `&lt;meta&gt; &lt;br&gt;……`
</code></pre><p>（2）    兄弟关系 <code>&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;</code><br>嵌套关系 <code>&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;</code></p>
<p>2.<code>&lt;hn&gt;</code>标签：<code>&lt;h1&gt;~&lt;h6&gt;</code><br>  注意点：<br>（1）H标签是用来给文本添加标题语义的<br>（2）被H系列标签包裹的内容会独占一行<br>（3）在企业开发中一般情况下一个界面只能出现一个H1标签</p>
<p>3.<code>&lt;p&gt;</code>标签：<br>作用：告诉浏览器哪些文字是一个段落<br>注意点：在浏览器中会独占一行</p>
<p>4．<code>&lt;hr&gt;</code>标签：分割线<br>   注意点：<br>在浏览器中会独占一行</p>
<p>5.img标签<br>  （1）格式：<code>&lt;img src=””alt=””title=”” &gt;</code><br>  （2）注意点：<br>        如果我们不指定img标签的宽度和高度，那么系统按照默认图片宽度和高度，如果我们手动指定了Img标签的宽度和高度，有可能导致图片变形。<br>        如果想指定img标签的宽度和高度，又不想图片变形，我们只能只指定宽度或高度其中一个<br>  （3）常用属性：<br>        src：用来显示图片的路径<br>              title：用来告诉浏览器，当鼠标悬停在图片上时，需要弹出的描述框中显示什么内容<br>              alt:当需要显示的图片找不到的时候显示什么内容</p>
<p>6.<code>&lt;br&gt;</code>：用于换行<br>  注意点：<br>        多个br标签可以同时使用由于HTML是用于给文本添加语义的，而br标签的语义不是另起一个段落，所以在企业开发中很少使用它</p>
<p>7.路径问题<br>  给src属性赋值有两种方式：<br>    （1）相对路径:每次都是从.html文件所在的文件夹开始查找<br>        同级：图片和.html文件存储在同一个文件夹中，格式：src=”xxx.xxx”<br>        下级：存储图片的文件夹和.html文件在同一个文件夹中，格式：src=”xxx/xxx.xxx”<br>        上级：存储图片的位置和存储代码的文件夹在同一个文件夹中，格式：src=”../xxx.xxx”<br>    （2）绝对路径:每次都是从指定的盘符开始查找<br>  注意点：<br>        企业开发中如果需要编写路径，统一使用反斜杠/<br>        企业开发中一般不使用绝对路径，因为可移植性不好</p>
<p>8.a标签：用于控制页面与页面之间的跳转<br>   （1）格式：<code>&lt;a href=””&gt;&lt;/a&gt;</code><br>   （2）注意点：<br>        a标签不仅可以让文字可以点击，也可以让图片能够被点击<br>        a标签必须有一个href属性<br>        如果通过a标签的href属性指定一个URL地址，那么必须在地址前加上<a href="http://或https://" target="_blank" rel="external">http://或https://</a><br>        a标签的href属性除了可以指定一个网址，还可以指定一个本地地址<br>   （3）常用属性：<br>        target（跳转方式）：_self:在当前选项卡中跳转，默认。_blank:在新的选项卡中跳转<br>        title：用来告诉浏览器，当鼠标悬停在链接上时，需要弹出的描述框中显示什么内容<br>   （4）假链接：点击之后不会跳转，企业开发前期，其他页面都没有写出来，就用假链接来代替<br>            格式：<code>&lt;a href=”#”&gt;</code>会自动回到网页顶部<br>            <code>&lt;a href=”javascript”&gt;</code>不会自动回到网页顶部</p>
<p>9.base标签：专门用来统一的指定当前网页中所有的超链接需要如何打开<br>    格式：<code>&lt;base target=””&gt;</code><br>    注意点：如果base和a标签同时指定了打开方式，网页的打开方式由a标签决定</p>
<p>10.锚点：<br>(1)要想通过a标签跳转到当前界面的指定位置，那么必须告诉a标签一个独一无二的id，这样才能在当前界面找到需要跳转到的目标位置,格式：<br> <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;a href=”zhongbu”&gt;&lt;h2&gt;我是顶部&lt;/h2&gt;&lt;/a&gt;</div><div class="line">&lt;h2 id=”zhongbu”&gt;我是中部&lt;/h2&gt;</div><div class="line">&lt;a href=”dibu”&gt; 跳转到底部&lt;/a&gt;</div><div class="line">&lt;h2 id=”dibu”&gt;我是底部&lt;/h2&gt;</div></pre></td></tr></table></figure></p>
<p> (2)想通过a标签跳转到其他界面的指定位置<br> 格式：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;a href=”新界面的网址#123”&gt;跳转到xxx&lt;/a&gt;</div><div class="line">&lt;h2 id=”123”&gt;欢迎来到这里&lt;/h2&gt;</div></pre></td></tr></table></figure></p>
<p>11.列表标签<br>（1）无需列表：ul<br>   作用：给一堆数据添加列表语义，并且这一堆数据没有先后之分<br>   格式：<code>&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code><br>   应用场景：新闻列表 商品列表 导航条<br>（2）有序列表：ol<br>   作用：给一堆数据添加列表语义，并且这一堆数据有先后之分<br>   格式：<code>&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;</code><br>（3）定义列表：dl<br>   作用：给一堆数据添加列表语义，先通过dt标签定义列表中的所有标题，然后在通过dd标签给标题添加描述信息<br>   格式：<code>&lt;dl&gt;&lt;dt&gt;&lt;/dt&gt;&lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt;</code><br>dt:定义列表的标题  dd:描述标题对应的含义<br>        应用场景：网页的导航条   做网站尾部的相关信息   做图文混排 </p>
<p>12.表格标签：<code>&lt;table&gt;&lt;/table&gt;</code><br>   （1）作用：给一堆数据添加表格语义<br>   （2）格式：<br>   <code>&lt;table&gt;&lt;caption&gt;&lt;/caption&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code><br>    tr：表示一行<br>    td:表示一行的一个单元格<br>    th：专门用来存储每一列的标题，内容会自动加粗居中<br>    caption:专门用来指定表格标题<br>   （3）注意点：表格边框属性border默认为0</p>
<pre><code> 常用属性：（1）宽度和高度（table、td）
 表格默认宽高度是根据内容的尺寸调整的，也可以通过table标签设置width/height属性来手动设置；
 如果给td标签设置width/height属性，只会改变单元格的宽度和高度，不会影响整个表格的宽度和高度
          （2）水平对齐（table、td、tr）
给table标签设置align属性，可以控制表格在水平方向的对齐方式；
给tr标签设置align属性，可以控制当前行中的所有单元格的水平方向对齐方式；
给td标签设置align属性，可以控制当前行中的单元格内容的水平方向对齐方式；
          注意点：如果同时给tr、td设置align属性，那么单元格中的内容会安照td的设置来对齐
          （3）垂直对齐（td、tr）
给tr标签设置设置valign属性,可以控制当前行中的所有单元格的垂直方向对齐方式；
给td标签设置设置valign属性,可以控制当前行的单元格内容的垂直方向对齐方式
          注意点：如果同时给tr、td设置valign属性，那么单元格中的内容会安照td的设置来对齐
</code></pre><p>（4）外边距：单元格与单元格之间的距离，默认情况下cellspacing=2px<br>（5）内边距:单元格的边框与内容之间的间隙，默认情况下cellpadding=1px<br>（6）水平方向上的单元格合并：（行上的单元格合并），给td标签设置一个colspan属性，来指定把一个单元格当作多个单元格<br>（7）垂直方向上的单元格合并：（列上的单元格合并），给td标签设置一个rowspan属性,来指定把一个单元格当作多个单元格</p>
<p><strong>细线表格制作方式</strong>：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;table bgcolor="black" cellspacing="1px" &gt;</div><div class="line">                   &lt;tr bgcolor="white" &gt;</div><div class="line">                      &lt;td&gt;1.1&lt;/td&gt;</div><div class="line">                      &lt;td&gt;1.2&lt;/td&gt;</div><div class="line">                   &lt;/tr&gt;</div><div class="line">                   &lt;tr  bgcolor="white" &gt;</div><div class="line">                      &lt;td&gt;2.1&lt;/td&gt;</div><div class="line">                      &lt;td&gt;2.2&lt;/td&gt;</div><div class="line">                   &lt;/tr&gt;</div></pre></td></tr></table></figure></p>
<p>表格完整格式：（仅作了解）<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;table&gt;</div><div class="line">    &lt;caption&gt;&lt;/caption&gt;</div><div class="line">    &lt;thead&gt;</div><div class="line">        &lt;tr&gt;</div><div class="line">            &lt;th&gt;&lt;/th&gt;</div><div class="line">        &lt;/tr&gt;</div><div class="line">    &lt;/thead&gt;</div><div class="line">    &lt;tbody&gt;</div><div class="line">        &lt;tr&gt;</div><div class="line">            &lt;td&gt;&lt;/td&gt;</div><div class="line">        &lt;/tr&gt;</div><div class="line">    &lt;/tbody&gt;</div><div class="line">    &lt;tfoot&gt;</div><div class="line">        &lt;tr&gt;</div><div class="line">            &lt;td&gt;&lt;/td&gt;</div><div class="line">        &lt;/tr&gt;</div><div class="line">    &lt;/tfoot&gt;</div><div class="line">&lt;/table&gt;</div></pre></td></tr></table></figure></p>
<p>13.表单标签：<br>（1）作用：表单是专门用来收集用户信息的<br>表单标签比较特殊，在浏览器中有自己默认的外观和功能。<br>（2）格式： <code>&lt;from&gt;&lt;表单元素&gt;&lt;/from&gt;</code><br>（3）常见表单元素：<br>      input标签（默认有边框）：它有一个type属性，这个属性有很多类型的取值，取值的不同决定了input标签的功能和外观，除了按钮类型的input标签以外，其他标签都可以通过value属性来指定将来提交到服务器的值<br>    《1》<code>&lt;input type=”text”&gt;</code>明文输入框<br>    《2》<code>&lt;input type=”password”&gt;</code>暗文输入框<br>    《3》<code>&lt;input type=”radio”&gt;</code>单选框<br>注意点：默认单选框不会互斥，要想选框互斥，要给每个单选框标签设置一个name属性，并且属性值必须相同。要想让单选框默认选中其中一个，那么就给他添加一个checked属性<br>    《4》<code>&lt;input type=”checkbox”&gt;</code>多选框<br>注意点：默认可以选择多个，要想让单选框默认选中其中一个，那么就给他添加一个checked属性<br>    《5》 按钮<br>    普通按钮：<code>&lt;input type=”button”value=”按钮”&gt;</code>，通过value属性给按钮添加标题<br>    图片按钮：<code>&lt;input type=”img”src=””&gt;</code>，作用与普通按钮一样<br>    重置按钮：<code>&lt;input type=”reset”&gt;</code>，用于清空表单填写的内容<br>     注意点：默认按钮标题是重置，可以通过value属性修改按钮标题<br>    提交按钮：<code>&lt;input type=”submit”&gt;</code>，将表单中填写好的内容提交到远程服务器<br>注意点：要想把表单中填写的内容提交给远程服务器中，需要做到以下两点：<code>&lt;form action=”网址”&gt;&lt;/form&gt;</code>；给需要提交的表单元素都添加name属性<br>    《6》隐藏域：<code>&lt;input type=”hidden”&gt;</code>配合提交按钮将一些数据默默的提交到远程服务器<br>    <code>label</code>标签：默认情况下，文字与输入框是没有关联关系的，也就是说点击文字输入框不会聚焦，如果想聚焦，需要这样：<br>方法一：<code>&lt;label  for=”一样”&gt;文字:&lt;/label&gt;&lt;input type=”” id=”一样”&gt;</code><br>方法二：<code>&lt;labrl&gt;文字：&lt;input type=””&gt;&lt;/label&gt;</code>局限性是不能交叉绑定</p>
<p>14.datalist标签：给输入框绑定待选项（了解）<br>格式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;input type=<span class="string">"text"</span> list=<span class="string">"cities"</span>&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">”cities”</span>&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>待选项内容<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>待选项内容<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>待选项内容<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>select标签：用于定义下拉列表<br>格式：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;select&gt;</div><div class="line">&lt;option&gt;列表数据&lt;/option&gt;</div><div class="line">&lt;option&gt;列表数据&lt;/option&gt;</div><div class="line">&lt;option&gt;列表数据&lt;/option&gt;</div><div class="line">&lt;/select&gt;</div></pre></td></tr></table></figure></p>
<p>注意点：下拉列表不能输入内容，但是可以选择内容。也可以设置默认值：<code>&lt;option selected=&quot;selected&quot;&gt;列表数据&lt;/option&gt;</code><br>给下拉列表分类：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;optgroup label=<span class="string">"分组名称"</span>&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">option</span>&gt;</span>列表数据<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span></div><div class="line">&lt;<span class="regexp">/optgroup&gt;</span></div></pre></td></tr></table></figure></p>
<p>textarea标签：默认情况下可以无限换行，有默认的宽度和高度，默认情况下输入框是可以手动拉伸的<br>格式：<br><code>&lt;textarea&gt;内容&lt;/textarea&gt;</code><br>可以通过这样给文本添加列数和行数：<code>&lt;textarea cols=”” rows=””&gt;内容&lt;/textarea&gt;</code>fieldset标签：给表单添加边框<br>legend标签：可以给边框指定一个标题</p>
<p>15.video标签：<br>（1）作用： 播放视频<br>（2）格式： 第一种格式：<code>&lt;video src=””&gt;&lt;/video&gt;</code>第二种格式：<code>&lt;video&gt;&lt;source src=”” type=”video/webm/ogg/mp4”&gt;&lt;/suorce&gt;&lt;/video&gt;</code>由于视频数据非常的重要，所以五大浏览器厂商都不愿意支持别人的视频格式，所以导致了没有一种视频格式是所有浏览器都支持的，这个时候w3c为了解决这个问题，所以有了第二种格式<br>（3）常用属性：width/height<br>autoplay:用来告诉video标签是否需要自动播放视频<br>                controls: 用来告诉video标签是否需要显示控制条<br>                poster：用来告诉video标签视频没有播放之前显示的占用图片<br>                loop：一般用于做广告视频，用于告诉video标签播放结束后是否需要循环播放<br>preload：预加载视频，与autoplay相冲，如果设置了autoplay属性那么preload就会失效<br>muted静音：</p>
<p>16.audio标签：<br>（1）作用：播放音频<br>（2）格式：第一种格式：<code>&lt;audio src=””&gt;&lt;/audio&gt;</code>           第二种格式：<code>&lt;audio&gt;&lt;source src=”audio/mp3”&gt;&lt;/source&gt;&lt;/audio&gt;</code><br>（3）常用属性：width/height<br>autoplay:用来告诉audio标签是否需要自动播放视频<br>                controls: 用来告诉audio标签是否需要显示控制条<br>                loop：用于告诉audio o标签播放结束后是否需要循环播放<br>preload：加载音频，与autoplay相冲，如果设置了autoplay属性那么preload就会失效<br>muted静音：</p>
<p>17.详情和概要标签：<br>（1）作用：利用summary标签来描述概要信息，利用dateils标签描述详情信息，默认情况下是折叠显示，想看详情信息必须点击<br>（2）格式：<code>&lt;details&gt;&lt;summary&gt;概要信息&lt;/summary&gt;详情信息&lt;/details&gt;</code><br>18.marquee标签：不是w3c推荐的标签，但各个浏览器对他的支持非常好<br>  （1）作用：跑马灯效果，不仅可以让文字滚动也可以让图片滚动<br>  （2）格式：<code>&lt;marquee &gt;内容&lt;/marquee &gt;</code><br>  （3）常用属性：<br>               direction：滚动方向 left/right/up/down<br>               scrollamount:滚动速度<br>               loop:滚动次数，默认是-1，无限次<br>               behavior:滚动类型  slide滚动到边界就停止<br>alternate滚动到边界就弹回来</p>
<p>19.字符实体<br><code>&amp;nbsp;</code>空格、<code>&amp;lt;</code>小于号、<code>&amp;gt;</code>大于号、<code>&amp;copy;</code>版权符号</p>
]]></content>
      
        
        <tags>
            
            <tag> HTML </tag>
            
            <tag> 简明教程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Top 10 ES6 Features]]></title>
      <url>/2016/10/13/top10es/</url>
      <content type="html"><![CDATA[<h1 id="Top-10-ES6-Features-Every-Busy-JavaScript-Developer-Must-Know"><a href="#Top-10-ES6-Features-Every-Busy-JavaScript-Developer-Must-Know" class="headerlink" title="Top 10 ES6 Features Every Busy JavaScript Developer Must Know"></a>Top 10 ES6 Features Every Busy JavaScript Developer Must Know</h1><p>Top 10 ES6 Features Every Busy JavaScript Developer Must Know<br> 10 ES6 Features Every Busy JavaScript Software Engineer Must Know<br>38 Replies<br><a id="more"></a><br>This essay will give you a quick introduction to ES6. If you don’t know what is ES6, it’s a new JavaScript implementation. If you’re a busy JavaScript software engineer (and who is not?), then proceed reading to learn the best 10 features of the new generation of the most popular programming language—JavaScript.</p>
<p>Here’s the list of the top 10 best ES6 features for a busy software engineer (in no particular order):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Default Parameters in ES6</div><div class="line">Template Literals in ES6</div><div class="line">Multi-line Strings in ES6</div><div class="line">Destructuring Assignment in ES6</div><div class="line">Enhanced Object Literals in ES6</div><div class="line">Arrow Functions in ES6</div><div class="line">Promises in ES6</div><div class="line">Block-Scoped Constructs Let and Const</div><div class="line">Classes in ES6</div><div class="line">Modules in ES6</div></pre></td></tr></table></figure></p>
<p>Disclaimer: the list if highly biased and subjective. It is in no way was intended to diminish usefulness of other ES6 features, which didn’t make it to the list simply because I had to limit the number to 10.</p>
<h1 id="Default-Parameters-in-ES6"><a href="#Default-Parameters-in-ES6" class="headerlink" title="Default Parameters in ES6"></a>Default Parameters in ES6</h1><p>Remember we had to do these statements to define default parameters:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> link = <span class="function"><span class="keyword">function</span> (<span class="params">height, color, url</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> height = height || <span class="number">50</span></div><div class="line">    <span class="keyword">var</span> color = color || <span class="string">'red'</span></div><div class="line">    <span class="keyword">var</span> url = url || <span class="string">'http://azat.co'</span></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>They were okay until the value was 0 and because 0 is falsy in JavaScript it would default to the hard-coded value instead of becoming the value itself. Of course, who needs 0 as a value (#sarcasmfont), so we just ignored this flaw and used the logic OR anyway… No more! In ES6, we can put the default values right in the signature of the functions:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> link = <span class="function"><span class="keyword">function</span>(<span class="params">height = <span class="number">50</span>, color = <span class="string">'red'</span>, url = <span class="string">'http://azat.co'</span></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>By the way, this syntax is similar to Ruby!</p>
<h1 id="Template-Literals-in-ES6"><a href="#Template-Literals-in-ES6" class="headerlink" title="Template Literals in ES6"></a>Template Literals in ES6</h1><p>Template literals or interpolation in other languages is a way to output variables in the string. So in ES5 we had to break the string like this:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">'Your name is '</span> + first + <span class="string">' '</span> + last + <span class="string">'.'</span></div><div class="line"><span class="keyword">var</span> url = <span class="string">'http://localhost:3000/api/messages/'</span> + id</div><div class="line">Luckily, <span class="keyword">in</span> ES6 we can use a <span class="keyword">new</span> syntax $&#123;NAME&#125; inside <span class="keyword">of</span> the back-ticked string:</div><div class="line"></div><div class="line"><span class="keyword">var</span> name = <span class="string">`Your name is <span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>.`</span></div><div class="line"><span class="keyword">var</span> url = <span class="string">`http://localhost:3000/api/messages/<span class="subst">$&#123;id&#125;</span>`</span></div></pre></td></tr></table></figure></p>
<h1 id="Multi-line-Strings-in-ES6"><a href="#Multi-line-Strings-in-ES6" class="headerlink" title="Multi-line Strings in ES6"></a>Multi-line Strings in ES6</h1><p>Another yummy syntactic sugar is multi-line string. In ES5, we had to use one of these approaches:</p>
<p>Sidenote: If you like this post and interested in a corporate on-site JavaScript, Node.js and React.js training to boost productivity of your team, then contact NodeProgram.com.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> roadPoem = <span class="string">'Then took the other, as just as fair,\n\t'</span></div><div class="line">    + <span class="string">'And having perhaps the better claim\n\t'</span></div><div class="line">    + <span class="string">'Because it was grassy and wanted wear,\n\t'</span></div><div class="line">    + <span class="string">'Though as for that the passing there\n\t'</span></div><div class="line">    + <span class="string">'Had worn them really about the same,\n\t'</span></div></pre></td></tr></table></figure></p>
<p>var fourAgreements = ‘You have the right to be you.\n\<br>    You can only be you when you do your best.’<br>While in ES6, simply utilize the backticks:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> roadPoem = <span class="string">`Then took the other, as just as fair,</span></div><div class="line">    And having perhaps the better claim</div><div class="line">    Because it was grassy and wanted wear,</div><div class="line">    Though as for that the passing there</div><div class="line">    Had worn them really about the same,`</div><div class="line"></div><div class="line"><span class="keyword">var</span> fourAgreements = <span class="string">`You have the right to be you.</span></div><div class="line">    You can only be you when you do your best.`</div></pre></td></tr></table></figure></p>
<h1 id="Destructuring-Assignment-in-ES6"><a href="#Destructuring-Assignment-in-ES6" class="headerlink" title="Destructuring Assignment in ES6"></a>Destructuring Assignment in ES6</h1><p>Destructuring can be a harder concept to grasp, because there’s some magic going on… let’s say you have simple assignments where keys house and mouse are variables house and mouse:</p>
<p>[Sidenote]</p>
<p>Reading blog posts is good, but watching video courses is even better because they are more engaging.</p>
<p>A lot of developers complained that there is a lack of affordable quality video material on Node. It’s distracting to watch to YouTube videos and insane to pay $500 for a Node video course!</p>
<p>Go check out Node University which has FREE video courses on Node: node.university.</p>
<p>[End of sidenote]<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = $(<span class="string">'body'</span>).data(), <span class="comment">// data has properties house and mouse</span></div><div class="line">  house = data.house,</div><div class="line">  mouse = data.mouse</div><div class="line">Other examples <span class="keyword">of</span> destructuring assignments (<span class="keyword">from</span> Node.js):</div><div class="line"></div><div class="line"><span class="keyword">var</span> jsonMiddleware = <span class="built_in">require</span>(<span class="string">'body-parser'</span>).json</div><div class="line"></div><div class="line"><span class="keyword">var</span> body = req.body, <span class="comment">// body has username and password</span></div><div class="line">  username = body.username,</div><div class="line">  password = body.password</div></pre></td></tr></table></figure></p>
<p>In ES6, we can replace the ES5 code above with these statements:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123; house, mouse&#125; = $(<span class="string">'body'</span>).data() <span class="comment">// we'll get house and mouse variables</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123;jsonMiddleware&#125; = <span class="built_in">require</span>(<span class="string">'body-parser'</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123;username, password&#125; = req.body</div><div class="line">This also works <span class="keyword">with</span> arrays. Crazy!</div><div class="line"></div><div class="line"><span class="keyword">var</span> [col1, col2]  = $(<span class="string">'.column'</span>),</div><div class="line">  [line1, line2, line3, , line5] = file.split(<span class="string">'\n'</span>)</div></pre></td></tr></table></figure></p>
<p>It might take some time to get use to the destructuring assignment syntax, but it’s a sweet sugarcoating.</p>
<h1 id="Enhanced-Object-Literals-in-ES6"><a href="#Enhanced-Object-Literals-in-ES6" class="headerlink" title="Enhanced Object Literals in ES6"></a>Enhanced Object Literals in ES6</h1><p>What you can do with object literals now is mind blowing! We went from a glorified version of JSON in ES5 to something closely resembling classes in ES6.</p>
<p>Here’s a typical ES5 object literal with some methods and attributes/properties:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> serviceBase = &#123;<span class="attr">port</span>: <span class="number">3000</span>, <span class="attr">url</span>: <span class="string">'azat.co'</span>&#125;,</div><div class="line">    getAccounts = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> accountServiceES5 = &#123;</div><div class="line">  <span class="attr">port</span>: serviceBase.port,</div><div class="line">  <span class="attr">url</span>: serviceBase.url,</div><div class="line">  <span class="attr">getAccounts</span>: getAccounts,</div><div class="line">  <span class="attr">toString</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.valueOf())</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">getUrl</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">"http://"</span> + <span class="keyword">this</span>.url + <span class="string">':'</span> + <span class="keyword">this</span>.port&#125;,</div><div class="line">  <span class="attr">valueOf_1_2_3</span>: getAccounts()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>If we want to be fancy, we can inherit from serviceBase by making it the prototype with the Object.create method:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> accountServiceES5ObjectCreate = <span class="built_in">Object</span>.create(serviceBase)</div><div class="line"><span class="keyword">var</span> accountServiceES5ObjectCreate = &#123;</div><div class="line">  <span class="attr">getAccounts</span>: getAccounts,</div><div class="line">  <span class="attr">toString</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.valueOf())</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">getUrl</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">"http://"</span> + <span class="keyword">this</span>.url + <span class="string">':'</span> + <span class="keyword">this</span>.port&#125;,</div><div class="line">  <span class="attr">valueOf_1_2_3</span>: getAccounts()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>I know, accountServiceES5ObjectCreate and accountServiceES5 are NOT totally identical, because one object (accountServiceES5) will have the properties in the <strong>proto</strong> object as shown below:</p>
<p>Enhanced Object Literals in ES6<br>Enhanced Object Literals in ES6</p>
<p>But for the sake of the example, we’ll consider them similar. So in ES6 object literal, there are shorthands for assignment getAccounts: getAccounts, becomes just getAccounts,. Also, we set the prototype right there in the <strong>proto</strong><code>` property which makes sense (not‘proto’</code> though:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> serviceBase = &#123;<span class="attr">port</span>: <span class="number">3000</span>, <span class="attr">url</span>: <span class="string">'azat.co'</span>&#125;,</div><div class="line">    getAccounts = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</div><div class="line"><span class="keyword">var</span> accountService = &#123;</div><div class="line">    <span class="attr">__proto__</span>: serviceBase,</div><div class="line">    getAccounts,</div><div class="line">Also, we can invoke <span class="keyword">super</span> and have dynamic keys (valueOf_1_2_3):</div><div class="line"></div><div class="line">    toString() &#123;</div><div class="line">     <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify((<span class="keyword">super</span>.valueOf()))</div><div class="line">    &#125;,</div><div class="line">    getUrl() &#123;<span class="keyword">return</span> <span class="string">"http://"</span> + <span class="keyword">this</span>.url + <span class="string">':'</span> + <span class="keyword">this</span>.port&#125;,</div><div class="line">    [ <span class="string">'valueOf_'</span> + getAccounts().join(<span class="string">'_'</span>) ]: getAccounts()</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(accountService)</div><div class="line">Enhanced <span class="built_in">Object</span> Literals <span class="keyword">in</span> ES6 II</div><div class="line">Enhanced <span class="built_in">Object</span> Literals <span class="keyword">in</span> ES6 II</div></pre></td></tr></table></figure></p>
<p>This is a great enhancement to good old object literals!</p>
<h1 id="Arrow-Functions-in-ES6"><a href="#Arrow-Functions-in-ES6" class="headerlink" title="Arrow Functions in ES6"></a>Arrow Functions in ES6</h1><p>This is probably one feature I waited the most. I love CoffeeScript for its fat arrows. Now we have them in ES6. The fat arrows are amazing because they would make your this behave properly, i.e., this will have the same value as in the context of the function—it won’t mutate. The mutation typically happens each time you create a closure.</p>
<p>Using arrows functions in ES6 allows us to stop using that = this or self = this or _this = this or .bind(this). For example, this code in ES5 is ugly:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _this = <span class="keyword">this</span></div><div class="line">$(<span class="string">'.btn'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">  _this.sendData()</div><div class="line">&#125;)</div><div class="line"></div><div class="line">This is the ES6 code without _this = <span class="keyword">this</span>:</div><div class="line"></div><div class="line">$(<span class="string">'.btn'</span>).click(<span class="function">(<span class="params">event</span>) =&gt;</span>&#123;</div><div class="line">  <span class="keyword">this</span>.sendData()</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>Sadly, the ES6 committee decided that having skinny arrows is too much of a good thing for us and they left us with a verbose old function instead. (Skinny arrow in CoffeeScript works like regular function in ES5 and ES6).</p>
<p>Here’s another example in which we use call to pass the context to the logUpperCase() function in ES5:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> logUpperCase = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span></div><div class="line"></div><div class="line">  <span class="keyword">this</span>.string = <span class="keyword">this</span>.string.toUpperCase()</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(_this.string)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>logUpperCase.call({ string: ‘es6 rocks’ })()<br>While in ES6, we don’t need to mess around with _this:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> logUpperCase = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.string = <span class="keyword">this</span>.string.toUpperCase()</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.string)</div><div class="line">&#125;</div><div class="line"></div><div class="line">logUpperCase.call(&#123; <span class="attr">string</span>: <span class="string">'es6 rocks'</span> &#125;)()</div></pre></td></tr></table></figure></p>
<p>Note that you can mix and match old function with =&gt; in ES6 as you see fit. And when an arrow function is used with one line statement, it becomes an expression, i.e,. it will implicitly return the result of that single statement. If you have more than one line, then you’ll need to use return explicitly.</p>
<p>This ES5 code is creating an array from the messages array:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ids = [<span class="string">'5632953c4e345e145fdf2df8'</span>,<span class="string">'563295464e345e145fdf2df9'</span>]</div><div class="line"><span class="keyword">var</span> messages = ids.map(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"ID is "</span> + value <span class="comment">// explicit return</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Will become this in ES6:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ids = [<span class="string">'5632953c4e345e145fdf2df8'</span>,<span class="string">'563295464e345e145fdf2df9'</span>]</div><div class="line"><span class="keyword">var</span> messages = ids.map(<span class="function"><span class="params">value</span> =&gt;</span> <span class="string">`ID is <span class="subst">$&#123;value&#125;</span>`</span>) <span class="comment">// implicit return</span></div></pre></td></tr></table></figure></p>
<p>Notice that I used the string templates? Another feature from CoffeeScript… I love them!</p>
<p>The parenthesis () are optional for single params in an arrow function signature. You need them when you use more than one param.</p>
<p>In ES5 the code has function with explicit return:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ids = [<span class="string">'5632953c4e345e145fdf2df8'</span>, <span class="string">'563295464e345e145fdf2df9'</span>];</div><div class="line"><span class="keyword">var</span> messages = ids.map(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, list</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'ID of '</span> + index + <span class="string">' element is '</span> + value + <span class="string">' '</span> <span class="comment">// explicit return</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>And more eloquent version of the code in ES6 with parenthesis around params and implicit return:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ids = [<span class="string">'5632953c4e345e145fdf2df8'</span>,<span class="string">'563295464e345e145fdf2df9'</span>]</div><div class="line"><span class="keyword">var</span> messages = ids.map(<span class="function">(<span class="params">value, index, list</span>) =&gt;</span> <span class="string">`ID of <span class="subst">$&#123;index&#125;</span> element is <span class="subst">$&#123;value&#125;</span> `</span>) <span class="comment">// implicit return</span></div></pre></td></tr></table></figure></p>
<h1 id="Promises-in-ES6"><a href="#Promises-in-ES6" class="headerlink" title="Promises in ES6"></a>Promises in ES6</h1><p>Promises have been a controversial topic. There were a lot of promise implementations with slightly different syntax. q, bluebird, deferred.js, vow, avow, jquery deferred to name just a few. Others said we don’t need promises and can just use async, generators, callbacks, etc. Gladly, there’s a standard Promise implementation in ES6 now!</p>
<p>Let’s consider a rather trivial example of a delayed asynchronous execution with setTimeout():<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Yay!'</span>)</div><div class="line">&#125;, <span class="number">1000</span>)</div></pre></td></tr></table></figure></p>
<p>We can re-write the code in ES6 with Promise:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wait1000 =  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  setTimeout(resolve, <span class="number">1000</span>)</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Yay!'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>Or with ES6 arrow functions:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wait1000 =  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</div><div class="line">  setTimeout(resolve, <span class="number">1000</span>)</div><div class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Yay!'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>So far, we’ve increased the number of lines of code from three to five without any obvious benefit. That’s right. The benefit will come if we have more nested logic inside of the setTimeout() callback:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Yay!'</span>)</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Wheeyee!'</span>)</div><div class="line">  &#125;, <span class="number">1000</span>)</div><div class="line">&#125;, <span class="number">1000</span>)</div></pre></td></tr></table></figure></p>
<p>Can be re-written with ES6 promises:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wait1000 =  <span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;setTimeout(resolve, <span class="number">1000</span>)&#125;)</div><div class="line"></div><div class="line">wait1000()</div><div class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Yay!'</span>)</div><div class="line">        <span class="keyword">return</span> wait1000()</div><div class="line">    &#125;)</div><div class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Wheeyee!'</span>)</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p>Still not convinced that Promises are better than regular callbacks? Me neither. I think once you got the idea of callbacks and wrap your head around them, then there’s no need for additional complexity of promises.</p>
<p>Nevertheless, ES6 has Promises for those of you who adore them. Promises have a fail-and-catch-all callback as well which is a nice feature. Take a look at this post for more info on promises: Introduction to ES6 Promises.</p>
<h1 id="Block-Scoped-Constructs-Let-and-Const"><a href="#Block-Scoped-Constructs-Let-and-Const" class="headerlink" title="Block-Scoped Constructs Let and Const"></a>Block-Scoped Constructs Let and Const</h1><p>You might have already seen the weird sounding let in ES6 code. I remember the first time I was in London, I was confused by all those TO LET signs. The ES6 let has nothing to do with renting. This is not a sugarcoating feature. It’s more intricate. let is a new var which allows to scope the variable to the blocks. We define blocks by the curly braces. In ES5, the blocks did NOTHING to the vars:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTotalAmount</span> (<span class="params">vip</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> amount = <span class="number">0</span></div><div class="line">  <span class="keyword">if</span> (vip) &#123;</div><div class="line">    <span class="keyword">var</span> amount = <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">  &#123; <span class="comment">// more crazy blocks!</span></div><div class="line">    <span class="keyword">var</span> amount = <span class="number">100</span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">var</span> amount = <span class="number">1000</span></div><div class="line">      &#125;</div><div class="line">  &#125;  </div><div class="line">  <span class="keyword">return</span> amount</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(calculateTotalAmount(<span class="literal">true</span>))</div></pre></td></tr></table></figure></p>
<p>The result will be 1000. Wow! That’s a really bad bug. In ES6, we use let to restrict the scope to the blocks. Vars are function scoped.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTotalAmount</span> (<span class="params">vip</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> amount = <span class="number">0</span> <span class="comment">// probably should also be let, but you can mix var and let</span></div><div class="line">  <span class="keyword">if</span> (vip) &#123;</div><div class="line">    <span class="keyword">let</span> amount = <span class="number">1</span> <span class="comment">// first amount is still 0</span></div><div class="line">  &#125; </div><div class="line">  &#123; <span class="comment">// more crazy blocks!</span></div><div class="line">    <span class="keyword">let</span> amount = <span class="number">100</span> <span class="comment">// first amount is still 0</span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">let</span> amount = <span class="number">1000</span> <span class="comment">// first amount is still 0</span></div><div class="line">      &#125;</div><div class="line">  &#125;  </div><div class="line">  <span class="keyword">return</span> amount</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(calculateTotalAmount(<span class="literal">true</span>))</div></pre></td></tr></table></figure></p>
<p>The value is 0, because the if block also has let. If it had nothing (amount=1), then the expression would have been 1.</p>
<p>When it comes to const, things are easier; it’s just an immutable, and it’s also block-scoped like let. Just to demonstrate, here are a bunch of constants and they all are okay because they belong to different blocks:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateTotalAmount</span> (<span class="params">vip</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> amount = <span class="number">0</span>  </div><div class="line">  <span class="keyword">if</span> (vip) &#123;</div><div class="line">    <span class="keyword">const</span> amount = <span class="number">1</span> </div><div class="line">  &#125; </div><div class="line">  &#123; <span class="comment">// more crazy blocks!</span></div><div class="line">    <span class="keyword">const</span> amount = <span class="number">100</span> </div><div class="line">    &#123;</div><div class="line">      <span class="keyword">const</span> amount = <span class="number">1000</span></div><div class="line">      &#125;</div><div class="line">  &#125;  </div><div class="line">  <span class="keyword">return</span> amount</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(calculateTotalAmount(<span class="literal">true</span>))</div></pre></td></tr></table></figure></p>
<p>In my humble opinion, let and const overcomplicate the language. Without them we had only one behavior, now there are multiple scenarios to consider. ;-(</p>
<h1 id="Classes-in-ES6"><a href="#Classes-in-ES6" class="headerlink" title="Classes in ES6"></a>Classes in ES6</h1><p>If you love object-oriented programming (OOP), then you’ll love this feature. It makes writing classes and inheriting from them as easy as liking a comment on Facebook.</p>
<p>Classes creation and usage in ES5 was a pain in the rear, because there wasn’t a keyword class (it was reserved but did nothing). In addition to that, lots of inheritance patterns like pseudo classical, classical, functional just added to the confusion, pouring gasoline on the fire of religious JavaScript wars.</p>
<p>I won’t show you how to write a class (yes, yes, there are classes, objects inherit from objects) in ES5, because there are many flavors. Let’s take a look at the ES6 example right away. I can tell you that the ES6 class will use prototypes, not the function factory approach. We have a class baseModel in which we can define a constructor and a getName() method:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">baseModel</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;, data = []) &#123; <span class="comment">// class constructor</span></div><div class="line">        <span class="keyword">this</span>.name = <span class="string">'Base'</span></div><div class="line">    <span class="keyword">this</span>.url = <span class="string">'http://azat.co/api'</span></div><div class="line">        <span class="keyword">this</span>.data = data</div><div class="line">    <span class="keyword">this</span>.options = options</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getName() &#123; <span class="comment">// class method</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`Class name: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Notice that I’m using default parameter values for options and data. Also, method names don’t need to have the word function or the colon (:) anymore. The other big difference is that you can’t assign properties this.NAME the same way as methods, i.e., you can’t say name at the same indentation level as a method. To set the value of a property, simply assign a value in the constructor.</p>
<p>The AccountModel inherits from baseModel with class NAME extends PARENT_NAME:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountModel</span> <span class="keyword">extends</span> <span class="title">baseModel</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(options, data) &#123;</div><div class="line">To call the parent <span class="keyword">constructor</span>, effortlessly invoke super() with params:</div><div class="line"></div><div class="line">    super(&#123;private: <span class="literal">true</span>&#125;, [<span class="string">'32113123123'</span>, <span class="string">'524214691'</span>]) <span class="comment">//call the parent method with super</span></div><div class="line">        <span class="keyword">this</span>.name = <span class="string">'Account Model'</span></div><div class="line">    <span class="keyword">this</span>.url +=<span class="string">'/accounts/'</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>If you want to be really fancy, you can set up a getter like this and accountsData will be a property:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    get accountsData() &#123; <span class="comment">//calculated attribute getter</span></div><div class="line">    <span class="comment">// ... make XHR</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>So how do you actually use this abracadabra? It’s as easy as tricking a three-year old into thinking Santa Claus is real:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> accounts = <span class="keyword">new</span> AccountModel(<span class="number">5</span>)</div><div class="line">accounts.getName()</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Data is %s'</span>, accounts.accountsData)</div></pre></td></tr></table></figure></p>
<p>In case you’re wondering, the output is:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class name: Account Model</div><div class="line">Data is %s <span class="number">32113123123</span>,<span class="number">524214691</span></div></pre></td></tr></table></figure></p>
<h1 id="Modules-in-ES6"><a href="#Modules-in-ES6" class="headerlink" title="Modules in ES6"></a>Modules in ES6</h1><p>As you might now, there were no native modules support in JavaScript before ES6. People came up with AMD, RequireJS, CommonJS and other workarounds. Now there are modules with import and export operands.</p>
<p>In ES5 you would use <code>&lt;script&gt;</code> tags with IIFE, or some library like AMD, while in ES6 you can expose your class with export. I am a Node.js guy, so I’ll use CommonJS which is also a Node.js syntax. It’s straightforward to use CommonJS on the browser with the Browserify bunder. Let’s say we have port variable and getAccounts method in ES5 module.js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">port</span>: <span class="number">3000</span>,</div><div class="line">  <span class="attr">getAccounts</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>In ES5 main.js, we would require(‘module’) that dependency:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> service = <span class="built_in">require</span>(<span class="string">'module.js'</span>)</div><div class="line"><span class="built_in">console</span>.log(service.port) <span class="comment">// 3000</span></div></pre></td></tr></table></figure></p>
<p>In ES6, we would use export and import. For example, this is our library in the ES6 module.js file:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">var</span> port = <span class="number">3000</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getAccounts</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>In the importer ES6 file main.js, we use import {name} from ‘my-module’ syntax. For example,<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;port, getAccounts&#125; <span class="keyword">from</span> <span class="string">'module'</span></div><div class="line"><span class="built_in">console</span>.log(port) <span class="comment">// 3000</span></div><div class="line">Or we can <span class="keyword">import</span> everything <span class="keyword">as</span> a variable service <span class="keyword">in</span> main.js:</div><div class="line"></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> service <span class="keyword">from</span> <span class="string">'module'</span></div><div class="line"><span class="built_in">console</span>.log(service.port) <span class="comment">// 3000</span></div></pre></td></tr></table></figure></p>
<p>Personally, I find the ES6 modules confusing. Yes, they are more eloquent, but Node.js modules won’t change anytime soon. It’s better to have only one style for browser and server JavaScript, so I’ll stick with CommonJS/Node.js style for now.</p>
<p>The support for ES6 modules in the browsers are not coming anytime soon (as of this writing), so you’ll need something like jspm to use ES6 modules.</p>
<p>For more information and examples on ES6 modules, take a look at this text. No matter what, write modular JavaScript!</p>
<p>How to Use ES6 Today (Babel)</p>
<p>ES6 is finalized, but not fully supported by all browsers (e.g., ES6 Firefox support). To use ES6 today, get a compiler like Babel. You can run it as a standalone tool or use with your build system. There are Babel plugins for Grunt, Gulp and Webpack.</p>
<p>How to Use ES6 Today (Babel)<br>How to Use ES6 Today (Babel)</p>
<p>Here’s a Gulp example. Install the plugin:</p>
<p>$ npm install –save-dev gulp-babel<br>In gulpfile.js, define a task build that takes src/app.js and compiles it into the build folder:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</div><div class="line">  babel = <span class="built_in">require</span>(<span class="string">'gulp-babel'</span>)</div><div class="line"></div><div class="line">gulp.task(<span class="string">'build'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'src/app.js'</span>)</div><div class="line">    .pipe(babel())</div><div class="line">    .pipe(gulp.dest(<span class="string">'build'</span>))</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>Node.js and ES6</p>
<p>For Node.js, you can compile your Node.js files with a build tool or use a standalone Babel module babel-core. To install it,</p>
<p>$ npm install –save-dev babel-core<br>Then in Node.js, you call this function:</p>
<p>require(“babel-core”).transform(es5Code, options)<br>Summary of ES6 Things</p>
<p>There are many other noteworthy ES6 features which you probably won’t use (at least not right away). In no particular order:</p>
<p>New Math, Number, String, Array and Object methods<br>Binary and octal number types<br>Default rest spread<br>For of comprehensions (hello again mighty CoffeeScript!)<br>Symbols<br>Tail calls<br>Generators<br>New data structures like Map and Set<br>For overachievers who can’t stop learning about ES6, like some people who can’t stop after the first potato chip (just one more!), here’s the list for further reading:<br><a href="https://webapplog.com/es6/" target="_blank" rel="external">Top 10 ES6 Features Every Busy JavaScript Developer Must Know</a></p>
]]></content>
      
        
        <tags>
            
            <tag> css </tag>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gulp实现项目模板化]]></title>
      <url>/2016/08/13/gulp%E5%AE%9E%E8%A1%8C%E9%A1%B9%E7%9B%AE%E6%A8%A1%E6%9D%BF%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>使用gulp实现项目模板化<br>gulpnodejs插件自动化WebFrontEnd<br>当一个大项目逐渐成型，或者一个框架又或者一个开发方式逐渐成型的时候，总会有一个所谓的“套路”，我们在工作中往往遵循着这个套路走。所以更换一家公司或者一个部门团队的时候，上手项目并不难，你只需要掌握这个团队管用的“套路”就ok了，关键是：要想办法优化这个“套路”。<br><a id="more"></a><br>之前一直在做内部框架的跨平台和自动化构建的事，加上开发业务逻辑的页面已经完成，就没去优化这个开发套路，什么套路呢？当项目中需要一个新的H5页面的时候，就需要手动去copy之前的一个页面代码，然后逐个修改，改成另外一个页面。去掉代码中的业务逻辑，会发现除了名称不同，其余的代码全部相同，秉承着“上级命令一定要完成”总宗旨，非也，是秉承着“我是一个程序员”的宗旨，就应该将一切需要手工完成的工作变成自动化的。所以……所以就不吹NB了，好好写……<br>一个古老的思路是，你应该有一套模板，当有新的页面需要开发的时候，只需一条命令或者一个按钮就可以自动帮你基于这套模板创建一个可直接用于开发的环境。为了达成这个目的，我是用到了：<br>1.gulp<br>gulp的教程这里就不写了。<br>2.该功能主要使用到的gulp插件<br>gulp-load-plugins 加载gulp插件的插件<br>gulp-file-include 文件包含插件<br>gulp-data 提供数据，该数据可被其他gulp插件使用<br>gulp-rename 重命名文件<br>gulp-template 渲染模板<br>上面的插件连接，点击进去就是文档。<br>笔者认为最好的学习方式就是有一个能运行起来的项目，然后看着代码一步步走，所以我把模板化从公司的项目中抽离出来，并做了删减，提炼出一个完整的可运行的项目，并放在我的git仓库，可以运行一下命令查看效果，调试并学习：</p>
<p>下面是gulpfile.js文件和package.json文件<br>gulpfile.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</div><div class="line"><span class="keyword">var</span> gulpLoadPlugins = <span class="built_in">require</span>(<span class="string">"gulp-load-plugins"</span>);</div><div class="line"><span class="keyword">var</span> plugins = gulpLoadPlugins();</div><div class="line"><span class="keyword">var</span> util     = <span class="built_in">require</span>(<span class="string">"gulp-util"</span>);</div><div class="line"><span class="keyword">var</span> devPath = <span class="string">'./html'</span>;</div><div class="line"><span class="keyword">var</span> appData = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * @desc 组装模板</div><div class="line"> * @src  devPath </div><div class="line"> * @deps </div><div class="line"> * @dest devPath + '/tmod/app/dest'</div><div class="line"> */</div><div class="line">gulp.task(<span class="string">'includeTpl'</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 获取 gulp 命令的 --name参数的值 （gulp createapp --name=aaa）</span></div><div class="line">    <span class="keyword">var</span> appName = util.env.name || <span class="string">'special'</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 首字母大写</span></div><div class="line">    <span class="keyword">var</span> appNameBig = appName.replace((<span class="regexp">/\w/</span>), <span class="function"><span class="keyword">function</span>(<span class="params">char</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> char.toUpperCase();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    appData=&#123;</div><div class="line">        <span class="attr">app</span>: appName,</div><div class="line">        <span class="attr">appapi</span>: appNameBig,</div><div class="line">        <span class="attr">appDo</span>: appName + <span class="string">"Do"</span>,</div><div class="line">        <span class="attr">title</span>: appName</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> gulp.src([</div><div class="line">            devPath + <span class="string">'/tmod/app/app.tpl'</span>,</div><div class="line">            devPath + <span class="string">'/tmod/app/appDo.tpl'</span>,</div><div class="line">            devPath + <span class="string">'/tmod/app/app.html'</span>,</div><div class="line">            devPath + <span class="string">'/tmod/app/appApi.tpl'</span>,</div><div class="line">            devPath + <span class="string">'/tmod/app/appapiInterFace.tpl'</span></div><div class="line">        ])</div><div class="line">        .pipe(plugins.fileInclude(&#123;</div><div class="line">            <span class="attr">prefix</span>: <span class="string">'@@'</span>,</div><div class="line">            <span class="attr">basepath</span>: <span class="string">'@file'</span></div><div class="line">        &#125;))</div><div class="line">        .pipe(gulp.dest(devPath + <span class="string">'/tmod/app/dest'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * @desc 解析模板</div><div class="line"> * @src  devPath </div><div class="line"> * @deps includeTpl</div><div class="line"> * @dest devPath + '/tmod/app/dest'</div><div class="line"> */</div><div class="line">gulp.task(<span class="string">'resolveTpl'</span>,[<span class="string">"includeTpl"</span>],<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> gulp.src([</div><div class="line">            devPath + <span class="string">'/tmod/app/dest/app.tpl'</span>,</div><div class="line">            devPath + <span class="string">'/tmod/app/dest/appDo.tpl'</span>,</div><div class="line">            devPath + <span class="string">'/tmod/app/dest/app.html'</span>,</div><div class="line">            devPath + <span class="string">'/tmod/app/dest/appApi.tpl'</span>,</div><div class="line">            devPath + <span class="string">'/tmod/app/dest/appapiInterFace.tpl'</span></div><div class="line">        ])</div><div class="line">        .pipe(plugins.data(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> &#123;<span class="attr">app</span>: appData.app, <span class="attr">appDo</span>:appData.appDo,<span class="attr">title</span>:appData.title, <span class="attr">appapi</span> : appData.appapi&#125;;</div><div class="line">        &#125;))</div><div class="line">        .pipe(plugins.template())</div><div class="line">        .pipe(gulp.dest(devPath + <span class="string">'/tmod/app/dest'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * @desc 创建部署</div><div class="line"> * @src  devPath + '/tmod/app/dest </div><div class="line"> * @deps resolveTpl</div><div class="line"> * @dest devPath + '/modules/'</div><div class="line"> */</div><div class="line">gulp.task(<span class="string">'createapp'</span>, [<span class="string">"resolveTpl"</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 创建部署入口js文件，如 index.js</span></div><div class="line">    gulp.src(devPath + <span class="string">'/tmod/app/dest/app.tpl'</span>)</div><div class="line">        .pipe(plugins.rename(&#123;</div><div class="line">            <span class="attr">basename</span>: appData.app,</div><div class="line">            <span class="attr">extname</span>: <span class="string">".js"</span></div><div class="line">        &#125;))</div><div class="line">        .pipe(gulp.dest(devPath + <span class="string">'/target/'</span>+appData.app));</div><div class="line"></div><div class="line">    <span class="comment">// 创建部署业务逻辑js文件，如 indexDo.js</span></div><div class="line">    gulp.src(devPath + <span class="string">'/tmod/app/dest/appDo.tpl'</span>)</div><div class="line">        .pipe(plugins.rename(&#123;</div><div class="line">            <span class="attr">basename</span>: appData.appDo,</div><div class="line">            <span class="attr">extname</span>: <span class="string">".js"</span></div><div class="line">        &#125;))</div><div class="line">        .pipe(gulp.dest(devPath + <span class="string">'/target/'</span>+appData.app));</div><div class="line"></div><div class="line">    <span class="comment">// 创建部署html页面文件，如 index.html</span></div><div class="line">    gulp.src([devPath + <span class="string">'/tmod/app/dest/*.html'</span>])</div><div class="line">        .pipe(plugins.rename(&#123;</div><div class="line">            <span class="attr">basename</span>: appData.app,</div><div class="line">            <span class="attr">extname</span>: <span class="string">".html"</span></div><div class="line">        &#125;))</div><div class="line">        .pipe(gulp.dest(devPath + <span class="string">'/target/'</span>+appData.app));</div><div class="line"></div><div class="line">    <span class="comment">// 创建部署api接口js文件，如 indexApi.js</span></div><div class="line">    gulp.src(devPath + <span class="string">'/tmod/app/dest/appApi.tpl'</span>)</div><div class="line">        .pipe(plugins.rename(&#123;</div><div class="line">            <span class="attr">basename</span>: appData.app + <span class="string">'Api'</span>,</div><div class="line">            <span class="attr">extname</span>: <span class="string">".js"</span></div><div class="line">        &#125;))</div><div class="line">        .pipe(gulp.dest(devPath + <span class="string">'/target/clientApi'</span>));</div><div class="line"></div><div class="line">    <span class="comment">// 创建部署跨平台接口js文件，如 indexapiInterFace.js</span></div><div class="line">    gulp.src(devPath + <span class="string">'/tmod/app/dest/appapiInterFace.tpl'</span>)</div><div class="line">        .pipe(plugins.rename(&#123;</div><div class="line">            <span class="attr">basename</span>: appData.app + <span class="string">'apiInterFace'</span>,</div><div class="line">            <span class="attr">extname</span>: <span class="string">".js"</span></div><div class="line">        &#125;))</div><div class="line">        .pipe(gulp.dest(devPath + <span class="string">'/target/clientApi'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>package.json<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"app"</span>,</div><div class="line">  <span class="string">"project"</span>: <span class="string">"app"</span>,</div><div class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line">  <span class="string">"host"</span>: <span class="string">"http://10.0.69.79"</span>,</div><div class="line">  <span class="string">"path"</span>: <span class="string">"/home/huangjian/workstation/bridge/newssdk/bin"</span>,</div><div class="line">  <span class="string">"devDependencies"</span>: &#123;</div><div class="line">    <span class="string">"gulp"</span>: <span class="string">"^3.9.0"</span>,</div><div class="line">    <span class="string">"gulp-data"</span>: <span class="string">"^1.2.0"</span>,</div><div class="line">    <span class="string">"gulp-file-include"</span>: <span class="string">"^0.13.7"</span>,</div><div class="line">    <span class="string">"gulp-load-plugins"</span>: <span class="string">"^0.10.0"</span>,</div><div class="line">    <span class="string">"gulp-rename"</span>: <span class="string">"^1.2.0"</span>,</div><div class="line">    <span class="string">"gulp-template"</span>: <span class="string">"^2.1.0"</span>,</div><div class="line">    <span class="string">"gulp-util"</span>: <span class="string">"^3.0.6"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大家重在研究代码的思路和各个组件的用法及配合，不要去研究代码的细节，比如这个构建出来的项目有什么用啊？当然对于你来说没什么用，因为这个是应用在公司项目中的，这个是为了给大家方便，抽离出来的，所以大家把握好重点。</p>
]]></content>
      
        
        <tags>
            
            <tag> gulp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery 源码简单分析]]></title>
      <url>/2016/08/05/jQuery-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>jQuery时下非常流行，简单好用，工作必用。想更深入学习，可以通过研究其源代码。   </p>
<h1 id="jQuery是一个闭包（即时函数）"><a href="#jQuery是一个闭包（即时函数）" class="headerlink" title="jQuery是一个闭包（即时函数）"></a>jQuery是一个闭包（即时函数）</h1><pre><code>(function( window, undefined ) {})
</code></pre><p>让我们来看一看jQuery源代码的基本信息<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/*!</span></div><div class="line">* jQuery JavaScript Library v2.0.0 版本信息</div><div class="line">* http://jquery.com/ 官方网站</div><div class="line">*</div><div class="line">* Includes Sizzle.js 复杂选择器文件名称</div><div class="line">* http://sizzlejs.com/  复杂选择器文件网站</div><div class="line">*</div><div class="line">* Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors  版权信息</div><div class="line">* Released under the MIT license 开源协议</div><div class="line">* http://jquery.org/license</div><div class="line">*</div><div class="line">* Date: 2013-04-18 更新时间</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>这说明jQuery有多个版本,现在我们分析的是2.0.0版本，在之前的版本版本需要兼容IE678,里面有大量的兼容性处理。从2.0.0版本入手开始研究,从上往下解读注释</p>
<pre><code>包括:
    01 官方网站
    02 复杂选择器
    03 版权信息和开源协议
    04 #1335和bug管理系统
</code></pre><h2 id="jQ本质就是一个闭包"><a href="#jQ本质就是一个闭包" class="headerlink" title="jQ本质就是一个闭包"></a>jQ本质就是一个闭包</h2><p>   使用闭包的好处：</p>
<pre><code>① 为了避免和其他框架产生冲突(代码说明) 
② 多个框架中如果出现了同名的变量或者是函数那么会存在覆盖或者是冲突,而使用闭包结构可以处理这个问题
③ 其它
</code></pre><p>   传递window参数的好处：  </p>
<pre><code>① 参数的区分:形式参数和实际参数
② 函数作用域说明:函数内部的数据外界无法访问(引申闭包相关知识点)
③ 把内部的数据传递给外部使用
④ 用于压缩代码(不是很理解)
</code></pre><p>   传递window参数的好处：</p>
<pre><code>① 方便代码的压缩
② 使用undefined作为形参传入,为了防止代码的修改(在IE以前的版本中undefined可以被修改)
</code></pre><h1 id="jQuery被写成了一个工厂函数"><a href="#jQuery被写成了一个工厂函数" class="headerlink" title="jQuery被写成了一个工厂函数"></a>jQuery被写成了一个工厂函数</h1><p>根据我们已经清楚的部分来开始初步的搭建框架结构,主要包括以下部分</p>
<pre><code>    001 该框架的最外层是一个立即调用函数(闭包),需要接受两个参数window和undefined
    002 提供一个jQuery工厂函数
    003 设置jQuery函数对象的原型对象(直接替换),并修正构造器属性,添加init方法
    004 在jQuery工厂函数内部返回使用init方法创建的对象
    005 设置原型对象赋值并讲解fn就是原型对象
03 讲解外界应该如何使用jQuery函数
    001 依据我们使用jQuery框架的经验,在HTML文件中通过jQuery或者是$来访问
    002 分析外部如何访问闭包内部的数据(在闭包中提供接口返回|把闭包中需要让外界访问的对象通过全局变量传递)
    003 书写代码 window.$ = window.jQuery = jQuery;
    004 注意说明:外界在调用的时候是通过jQuery()这种方式调用的,那么获取的就是一个jQuery.prototype.init类型的实例化对象
04 验证并说明调用jQuery得到的是jQuery.fn.init类型的实例化对象
</code></pre><p>代码示例：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">包含功能:</div><div class="line">    (1) 整体结构(立即调用函数)</div><div class="line">    (2) jQuery工厂函数定义</div><div class="line">    (3) fn函数</div><div class="line">    (4) window.$ 和window.jQuery</div><div class="line">*/</div><div class="line">(function (window) &#123;</div><div class="line">    //01 jQuery工厂函数</div><div class="line">    var jQuery = function () &#123;</div><div class="line">        //02 返回一个jQuery.prototype.init类型的实例化对象</div><div class="line">        return new jQuery.fn.init();</div><div class="line">    &#125;;</div><div class="line">    //03 替换jQuery工厂函数的原型对象</div><div class="line">    jQuery.prototype = &#123;</div><div class="line">        //修正构造器属性</div><div class="line">        constructor:jQuery,</div><div class="line">        init:function () &#123;</div><div class="line">            //...init方法内部实现细节</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //04 把jQuery工厂函数的原型对象赋值给jQuery.prototype.init的原型对象</div><div class="line">    jQuery.prototype.init.prototype = jQuery.prototype;</div><div class="line">    //05 为jQuery工厂函数添加fn属性,该方法指向jQuery的原型对象</div><div class="line">    jQuery.fn = jQuery.prototype;</div><div class="line">    //06 设置让外界能够拿到并使用jQuery工厂函数</div><div class="line">    window.$ = window.jQuery = jQuery;</div><div class="line">&#125;)(window);</div></pre></td></tr></table></figure></p>
<p>上面分析的很简单，如果想要深入了解可以到GitHub网站等，希望对您有帮助</p>
]]></content>
      
        
        <tags>
            
            <tag> jQuery </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[移动端开发技巧若干]]></title>
      <url>/2016/07/22/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%E8%8B%A5%E5%B9%B2/</url>
      <content type="html"><![CDATA[<p>一些工作中的技巧。</p>
<h1 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h1><p>在做移动端时，要考虑各种各样的问题，这种情况下，如何优雅的设置meta标签，显得尤为重要。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</div><div class="line">&lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt;</div><div class="line">&lt;meta name="viewport" content="width=640,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" /&gt;</div><div class="line">&lt;meta content="telephone=no" name="format-detection"&gt;</div><div class="line">&lt;meta content="email=no" name="format-detection"&gt;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>1、<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>，设置编码格式为<code>utf-8</code>。</p>
<p>2、 设置视口模式，设备宽带等于视口宽带，初始缩放、最大缩放、最小缩放均为1.0,同时禁止用户缩放。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>3、微信浏览器页面时，只需将宽度设置为640px。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=640,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>4、对格式进行保护，禁止将数字识别为电话号码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=<span class="string">"format-detection"</span> content=<span class="string">"telephone=no"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p>5、同上，禁止Android平台中对邮箱地址的识别。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=<span class="string">"format-detection"</span> content=<span class="string">"email=no"</span> /&gt;</div></pre></td></tr></table></figure></p>
<h1 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h1><h2 id="CSS-reset"><a href="#CSS-reset" class="headerlink" title="CSS reset"></a>CSS reset</h2><p>因为一些元素在不同对浏览器有不同对效果，所以我们需要重新设置。谨记”优雅降级、渐进增强”原则。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">charset</span> <span class="string">"utf-8"</span>;</div><div class="line"><span class="selector-tag">html</span>&#123;</div><div class="line">	<span class="attribute">-webkit-text-size-adjust</span>:none;</div><div class="line">	<span class="attribute">-webkit-user-select</span>:none;</div><div class="line">	<span class="attribute">-webkit-touch-callout</span>: none;</div><div class="line">	<span class="attribute">font-family</span>: Arial;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">font-size</span>:<span class="number">16px</span>;&#125;</div><div class="line"><span class="selector-tag">body</span>,<span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>,<span class="selector-tag">p</span>,<span class="selector-tag">dl</span>,<span class="selector-tag">dd</span>,<span class="selector-tag">ul</span>,<span class="selector-tag">ol</span>,<span class="selector-tag">pre</span>,<span class="selector-tag">form</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">th</span>,<span class="selector-tag">td</span>,<span class="selector-tag">select</span>&#123;<span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>:<span class="number">0</span>; <span class="attribute">font-weight</span>: normal;<span class="attribute">text-indent</span>: <span class="number">0</span>;&#125;</div><div class="line"><span class="selector-tag">a</span>,<span class="selector-tag">button</span>,<span class="selector-tag">input</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">select</span>&#123; <span class="attribute">background</span>: none; <span class="attribute">-webkit-tap-highlight-color</span>:<span class="built_in">rgba</span>(255,0,0,0); <span class="attribute">outline</span>:none; <span class="attribute">-webkit-appearance</span>:none;&#125;</div><div class="line"><span class="selector-tag">em</span>&#123;<span class="attribute">font-style</span>:normal&#125;</div><div class="line"><span class="selector-tag">li</span>&#123;<span class="attribute">list-style</span>:none&#125;</div><div class="line"><span class="selector-tag">a</span>&#123;<span class="attribute">text-decoration</span>:none;&#125;</div><div class="line"><span class="selector-tag">img</span>&#123;<span class="attribute">border</span>:none; <span class="attribute">vertical-align</span>:top;&#125;</div><div class="line"><span class="selector-tag">table</span>&#123;<span class="attribute">border-collapse</span>:collapse;&#125;</div><div class="line"><span class="selector-tag">textarea</span>&#123; <span class="attribute">resize</span>:none; <span class="attribute">overflow</span>:auto;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="公用-CSS-style"><a href="#公用-CSS-style" class="headerlink" title="公用 CSS style"></a>公用 CSS style</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 清除浮动 */</span></div><div class="line"><span class="selector-class">.clear</span> &#123; <span class="attribute">zoom</span>:<span class="number">1</span>; &#125;</div><div class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">:after</span> &#123; <span class="attribute">content</span>:<span class="string">''</span>; <span class="attribute">display</span>:block; <span class="attribute">clear</span>:both; &#125;</div><div class="line"></div><div class="line"><span class="comment">/* 定义盒模型（宽高不受边框影响） */</span></div><div class="line"><span class="selector-class">.boxSz</span>&#123;</div><div class="line">	<span class="attribute">-webkit-box-sizing</span>: border-box;</div><div class="line">	<span class="attribute">-moz-box-sizing</span>: border-box;</div><div class="line">	<span class="attribute">-ms-box-sizing</span>: border-box;</div><div class="line">	<span class="attribute">-o-box-sizing</span>: border-box;</div><div class="line">	<span class="attribute">box-sizing</span>: border-box;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 换行 */</span></div><div class="line"><span class="selector-class">.forWrap</span>&#123;</div><div class="line">	<span class="attribute">word-break</span>: break-all;       <span class="comment">/* 仅对英文起作用，以字母作为换行依据。 */</span></div><div class="line">	<span class="attribute">word-wrap</span>: break-word;   	<span class="comment">/* 仅对英文起作用，以单词作为换行依据。*/</span></div><div class="line">	<span class="attribute">white-space</span>: pre-wrap;     <span class="comment">/* 仅对中文起作用，强制换行。*/</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 禁止换行 */</span></div><div class="line"><span class="selector-class">.unWrap</span>&#123;</div><div class="line">	<span class="attribute">white-space</span>:nowrap;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 禁止换行,超出省略号 */</span></div><div class="line"><span class="selector-class">.noWrapEllipsis</span>&#123;</div><div class="line">	 <span class="attribute">white-space</span>:nowrap; <span class="attribute">overflow</span>:hidden; <span class="attribute">text-overflow</span>:ellipsis;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 多行显示省略号，less写法，@line是行数 */</span></div><div class="line"><span class="selector-class">.ellipsisLn</span>(@<span class="keyword">line</span>) &#123;</div><div class="line">    <span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</div><div class="line">    <span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</div><div class="line">    <span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</div><div class="line">    <span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;</div><div class="line">    <span class="selector-tag">-webkit-line-clamp</span>: @<span class="keyword">line</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 1px 边框解决方案，示例中设置上边框，可以调整 top、right、bottom、left 的值分别设置上下左右边框 */</span></div><div class="line"><span class="selector-id">#box2</span><span class="selector-pseudo">:after</span>&#123;</div><div class="line">	<span class="attribute">content</span>: <span class="string">" "</span>;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;</div><div class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</div><div class="line">    <span class="attribute">color</span>: <span class="number">#C7C7C7</span>;</div><div class="line">    <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(0.5);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 文字两端对齐 */</span></div><div class="line"><span class="selector-class">.text-justify</span>&#123;</div><div class="line">	<span class="attribute">text-align</span>:justify; </div><div class="line">	<span class="attribute">text-justify</span>:inter-ideograph;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* flex布局兼容写法并让内容水平垂直居中 */</span></div><div class="line"><span class="selector-class">.flex-center</span>&#123;</div><div class="line">	<span class="attribute">display</span>: -webkit-box;</div><div class="line">	<span class="attribute">display</span>: -moz-box;</div><div class="line">	<span class="attribute">display</span>: -ms-flexbox;</div><div class="line">	<span class="attribute">display</span>: -o-box;</div><div class="line">	<span class="attribute">display</span>: box;</div><div class="line"></div><div class="line">	<span class="attribute">-webkit-box-pack</span>: center;</div><div class="line">    <span class="attribute">-moz-box-pack</span>: center;</div><div class="line">    <span class="attribute">-ms-flex-pack</span>: center;</div><div class="line">    <span class="attribute">-o-box-pack</span>: center;</div><div class="line">    <span class="attribute">box-pack</span>: center;</div><div class="line"></div><div class="line">    <span class="attribute">-webkit-box-align</span>: center;</div><div class="line">    <span class="attribute">-moz-box-align</span>: center;</div><div class="line">    <span class="attribute">-ms-flex-align</span>: center;</div><div class="line">    <span class="attribute">-o-box-align</span>: center;</div><div class="line">    <span class="attribute">box-align</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Css小技巧"><a href="#Css小技巧" class="headerlink" title="Css小技巧"></a>Css小技巧</h2><p>1、去除android <code>a button input</code>被点击时边框的颜色<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span>,<span class="selector-tag">button</span>,<span class="selector-tag">input</span>&#123;<span class="attribute">-webkit-tap-highlight-color</span>:<span class="built_in">rgba</span>(255,0,0,0);&#125;</div></pre></td></tr></table></figure></p>
<p>2、ios使用<code>-webkit-text-size-adjust</code>禁止调整字体大小<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">-webkit-text-size-adjust</span>: <span class="number">100%</span><span class="meta">!important</span>;&#125;</div></pre></td></tr></table></figure></p>
<p>3、android 上去掉语音输入按钮<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">input</span><span class="selector-pseudo">::-webkit-input-speech-button</span> &#123;<span class="attribute">display</span>: none&#125;</div></pre></td></tr></table></figure></p>
<p>4、移动端无微软雅黑字体<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">font-family</span>:Helvetica;&#125;</div></pre></td></tr></table></figure></p>
<p>5、禁用Webkit内核浏览器的文字大小调整功能。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-webkit-text-size-adjust</span>: <span class="selector-tag">none</span>;</div></pre></td></tr></table></figure></p>
<p>6、禁止ios和android用户选中文字<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.css</span>&#123;<span class="attribute">-webkit-user-select</span>:none&#125;</div></pre></td></tr></table></figure></p>
<p>7、webkit去除表单元素的默认样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.css</span>&#123;<span class="attribute">-webkit-appearance</span>:none;&#125;</div></pre></td></tr></table></figure></p>
<p>8、修改webkit表单输入框placeholder的样式<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">input</span><span class="selector-pseudo">::-webkit-input-placeholder</span>&#123;<span class="attribute">color</span>:<span class="number">#AAAAAA</span>;&#125;</div><div class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span><span class="selector-pseudo">::-webkit-input-placeholder</span>&#123;<span class="attribute">color</span>:<span class="number">#EEEEEE</span>;&#125;</div></pre></td></tr></table></figure></p>
<h1 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h1><p>1、打电话和发短信<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;a href="tel:0755-10086"&gt;打电话给:0755-10086&lt;/a&gt;</div><div class="line">&lt;a href="sms:10086"&gt;发短信给: 10086&lt;/a&gt;</div></pre></td></tr></table></figure></p>
<p>2、传图片视频<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;input type=file accept="image/*"&gt;</div><div class="line">&lt;input type=file accept="video/*"&gt;</div></pre></td></tr></table></figure></p>
<p>3、在ios下，取消输入时首字母大写<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input autocapitalize="off" autocorrect="off" /&gt;</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> 开发技巧 </tag>
            
            <tag> 移动端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JSONP跨域]]></title>
      <url>/2016/07/08/JSONP%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<p>Asynchronous JavaScript and XML (Ajax) 是Web2.0的关键技术。AJAX与服务器交换数据刷新局部网页,不需重载。</p>
<p>因为浏览器及同源策略的限制，ajax不允许跨域通信。同源是指协议、域名和端口都一致的情况。同源策略保证一个源的动态脚本不能读取或操作其他源的http响应和cookie，使浏览器隔离不同源的内容之间互相操作。<br><a id="more"></a></p>
<h3 id="Access-Control-Allow-Origin"><a href="#Access-Control-Allow-Origin" class="headerlink" title="Access-Control-Allow-Origin"></a>Access-Control-Allow-Origin</h3><p>解决跨域问题可以在第三方网站开启HTTP的Access-Control-Allow-Origin参数，当目标页面的response包含Access-Control-Allow-Origin 这个header，而且还包含我们的域名时，浏览器就允许拿到它页面的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: http://www.1oveit.club</div></pre></td></tr></table></figure></p>
<p>当值为 * 表示匹配所有，都能用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin: *</div></pre></td></tr></table></figure></p>
<p>但是此时的主动权不在我们手里。</p>
<h3 id="JSONP解决跨域"><a href="#JSONP解决跨域" class="headerlink" title="JSONP解决跨域"></a>JSONP解决跨域</h3><p>还可以使用更为主动的方法，使用JSONP解决跨域问题。分为以下几步：<br>我们知道多个不同的script标签中的数据是可以相互访问的，而script的src的本质就是将导入文件中的内容拷贝到当前script标签中，我们拿到百度搜索URL地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=ab&amp;cb=jQuery11020672211218553074_1491468814655</div></pre></td></tr></table></figure></p>
<p>搜索之后的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jQuery11020672211218553074_1491468814655(&#123;q:&quot;ab&quot;,p:false,s:[&quot;abs&quot;,&quot;ab胶&quot;,&quot;abc&quot;,&quot;abac形式的成语&quot;,&quot;abcc形式的成语&quot;,&quot;abab式的词语&quot;,&quot;abo&quot;,&quot;abp&quot;,&quot;abstract&quot;,&quot;abs塑料&quot;]&#125;);</div></pre></td></tr></table></figure></p>
<p>从而可以引出跨域(jsonP)原理：<br>1.src可以拿到非当前域的数据。<br>2.script的src的本质就是将导入文件中的内容拷贝到当前script标签中。<br>3.如果src返回的数据符合 函数名称(参数); 格式, 那么就可以实现跨域。<br><strong>具体例子</strong>：<br>在本地的文件的script准备回调函数say,<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(obj);     </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过script的src属性拿到百度要搜索的URL并且拼接<code>?wd=ab&amp;cb=say</code>参数，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=ab&amp;cb=say&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>最后，调用say方法，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">say(&#123;q:&quot;ab&quot;,p:false,s:[&quot;abs&quot;,&quot;ab胶&quot;,&quot;abc&quot;,&quot;abac形式的成语&quot;,&quot;abcc形式的成语&quot;,&quot;abab式的词语&quot;,&quot;abo&quot;,&quot;abp&quot;,&quot;abstract&quot;,&quot;abs塑料&quot;]&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>具体例子</strong>：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">      //1.使用src，请求数据</div><div class="line">         &lt;script src="http://datainfo.duapp.com/shopdata/getGoods.php?callback=callback"&gt;</div><div class="line">     //2.在本地声明一个方法</div><div class="line">         function callback(args)      &#123;  console.log(args); &#125;</div><div class="line">        //3.要在服务端要处理跨域</div><div class="line">            $res = $_GET['callback'];</div><div class="line">            echo $res."('我是服务的数据')";</div><div class="line">    function callback(args) &#123;</div><div class="line">        console.log(args);</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;!--</div><div class="line">    如果服务器返回的是js代码，那么浏览器就会直接执行js代码</div><div class="line">    借助浏览器的特性来实现跨域</div><div class="line">--&gt;</div><div class="line">&lt;script src="http://datainfo.duapp.com/shopdata/getGoods.php?call6‘back=callback"&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>总体的流程大概就是这样子，不过实际开发中要与后台定好接口，希望能够帮到你。</p>
]]></content>
      
        
        <tags>
            
            <tag> JSONP跨域 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nvm-Mac安装使用]]></title>
      <url>/2016/06/02/nav-Mac%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>node更新太快了，版本差异各异，这时候有必要安装node版本管理工具nvm了。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>使用homebrew安装会出现莫名其妙的问题，这里推荐使用curl方式来安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>此时nvm安装在~/.nvm下，紧接着配置环境变量。</p>
<h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><p>推荐大家使用zsh(终端神器)，打开~/.zshrc，在最后一行加上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export NVM_DIR=&quot;$HOME/.nvm&quot;</div><div class="line">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot;</div></pre></td></tr></table></figure></p>
<p>此时nvm都被添加到全局环境变量，紧接着输入source ~/.zshrc重新启动一下配置。<br>输入nvm，会输出以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">➜  ~  nvm</div><div class="line"></div><div class="line">Node Version Manager</div><div class="line"></div><div class="line">Note: &lt;version&gt; refers to any version-like string nvm understands. This includes:</div><div class="line">  - full or partial version numbers, starting with an optional &quot;v&quot; (0.10, v0.1.2, v1)</div><div class="line">  - default (built-in) aliases: node, stable, unstable, iojs, system</div><div class="line">  - custom aliases you define with `nvm alias foo`</div><div class="line"></div><div class="line">Usage:</div><div class="line">  nvm help                                  Show this message</div><div class="line">  nvm --version                             Print out the latest released version of nvm</div><div class="line">  nvm install [-s] &lt;version&gt;                Download and install a &lt;version&gt;, [-s] from source. Uses .nvmrc if available</div><div class="line">    --reinstall-packages-from=&lt;version&gt;     When installing, reinstall packages installed in &lt;node|iojs|node version number&gt;</div><div class="line">  nvm uninstall &lt;version&gt;                   Uninstall a version</div><div class="line">  nvm use [--silent] &lt;version&gt;              Modify PATH to use &lt;version&gt;. Uses .nvmrc if available</div><div class="line">  nvm exec [--silent] &lt;version&gt; [&lt;command&gt;] Run &lt;command&gt; on &lt;version&gt;. Uses .nvmrc if available</div><div class="line">  nvm run [--silent] &lt;version&gt; [&lt;args&gt;]     Run `node` on &lt;version&gt; with &lt;args&gt; as arguments. Uses .nvmrc if available</div><div class="line">  nvm current                               Display currently activated version</div><div class="line">  nvm ls                                    List installed versions</div><div class="line">  nvm ls &lt;version&gt;                          List versions matching a given description</div><div class="line">  nvm ls-remote                             List remote versions available for install</div><div class="line">  nvm version &lt;version&gt;                     Resolve the given description to a single local version</div><div class="line">  nvm version-remote &lt;version&gt;              Resolve the given description to a single remote version</div><div class="line">  nvm deactivate                            Undo effects of `nvm` on current shell</div><div class="line">  nvm alias [&lt;pattern&gt;]                     Show all aliases beginning with &lt;pattern&gt;</div><div class="line">  nvm alias &lt;name&gt; &lt;version&gt;                Set an alias named &lt;name&gt; pointing to &lt;version&gt;</div><div class="line">  nvm unalias &lt;name&gt;                        Deletes the alias named &lt;name&gt;</div><div class="line">  nvm reinstall-packages &lt;version&gt;          Reinstall global `npm` packages contained in &lt;version&gt; to current version</div><div class="line">  nvm unload                                Unload `nvm` from shell</div><div class="line">  nvm which [&lt;version&gt;]                     Display path to installed node version. Uses .nvmrc if available</div><div class="line"></div><div class="line">Example:</div><div class="line">  nvm install v0.10.32                  Install a specific version number</div><div class="line">  nvm use 0.10                          Use the latest available 0.10.x release</div><div class="line">  nvm run 0.10.32 app.js                Run app.js using node v0.10.32</div><div class="line">  nvm exec 0.10.32 node app.js          Run `node app.js` with the PATH pointing to node v0.10.32</div><div class="line">  nvm alias default 0.10.32             Set default node version on a shell</div><div class="line"></div><div class="line">Note:</div><div class="line">  to remove, delete, or uninstall nvm - just remove the `$NVM_DIR` folder (usually `~/.nvm`)</div></pre></td></tr></table></figure></p>
<h1 id="使用nvm"><a href="#使用nvm" class="headerlink" title="使用nvm"></a>使用nvm</h1><p>上面打印的内容已经告诉我们怎么使用了。首先输入<br><code>nvm ls-remote</code><br>查看node远程版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜  ~  nvm ls-remote</div><div class="line">            v0.1.14</div><div class="line">            v0.1.15</div><div class="line">            v0.1.16</div><div class="line">            ...</div></pre></td></tr></table></figure></p>
<p>然后输入<code>nvm install &lt;版本号&gt;</code><br>比如安装4.1.0版本<code>nvm install v4.1.0</code><br>紧接着使用，输入<code>nvm use &lt;版本号&gt;</code><br>比如使用4.1.0版本，输入<code>nvm use v4.1.0</code></p>
<h1 id="默认nvm"><a href="#默认nvm" class="headerlink" title="默认nvm"></a>默认nvm</h1><p>当你新开一个bash，输入nvm current时显示为null。<br>可以设置默认的nvm来解决问题，输入<code>nvm alias default v4.1.0</code>,可以看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  ~  nvm alias default v4.1.0</div><div class="line">default -&gt; v4.1.0</div></pre></td></tr></table></figure></p>
<p>指定v4.1.0作为默认版本</p>
<p>以后新开bash输入nvm current默认显示v4.1.0。</p>
]]></content>
      
        
        <tags>
            
            <tag> nvm </tag>
            
            <tag> node </tag>
            
            <tag> 版本管理工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript简明教程（7）]]></title>
      <url>/2016/05/28/js-07/</url>
      <content type="html"><![CDATA[<p>很高兴你能看到这里，希望对你学习JavaScript有帮助。这是最后一章节，主要讲有关JavaScript的设计模式。</p>
<h1 id="函数属性缓存"><a href="#函数属性缓存" class="headerlink" title="函数属性缓存"></a>函数属性缓存</h1><p>思路说明</p>
<pre><code>01 函数是对象，因此可以在函数上面添加属性和方法
02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果
03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value）
04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。
</code></pre><a id="more"></a>
<p>代码示例(单个参数)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">param</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (func.cache[param] == <span class="literal">undefined</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">var</span> result = <span class="string">"字符串"</span>; <span class="comment">//初始化值</span></div><div class="line">        <span class="comment">//...对result做复杂的计算</span></div><div class="line">        func.cache[param] = result + param;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> func.cache[param];</div><div class="line">&#125;</div><div class="line">func.cache = &#123;&#125;;    <span class="comment">//空对象</span></div><div class="line"><span class="built_in">console</span>.log(func(<span class="string">"demo"</span>));  <span class="comment">//字符串demo</span></div><div class="line"><span class="built_in">console</span>.log(func(<span class="string">"test"</span>));  <span class="comment">//字符串test</span></div><div class="line"><span class="built_in">console</span>.log(func(<span class="string">"demo"</span>));  <span class="comment">//字符串demo 直接使用属性缓存中的数据,而不再进行复杂的计算(可以提升性能)</span></div></pre></td></tr></table></figure></p>
<p>代码示例（多个参数）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> key = <span class="built_in">JSON</span>.stringify(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</div><div class="line">    <span class="keyword">if</span> (func.cache[key] == <span class="literal">undefined</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">var</span> result = <span class="string">"字符串"</span>; <span class="comment">//初始化值</span></div><div class="line">        <span class="comment">//...对result做复杂的计算</span></div><div class="line">        func.cache[key] = result + key;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> func.cache[key];</div><div class="line">&#125;</div><div class="line">func.cache = &#123;&#125;;    <span class="comment">//空对象</span></div><div class="line">func(<span class="string">"123"</span>,<span class="string">"456"</span>);  <span class="comment">//</span></div><div class="line"><span class="comment">//说明:如果传入的参数数量超过1,则可以将传入的参数序列化为一个json字符串作为参数处理。</span></div></pre></td></tr></table></figure></p>
<p>代码说明：<br>slice:<code>返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素</code></p>
<h1 id="命名空间模式"><a href="#命名空间模式" class="headerlink" title="命名空间模式"></a>命名空间模式</h1><p>作用:<br>(1)有助于减少程序中所需要的全局变量的数量<br>(2)并且同时还有助于避免命名冲突或过长的名字前缀。<br> <strong>说明：JavaScript中并没有内置的命名空间</strong></p>
<h2 id="如何实现命名空间"><a href="#如何实现命名空间" class="headerlink" title="如何实现命名空间"></a>如何实现命名空间</h2><pre><code>可以为应用程序创建一个全局对象,然后将所有功能都添加到该全局对象中
从而在具有大量函数,对象和其他变量的情况下并不会污染全局范围。
</code></pre><p><strong>建议</strong></p>
<pre><code>全局命名空间的名称可以随便写,但建议使用项目的名称或者是APP的名称
按照习惯,通过程序员会约定以全部大写的方式来约定全局命名空间。
</code></pre><p><strong>命名空间模式的缺点</strong></p>
<pre><code>① 需要输入更多的字符,在每个变量和函数前面都需要附加上前缀,总体上增加了代码的体积。
② 仅有一个全局实例,意味着代码的任何部分都能够修改当前的实例。
③ 很长的前缀意味着需要花更长的时间来解析属性(变量|属性访问原则-就近原则)
</code></pre><p>代码示例（零散的代码）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line">    <span class="keyword">var</span> testDemo01 = <span class="string">"测试字符串01"</span>;</div><div class="line">    <span class="keyword">var</span> testDemo02 = <span class="string">"测试字符串02"</span>;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    obj.des = <span class="string">"描述信息"</span>;</div><div class="line">    obj.logDes = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(obj.des);</div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p>代码示例(命名空间模式)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个全局变量</span></div><div class="line">    <span class="keyword">var</span> MYAPP = &#123;&#125;;</div><div class="line">    <span class="comment">//02 处理构造函数</span></div><div class="line">    MYAPP.Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    MYAPP.Man = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    <span class="comment">//03 处理变量</span></div><div class="line">    MYAPP.array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line">    MYAPP.testDemo01 = <span class="string">"测试字符串01"</span>;</div><div class="line">    MYAPP.testDemo02 = <span class="string">"测试字符串02"</span>;</div><div class="line">    <span class="comment">//处理对象</span></div><div class="line">    MYAPP.obj = &#123;&#125;;</div><div class="line">    MYAPP.obj.des = <span class="string">"描述信息"</span>;</div><div class="line">    MYAPP.obj.logDes = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(obj.des);</div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<pre><code>01 在使用命名空间模式的时候,因为所有的变量和属性都添加到同一个全局对象下面,因此该全局对象下面可能有很多很多的属性。
02 而我们在添加属性的时候,很有可能该属性已经存在,这导致可能会覆盖掉之前的属性。
03 所以,在添加一个属性或者是创建一个命名空间之前,最好是先检查它是否已经存在。
04 但是如果每次添加属性都需要对属性进行检查则会产生代码冗余问题。
</code></pre><p>示例代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 不好的演示</span></div><div class="line"><span class="comment">//其他代码</span></div><div class="line"><span class="comment">//var MYAPP = &#123;&#125;;     //注意这是不安全的代码,因为有可能覆盖掉上下文中的代码</span></div><div class="line"><span class="comment">//02 在创建命名空间之前,先检查该命名空间是否存在</span></div><div class="line"><span class="comment">//    if (MYAPP == 'undefined')&#123;</span></div><div class="line"><span class="comment">//        var MYAPP = &#123;&#125;;</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line"><span class="comment">//03 更好的做法</span></div><div class="line"><span class="keyword">var</span> MYAPP = MYAPP || &#123;&#125;;        <span class="comment">//如果MYAPP为假,那么就返回&#123;&#125;并赋值给MYAPP</span></div><div class="line"><span class="comment">//04 添加属性时的检查问题</span></div><div class="line"><span class="comment">//假如现在需要添加一个name属性,那么在添加之前需要先检查该属性是否存在</span></div><div class="line"><span class="keyword">if</span> (MYAPP.name == <span class="string">'undefined'</span>)</div><div class="line">&#123;</div><div class="line">    MYAPP.name = <span class="string">"默认的名称"</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//假如要添加一个obJ属性</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> MYAPP.obj == <span class="string">'undefined'</span>)</div><div class="line">&#123;</div><div class="line">        MYAPP.obj = &#123;&#125;;</div><div class="line">&#125;</div><div class="line"><span class="comment">//假如要给MYAPP.obj添加属性,则</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> MYAPP.obj.des === <span class="string">"undefined"</span>)</div><div class="line">&#123;</div><div class="line">    MYAPP.obj.des = <span class="string">"对象的描述信息"</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(MYAPP.obj);</div></pre></td></tr></table></figure></p>
<p>代码说明：我们在添加属性或者是方法的时候,比较安全的做法是在添加之前先在当前环境中进行检查,以免覆盖但是我们的检查操作催生出了一个新的问题,就是重复代码过多,能否考虑把检查的过程抽取</p>
<p><strong>示例代码</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> MYAPP = MYAPP || &#123;&#125;;</div><div class="line">    MYAPP.namescape = <span class="function"><span class="keyword">function</span> (<span class="params">string</span>) </span>&#123;</div><div class="line">        <span class="comment">//split() 方法用于把一个字符串分割成字符串数组</span></div><div class="line">        <span class="keyword">var</span> parts = string.split(<span class="string">'.'</span>);</div><div class="line">        <span class="keyword">var</span> parent = MYAPP;</div><div class="line">        <span class="built_in">console</span>.log(parts);</div><div class="line">        <span class="comment">//先去掉最前面的冗余的全局变量</span></div><div class="line">        <span class="keyword">if</span>(parts[<span class="number">0</span>] == <span class="string">"MYAPP"</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//splice() 方法向/从数组中添加/删除项目,然后返回被删除的项目</span></div><div class="line">            <span class="comment">//parts.splice(0,1);</span></div><div class="line">            <span class="comment">//slice() 方法可从已有的数组中返回选定的元素</span></div><div class="line">            <span class="comment">//返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素</span></div><div class="line">            parts = parts.slice(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.log(parts,<span class="string">"处理之后的数组"</span>);</div><div class="line">        <span class="comment">//通过for循环来遍历结构</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; parts.length; i++) &#123;</div><div class="line">            <span class="comment">//检查属性,如果对应的属性不存在,那么就创建一个属性</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> parent[parts[i]] == <span class="string">'undefined'</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">//初始化为一个空的对象</span></div><div class="line">                parent[parts[i]] = &#123;&#125;;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//修正parent的值</span></div><div class="line">            parent = parent[parts[i]];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> parent;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//代码示例</span></div><div class="line">    <span class="keyword">var</span> testDemo01 = MYAPP.namescape(<span class="string">"MYAPP.test.testDemo01"</span>);</div><div class="line">    <span class="keyword">var</span> testDemo02 = MYAPP.namescape(<span class="string">"MYAPP.test.testDemo02"</span>);</div><div class="line">    <span class="built_in">console</span>.log(MYAPP);</div><div class="line">    <span class="comment">//忽略全面的前缀</span></div><div class="line">    MYAPP.namescape(<span class="string">"sadsa.sadjaldj.adada.test"</span>);</div><div class="line">    <span class="built_in">console</span>.log(MYAPP);</div><div class="line">    <span class="comment">//演示长命名空间的情况</span></div><div class="line">    MYAPP.namescape(<span class="string">"demo.testDemo.testDemos.ss.dd.qq.ddd.ffff.fff"</span>);</div><div class="line">    <span class="built_in">console</span>.log(MYAPP);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>补充说明<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">01</span> split() 方法用于把一个字符串分割成字符串数组</div><div class="line"><span class="number">02</span> splice() 方法向/从数组中添加/删除项目,然后返回被删除的项目</div><div class="line"><span class="number">03</span> slice() 方法可从已有的数组中返回选定的元素</div></pre></td></tr></table></figure></p>
<h1 id="设计模式简单说明"><a href="#设计模式简单说明" class="headerlink" title="设计模式简单说明"></a>设计模式简单说明</h1><pre><code>概念:设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案
    注意,设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案
起源:该属于源于建筑行业
历史:
    （1）由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学
    （2）四人帮著作《设计模式：可复用面向对象软件的基础》（Design Patterns - Elements of Reusable Object-Oriented Software）
    （3）Gang of Four:Erich Gamma + Richard Helm + Ralph Johnson +John Vlissides
优点:
    为了可重用代码、让代码更容易被他人理解、保证代码可靠性
</code></pre><h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><pre><code>创建型模式:工厂方法模式 + 抽象工厂模式 + 单例模式 + 建造者模式 + 原型模式
结构型模式:适配器模式 + 代理模式 + ...
行为型模式:观察者模式 + 命令模式 + ...
</code></pre><h2 id="单例模式的思想"><a href="#单例模式的思想" class="headerlink" title="单例模式的思想"></a>单例模式的思想</h2><pre><code>保证一个特定的类只有一个实例。
即当我们第二次创建新对象的时候,得到的应该是和第一次创建的对象一模一样的对象(同一个对象)
</code></pre><p><strong>其他语言中实现单例模式</strong></p>
<pre><code>在其它有Class的语言中,实现单例模式核心步骤是:
    01 在创建对象实例时候判断,该类的实例对象是否已经存在,如果已经存在,那么就直接返回
    02 如果不存在,那么就创建一个新的实例对象,并保存起来,下次创建实例对象的时候直接使用。
</code></pre><h2 id="JavaScript中的单例模式"><a href="#JavaScript中的单例模式" class="headerlink" title="JavaScript中的单例模式"></a>JavaScript中的单例模式</h2><pre><code>JavaScript是一门弱类型,动态,基于原型的语言,并没有类,只有对象。
在JavaScript中要实现单例模式有很多种方式。
最简单的方式:使用字面量的方式来创建对象,因为在JavaScript中对象之间永远不可能相等,除非他们是同一个对象。
</code></pre><p><strong>使用字面量方式创建的对象总是唯一的</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">script&gt;</div><div class="line">    <span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">"zhangsan"</span>&#125;;</div><div class="line">    <span class="keyword">var</span> obj2 = &#123;<span class="attr">name</span>:<span class="string">"zhangsan"</span>&#125;;</div><div class="line">    <span class="built_in">console</span>.log(obj1 == obj2);      <span class="comment">//false</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>使用new操作符创建对象实现单例</strong></p>
<pre><code>实现单例模式的几种途径
    ① 在代码中提供一个全局变量来存储创建出来的实例 缺点:该全局变量可能会被轻易的修改和覆盖
    ② 尝试在构造函数的静态成员中缓存实例属性。缺点:函数的静态属性在外部可以直接修改,容易导致实例对象的丢失。
    ③ 将实例对象包装在闭包中。优点是安全性较好,无法被轻易的修改,缺点是有额外闭包的开销。
</code></pre><p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">China</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="comment">//创建对象</span></div><div class="line"><span class="keyword">var</span> china01 = <span class="keyword">new</span> China();</div><div class="line"><span class="keyword">var</span> china02 = <span class="keyword">new</span> China();</div><div class="line"><span class="comment">//思考:如果想要实现单例模式,那么最终的结果必要是china01 和china02是同一个对象,那么如何实现</span></div></pre></td></tr></table></figure></p>
<p><strong>实现方案(一)使用全局变量方式存储创建出来的实例对象</strong><br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个全局变量</span></div><div class="line">    <span class="keyword">var</span> instance;</div><div class="line">   <span class="comment">//02 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="literal">undefined</span>)</div><div class="line">        &#123;</div><div class="line">            instance = <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.name = <span class="string">"默认的名称"</span>;</div><div class="line">        <span class="keyword">this</span>.age = <span class="number">66</span>;</div><div class="line">        <span class="comment">//使用全局变量来接收内部创建出来的实例对象(this)</span></div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//03 使用构造函数创建对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p2);</div><div class="line">    <span class="built_in">console</span>.log(p1.name);</div><div class="line">    <span class="built_in">console</span>.log(p2.name);</div><div class="line">    p1.name = <span class="string">"修改之后的名称"</span>;</div><div class="line">    <span class="built_in">console</span>.log(p1.name);</div><div class="line">    <span class="built_in">console</span>.log(p2.name);</div><div class="line">    <span class="comment">//说明:在上面的方案中我们使用一个全局变量来接收实例对象的值,在构造函数内部也是通过判断这个全局变量来做一些其他的处理</span></div><div class="line">    instance = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> p3 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p3);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><code>说明：</code>这种方法确实可以实现单例模式,但是并不安全,因为全局变量可能会被轻易的修改或者是覆盖,因此不推荐这种方式。</p>
<p><strong>实现方案(二)通过构造函数静态属性来缓存实例对象</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//02 在内部判断构造函数的静态属性中是否拥有实例对象</span></div><div class="line">        <span class="comment">//如果拥有实例对象,那么就直接返回,否则就设置实例对象,并赋值给构造函数的静态属性</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> Person.instance == <span class="string">"object"</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> Person.instance;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//设置实例对象的属性和方法</span></div><div class="line">        <span class="keyword">this</span>.name = <span class="string">"默认的名称"</span>;</div><div class="line">        <span class="keyword">this</span>.age = <span class="number">66</span>;</div><div class="line">        <span class="comment">//03 把内部创建的实例化对象赋值给构造函数的静态属性</span></div><div class="line">        Person.instance = <span class="keyword">this</span>;</div><div class="line">        <span class="comment">//显示返回</span></div><div class="line">        <span class="comment">//return Person.instance;</span></div><div class="line">        <span class="comment">//隐式返回</span></div><div class="line">        <span class="comment">//return this;</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//04 创建实例对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p2);</div><div class="line">    Person.instance = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> p3 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p3);      <span class="comment">//false</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><code>说明：</code>在构造函数外部可以直接访问其静态成员(属性和方法),可能会导致实例对象的丢失。</p>
<p><strong>实现方案(二)通过闭包-惰性函数定义来实现</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//02 在函数内部使用私有变量来缓存实例</span></div><div class="line">        <span class="keyword">var</span> instance = <span class="keyword">this</span>;</div><div class="line">        <span class="comment">//03 设置实例对象的属性和方法</span></div><div class="line">        <span class="keyword">this</span>.name = <span class="string">"默认的姓名"</span>;</div><div class="line">        <span class="keyword">this</span>.age = <span class="number">66</span>;</div><div class="line">        <span class="comment">//04 使用惰性函数定义来更新构造函数的实现</span></div><div class="line">        <span class="comment">//通过一个闭包来返回缓存的实例对象</span></div><div class="line">        Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> instance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//05 创建对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p2);</div><div class="line">    <span class="comment">//代码说明:第一次调用原始构造函数的时候,它会像往常一样返回this(指向内部新创建的实例对象)</span></div><div class="line">    <span class="comment">//再后面调用的时候,它会执行更新后的构造函数,在这个新的函数实现中,我们通过闭包来访问了私有变量,并简单的返回。</span></div><div class="line">    <span class="comment">//这个instance私有变量存储的是第一次调用构造函数时创建出来的实例对象</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>新的问题</strong><br>01 因为内部使用惰性函数定义(重写构造函数会导致之前添加在构造函数中的属性丢失),所以存在属性丢失问题<br>02 在上面的代码中,体现在于创建对象前后设置的构造函数的原型对象丢失问题</p>
<p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> instance = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">this</span>.name = <span class="string">"默认的姓名"</span>;</div><div class="line">        <span class="keyword">this</span>.age = <span class="number">66</span>;</div><div class="line">        Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> instance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//设置构造函数的原型对象</span></div><div class="line">    Person.prototype.des = <span class="string">"描述信息"</span>;</div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="comment">//在创建第一个对象之后,设置原型对象</span></div><div class="line">    Person.prototype.someThing = <span class="string">"something"</span>;</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p2);</div><div class="line">    <span class="built_in">console</span>.log(p1.des);        <span class="comment">//描述信息</span></div><div class="line">    <span class="built_in">console</span>.log(p2.des);        <span class="comment">//描述信息</span></div><div class="line">    <span class="built_in">console</span>.log(p1.someThing);  <span class="comment">//undefined</span></div><div class="line">    <span class="built_in">console</span>.log(p2.someThing);  <span class="comment">//undefined</span></div><div class="line">    <span class="comment">//打印对象的构造函数</span></div><div class="line">    <span class="built_in">console</span>.log(p1.constructor.name);       <span class="comment">//Person</span></div><div class="line">    <span class="built_in">console</span>.log(p2.constructor.name);       <span class="comment">//Person</span></div><div class="line">    <span class="comment">//判断对象的构造函数</span></div><div class="line">    <span class="built_in">console</span>.log(p1.constructor == Person);  <span class="comment">//false</span></div><div class="line">    <span class="built_in">console</span>.log(p1.constructor == p2.constructor,<span class="string">"构造函数是否一致"</span>);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>解决问题的核心过程</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">01</span> 提供一个构造函数</div><div class="line"><span class="number">02</span> 在构造函数内部提供一个私有变量instance</div><div class="line"><span class="number">03</span> 重写构造函数,返回私有变量instance</div><div class="line"><span class="number">04</span> 把原有的原型对象赋值给新Person构造函数的原型对象</div><div class="line"><span class="number">05</span> 调用<span class="keyword">new</span> 构造函数方法创建一个实例化对象赋值给instance</div><div class="line"><span class="number">06</span> 修正instance实例的构造器属性,指向新的构造函数(注意:虽</div><div class="line">然重写了构造函数,但是instance的构造函数仍然是以前的Person)</div><div class="line"><span class="number">07</span> 设置实例属性和方法</div><div class="line"><span class="number">08</span> 返回instance对象</div><div class="line">代码示例</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//01 提供一个私有变量</span></div><div class="line">        <span class="keyword">var</span> instance;</div><div class="line">        <span class="comment">//02 重写构造函数</span></div><div class="line">        Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(instance);</div><div class="line">            <span class="comment">//console.log(instance.constructor);</span></div><div class="line">            <span class="keyword">var</span> t = <span class="keyword">this</span>;</div><div class="line">            <span class="built_in">console</span>.log(t);</div><div class="line">            <span class="keyword">return</span> instance;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//03 保留原型属性</span></div><div class="line">        Person.prototype = <span class="keyword">this</span>.__proto__;    <span class="comment">//这是一个空的对象</span></div><div class="line">        Person.lal = <span class="string">"lala"</span>;</div><div class="line">        <span class="comment">//04 创建并使用私有变量来接收实例对象</span></div><div class="line">        instance = <span class="keyword">new</span> Person();</div><div class="line">        <span class="comment">//05 修正构造函数指针</span></div><div class="line">        instance.constructor = Person;</div><div class="line">        <span class="comment">//06 设置实例属性和方法</span></div><div class="line">        instance.name = <span class="string">"默认的名字"</span>;</div><div class="line">        instance.age = <span class="number">66</span>;</div><div class="line">        <span class="comment">//07 返回私有变量</span></div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">   Person.haha = <span class="string">"哈哈"</span>;</div><div class="line">    <span class="comment">//设置构造函数的原型对象</span></div><div class="line">    Person.prototype.des = <span class="string">"描述信息"</span>;</div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="comment">//在创建第一个对象之后,设置原型对象</span></div><div class="line">    Person.prototype.someThing = <span class="string">"something"</span>;</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p2);</div><div class="line">    <span class="built_in">console</span>.log(p1.des);        <span class="comment">//描述信息</span></div><div class="line">    <span class="built_in">console</span>.log(p2.des);        <span class="comment">//描述信息</span></div><div class="line">    <span class="built_in">console</span>.log(p1.someThing);  <span class="comment">//something</span></div><div class="line">    <span class="built_in">console</span>.log(p2.someThing);  <span class="comment">//something</span></div><div class="line">    <span class="comment">//打印构造器属性</span></div><div class="line">    <span class="built_in">console</span>.log(p1.constructor == Person,<span class="string">"验证构造器指向"</span>);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p><strong>全局变量方式实现单例-改进版</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> Person;</div><div class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//01 提供一个局部变量instance</span></div><div class="line">        <span class="keyword">var</span> instance;</div><div class="line">        Person = <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (instance)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">return</span> instance;</div><div class="line">            &#125;</div><div class="line">            instance = <span class="keyword">this</span>;</div><div class="line">            <span class="keyword">this</span>.name = <span class="string">"默认的名字"</span>;</div><div class="line">            <span class="keyword">this</span>.age = <span class="number">66</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;)();</div><div class="line">    <span class="comment">//创建对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(p1 == p2);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>说明：<code>通过即时函数来限定作用域,外部无法修改内部instance的值(现在是一个局部变量)</code></p>
<h1 id="工厂模式简单说明"><a href="#工厂模式简单说明" class="headerlink" title="工厂模式简单说明"></a>工厂模式简单说明</h1><pre><code>工厂模式的目的是用于创建对象,通常在类或者是类的静态方法中实现。
</code></pre><p><strong>工厂模式的目标</strong></p>
<pre><code>01 用一套方法去创建相似的目标。
02 在编译时不知道具体类型的情况下,为用户提供创建对象的接口
</code></pre><p><strong>工厂模式实现过程</strong></p>
<pre><code>01 提供一个父构造函数
02 在父构造函数的原型上添加共享的方法
03 在父构造函数身上提供一个静态方法(静态工厂方法)
    001 先获取参数(产品类型)
    002 判断构造函数是否存在(容错性处理)
    003 设置原型链继承:设置子构造函数的原型对象为父构造函数的一个实例对象(目的是为了让子构造函数创建的对象拥有父构造函数上面实例属性和原型属性)
    004 使用子构造函数创建实例对象
    005 返回新创建的实例对象
04 定义特定的工厂客户(静态方法)
05 通过父构造函数的静态工厂方法来创建产品对象
</code></pre><p><strong>代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个父构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">PhoneMaker</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">    <span class="comment">//02 在父构造函数的原型上添加共享的方法</span></div><div class="line">    PhoneMaker.prototype.callPhoneDes = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"手机的特点是:  "</span> + <span class="keyword">this</span>.des);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//03 在父构造函数身上提供一个静态方法(静态工厂方法)</span></div><div class="line">    PhoneMaker.factory = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">        <span class="comment">//001 先获取参数(产品类型)</span></div><div class="line">        <span class="keyword">var</span> typeStr = type;</div><div class="line">        <span class="comment">//002 判断构造函数是否存在(容错性处理)</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> PhoneMaker[typeStr] !== <span class="string">'function'</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="string">"Error 对应的构造函数不存在,不能生产该种类型的产品"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//003 设置原型链继承</span></div><div class="line">        PhoneMaker[typeStr].prototype = <span class="keyword">new</span> PhoneMaker();</div><div class="line">        <span class="comment">//004 使用子构造函数创建实例对象</span></div><div class="line">        <span class="keyword">var</span> newPhone = <span class="keyword">new</span>  PhoneMaker[typeStr]();</div><div class="line">        <span class="comment">//005 返回新创建的实例对象</span></div><div class="line">        <span class="keyword">return</span> newPhone;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//定义特定的工厂客户(静态方法)</span></div><div class="line">    PhoneMaker.iphone = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.des = <span class="string">"最安全稳定的系统"</span>;</div><div class="line">    &#125;</div><div class="line">    PhoneMaker.oppo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.des = <span class="string">"充当五分钟,通话两小时"</span>;</div><div class="line">    &#125;</div><div class="line">    PhoneMaker.vivo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.des = <span class="string">"vivo手机,你的音乐手机"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//通过父构造函数的静态工厂方法来创建产品对象</span></div><div class="line">    <span class="keyword">var</span> vivo = PhoneMaker.factory(<span class="string">'vivo'</span>);</div><div class="line">    <span class="keyword">var</span> iphone = PhoneMaker.factory(<span class="string">'iphone'</span>);</div><div class="line">    <span class="keyword">var</span> oppo = PhoneMaker.factory(<span class="string">'oppo'</span>);</div><div class="line">    vivo.callPhoneDes();</div><div class="line">    oppo.callPhoneDes();</div><div class="line">    iphone.callPhoneDes();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p><strong>观察者模式</strong><br>观察者模式又名为发布-订阅者模式，它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。</p>
<p><strong>观察者模式的特点（优点）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">01 观察者模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案</div><div class="line">02 观察者模式可以取代对象之间硬性编码的通知机制，一个对象不再是显示的调用另外一个对象的接口，这种模式让两个对象松耦合的联系在一起，它们不需要清楚彼此的实现细节就能够相互通信。</div><div class="line">03 在这种设计模式中，不再是一个对象调用另外一个对象的方法，而是一个对象订阅另一个对象的特定活动并且在状态改变后获得通知</div></pre></td></tr></table></figure></p>
<p><strong>模型</strong><br>01 订阅者也称为<code>观察者</code><br>02 被观察的对象称为<code>发布者</code>或者是主题<br>03 当发生一个重要事件的时候，发布者将会通知所有订阅者并且经常以事件的形式来传递消息。<br>示例代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提取成公共的发行者对象</span></div><div class="line">    <span class="keyword">var</span> publisher = &#123;</div><div class="line">        <span class="attr">users</span>:&#123;</div><div class="line">            <span class="attr">default</span>:[]</div><div class="line">        &#125;,   <span class="comment">//所有的订阅者对象</span></div><div class="line">        addUser:<span class="function"><span class="keyword">function</span> (<span class="params">fn,type</span>) </span>&#123;</div><div class="line">            <span class="comment">//对订阅的类型进行判断</span></div><div class="line">            <span class="keyword">var</span> type = type || <span class="string">"default"</span>;</div><div class="line">            <span class="comment">//如果是新的订阅类型,那么我们需要做初始化的处理</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.users[type] == <span class="literal">undefined</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">this</span>.users[type] = [];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">this</span>.users[type].push(fn);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">removeUser</span>:<span class="function"><span class="keyword">function</span> (<span class="params">fn,type</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.tool(type,<span class="string">"removerUser"</span>,fn);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">publish</span>:<span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.tool(type,<span class="string">"publish"</span>);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">tool</span>:<span class="function"><span class="keyword">function</span> (<span class="params">type,funcType,fn</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> type = type || <span class="string">"default"</span>;</div><div class="line">            <span class="keyword">var</span> users = <span class="keyword">this</span>.users[type];</div><div class="line">            <span class="keyword">if</span> (users == <span class="literal">undefined</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"当前没有任何订阅者"</span>);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; users.length; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (funcType == <span class="string">'publish'</span>)</div><div class="line">                &#123;</div><div class="line">                    users[i]()</div><div class="line">                &#125;<span class="keyword">else</span></div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span> (users[i] == fn)</div><div class="line">                    &#123;</div><div class="line">                        users.splice(i, <span class="number">1</span>);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//02 提供一个工具函数,能够利用发行者对象的模板来快速创建新的发布者</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">makePaper</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> publisher) &#123;</div><div class="line">            <span class="keyword">if</span> (publisher.hasOwnProperty(i) &amp;&amp; <span class="keyword">typeof</span> publisher[i] == <span class="string">'function'</span>)</div><div class="line">            &#123;</div><div class="line">                o[i] = publisher[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        o.users = &#123;<span class="attr">default</span>:[]&#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//03 创建发布者</span></div><div class="line">    <span class="keyword">var</span> paper1 = &#123;</div><div class="line">        <span class="attr">day</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.publish();</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">month</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.publish(<span class="string">"month"</span>)</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">year</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.publish(<span class="string">"year"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//把某个对象编程一个发布者</span></div><div class="line">    makePaper(paper1);</div><div class="line">    <span class="comment">//04 创建订阅者(当发布者发布消息的时候,订阅者能够收到信息--自动调用订阅者的方法)</span></div><div class="line">    <span class="keyword">var</span> obj = &#123;</div><div class="line">        <span class="attr">lookDayNews</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"obj - 查看最新的日报信息"</span>);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">lookImageNews</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"obj - 查看图片信息"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//05 设置订阅</span></div><div class="line">    paper1.addUser(obj.lookDayNews);</div><div class="line">    paper1.addUser(obj.lookImageNews,<span class="string">'month'</span>);</div><div class="line">    paper1.day();</div><div class="line">    paper1.month();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> 简明教程 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[固定导航，不做抖man]]></title>
      <url>/2016/05/11/%E8%A7%A3%E5%86%B3%E9%A1%B5%E9%9D%A2%E6%8A%96%E5%8A%A8/</url>
      <content type="html"><![CDATA[<p>如何hold住导航？</p>
<h1 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h1><p>假设一个网页由Header,Nav,Main三部分构成。<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Header(Logo, other information)</div><div class="line"></div><div class="line">----------------------------------------------</div><div class="line"></div><div class="line">Nav(Nav,menu,links)</div><div class="line"></div><div class="line">----------------------------------------------</div><div class="line"></div><div class="line">Main(Container, Content)</div><div class="line"></div><div class="line">-----------------------------------------------</div></pre></td></tr></table></figure></p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>根据需求，当大于Header的高度时，固定住导航。当我们滚动滚轮时候，此时 Header 会被 Nav 所遮住，再往下面滚动时Nav会固定在顶部。最常规的解决方法,让Header固定定位，Nav上边距为Header的高度：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">Header</span>：<span class="selector-tag">position</span>: <span class="selector-tag">fixed</span></div><div class="line"></div><div class="line"><span class="selector-tag">Nav</span>: <span class="selector-tag">margin-top</span>: <span class="selector-tag">A</span><span class="selector-class">.height</span></div></pre></td></tr></table></figure></p>
<p>设置滚动事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (scrollTop &gt; Header.height) &#123;</div><div class="line">    <span class="attr">Nav</span>: position: fixed</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="attr">Nav</span>: position: initial</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样做会所产生的问题：<br>    当 Header fixed 后，页面高度由 Header + Nav + Main 变为 Header + Main，导致 Main 自动上移了 Nav.height，从而使 scrollTop 变小。这样根据滚动事件将执行 Nav: position: initial，用鼠标慢慢拖动时，Nav 会进行多次抖动（fixed-&gt;initial-&gt;fixed-&gt;initial-&gt;……）。</p>
<p>解决的方法如下：</p>
<pre><code>使 Header fixed 后，页面高度依旧为 Header + Nav + Main。

    Header: margin-top: A.height

    Nav-wrap： height: Nav.height

为了使用户产生 Header fixed 后的视觉动感，可设置 scrollTop &gt; Header.height + Nav.height / 3
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> css </tag>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript简明教程（6）]]></title>
      <url>/2016/04/25/js-06/</url>
      <content type="html"><![CDATA[<p>闭包是学习JavaScript的难点之一，因JavaScript是单线程，故回调使用频繁，本章节主要讲了闭包以及回调。</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><strong>闭包简单说明</strong></p>
<pre><code>闭:关闭,封闭
包:包住,包裹
闭包:通过某种方式实现的一个封闭的、包裹的对外不公开的结构|空间
闭包的原理:变量的访问原则(即上一级的作用域无法访问下一级的作用域),其实函数本身就是闭包。
</code></pre><a id="more"></a>
<p><strong>闭包要解决的问题</strong></p>
<pre><code>提供一种间接的方式能够访问到函数内部的数据（变量）
</code></pre><p><strong>实现思路</strong></p>
<pre><code>01 我们需要能够在函数外部访问函数内部的变量，正常情况无法访问；
02 在函数内部如果新创建函数，那么安装作用域链的原则，这个新创建的内部函数能够访问到函数中的这些变量。
03 我们如果能够操作函数中新创建的函数，那么就能够操作函数中的变量（如访问和设置等）
04 如果要能够操作函数中新创建的函数，那么需要在函数中把新创建的函数返回。
05 调用函数，接收并得到其返回值（是一个函数）
06 调用返回值（函数），通过函数传参的方式来设置函数中的变量。
07 调用返回值（函数），通过在函数内部再次return的方式来访问函数中的变量。
</code></pre><p><strong>闭包的基本模式</strong></p>
<pre><code>在函数内部创建函数(内部函数),在这个内部函数中,可以操作外部函数中的变量
01 在函数(外部)中创建函数(内部函数),在该函数(内部函数)中操作外部函数中的变量
02 在外部函数中,把内部函数作为返回值返回
03 调用外部函数,并接收其返回值(是一个函数)
04 调用接收到的返回值(内部函数),来间接的操作外部函数中的变量
</code></pre><p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">        num = n;</div><div class="line">        <span class="built_in">console</span>.log(num);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> funcName = func();</div><div class="line">funcName(<span class="string">"哗啦哗啦"</span>);</div></pre></td></tr></table></figure></p>
<h2 id="闭包获取数据"><a href="#闭包获取数据" class="headerlink" title="闭包获取数据"></a>闭包获取数据</h2><p><strong>获取单个数据（考虑赋值）</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num = <span class="number">123</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (a !== <span class="literal">undefined</span>)</div><div class="line">        &#123;</div><div class="line">            num = a;</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">return</span> num;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f1 = func();</div><div class="line"><span class="keyword">var</span> x = f1(<span class="number">456</span>);</div><div class="line"><span class="keyword">var</span> y = f1();</div><div class="line"><span class="built_in">console</span>.log(x);</div><div class="line"><span class="built_in">console</span>.log(y);</div></pre></td></tr></table></figure></p>
<p>说明：上面的代码能够支持通过闭包对函数中的变量num进行访问（取值）或赋值的操作。</p>
<p><strong>获取多个数据（数组）</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"张学友"</span>;</div><div class="line">    <span class="keyword">var</span> age = <span class="number">40</span>;</div><div class="line">    <span class="keyword">return</span> [</div><div class="line">            <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> name;</div><div class="line">            &#125;,</div><div class="line">            <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> age;</div><div class="line">            &#125;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> foo = func();</div><div class="line"><span class="built_in">console</span>.log(foo[<span class="number">0</span>]());      <span class="comment">//张学友</span></div><div class="line"><span class="built_in">console</span>.log(foo[<span class="number">1</span>]());      <span class="comment">//40</span></div></pre></td></tr></table></figure></p>
<p>说明：上面的代码能够满足返回多个变量值的需求，但是要数组操作的方式并不常见，且和使用习惯不符合。</p>
<p><strong>利用对象返回并设置对个变量值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"张学友"</span>;</div><div class="line">    <span class="keyword">var</span> age = <span class="number">45</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">getName</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> name;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">getAge</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> age;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">setName</span>:<span class="function"><span class="keyword">function</span> (<span class="params">nameValue</span>) </span>&#123;</div><div class="line">            name = nameValue;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">setAge</span>:<span class="function"><span class="keyword">function</span> (<span class="params">ageValue</span>) </span>&#123;</div><div class="line">            age = ageValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> func = foo();</div><div class="line"><span class="built_in">console</span>.log(func.getName());        <span class="comment">//张学友</span></div><div class="line"><span class="built_in">console</span>.log(func.getAge());         <span class="comment">//45</span></div><div class="line">func.setName(<span class="string">"张三"</span>);</div><div class="line">func.setAge(<span class="number">30</span>);</div><div class="line"><span class="built_in">console</span>.log(func.getName());        <span class="comment">//张三</span></div><div class="line"><span class="built_in">console</span>.log(func.getAge());         <span class="comment">//30</span></div></pre></td></tr></table></figure></p>
<p><strong>闭包的作用</strong><br>最基本的作用:闭包中的变量更安全,只能通过特定的接口来访问<br>说明:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(1)创建一个私有的空间,保护数据,外界如果需要访问数据必须通过函数提供的指定方法</div><div class="line">(2)在这些指定的方法中,我们可以设置一些校验的逻辑,以保证对数据访问和设置的安全性</div></pre></td></tr></table></figure></p>
<h2 id="闭包的使用注意"><a href="#闭包的使用注意" class="headerlink" title="闭包的使用注意"></a>闭包的使用注意</h2><p><strong>进程和线程</strong></p>
<pre><code>进程指的是系统中正在运行的一个应用程序。
线程:一个进程中可以有一个或多个线程,线程是CPU调度的最小单位,是真正执行任务的。
多线程:一个中可能有多条线程,多条线程之间并发的执行多个不同的任务。
单线程:一个进程中只有一条线程,即同一时间只能执行一个操作,只能干一件事情。
</code></pre><p><strong>javascript是单线程的</strong></p>
<pre><code>js中的线程主要处理三块任务:
01 渲染任务
02 js的代码执行任务
03 js中的事件处理任务(如setTimeOut方法)
</code></pre><p><strong>javascript中代码的执行顺序</strong></p>
<p><code>01 先把主任务执行完毕(代码任务)</code><br><code>02 主任务执行完毕之后再执行次要的任务(包括setTimeOut方法等)</code></p>
<p><strong>关于setTimeOut函数</strong></p>
<pre><code>函数的作用:一次性定时器(用于延迟执行任务)
参数:
    第一个参数:要执行的任务
    第二个参数:要延迟执行的时间,时间的单位是毫秒
函数说明：
    01 至少在指定的时间后才能够执行回调函数
    02 因为要等主任务中的代码执行完毕之后,才回去检查setTimeOut的回调函数。
</code></pre><p><strong>通过闭包解决setTimeOut函数的问题</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line"></div><div class="line">        setTimeout((<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(j);</div><div class="line">            &#125;</div><div class="line">        &#125;)(i),<span class="number">10</span>);</div><div class="line"></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"----"</span>);</div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>函数的特殊之处</strong><br>函数的特殊之处在于,它本身是对象,且函数可以提供作用域。</p>
<pre><code>(01) 函数可以在运行时动态的创建,还可以在程序执行过程中创建。
(02) 函数可以赋值给变量,可以被扩展,甚至是删除。
(03) 函数可以作为其他函数的参数和返回值。
(04) 函数可以拥有自己的属性和方法。
注意:{} 块在js中不会创建作用域,哪怕是if或者是while语句中使用var关键字声明的变量也并非局部变量。
函数是可以通过（）调用并执行的对象。
</code></pre><p><strong>函数是第一型对象</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">01 函数可以像普通对象一样作为函数的参数</div><div class="line">02 函数可以像普通对象一样赋值给变量（函数表达式）</div><div class="line">03 函数可以像普通对象一个作为函数的返回值返回</div></pre></td></tr></table></figure></p>
<p><strong>代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//函数作为参数传递</span></div><div class="line">   setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">   &#125;,<span class="number">100</span>);</div><div class="line">   <span class="comment">//函数作为返回值</span></div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">           <span class="built_in">console</span>.log(<span class="string">"demo"</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">var</span> f = func();</div><div class="line">   f();                <span class="comment">//demo</span></div><div class="line">   <span class="comment">//函数赋值给变量</span></div><div class="line">   <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">   a();    <span class="comment">//直接通过变量的名称调用函数</span></div></pre></td></tr></table></figure></p>
<p><strong>函数的两个特征</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">01 函数本质上是对象</div><div class="line">02 函数可以创建作用域</div></pre></td></tr></table></figure></p>
<p><strong>约定</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a + b;&#125;; <span class="comment">//命名函数表达式</span></div><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a + b;&#125;;    <span class="comment">//函数表达式,匿名函数</span></div><div class="line">    以上也称为使用字面量的方式来创建函数(或者是函数字面量)</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;&#125;;   <span class="comment">//函数声明</span></div></pre></td></tr></table></figure></p>
<p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 函数声明</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">demo01</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;</div><div class="line">   <span class="comment">//02 函数表达式(匿名函数)</span></div><div class="line">    <span class="keyword">var</span> demo02 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//03 命名函数表达式</span></div><div class="line">    <span class="keyword">var</span> demo03 = <span class="function"><span class="keyword">function</span> <span class="title">demo03Test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//04 打印name属性</span></div><div class="line">    <span class="built_in">console</span>.log(demo01.name);   <span class="comment">//demo01</span></div><div class="line">    <span class="built_in">console</span>.log(demo02.name);   <span class="comment">//demo02 (注意在火狐浏览器中打印出来的name属性为空)</span></div><div class="line">    <span class="built_in">console</span>.log(demo03.name);   <span class="comment">//demo03Test</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>函数回调</strong><br>回调函数(回调),当我们把某个函数作为参数传递给另一个函数的时候,这个函数就称为回调函数</p>
<p><strong>函数回调的基本模式</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">callBack</span>) </span>&#123;</div><div class="line">        <span class="comment">//处理其他的操作</span></div><div class="line">        callBack();     <span class="comment">//调用回调函数</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"这是一个回调函数"</span>);</div><div class="line">    &#125;</div><div class="line">    func(demo); <span class="comment">//注意调用函数的时候,参数是回调函数的引用(不要加括号);</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>函数回调解决this问题</strong><br>说明：如果回调函数是某个对象的方法,而该对象方法中使用了this指针那么该方法作为回调函数来使用的时候,需要注意this<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提供一个对象,该对象中永远showName方法</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"默认的名字"</span>,</div><div class="line">    <span class="attr">age</span>:<span class="number">30</span>,</div><div class="line">    <span class="attr">showName</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">showAge</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//02 提供一个函数,该函数接受一个参数(函数引用)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">callBack,callBack_obj</span>) </span>&#123;</div><div class="line">    <span class="comment">//处理第一个参数传递对象方法字符串的形式</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> callBack == <span class="string">'string'</span>)</div><div class="line">    &#123;</div><div class="line">        callBack = callBack_obj[callBack];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callBack == <span class="string">'function'</span>)</div><div class="line">    &#123;</div><div class="line">        callBack.call(callBack_obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//demo(obj.showName,obj);</span></div><div class="line"><span class="comment">//demo(obj.showAge,obj);</span></div><div class="line"><span class="comment">//传递字符串和对象来进行调用</span></div><div class="line">demo(<span class="string">"showName"</span>,obj);</div></pre></td></tr></table></figure></p>
<p>代码说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">（01）以上代码传入两个参数，分别为具体的回调函数，和该回调函数所属的对象</div><div class="line">（02）该函数的参数接受两种方式的回调传递（一种是直接传递函数引用，一种是直接以字符串的方式传递对象方法的字符串）</div><div class="line">（03）在函数内部对传入的回调参数做处理，修正this的问题</div></pre></td></tr></table></figure></p>
<p><strong>函数作为函数的返回值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">① 使用闭包实现一个计数器(在该示例中setup函数的返回值为一个函数)</div><div class="line">② 通过调用返回值(一个函数),可以操作setup函数中的变量</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> setup = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> count ++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> next = setup();</div><div class="line">    <span class="built_in">console</span>.log(next());    <span class="comment">//0</span></div><div class="line">    <span class="built_in">console</span>.log(next());    <span class="comment">//1</span></div><div class="line">    <span class="built_in">console</span>.log(next());    <span class="comment">//2</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p><strong>惰性函数定义</strong><br>说明：某个函数直到第一次使用的时候才被正确的定义,并且其具有向后惰性,执行更少的工作。<br>应用场景:函数有一些初始化的准备工作要做,且只需要执行一次的情况。<br>特点:能够更新自己(函数)的实现。<br>缺点:<br>     01 当重新定义自身的时候,已经添加到原始函数的任何属性都会丢失。<br>     02 如何函数被赋值给了其他的变量或者是对象方法,那么在使用变量或者是对象方法调用时仍然会执行旧的函数体。<br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"foo!"</span>);</div><div class="line">    foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"new foo!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//函数的调用</span></div><div class="line"><span class="comment">//foo();  //foo!</span></div><div class="line"><span class="comment">//foo();  //new foo!</span></div></pre></td></tr></table></figure></p>
<p>问题：</p>
<pre><code>① 添加属性
② 把函数赋值给新的变量
③ 以对象的方法调用函数
当惰性函数定义在处理以上三种情况的时候，使用新的变量名调用或者是是以对象的方法来调用函数，那么该函数在执行的时候并不会更新自身，而是执行旧的函数体的内容
</code></pre><p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 声明函数foo</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"foo!"</span>);</div><div class="line">        foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"foo! foo!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02 为foo函数对象添加属性</span></div><div class="line">    foo.description = <span class="string">"foo函数的描述信息"</span>;</div><div class="line">    <span class="comment">//03 把foo函数赋值给其他的变量</span></div><div class="line">    <span class="keyword">var</span> func = foo;</div><div class="line">    <span class="comment">//04 把foo函数赋值给对象中的方法</span></div><div class="line">    <span class="keyword">var</span> obj = &#123;</div><div class="line">        <span class="attr">showFoo</span>:foo</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//05 验证并演示输出</span></div><div class="line">    func(); <span class="comment">//foo!</span></div><div class="line">    func(); <span class="comment">//foo!</span></div><div class="line">    <span class="built_in">console</span>.log(func.description);  <span class="comment">//foo函数的描述信息</span></div><div class="line">    <span class="comment">//总结:01 如果把函数赋值给其他的变量,那么在以其他变量的方式调用时不会更新自身,还是执行旧的函数体</span></div><div class="line">    obj.showFoo();  <span class="comment">//foo!</span></div><div class="line">    obj.showFoo();  <span class="comment">//foo!</span></div><div class="line">    <span class="built_in">console</span>.log(obj.showFoo.description);   <span class="comment">//foo函数的描述信息</span></div><div class="line">    <span class="comment">//总结:02 如果把函数赋值给对象的方法,那么在以对象方法形式调用时不会更新自身,还是会执行旧的函数体。</span></div><div class="line">    foo();  <span class="comment">//已经更新过foo函数 foo! foo!</span></div><div class="line">    foo();  <span class="comment">//已经更新过foo函数 foo! foo!</span></div><div class="line">    <span class="built_in">console</span>.log(foo.description);   <span class="comment">//undefined</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>即时函数</strong></p>
<p>定义:<code>在函数定义之后立即执行该函数。</code><br>即时函数模式的组成:<br>     ① 使用函数表达式来定义函数(匿名函数,注意不能使用函数声明方式)<br>     ② 在函数表达式末尾添加一组(),表示立即执行当前函数。<br>     ③ 将整个函数包装在()中,有两种方式`</p>
<p>即时函数的作用</p>
<pre><code>01 用来将所有的代码包装到当前的作用域中,并且不会将任何的变量泄露到全局作用域中。
02 js中没有代码块作用域,而函数是js中唯一可以创建作用域的。
03 即时函数就是利用了函数创建作用域这一点,来实现对一些需要封装且不允许外部访问的操作。
</code></pre><p>即时函数的优点<br>01 不会产生全局变量,在即时函数内部定义的所有变量都仅仅只是该函数的局部变量,不会造成全局变量污染问题。<br>02 具有更好的封装性,外部无法访问到该函数内部的数据。</p>
<p><strong>即时函数代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一种写法</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">"即时函数的第一种写法"</span>);</div><div class="line">&#125;());</div><div class="line"><span class="comment">//第二种写法</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"即时函数的第二种写法"</span>);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>写法补充<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(a);</div><div class="line">   &#125;(<span class="number">20</span>));</div><div class="line">   +<span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(b);</div><div class="line">   &#125;(<span class="number">30</span>);</div><div class="line">   -<span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(b);</div><div class="line">   &#125;(<span class="number">40</span>);</div></pre></td></tr></table></figure></p>
<p><strong>即时函数的传参和返回值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 接受参数</span></div><div class="line">   (<span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(str);           <span class="comment">//hello</span></div><div class="line">   &#125;)(<span class="string">"hello"</span>);</div><div class="line"></div><div class="line">   <span class="comment">//02 提供返回值并赋值给新的变量</span></div><div class="line">   <span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="number">2</span> + <span class="number">1</span>;</div><div class="line">   &#125;)();</div><div class="line">   <span class="built_in">console</span>.log(foo);           <span class="comment">//3</span></div></pre></td></tr></table></figure></p>
<p><strong>即时对象初始化</strong><br>01 结构特征:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">① 提供一个对象,在该对象内部提供一个init初始化方法</div><div class="line"></div><div class="line">② 使用()把对象包装起来(让字面量变成表达式)</div><div class="line"></div><div class="line">③ 然后随即调用init方法,完成初始化操作。</div></pre></td></tr></table></figure></p>
<p>02 基本结构<br><code>({}).init();</code></p>
<p>03 模式优点</p>
<pre><code>在执行一次性的初始化任务时保护全局的命名空间。
</code></pre><p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    (&#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"张三"</span>,</div><div class="line">        <span class="attr">age</span>:<span class="number">23</span>,</div><div class="line">        <span class="attr">getDescript</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"名字:"</span> + <span class="keyword">this</span>.name + <span class="string">"年龄:"</span> + <span class="keyword">this</span>.age);</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//注意:在对象中访问对象的属性和方法都需要使用this.前缀</span></div><div class="line">        init:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.getDescript();</div><div class="line">            <span class="comment">//其他的初始化处理</span></div><div class="line">        &#125;</div><div class="line">    &#125;).init();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>函数属性缓存</strong><br>思路说明</p>
<pre><code>01 函数是对象，因此可以在函数上面添加属性和方法
02 如果某个函数需要接受参数，可能会反复计算且在函数内部需要进行耗时的大量的逻辑处理才能得到结果
03 那么我们可以考虑把函数的参数，而计算得到的结果保存在函数对象中（函数的参数作为key,所得的结果作为value）
04 等需要获取参数对应指定结果的时候，考虑先去缓存中查找，如果有那么就直接使用，若没有则计算并保存一份到缓存中。
</code></pre><p>代码示例(单个参数)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">param</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (func.cache[param] == <span class="literal">undefined</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">var</span> result = <span class="string">"字符串"</span>; <span class="comment">//初始化值</span></div><div class="line">        <span class="comment">//...对result做复杂的计算</span></div><div class="line">        func.cache[param] = result + param;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> func.cache[param];</div><div class="line">&#125;</div><div class="line">func.cache = &#123;&#125;;    <span class="comment">//空对象</span></div><div class="line"><span class="built_in">console</span>.log(func(<span class="string">"demo"</span>));  <span class="comment">//字符串demo</span></div><div class="line"><span class="built_in">console</span>.log(func(<span class="string">"test"</span>));  <span class="comment">//字符串test</span></div><div class="line"><span class="built_in">console</span>.log(func(<span class="string">"demo"</span>));  <span class="comment">//字符串demo 直接使用属性缓存中的数据,而不再进行复杂的计算(可以提升性能)</span></div></pre></td></tr></table></figure></p>
<p>代码示例（多个参数）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> key = <span class="built_in">JSON</span>.stringify(<span class="built_in">Object</span>.prototype.slice.call(<span class="built_in">arguments</span>));</div><div class="line">    <span class="keyword">if</span> (func.cache[key] == <span class="literal">undefined</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">var</span> result = <span class="string">"字符串"</span>; <span class="comment">//初始化值</span></div><div class="line">        <span class="comment">//...对result做复杂的计算</span></div><div class="line">        func.cache[key] = result + key;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> func.cache[key];</div><div class="line">&#125;</div><div class="line">func.cache = &#123;&#125;;    <span class="comment">//空对象</span></div><div class="line">func(<span class="string">"123"</span>,<span class="string">"456"</span>);  <span class="comment">//</span></div><div class="line"><span class="comment">//说明:如果传入的参数数量超过1,则可以将传入的参数序列化为一个json字符串作为参数处理。</span></div></pre></td></tr></table></figure></p>
<p>代码说明：<br>slice:<code>返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素</code></p>
]]></content>
      
        
        <tags>
            
            <tag> 简明教程 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript简明教程（5）]]></title>
      <url>/2016/03/18/js-05/</url>
      <content type="html"><![CDATA[<p>JavaScript中有严格模式和非严格模式两种运行环境,本章节主要讲严格模式及非严格模式下函数和变量的区别,最后简单讲诉了JavaScript作用域。</p>
<h1 id="变量和函数"><a href="#变量和函数" class="headerlink" title="变量和函数"></a>变量和函数</h1><p><strong>私有变量和函数</strong></p>
<pre><code>定义在构造函数内部而被this对象的变量,在外部无法访问到的变量和函数
</code></pre><a id="more"></a>
<p><strong>公有变量和方法</strong></p>
<pre><code>对外暴露接口,可以通过构造函数对象创建的对象访问的属性和方法
</code></pre><p><strong>代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">type,number</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.type = type;   <span class="comment">//公共的属性</span></div><div class="line">        <span class="keyword">this</span>.number = number;</div><div class="line">        <span class="keyword">var</span> city = <span class="string">"广州"</span>;                <span class="comment">//私有变量</span></div><div class="line">        <span class="keyword">var</span> getNumber = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;       <span class="comment">//私有函数</span></div><div class="line">            <span class="keyword">return</span> number;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">var</span> getType = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> type;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//能够访问私有变量和函数的方法 --- 特权方法</span></div><div class="line">        <span class="keyword">this</span>.getDescription = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(getNumber() + getType() + city);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> car = <span class="keyword">new</span> Car(<span class="string">"汽车"</span>,<span class="string">"201718"</span>);</div><div class="line">    car.getDescription();</div></pre></td></tr></table></figure></p>
<p>说明：能够访问构造函数内部私有变量|函数的方法称之为特权方法</p>
<p><strong>构造函数的问题</strong><br>构造函数本身是一个函数，在调用的时候有多种调用方式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">① <span class="keyword">new</span> 构造函数（）调用</div><div class="line">② 构造函数（）调用</div></pre></td></tr></table></figure></p>
<p>以上，第二种调用方式存在作用域安全的问题</p>
<p><strong>作用域安全的构造函数</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="comment">//容错处理</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//设置实例属性和方法</span></div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02  创建对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">"zhangsan"</span>);</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">"lisi"</span>);</div><div class="line">    p1.showName();</div><div class="line">    p2.showName();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>新的问题</strong><br><code>说明</code>:上面的代码在使用借用构造函数方式继承的时候存在问题，无法创建出的对象，原因在于通过call或者是apply函数调用的时候，内部的this绑定的子类型中的对象，因此在使用instanceOf 判断的时候，结果为假。<br><code>解决</code>：可以设置让子类型（构造函数）的原型对象为父类型的一个实例。<br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="comment">//容错处理</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//设置实例属性和方法</span></div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02  创建对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">"zhangsan"</span>);</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">"lisi"</span>);</div><div class="line">    p1.showName();</div><div class="line">    p2.showName();</div><div class="line">    <span class="comment">// 使用借用构造函数来实现继承</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Boy</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">        Person.call(<span class="keyword">this</span>,name);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//需要结合原型继承来解决 instanceOf 实例对象检测的问题</span></div><div class="line">    Boy.prototype = <span class="keyword">new</span> Person();</div><div class="line">    <span class="keyword">var</span> boy = <span class="keyword">new</span> Boy(<span class="string">"测试的名字"</span>);</div><div class="line">    boy.showName();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><p>关键字 <code>“use strict”</code>;<br><strong>实现严格模式</strong>:只需要在脚本代码中添加上上述关键字即可。 关键字具体说明<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="number">1</span>) 注意区分大小写，必须全部都是小写的</div><div class="line">(<span class="number">2</span>) 注意空格，整个字符串总共<span class="number">10</span>个字符</div><div class="line">(<span class="number">3</span>) 单引号和双引号无所谓，但是需要有双引号</div><div class="line">(<span class="number">4</span>) 必须写在作用域的最顶部，注意其位置</div><div class="line">(<span class="number">5</span>) 可以加分号，也可以不加，但是必须是一个字符串</div></pre></td></tr></table></figure></p>
<p>注意：以下的关键字写法均是错误的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"USE strict"</span>;</div><div class="line"><span class="string">" use strict "</span>;</div><div class="line"><span class="string">"("</span>USE strict<span class="string">").toLowerCase();"</span></div></pre></td></tr></table></figure></p>
<h2 id="严格模式使用注意"><a href="#严格模式使用注意" class="headerlink" title="严格模式使用注意"></a>严格模式使用注意</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> 所有的变量必须使用<span class="keyword">var</span> 关键字声明</div><div class="line"><span class="number">2</span> 不能使用<span class="keyword">delete</span>关键字删除全局变量 ,以前默认删除失败,严格模式下直接报错</div><div class="line"><span class="number">3</span> 在对象中不允许有同名的属性</div><div class="line"><span class="number">4</span> 函数的参数必须唯一(不能出现同名的参数)</div><div class="line"><span class="number">5</span> <span class="built_in">arguments</span>对象的行为不同,在非严格模式下修改形参的值会反映到<span class="built_in">arguments</span>中,而严格模式下则相对独立</div><div class="line"><span class="number">6</span> 禁用了argument.callee和caller函数,他们一个引用函数本身,一个引用调用函数</div><div class="line"><span class="number">7</span> 不能在<span class="keyword">if</span>语句中声明函数</div><div class="line"><span class="number">8</span> 禁止使用<span class="built_in">eval</span>和<span class="built_in">arguments</span>作为标识符</div><div class="line"><span class="number">9</span> 修正<span class="keyword">this</span>的值,在严格模式下,函数<span class="keyword">this</span>的值始终是指定的值,无论指定的是什么值。</div><div class="line"><span class="number">10</span> 禁用了<span class="keyword">with</span>语句</div><div class="line"><span class="number">11</span> 去掉了JavaScript中的八进制字面量(以<span class="number">0</span>开头的八进制字面量是无效的语法)</div></pre></td></tr></table></figure>
<p><strong>1 所有的变量都必须使用var关键字声明</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">10</span>;             <span class="comment">//错误的演示</span></div><div class="line"><span class="built_in">console</span>.log(<span class="number">10</span>);</div></pre></td></tr></table></figure></p>
<p><strong>② 不能使用delete关键字删除全局变量</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在非严格模式下,删除失败(静默失败)   失败了不吭声,严格模式下直接报错</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">delete</span> a;</div><div class="line"><span class="built_in">console</span>.log(a);</div></pre></td></tr></table></figure></p>
<p><strong>③ 在对象中不允许有同名的属性</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在非严格模式下,会使用后面的属性赋值作为最终值,在严格模式下则直接报错</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"张三"</span>,</div><div class="line">    <span class="attr">name</span>:<span class="string">"李四"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj);</div></pre></td></tr></table></figure></p>
<p><strong>④ 函数的参数必须唯一(不能出现同名的参数)</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在非严格模式下,如果函数在定义的时候,使用了多个同名的参数,则在函数内部形参的实际值为最后一个传入的实参值</span></div><div class="line"><span class="comment">//在严格模式下,直接报错</span></div><div class="line"><span class="comment">//    function func(a,a,a) &#123;</span></div><div class="line"><span class="comment">//        console.log(a);</span></div><div class="line"><span class="comment">//        console.log(arguments);</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a,b,c</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div><div class="line">&#125;</div><div class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</div></pre></td></tr></table></figure></p>
<p><strong>arguments对象的行为不同</strong><br>说明：<br>（1）严格模式下,在函数内部修改了对象的指向,对arguments的值不会产生影响<br>（2）在严格模式下,形参的值和arguments的值是相互独立的,在函数内部修改了形参的值对arguments不受影响<br>（3）在非严格模式下，修改了形参的值，arguments中的数据会跟着改变<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">//测试引用类型的值作为函数的参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(obj);</div><div class="line">       <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">       <span class="comment">//在函数内部修改形参的值</span></div><div class="line">       obj = &#123;<span class="attr">age</span>:<span class="number">20</span>&#125;;</div><div class="line">       <span class="built_in">console</span>.log(obj);</div><div class="line">       <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">   &#125;</div><div class="line">   funcName(&#123;<span class="attr">name</span>:<span class="string">"张三"</span>&#125;);</div><div class="line">   <span class="comment">//测试基本类型数据作为函数的参数</span></div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(str);</div><div class="line">       <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">       str = <span class="string">"hello"</span>;</div><div class="line">       <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">   &#125;</div><div class="line">   fun(<span class="string">"hi"</span>);</div></pre></td></tr></table></figure></p>
<p><strong>⑥ 禁用了argument.callee和caller函数</strong><br>说明：<br>argument.callee是对函数自身的引用<br>argument.calller是对调用函数的引用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = (<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n ==<span class="number">1</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">arguments</span>.callee(n<span class="number">-1</span>) + n;</div><div class="line">    &#125;)(<span class="number">10</span>);</div><div class="line">    <span class="built_in">console</span>.log(num);       <span class="comment">//55</span></div></pre></td></tr></table></figure></p>
<p><strong>⑦ 不能在if语句中声明函数</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果在if语句中声明函数，则会产生语法错误</span></div><div class="line">  <span class="keyword">if</span> (<span class="literal">true</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"________"</span>);</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"呵呵呵呵"</span>);</div><div class="line">        &#125;</div><div class="line">        demo();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><strong>⑧ 禁止使用eval和argument作为标识符</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">eval</span> = <span class="string">"测试的字符串"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>);</div><div class="line"><span class="keyword">var</span> <span class="built_in">arguments</span> = <span class="string">"参数列表"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div></pre></td></tr></table></figure></p>
<p><strong>⑨ 修正this的值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">在严格模式下,函数<span class="keyword">this</span>的值始终是指定的值,无论指定的是什么值</div><div class="line"><span class="keyword">var</span> name = <span class="string">"测试的name"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demoTest</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//在非严格模式下,打印出来的this为全局的对象window</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">//在严格模式下打印出来的this为undefined</span></div><div class="line">&#125;</div><div class="line">demoTest();</div></pre></td></tr></table></figure></p>
<p><strong>⑩ 禁用了with语句</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"暂时干"</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;;</div><div class="line">  <span class="keyword">with</span>(o)</div><div class="line">  &#123;</div><div class="line">      name = <span class="string">"lisi"</span>;</div><div class="line">      age = <span class="number">48</span></div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(o);</div></pre></td></tr></table></figure></p>
<p><strong>禁用了八进制</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//以0开头的数据常常引起混乱</span></div><div class="line"><span class="comment">//var num = 023;     //2*8 + 3 ==&gt; 19</span></div><div class="line"><span class="comment">//console.log(num); //19</span></div></pre></td></tr></table></figure></p>
<p><strong>书写格式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">01 必须使用单引号或者是双引号括住字符串</div><div class="line">02 必须使用小写,不能出现大写字符</div><div class="line">03 必须是10个字符</div><div class="line">04 字符串后面的分号可以省略</div><div class="line">05 必须写在当前作用域的最顶上</div></pre></td></tr></table></figure></p>
<p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//"use strict";   //正确写法</span></div><div class="line">    <span class="comment">//"use strict"    //正确写法     分号可以省略</span></div><div class="line">    <span class="comment">//'use strict';   //正确写法     可以使用单引号</span></div><div class="line">    <span class="comment">//"use  strict";    //错误写法   必须是10个字符</span></div><div class="line">    <span class="comment">//"use Strict";     //错误写法   所有的字符都必须小写</span></div><div class="line"><span class="meta">    "use strict"</span>;</div><div class="line">    a = <span class="number">10</span>;</div><div class="line">    <span class="comment">//    "use strict";           //错误写法 必须写在当前作用域的顶端</span></div><div class="line">    b = <span class="number">20</span>;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>作用范围</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">① 函数的顶部(只对当前的函数有效)</div><div class="line">② script标签的顶部,只对当前的标签有效,对页面中其他的script无效</div></pre></td></tr></table></figure></p>
<p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//位置01       对func01和func02都有效</span></div><div class="line"> <span class="comment">//"use strict";</span></div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">func01</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="comment">//位置02   对func01有效,对func02无效</span></div><div class="line">     <span class="comment">//"use strict";</span></div><div class="line">     a = <span class="number">10</span>;</div><div class="line">     <span class="built_in">console</span>.log(a);</div><div class="line"> &#125;</div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">func02</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="comment">//位置03 对func02有效,但对func01无效</span></div><div class="line">    <span class="comment">//"use strict";</span></div><div class="line">     b = <span class="number">20</span>;</div><div class="line">     <span class="built_in">console</span>.log(b);</div><div class="line"> &#125;</div><div class="line">func01();</div><div class="line"> func02();</div></pre></td></tr></table></figure></p>
<p><strong>函数的几种调用方式</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">01</span> 普通函数调用 内部的<span class="keyword">this</span>指向全局对象<span class="built_in">window</span></div><div class="line"><span class="number">02</span> 构造函数调用 内部的<span class="keyword">this</span>指向新创建的对象</div><div class="line"><span class="number">03</span> 对象的方法调用 内部的<span class="keyword">this</span>指向调用的对象本身</div><div class="line"><span class="number">04</span> 通过call 或者是apply方式调用(函数上下文),<span class="keyword">this</span>指向的是当前的上下文对象</div></pre></td></tr></table></figure></p>
<p><strong>this丢失demo演示</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> obj = &#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"张三"</span>,</div><div class="line">        <span class="attr">getName</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//以对象的方法来进行调用</span></div><div class="line">    obj.getName();  <span class="comment">//张三</span></div><div class="line">    <span class="keyword">var</span> getName = obj.getName;</div><div class="line">    getName();  <span class="comment">//以普通函数的方式调用,此时内部的this指向的是window对象  打印的是window.name 为空值</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>代码示例02</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 获取页面中id值为demo的标签</span></div><div class="line">    <span class="comment">//var div = document.getElementById('demo');</span></div><div class="line"><span class="comment">//    var getId = document.getElementById;</span></div><div class="line"><span class="comment">//    var div = getId('demo');        //会报错?</span></div><div class="line"><span class="comment">//    console.log(div);</span></div><div class="line">    <span class="comment">//借用apply来修正this</span></div><div class="line">    <span class="built_in">document</span>.getElementById = (<span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">           <span class="keyword">return</span> func.apply(<span class="built_in">document</span>,<span class="built_in">arguments</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;)(<span class="built_in">document</span>.getElementById);</div><div class="line">    <span class="keyword">var</span> getId = <span class="built_in">document</span>.getElementById;</div><div class="line">    <span class="keyword">var</span> div = getId(<span class="string">'demo'</span>);        <span class="comment">//会报错?</span></div><div class="line">    <span class="built_in">console</span>.log(div);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>代码说明：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">01</span> 因为<span class="built_in">document</span>.getElementById方法的内部实现中需要使用到<span class="keyword">this</span>,这个<span class="keyword">this</span>本来期望指向的是<span class="built_in">document</span>对象</div><div class="line"><span class="number">02</span> 当我们以<span class="built_in">document</span>.getElementById来调用的时候,内部的<span class="keyword">this</span>指向<span class="built_in">document</span>对象</div><div class="line"><span class="number">03</span> 但是当我们以getId的方式调用的时候,内部的<span class="keyword">this</span>指向的是<span class="built_in">window</span>对象(因为我们以普通的方式进行调用)</div></pre></td></tr></table></figure></p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>变量其作用的范围就是它的作用域</p>
<p><strong>块级作用域</strong><br>说明：JavaScript中没有块级作用域<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">       <span class="keyword">var</span> num = i;</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">console</span>.log(i);</div><div class="line">   <span class="built_in">console</span>.log(num);</div><div class="line">   <span class="comment">//说明:如果有块级作用域,则i和num打印的结果应该为undefined</span></div></pre></td></tr></table></figure></p>
<p><strong>词法作用域</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">词法作用域:在代码写好的那一刻,变量的作用域就已经确定的</div><div class="line">动态作用域:变量的作用域由执行时的环境所决定</div><div class="line">说明:在js中不是动态作用域,当调用的时候,是往上查找的,不会到其他函数的作用域中去查找</div></pre></td></tr></table></figure></p>
<p><strong>在JavaScript中唯一能够产生作用域的东西是函数</strong><br>代码演示<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    var a = "这是第一个a";</div><div class="line">    function func01() &#123;</div><div class="line">        console.log(a);         //先在当前作用域中查找,如果没有则访问全局的作用域</div><div class="line">    &#125;</div><div class="line">    function func02() &#123;</div><div class="line">        var a = "这是第二个a";</div><div class="line">        func01()</div><div class="line">    &#125;</div><div class="line">    func01();       //打印结果为:这是第一个a</div><div class="line">    func02();       //打印结果为:这是第一个a</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    var a = "这是第一个a";</div><div class="line">    function func02() &#123;</div><div class="line">        var a = "这是第二个a";</div><div class="line">        func01()</div><div class="line">    &#125;</div><div class="line">    function func01() &#123;</div><div class="line">        console.log(a);         //先在当前作用域中查找,如果没有则访问全局的作用域</div><div class="line">    &#125;</div><div class="line">    func01();       //打印结果为:这是第一个a</div><div class="line">    func02();       //打印结果为:这是第一个a</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p><strong>词法作用域的规则</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">① 在函数内部允许访问外部的变量</div><div class="line">② 只有函数可以限定作用域</div><div class="line">③ 作用域规则首先使用提升规则分析</div><div class="line">④ 如果当前作用域中有该变量,则不考虑外部作用域的同名变量</div></pre></td></tr></table></figure></p>
<h2 id="变量和函数提升"><a href="#变量和函数提升" class="headerlink" title="变量和函数提升"></a>变量和函数提升</h2><p><strong>JS中的代码执行分为两个步骤</strong><br>① 预解析<br>JavaScript在预解析阶段,会对使用var关键字声明的变量和function声明的代码块进行提升操作,提升到当前作用域的顶端<br>② 执行</p>
<p><strong>代码提升的几种情况</strong></p>
<p><strong>01 函数提升</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    func();</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"测试的函数"</span>);</div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>02 变量提升</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="built_in">console</span>.log(a);     <span class="comment">//打印出来的结果为undefined</span></div><div class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line">    <span class="comment">//var a;                //注意:只会对变量的声明进行提升</span></div><div class="line">    <span class="comment">//console.log(a);</span></div><div class="line">    <span class="comment">//a = 10</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>03 函数同名情况提升</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    func01();                   <span class="comment">//打印last</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func01</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"first"</span>);</div><div class="line">    &#125;</div><div class="line">    func01();                   <span class="comment">//打印last</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func01</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"last"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//模拟提升后的情况</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func01</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"first"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func01</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"last"</span>);</div><div class="line">    &#125;</div><div class="line">    func01();</div><div class="line">    func01();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>说明：<code>预处理的时候，同名的函数都会进行提升，但是后面的会覆盖掉前面的</code></p>
<p><strong>04 变量名和函数同名的情况</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="built_in">console</span>.log(a);                     <span class="comment">//打印function</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"我是一个函数"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</div><div class="line">    <span class="built_in">console</span>.log(a);                     <span class="comment">//打印20</span></div><div class="line">    <span class="comment">//变量和函数提升后的结果 错误</span></div><div class="line"><span class="comment">//    function a() &#123;</span></div><div class="line"><span class="comment">//        console.log("我是一个函数");</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line"><span class="comment">//    var a ;</span></div><div class="line"><span class="comment">//    console.log(a);</span></div><div class="line"><span class="comment">//    a = 20;</span></div><div class="line"><span class="comment">//    console.log(a);</span></div><div class="line">    <span class="comment">//变量和函数提升后的结果 正确</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"我是一个函数"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line"><span class="string">``</span><span class="string">`js</span></div><div class="line">总结:如果出现变量和函数同名的情况,则在进行提升的时候,只会提升函数到当前作用域顶端而忽略变量的提升操作</div><div class="line"></div><div class="line">**变量的提升是分作用域的**</div><div class="line">示例代码01</div><div class="line">`<span class="string">``</span>js</div><div class="line">&lt;script&gt;</div><div class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//undefined</span></div><div class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line">    <span class="comment">//模拟提升</span></div><div class="line">    <span class="keyword">var</span> a;</div><div class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//undefined</span></div><div class="line">    a = <span class="number">10</span>;</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>示例代码02<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> num = <span class="number">20</span>;</div><div class="line">        <span class="built_in">console</span>.log(num);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(num);   <span class="comment">//10</span></div><div class="line">    func();             <span class="comment">//20</span></div><div class="line">    <span class="comment">//模拟提升</span></div><div class="line">    <span class="keyword">var</span> num;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> num;</div><div class="line">        num = <span class="number">20</span>;</div><div class="line">        <span class="built_in">console</span>.log(num);</div><div class="line">    &#125;</div><div class="line">    num = <span class="number">10</span>;</div><div class="line">    <span class="built_in">console</span>.log(num);   <span class="comment">//10</span></div><div class="line">    func();             <span class="comment">//20</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p>示例代码03<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(num);</div><div class="line">    <span class="keyword">var</span> num = <span class="number">20</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(num);   <span class="comment">//10</span></div><div class="line">func();             <span class="comment">//undefiend</span></div><div class="line"><span class="comment">//模拟提升</span></div><div class="line"><span class="keyword">var</span> num;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num;</div><div class="line">    <span class="built_in">console</span>.log(num);</div><div class="line">    num = <span class="number">20</span>;</div><div class="line">&#125;</div><div class="line">num = <span class="number">10</span>;</div><div class="line"><span class="built_in">console</span>.log(num);   <span class="comment">//10</span></div><div class="line">func();             <span class="comment">//undefiend</span></div></pre></td></tr></table></figure></p>
<p>示例代码04<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(num);</div><div class="line">    num = <span class="number">20</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(num);   <span class="comment">//10</span></div><div class="line">func();             <span class="comment">//10</span></div><div class="line"><span class="comment">//模拟变量提升</span></div><div class="line"><span class="keyword">var</span> num;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(num);</div><div class="line">    num = <span class="number">20</span>;</div><div class="line">&#125;</div><div class="line">num= <span class="number">10</span>;</div><div class="line"><span class="built_in">console</span>.log(num);   <span class="comment">//10</span></div><div class="line">func();             <span class="comment">//10</span></div><div class="line"><span class="built_in">console</span>.log(num);   <span class="comment">//20</span></div></pre></td></tr></table></figure></p>
<p><strong>函数表达式的提升</strong><br>说明：在使用函数表达式方式创建函数的时候,整个函数表达式并不会进行提升,只会对var声明的变量提升<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func();</div><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"会不会被调用"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//以上如上代码将报错</span></div><div class="line"><span class="comment">//模拟提升的过程</span></div><div class="line"><span class="keyword">var</span> func;</div><div class="line">func();                 <span class="comment">//找不到这个函数</span></div><div class="line">func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"会不会被调用"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><pre><code>01 在js中函数可以创建作用域
02 函数中又可以创建函数(即又可以开辟新的作用域)
03 函数内部的作用域可以访问外部的作用域
04 如果有多个函数嵌套,那么就会构成一个链式的访问结构,也就是作用域链
05 注意:函数内部的作用域可以访问外部的作用域,但是外部的作用域却不能访问内部的作用域
</code></pre><p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//f1---&gt;全局作用域</span></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">//f4--&gt;f1---&gt;全局作用域</span></div><div class="line">            <span class="function"><span class="keyword">function</span> <span class="title">f5</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//f2--&gt;全局作用域</span></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f6</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<h1 id="作用域链绘图"><a href="#作用域链绘图" class="headerlink" title="作用域链绘图"></a>作用域链绘图</h1><p>说明</p>
<pre><code>① 先画出全局作用域线条，然后在上面添加全局作用域中的函数和变量，作为0级作用域链
② 画出全局作用域中的函数的作用域线条，，然后在上面添加当前作用域中的函数和变量，作为1级作用域链
③ 以此类推，直至完成
</code></pre><p>示例代码01<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><code>图示</code><br><img src="/assets/img/Snip20170217_4.png" alt=""></p>
<p>示例代码02<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="function"><span class="keyword">function</span> <span class="title">f5</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> b = <span class="string">"demo"</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> c = <span class="string">"啊哈哈"</span>;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> d = <span class="string">"test"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><code>图示</code><br><img src="/assets/img/Snip20170217_3.png" alt=""></p>
<h2 id="作用域注意点和变量搜索原则"><a href="#作用域注意点和变量搜索原则" class="headerlink" title="作用域注意点和变量搜索原则"></a>作用域注意点和变量搜索原则</h2><p><strong>注意点</strong></p>
<pre><code>01 在获取值和设置值的时候都是访问变量
02 并非在函数内部写了变量,这个变量就属于当前函数,而是必须使用var 关键字声明的变量才属于当前函数
03 函数在声明的时候,里面的代码并不会执行,只有在函数调用的时候才会执行
04 声明函数时候的函数名,其实也是一个变量名,可以通过这个变量名来进行设置和赋值
05 注意:在变量内部使用var 关键字声明一个变量并不会把同名的全局变量覆盖掉
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">var</span> a = <span class="number">20</span>;              <span class="comment">//注意:该行代码并不会覆盖掉全局变量中的变量a</span></div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">&#125;</div><div class="line">f1();               <span class="comment">//20</span></div><div class="line"><span class="built_in">console</span>.log(a);     <span class="comment">//10</span></div></pre></td></tr></table></figure>
<p>代码点评：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在函数中使用var关键字声明变量a并不会覆盖全局作用域中的a。</div><div class="line">注意需要同时考虑变量在当前作用域的提升以及访问变量时的搜索原则。</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f1 = <span class="string">"demo字符串"</span>;         <span class="comment">//该行代码会把f1函数覆盖掉</span></div><div class="line">f1 = <span class="string">"demoTest字符串"</span>;</div><div class="line"><span class="built_in">console</span>.log(f1);</div><div class="line"><span class="comment">//f1();</span></div></pre></td></tr></table></figure>
<p>代码点评:<br><code>函数的名称也是变量，如果在代码中出现同名的变量，那么函数的实现会被覆盖掉</code></p>
<p> <strong>变量搜索原则</strong></p>
<pre><code>01 在使用变量的时候,首先在自己的作用域中查找
02 如果找到了就直接使用,如果没有找到,那么就到上一级作用域中去查找
03 重复上面的步骤,直到0级作用域,如果还是找不到那么就返回undefined(报错)
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> 简明教程 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript简明教程（4）]]></title>
      <url>/2016/03/05/js-04/</url>
      <content type="html"><![CDATA[<p>本章节主要讲解了原型链及相关方法。</p>
<h1 id="原型链及相关属性方法简单说明"><a href="#原型链及相关属性方法简单说明" class="headerlink" title="原型链及相关属性方法简单说明"></a>原型链及相关属性方法简单说明</h1><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><strong>代码示例</strong><br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供Person构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02 设置Person的原型对象</span></div><div class="line">    Person.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//03 创建Student构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">number</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.numer = number</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//04 设置Student的原型对象</span></div><div class="line">    Student.prototype = <span class="keyword">new</span> Person();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>原型链图示例</strong><br><img src="/assets/img/Snip20170213_10.png" alt="原型"></p>
<h2 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h2><p><strong>Object构造函数</strong><br>01 使用Object构造函数创建字符串对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 创建字符串对象</span></div><div class="line"><span class="keyword">var</span> str1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"测试字符串"</span>);</div><div class="line"><span class="keyword">var</span> str2 = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">"测试字符串"</span>);</div><div class="line"><span class="keyword">var</span> str3 = str1;</div><div class="line"><span class="comment">//注意:对象比较相等(需要引用[地址]相等)</span></div><div class="line"><span class="built_in">console</span>.log(str1 == str2);      <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(str1 === str2);     <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(str1 === str3);     <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>02 使用Object构造函数创建数字对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">10</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);    <span class="comment">//object</span></div></pre></td></tr></table></figure></p>
<p>03 使用Object构造函数创建布尔类型对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bool = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="literal">true</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> bool);   <span class="comment">//object</span></div></pre></td></tr></table></figure></p>
<p><strong>js中所有的内置或自定义对象都继承自Object对象,几乎所有的对象都可以使用Object.prototype上面的属性和方法</strong></p>
<h2 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h2><p>01 因为js中所有的对象都继承自Obejct,都可以使用Object对象的原型属性和方法,因此不要轻易的扩展Object.prototype。<br>02 Object.property中的属性和方法</p>
<pre><code>① constructor 指向原型相关联的构造函数，为Object
② hasOwnProperty 判断对象中是否拥有某个实例属性(不包括原型链上面的属性)
③ isPrototypeOf  校验某个对象是否是指定对象的原型对象(整条原型链)
④ propertyIsEnumerable 属性是否存在且可枚举(使用for循环可以遍历,即目标属性能否在for循环中显示出来)
⑤ toString() 返回一个描述目标对象的字符串,对象则返回[object object]
   toString(参数) 参数出可以传入一个用于进制数的参数,该参数的默认值为10(主要针对Number类型有效)
⑥ toLocaleString 同toString,但是会做一些本地化的处理。
⑦ valueOf()  如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。
   Date对象调用该方法会返回一个时间戳。
</code></pre><p><strong>constructor</strong><br>说明：该属性指向创建该对象的构造函数，在这里为Object<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line">   <span class="built_in">console</span>.log(p.constructor);                     <span class="comment">//function Person() &#123;&#125;</span></div><div class="line">   <span class="built_in">console</span>.log(Person.prototype.constructor);      <span class="comment">//function Person() &#123;&#125;</span></div><div class="line">   <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.constructor);      <span class="comment">//function Object() &#123; [native code] &#125;</span></div></pre></td></tr></table></figure></p>
<p><strong>hasOwnProperty</strong><br>说明：判断对象中是否拥有某个实例属性(不包括原型链上面的属性)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"默认的姓名"</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//检查对象中是否拥有指定的属性(实例属性)</span></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">p1.hasOwnProperty(<span class="string">"name"</span>);  <span class="comment">//true</span></div><div class="line">p1.hasOwnProperty(<span class="string">"age"</span>);   <span class="comment">//false</span></div><div class="line">p1.hasOwnProperty(<span class="string">"constructor"</span>);   <span class="comment">//对象的constructor是从原型对象上继承的</span></div></pre></td></tr></table></figure></p>
<p><strong>isPrototypeOf</strong><br>说明：校验某个对象是否是指定对象的原型对象(整条原型链);<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> obj = &#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"张三"</span>,</div><div class="line">        <span class="attr">age</span>:<span class="number">20</span>,</div><div class="line">        <span class="attr">hello</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">showName</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//属性是否存在且可以枚举</span></div><div class="line">    <span class="built_in">console</span>.log(obj.propertyIsEnumerable(<span class="string">"name"</span>));      <span class="comment">//true</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>toString</strong><br>说明：返回一个描述目标对象的字符串,对象则返回[object object]<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    <span class="built_in">console</span>.log(obj.toString());  <span class="comment">//打印[object Object]</span></div><div class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line">    <span class="built_in">console</span>.log(arr.toString());    <span class="comment">//打印1,2,3,4,5</span></div><div class="line">    <span class="keyword">var</span> num = <span class="number">10</span>;</div><div class="line">    <span class="built_in">console</span>.log(num.toString());               <span class="comment">//10</span></div><div class="line">    <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">    <span class="built_in">console</span>.log(date.toString());           <span class="comment">//Mon Feb 13 2017 19:00:13 GMT+0800 (CST)</span></div><div class="line">    <span class="comment">//toString方法可以传入参数,在处理Number类型数据的时候,可以传入指定的进制</span></div><div class="line">    <span class="built_in">console</span>.log(num.toString(<span class="number">2</span>));       <span class="comment">//1010  == 1*2*2*2+0*2*2+1*2+1*1 = 10</span></div><div class="line">    <span class="built_in">console</span>.log(num.toString(<span class="number">3</span>));       <span class="comment">//101   == 1*3*3 + 0*3 + 1*1 = 10</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>toLocaleString</strong><br>说明：作用同toString方法一致，但是会做一些本地化的处理.</p>
<p><strong>valueOf</strong><br>说明：<br>① 如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。<br>② 如果是Date类型，则返回时间戳。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    <span class="built_in">console</span>.log(obj + <span class="number">1</span>);       <span class="comment">//[object Object]1</span></div><div class="line">    <span class="comment">//说明:如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。</span></div><div class="line">    <span class="keyword">var</span>  o = &#123;<span class="attr">name</span>:<span class="string">"张三"</span>&#125;;</div><div class="line">    <span class="built_in">console</span>.log(o + <span class="number">1</span>); <span class="comment">//[object Object]1</span></div><div class="line">    <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">    <span class="built_in">console</span>.log(date.valueOf());        <span class="comment">//1486984088998</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="静态成员和实例成员"><a href="#静态成员和实例成员" class="headerlink" title="静态成员和实例成员"></a>静态成员和实例成员</h2><p><strong>静态成员</strong><br>    定义在构造函数上面的成员(属性和方法)</p>
<p><strong>实例成员</strong><br>    定义在实例对象上面的成员(属性和方法)</p>
<p><strong>建议</strong></p>
<pre><code>① 把工具类的方法写成静态方法
② 把和对象相关的方法写成实例方法(成员)
</code></pre><p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = <span class="string">"张三"</span>;   <span class="comment">//实例属性</span></div><div class="line">        <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//为Person构造函数添加静态成员</span></div><div class="line">    Person.des = <span class="string">"描述信息"</span>;</div><div class="line">    Person.add = <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"添加信息"</span> + msg);</div><div class="line">    &#125;;</div><div class="line">    Person.add(<span class="string">"这是一个+操作"</span>);</div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    p1.showName();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<h2 id="Function构造函数"><a href="#Function构造函数" class="headerlink" title="Function构造函数"></a>Function构造函数</h2><p><strong>函数创建的几种方式</strong><br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">01</span> 函数声明</div><div class="line"><span class="number">02</span> 字面量的方式创建</div><div class="line"><span class="number">03</span> 使用<span class="keyword">new</span> <span class="built_in">Function</span>的形式创建</div></pre></td></tr></table></figure></p>
<p> <strong>函数创建代码示例</strong><br> <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func01</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"函数声明"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> func02 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"字面量方式创建"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//使用Function构造函数创建</span></div><div class="line">  <span class="keyword">var</span> func03 = <span class="keyword">new</span> <span class="built_in">Function</span>();</div></pre></td></tr></table></figure></p>
<p><strong>Function构造函数创建函数</strong><br>  参数说明:可以传入多个参数<br>  最后一个参数:<code>传入的最后一个参数为函数的函数体内容</code><br>  其他参数:创建出来的函数的参数<br>  如果只有一个参数,则表示这是该函数的函数体内容<br>  传递参数的格式:以字符串的方式进行传参<br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//需求01 使用Function构造函数创建一个函数对象,该函数执行一行打印操作</span></div><div class="line"><span class="keyword">var</span> funcName01 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"console.log('让我掉下眼泪的,不止昨夜的酒')"</span>);</div><div class="line">funcName01();</div><div class="line"><span class="comment">//需求02 使用Function构造函数创建一个函数对象,该函数需要接受两个参数,要求返回他们的和</span></div><div class="line"><span class="keyword">var</span> funcName02 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"return a + b;"</span>);</div><div class="line"><span class="built_in">console</span>.log(funcName02(<span class="number">10</span>, <span class="number">20</span>));    <span class="comment">//30</span></div></pre></td></tr></table></figure></p>
<p><strong>解决函数体代码过长的问题</strong><br>（1）使用转义字符，写在一行中<br>（2）使用+操作符来拼接字符串<br>（3）使用``操作符来管理字符串<br>（4）使用模板先处理字符串，然后在js中获得模板中的内容</p>
<h2 id="arguments、length和callee"><a href="#arguments、length和callee" class="headerlink" title="arguments、length和callee"></a>arguments、length和callee</h2><p><strong>arguments参数</strong><br>说明：在js中的函数中，有两个隐藏的参数分别是this和arguments<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">arguments</span> 是一个类似数组的结构,可以通过下标来操作函数的参数,但并非数组类型的。</div><div class="line">在函数调用的时候,会将函数的所有参数都传入<span class="built_in">arguments</span>对象中保存,因此我们可以通过操作<span class="built_in">arguments</span>属性来操作参数</div><div class="line">形参的数量大于实参的数量,则依次传入,未传入的设置为<span class="literal">undefined</span></div><div class="line">形参的数量小于实参的数量,则<span class="built_in">arguments</span>中保存实际的值</div></pre></td></tr></table></figure></p>
<p><strong>length</strong></p>
<pre><code>函数内部的arguments数组拥有length属性,可以通过该属性获取用户调用时传入的实参的个数

函数本身有一个length属性,可以通过该属性来获取形式参数的个数
</code></pre><p><strong>callee方法</strong></p>
<pre><code>函数内部的arguments对象中,有一个callee方法,该方法指向函数自身,常用于匿名函数的递归调用。
</code></pre><p><strong>代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div><div class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);  <span class="comment">//调用函数时实际传入的参数数量</span></div><div class="line">    &#125;</div><div class="line">    func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</div><div class="line">    <span class="built_in">console</span>.log(func.length);           <span class="comment">//预期的参数数量 —— 函数的形参数量</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func02</span>(<span class="params">a,b</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(a, b);</div><div class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</div><div class="line">    &#125;</div><div class="line">    func02(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);  <span class="comment">//实参的数量 &gt; 形参的数量 则arguments保存实参的值</span></div><div class="line">    func02(<span class="number">1</span>);      <span class="comment">//实参的数量 &lt; 形参的数量 则不足的补undefined</span></div><div class="line">    <span class="comment">//匿名函数调用</span></div><div class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//如果需要在该函数中调用自身,则可以使用arguments.callee方法</span></div><div class="line">        <span class="built_in">arguments</span>.callee();</div><div class="line">    &#125;)();</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<h2 id="Function的应用"><a href="#Function的应用" class="headerlink" title="Function的应用"></a>Function的应用</h2><p><strong>01 数组去重</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">var</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"arr"</span>,<span class="string">`</span></div><div class="line">    var array = [];</div><div class="line">    for(var i = 0 ; i&lt;arr.length; i++)</div><div class="line">    &#123;</div><div class="line">        if(array.indexOf(arr[i]) == -1)</div><div class="line">        &#123;</div><div class="line">            array.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return array;</div><div class="line">`);</div><div class="line">    <span class="built_in">console</span>.log(func([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>]));;</div></pre></td></tr></table></figure></p>
<p><strong>02 返回传入函数中所有数据的最大值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> maxNumber = <span class="built_in">arguments</span>[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (maxNumber &lt; <span class="built_in">arguments</span>[i])</div><div class="line">        &#123;</div><div class="line">            maxNumber = <span class="built_in">arguments</span>[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxNumber;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">30</span>, <span class="number">21</span>));</div></pre></td></tr></table></figure></p>
<h2 id="eval-简单说明"><a href="#eval-简单说明" class="headerlink" title="eval 简单说明"></a>eval 简单说明</h2><p><strong>eval 的基本使用</strong><br>eval函数用来讲字符串转换为JS的代码,并执行</p>
<p><strong>eval 处理JSON数据代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> jsonData = <span class="string">'&#123;"name":"张三","age":18&#125;'</span>;</div><div class="line">    <span class="comment">//把json的数据转换为对象</span></div><div class="line">    <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(jsonData);</div><div class="line">    <span class="built_in">console</span>.log(obj);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> jsonData = <span class="string">'&#123;"name":"张三","age":18&#125;'</span>;</div><div class="line">    <span class="comment">//var obj = eval(jsonData); //注意:如果直接这样写代码则会报错</span></div><div class="line">    <span class="comment">//正确的处理方式</span></div><div class="line">    <span class="comment">//方式一</span></div><div class="line">    <span class="built_in">eval</span>(<span class="string">"var obj = "</span> + jsonData);</div><div class="line">    <span class="built_in">console</span>.log(obj);</div><div class="line">    <span class="comment">//方式二</span></div><div class="line">    <span class="comment">//说明:使用eval来解析json格式字符串的时候,会将&#123;&#125;解析为代码块,而不是字面量</span></div><div class="line">    <span class="comment">// 在使用的时候为了避免这种错误,需要在JSO的最外面加上(),如此则会把大括号当做一条语句来解析</span></div><div class="line">    <span class="keyword">var</span> o = <span class="built_in">eval</span>(<span class="string">"("</span>+jsonData+<span class="string">")"</span>);</div><div class="line">    <span class="built_in">console</span>.log(o);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p><strong>eval 注意事项</strong></p>
<pre><code>① eval函数本身功能强大,但它的特性也为程序带来了很大的不确定性,因此在开发中并不推荐使用。
② eval函数是动态的执行代码,因此其效率不如直接执行静态脚本高。
</code></pre><p><strong>eval和Function比较</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">相同点:都能够把字符串转换为Javascript的代码</div><div class="line">不同点:eval转换为js的代码之后马上就执行,而Function需要先创建函数,调用函数之后才会执行。</div></pre></td></tr></table></figure></p>
<h2 id="Function-prototype原型链"><a href="#Function-prototype原型链" class="headerlink" title="Function.prototype原型链"></a>Function.prototype原型链</h2><p><strong>关于Function和自定义构造函数的原型对象</strong></p>
<pre><code>Function.prototype 是一个空的函数
自定义构造函数的原型对象是一个空的对象
</code></pre><p>说明</p>
<pre><code>Function也可以被当做是一个构造函数
通过new Function创建出来的函数,可以认为是Function的实例化对象。
Function的原型对象是一个空的函数,这个空的函数也是一个对象,它的原型对象是Object.prototype。
在JS中,Object的原型对象是所有对象的祖宗。

Function是构造函数,则其原型对象为空的函数
        空的函数的原型对象为Object.prototype
Function本身也是对象,则其构造函数为:function Function() { [native code] }  是自身
同Object类型
Object本身是构造函数,其原型对象是Object.prototype
Object本身也是对象,其构造函数为:function Function() { [native code]
</code></pre><p><strong>代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提供Person构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02 设置Person的原型对象</span></div><div class="line">    Person.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//03 创建Student构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">number</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.numer = number</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//04 设置Student的原型对象</span></div><div class="line">    Student.prototype = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure></p>
<p><strong>完整的原型链示意图</strong><br><img src="/assets/img/Snip20170213_12.png" alt="原型"><br><strong>Object和Function的关系</strong><br>01 Object构造函数是通过Function构造函数实例化出来的<br>02 Function构造函数也是通过Function构造函数实例化出来的</p>
<p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//检查对象是否是某个构造函数的实例</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);</div><div class="line">    <span class="comment">//注意:以上打印结果均为true</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="对象的拷贝操作"><a href="#对象的拷贝操作" class="headerlink" title="对象的拷贝操作"></a>对象的拷贝操作</h2><p><strong>浅拷贝</strong><br>如果对象中的属性是引用类型的值,那么存在数据共享问题,修改某个对象会对拷贝的对象产生影响<br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"张三"</span>,<span class="attr">car</span>:&#123;<span class="attr">number</span>:<span class="string">"2017"</span>,<span class="attr">type</span>:<span class="string">"火车"</span>&#125;&#125;;</div><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="comment">//obj对象需要拷贝o对象中所有的属性</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> o )&#123;</div><div class="line">    obj[i]  = o[i];</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(obj);</div><div class="line">o.car.type = <span class="string">"飞船"</span>;</div><div class="line"><span class="built_in">console</span>.log(obj);</div></pre></td></tr></table></figure></p>
<p><strong>深拷贝</strong></p>
<pre><code>如果对象中的属性是值类型,那么就直接拷贝赋值
如果对象中的属性是引用类型,那么就再次调用拷贝方法,遍历对象
</code></pre><p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"张三"</span>,<span class="attr">car</span>:&#123;<span class="attr">number</span>:<span class="string">"2017"</span>,<span class="attr">type</span>:<span class="string">"火车"</span>&#125;&#125;;</div><div class="line"> <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj,tmp</span>) </span>&#123;</div><div class="line">     tmp = tmp || &#123;&#125;;    <span class="comment">//如果没有传入,那么就创建一个空的对象</span></div><div class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)</div><div class="line">     &#123;</div><div class="line">         <span class="keyword">if</span> (obj.hasOwnProperty(i))   <span class="comment">//只拷贝实例属性</span></div><div class="line">         &#123;</div><div class="line">             <span class="comment">//判断是否是引用类型</span></div><div class="line">             <span class="keyword">if</span> ((<span class="keyword">typeof</span> obj[i]) == <span class="string">'object'</span>)</div><div class="line">             &#123;</div><div class="line">                 <span class="comment">//重新调用拷贝方法</span></div><div class="line">                 tmp[i] = <span class="built_in">Array</span>.isArray(obj[i]) ? [] :&#123;&#125;;</div><div class="line">                 deepCopy(obj[i],tmp[i]);</div><div class="line">             &#125;<span class="keyword">else</span></div><div class="line">             &#123;</div><div class="line">                 <span class="comment">//直接拷贝</span></div><div class="line">                 tmp[i] = obj[i];</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line">deepCopy(o,obj);</div><div class="line"> <span class="built_in">console</span>.log(obj);</div><div class="line"> o.car.type = <span class="string">"测试的类型"</span>;</div><div class="line"> <span class="built_in">console</span>.log(obj);</div><div class="line"> <span class="built_in">console</span>.log(o);</div></pre></td></tr></table></figure></p>
<p><strong>注意isArray的兼容性问题</strong><br>isArray是ECMA5中新推出的方法,需要处理兼容性问题<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray != <span class="string">"function"</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) == <span class="string">'[object Array]'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Number原型扩展"><a href="#Number原型扩展" class="headerlink" title="Number原型扩展"></a>Number原型扩展</h2><p>小案例：在Number的原型对象上面定义一个新的方法add(),该方法接收一个参数,并将该参数与自身的值进行相加,然后进行返回。<br>代码实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span> + num;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> n = <span class="number">10</span>;</div><div class="line"><span class="built_in">console</span>.log(n.add(<span class="number">3</span>));</div><div class="line"><span class="comment">//console.log(5.add(5));  错误:解析器无法处理字面量的这种情况</span></div><div class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">50</span>);</div><div class="line"><span class="built_in">console</span>.log(num.add(<span class="number">20</span>));       <span class="comment">//70</span></div><div class="line"><span class="built_in">console</span>.log((<span class="number">1</span>).add(<span class="number">4</span>));        <span class="comment">//5 使用()把数字包起来</span></div></pre></td></tr></table></figure></p>
<p>使用注意<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">（01）使用数字变量可以调用成功</div><div class="line">（02）使用数字表达式可以调用成功</div><div class="line">（03）直接使用数字字面量方式调用失败</div></pre></td></tr></table></figure></p>
<p>js的语法解析器无法处理数字字面量这种情况。</p>
<h2 id="With语句"><a href="#With语句" class="headerlink" title="With语句"></a>With语句</h2><p><strong>with语句简单介绍</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">with语句是js中一个强大但有争议的特性。</div><div class="line">with语句允许我们将一个对象的所有属性引用到当前的作用域</div><div class="line">允许我们无需使用拥有者对象的前缀，就可以直接对这些属性进行引用和赋值操作。</div></pre></td></tr></table></figure></p>
<p><code>注意</code>：ECMAScript5规范在严格模式下已经禁用了该语句，在开发中不推荐使用，但是要求能够看懂with的代码。</p>
<p><strong>with语句内部细节</strong><br><code>说明</code>： with语句会创建一个作用域，在该作用域内，在引用特定对象的属性时，可以不使用前缀。<br>应用场景：<code>对深层级对象的引用进行缩短</code>。</p>
<p><strong>在with作用域内部引用属性</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">//[01] 测试with语句作用域内对对象属性的引用</span></div><div class="line">    <span class="comment">//01 提供全局变量,名称为testValue</span></div><div class="line">    <span class="keyword">var</span> testValue = <span class="string">'测试使用的全局变量'</span>;</div><div class="line">    <span class="comment">//02 提供对象,对象内部提供属性</span></div><div class="line">    <span class="keyword">var</span> testObject = &#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">'对象的名称属性'</span>,</div><div class="line">        <span class="attr">testValue</span>:<span class="string">'对象内部的属性'</span></div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//03 使用with语句引用</span></div><div class="line">    <span class="keyword">with</span>(testObject)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">console</span>.log(name);          <span class="comment">//对象的名称属性</span></div><div class="line">        <span class="built_in">console</span>.log(testValue);     <span class="comment">//对象内部的属性</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);          <span class="comment">//window</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(testValue);         <span class="comment">//测试使用的全局变量</span></div><div class="line"><span class="string">``</span><span class="string">`   </span></div><div class="line">总结：</div><div class="line">(1) 在with语句作用域内,对象属性的优先级绝对高于在更层级作用域内定义的同名变量</div><div class="line">(2) this(函数上下文)依然指向window,并不会收到with作用域的影响</div><div class="line"></div><div class="line">**在with作用域内进行赋值操作**</div><div class="line">`<span class="string">``</span>js</div><div class="line">   <span class="comment">//01 提供一个对象,在内部提供属性</span></div><div class="line">    <span class="keyword">var</span> obj = &#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">'对象的内部属性'</span>,</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02 with语句测试对对象属性的赋值操作</span></div><div class="line">    <span class="keyword">with</span>(obj)</div><div class="line">    &#123;</div><div class="line">        name = <span class="string">'修正对象中name的值'</span>;</div><div class="line">        <span class="comment">//在作用域内部添加变量(思考?该变量是添加为全局作用域还是当前obj对象的属性?)</span></div><div class="line">        age = <span class="string">'25'</span>;</div><div class="line">        showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'name == '</span> + name);</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//测试修改对象属性操作</span></div><div class="line">    <span class="built_in">console</span>.log(obj.name);</div><div class="line">    <span class="comment">//测试添加对象属性操作</span></div><div class="line">    <span class="built_in">console</span>.log(obj.age);             <span class="comment">//undefined</span></div><div class="line">    <span class="comment">//obj.showName();                 //obj.showName is not a function    console.log('____________________');</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//== name == window.name</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.name);</div><div class="line">    <span class="built_in">console</span>.log(name);</div><div class="line">    showName();             <span class="comment">//==this.showName() ==window.showName()</span></div></pre></td></tr></table></figure></p>
<p>总结：<br>（1）在with作用域的内部我们可以使用无前缀引用对象的属性进行读取和赋值的操作 但是 不能使用无前缀的方式添加属性<br>（2）如果使用无前缀的方式来添加属性[对不存在的属性进行赋值操作],那么属性将被添加到全局上下文[window|this]<br>（3）可能产生的错误:意外的引入一个全局变量,而非为with作用域对象添加属性</p>
<p><strong>with语句的问题</strong><br>（1）with作用域内操作优先级混乱<br>（2）性能不好，会大大降低js代码的执行性能<br>（3）ECMAScript5规定在严格模式下禁用with特性</p>
<p><strong>with语句简化代码的替代方案</strong><br>使用即时调用函数来替代with语句，通过函数传参的方式使用更短的引用来替代冗长的引用前缀比使用with语句消除前缀的方式更好。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span>(<span class="keyword">this</span>.style)</div><div class="line">&#123;</div><div class="line">    width = <span class="string">'200px'</span>;</div><div class="line">    height = <span class="string">'200px'</span>;</div><div class="line">    backgroundColor = <span class="string">'#ca3'</span>;</div><div class="line">    <span class="built_in">console</span>.log(width); <span class="comment">//要访问的本应该是外部的字符串变量 "错误哈哈",但是这里被解释为200px</span></div><div class="line">&#125;</div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</div><div class="line">    s.width = <span class="string">'200px'</span>;</div><div class="line">    s.height = <span class="string">'200px'</span>;</div><div class="line">    s.backgroundColor = <span class="string">'#ca3'</span>;</div><div class="line">&#125;)(<span class="keyword">this</span>.style);</div></pre></td></tr></table></figure></p>
<p><strong>使用面向过程的方式处理</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> bookList = [</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"什么是批判"</span>,<span class="attr">author</span>:<span class="string">"福柯"</span>&#125;,</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"飞鸟集"</span>,<span class="attr">author</span>:<span class="string">"泰戈尔"</span>&#125;</div><div class="line">    ];</div><div class="line">    <span class="comment">//增加操作</span></div><div class="line">    bookList.push(&#123;<span class="attr">name</span>:<span class="string">"城堡"</span>,<span class="attr">author</span>:<span class="string">"卡夫卡"</span>&#125;);</div><div class="line">    <span class="comment">//查询操作</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bookList.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> obj = bookList[i];</div><div class="line">        <span class="keyword">if</span> (obj.name == <span class="string">"飞鸟集"</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">console</span>.log(obj);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//修改操作</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bookList.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> obj = bookList[i];</div><div class="line">        <span class="keyword">if</span> (obj.name == <span class="string">"飞鸟集"</span>)</div><div class="line">        &#123;</div><div class="line">            obj.author = <span class="string">"泰戈尔-戈尔泰"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//删除操作</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bookList.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> obj = bookList[i];</div><div class="line">        <span class="keyword">if</span> (obj.name == <span class="string">"飞鸟集"</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//删除该对象</span></div><div class="line">            bookList.splice(i, <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(bookList);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>使用函数来封装图书管理操作</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> bookList = [</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"什么是批判"</span>,<span class="attr">author</span>:<span class="string">"福柯"</span>&#125;,</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"飞鸟集"</span>,<span class="attr">author</span>:<span class="string">"泰戈尔"</span>&#125;</div><div class="line">    ];</div><div class="line">    <span class="comment">//增加操作</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addBook</span>(<span class="params">bookObj</span>) </span>&#123;</div><div class="line">        bookList.push(bookObj);</div><div class="line">    &#125;</div><div class="line">    addBook(&#123;<span class="attr">name</span>:<span class="string">"城堡"</span>,<span class="attr">author</span>:<span class="string">"卡夫卡"</span>&#125;);</div><div class="line">    <span class="comment">//查询操作</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getBook</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bookList.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> obj = bookList[i];</div><div class="line">            <span class="keyword">if</span> (obj.name == name)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">return</span> obj;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(getBook(<span class="string">"什么是批判"</span>));</div><div class="line">    <span class="comment">//修改操作</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">updateBookData</span>(<span class="params">name,authorName</span>)</span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bookList.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> obj = bookList[i];</div><div class="line">            <span class="keyword">if</span> (obj.name == name)</div><div class="line">            &#123;</div><div class="line">                obj.author = authorName;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    updateBookData(<span class="string">"飞鸟集"</span>,<span class="string">"泰戈尔斯坦"</span>);</div><div class="line">   <span class="comment">//删除操作</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeBook</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bookList.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> obj = bookList[i];</div><div class="line">            <span class="keyword">if</span> (obj.name == name)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">//删除该对象</span></div><div class="line">                bookList.splice(i, <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(bookList);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>数封装-复用形式</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> bookList = [</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"什么是批判"</span>,<span class="attr">author</span>:<span class="string">"福柯"</span>&#125;,</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"飞鸟集"</span>,<span class="attr">author</span>:<span class="string">"泰戈尔"</span>&#125;</div><div class="line">    ];</div><div class="line">    <span class="comment">//增加操作</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addBook</span>(<span class="params">bookObj</span>) </span>&#123;</div><div class="line">        bookList.push(bookObj);</div><div class="line">    &#125;</div><div class="line">    addBook(&#123;<span class="attr">name</span>:<span class="string">"城堡"</span>,<span class="attr">author</span>:<span class="string">"卡夫卡"</span>&#125;);</div><div class="line">    <span class="comment">//查询操作</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getBook</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bookList.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> obj = bookList[i];</div><div class="line">            <span class="keyword">if</span> (obj.name == name)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">return</span> obj;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(getBook(<span class="string">"什么是批判"</span>));</div><div class="line">    <span class="comment">//修改操作</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">updateBookData</span>(<span class="params">name,authorName</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> obj = getBook(name);</div><div class="line">        obj.author = authorName;</div><div class="line">    &#125;</div><div class="line">    updateBookData(<span class="string">"飞鸟集"</span>,<span class="string">"泰戈尔斯坦"</span>);</div><div class="line">    <span class="comment">//删除操作</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeBook</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> obj = getBook(name);</div><div class="line">        <span class="keyword">var</span> index = bookList.indexOf(obj);</div><div class="line">        bookList.splice(index,<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    addBook(&#123;<span class="attr">name</span>:<span class="string">"东京人"</span>,<span class="attr">author</span>:<span class="string">"川端康成"</span>&#125;);</div><div class="line">    <span class="built_in">console</span>.log(bookList);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p><strong>面向对象的方式管理图书</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">&lt;scrip&gt;</div><div class="line">    <span class="keyword">var</span> obj = [</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"什么是批判"</span>,<span class="attr">author</span>:<span class="string">"福柯"</span>&#125;,</div><div class="line">        &#123;<span class="attr">name</span>:<span class="string">"飞鸟集"</span>,<span class="attr">author</span>:<span class="string">"泰戈尔"</span>&#125;</div><div class="line">    ];</div><div class="line">泰    <span class="function"><span class="keyword">function</span> <span class="title">BookManager</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.bookList = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">   BookManager.prototype = &#123;</div><div class="line">        <span class="attr">constructor</span>:BookManager,</div><div class="line">        <span class="attr">init</span>:<span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.bookList = arr || [];</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">addBook</span>:<span class="function"><span class="keyword">function</span> (<span class="params">bookObj</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.bookList.push(bookObj)</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">getBook</span>:<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.bookList.length; i++) &#123;</div><div class="line">            <span class="keyword">var</span> obj = <span class="keyword">this</span>.bookList[i];</div><div class="line">            <span class="keyword">if</span> (obj.name == name)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">return</span> obj;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;,</div><div class="line">        <span class="attr">updateBookData</span>:<span class="function"><span class="keyword">function</span> (<span class="params">name,authorName</span>)</span>&#123;</div><div class="line">            <span class="keyword">var</span> obj = <span class="keyword">this</span>.getBook(name);</div><div class="line">            obj.author = authorName;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">removeBook</span>:<span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> obj = <span class="keyword">this</span>.getBook(name);</div><div class="line">            <span class="keyword">var</span> index = <span class="keyword">this</span>.bookList.indexOf(obj);</div><div class="line">            <span class="keyword">this</span>.bookList.splice(index,<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//01 创建对象</span></div><div class="line">    <span class="keyword">var</span> YYManager = <span class="keyword">new</span> BookManager();</div><div class="line">    YYManager.init(obj);</div><div class="line">    <span class="built_in">console</span>.log(YYManager.bookList);</div><div class="line">    <span class="comment">//02 演示添加操作</span></div><div class="line">    YYManager.addBook(&#123;<span class="attr">name</span>:<span class="string">"花田半亩"</span>,<span class="attr">author</span>:<span class="string">"田维"</span>&#125;);</div><div class="line">    <span class="built_in">console</span>.log(YYManager.bookList);</div><div class="line">    <span class="comment">//03 演示查询操作</span></div><div class="line">    <span class="built_in">console</span>.log(YYManager.getBook(<span class="string">"花田半亩"</span>));</div><div class="line">    <span class="comment">//04 演示更新操作</span></div><div class="line">    YYManager.updateBookData(<span class="string">"花田半亩"</span>,<span class="string">"甜田"</span>);</div><div class="line">    <span class="built_in">console</span>.log(YYManager.getBook(<span class="string">"花田半亩"</span>));;</div><div class="line">    <span class="comment">//05 演示删除操作</span></div><div class="line">    YYManager.removeBook(<span class="string">"什么是批判"</span>);</div><div class="line">    <span class="built_in">console</span>.log(YYManager.bookList);</div><div class="line">    <span class="comment">//02 创建第二个人的图书管理对象</span></div><div class="line">    <span class="keyword">var</span> wulitaotaoMManager = <span class="keyword">new</span> BookManager();</div><div class="line">    wulitaotaoMManager.init([&#123;<span class="attr">name</span>:<span class="string">"装逼速成"</span>,<span class="attr">author</span>:<span class="string">"六扇门"</span>&#125;]);</div><div class="line">    <span class="built_in">console</span>.log(wulitaotaoMManager.bookList);</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>总结<br>01 提供构造函数，在构造函数内部设置实例化属性<br>02 把常用的操作提取成对象的实例方法，写在原型对象身上<br>03 提供init方法，用于初始化数据<br>04 注意：如果切断了原型对象那么需要修正内部的构造器属性指向</p>
]]></content>
      
        
        <tags>
            
            <tag> 简明教程 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript简明教程（3）]]></title>
      <url>/2016/02/18/js-3/</url>
      <content type="html"><![CDATA[<p>关于继承，通俗说子继父业。在JavaScript中，Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h2><p>在讲继承之前，我们必须先了解一些相关的方法。</p>
<h3 id="hasOwnProperty和in属性操作"><a href="#hasOwnProperty和in属性操作" class="headerlink" title="hasOwnProperty和in属性操作"></a>hasOwnProperty和in属性操作</h3><p><strong>in关键字</strong><br>作用：用来检查对象中是否存在某个属性(不区分实例属性和原型属性)。语法：“属性名” in 对象。代码示例:<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02 设置构造函数的原型对象的属性</span></div><div class="line">    Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//03 创建对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="comment">//04 使用in关键字判断对象中是否存在以下属性:name age sayHello</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"age"</span> <span class="keyword">in</span> p1);       <span class="comment">//false</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> p1);      <span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"sayHello"</span> <span class="keyword">in</span> p1);  <span class="comment">//true</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>对象的hasOwnProperty方法</strong><br>作用：用来检查对象中是否存在指定的属性(只检查实例属性)<br>语法：对象.hasOwnProperty(“属性名”)<br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02 设置构造函数的原型对象的属性</span></div><div class="line">    Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</div><div class="line">    &#125;</div><div class="line">    Person.prototype.des = <span class="string">"默认的描述信息"</span>;</div><div class="line">    <span class="comment">//03 创建对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="comment">//04 使用hasOwnProperty方法判断该属性是否是对象的实例属性</span></div><div class="line">    <span class="built_in">console</span>.log(p1.hasOwnProperty(<span class="string">"age"</span>));       <span class="comment">//false</span></div><div class="line">    <span class="built_in">console</span>.log(p1.hasOwnProperty(<span class="string">"name"</span>));      <span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(p1.hasOwnProperty(<span class="string">"sayHello"</span>));  <span class="comment">//false</span></div><div class="line">    <span class="built_in">console</span>.log(p1.hasOwnProperty(<span class="string">"des"</span>));       <span class="comment">//false</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>判断某对象中存在且只存在某个原型属性</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isProperty</span>(<span class="params">obj, property</span>) </span>&#123;</div><div class="line">       <span class="keyword">return</span> !obj.hasOwnProperty(property) &amp;&amp; (property <span class="keyword">in</span> obj);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h3 id="constructor构造器属性"><a href="#constructor构造器属性" class="headerlink" title="constructor构造器属性"></a>constructor构造器属性</h3><p><strong>说明</strong><br>  使用构造函数创建对象,则</p>
<pre><code>原型对象中的constructor属性指向对应的构造函数
实例对象中的constructor指向对应的构造函数,其中这里的constructor就是从原型中获取的即constructor时实例对象中的原型属性,而非实例属性
</code></pre><p><strong>代码验证</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提供一个构造函数</span></div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">       <span class="keyword">this</span>.name = name;</div><div class="line">   &#125;</div><div class="line">   <span class="comment">//02 设置构造函数的原型对象的属性</span></div><div class="line">   Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</div><div class="line">   &#125;;</div><div class="line">   Person.prototype.des = <span class="string">"默认的描述信息"</span>;</div><div class="line">   <span class="comment">//03 创建对象</span></div><div class="line">   <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">isProperty</span>(<span class="params">obj, property</span>) </span>&#123;</div><div class="line">       <span class="keyword">return</span> !obj.hasOwnProperty(property) &amp;&amp; (property <span class="keyword">in</span> obj);</div><div class="line">   &#125;</div><div class="line">   <span class="built_in">console</span>.log(isProperty(p1, <span class="string">"constructor"</span>));    <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h3 id="isprotoTypeOf和instance"><a href="#isprotoTypeOf和instance" class="headerlink" title="isprotoTypeOf和instance"></a>isprotoTypeOf和instance</h3><p><strong>isprotoTypeOf</strong><br>作用：判断是否是某个实例对象的原型对象<br>语法:构造函数.protoType.isPrototypeOf(对象)<br>用法示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    Person.prototype.name = <span class="string">"嘿嘿"</span>;</div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line">    <span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(p1));<span class="comment">//rue</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(p1));<span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(Dog.prototype.isPrototypeOf(p1));<span class="comment">//false</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>instance</strong><br>作用：用于检查对象是否是某个构造函数(类型)的实例<br>语法：对象 instance 构造函数<br>注意：所有的对象都是Object构造函数（类型）的实例<br>用法示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">    <span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>);      <span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);   <span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Object</span>);     <span class="comment">//true</span></div><div class="line">    <span class="comment">//instanceOf在判断的时候,算上整条原型链</span></div><div class="line">    <span class="comment">//arr 是Array 和Object 任何一个类的示例</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h2><h3 id="继承基本概念"><a href="#继承基本概念" class="headerlink" title="继承基本概念"></a>继承基本概念</h3><p><strong>继承</strong>：即通过一定的方式实现让某个类型A获取另外一个类型B的属性或方法。其中类型A称之为子类型，类型B称之为父类型或超类型。</p>
<p><strong>javaScript中的继承</strong><br>Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。<br>继承有两种方式：接口继承和实现继承，在js中只支持实现继承，实现继承主要依赖原型链来完成。<br><strong>JavaScript中实现继承的几种方式</strong>：<br>说明:其他语言中继承通常通过类来实现，js中没有类的概念，js中的继承是某个对象继承另外一个对象，是基于对象的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">01 原型式继承</div><div class="line">02 原型链继承</div><div class="line">03 经典继承(借用构造函数)</div><div class="line">04 组合继承</div></pre></td></tr></table></figure></p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p><strong>原型链继承的方式A</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02 设置原型对象的属性</span></div><div class="line">    Person.prototype.className = <span class="string">"逍遥派1班"</span>;</div><div class="line">    <span class="comment">//03 使用构造函数来创建原型对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">10</span>);</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>);</div><div class="line">    <span class="comment">//04 打印p1和p2对象中的className属性</span></div><div class="line">    <span class="built_in">console</span>.log(p1.className);</div><div class="line">    <span class="built_in">console</span>.log(p2.className);</div><div class="line">    <span class="comment">//结论:对象p1和p2继承了构造函数原型对象中的属性className</span></div><div class="line">    <span class="comment">//但是这并不是严格意义上的继承</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>原型链继承的方式B</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 提供一个构造函数</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//02 设置原型对象的属性</span></div><div class="line">    Person.prototype = &#123;</div><div class="line">        <span class="attr">constructor</span>:Person,</div><div class="line">        <span class="attr">className</span>:<span class="string">"逍遥派1班"</span></div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//03 使用构造函数来创建原型对象</span></div><div class="line">    <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">10</span>);</div><div class="line">    <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>);</div><div class="line">    <span class="comment">//04 打印p1和p2对象中的className属性</span></div><div class="line">    <span class="built_in">console</span>.log(p1.className);</div><div class="line">    <span class="built_in">console</span>.log(p2.className);</div><div class="line">    <span class="comment">//结论:对象p1和p2继承了构造函数原型对象中的属性className</span></div><div class="line">    <span class="comment">//注意:使用原型替换的方式实现继承的时候,原有原型对象中的属性和方法会丢失</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>原型链继承的方式C</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提供超类型|父类型构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'SuperClass的名称'</span>;</div><div class="line">    <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//02 设置父类型的原型属性和原型方法</span></div><div class="line">SuperClass.prototype.info = <span class="string">'SuperClass的信息'</span>;</div><div class="line">SuperClass.prototype.showInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.info);</div><div class="line">&#125;;</div><div class="line"><span class="comment">//03 提供子类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="comment">//04 设置继承(原型对象继承)</span></div><div class="line">SubClass.prototype = SuperClass.prototype;</div><div class="line">SubClass.prototype.constructor = SubClass;</div><div class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> SubClass();</div><div class="line"><span class="built_in">console</span>.log(sub.name);          <span class="comment">//undefined</span></div><div class="line"><span class="built_in">console</span>.log(sub.info);          <span class="comment">//SuperClass的信息</span></div><div class="line">sub.showInfo();                 <span class="comment">//SuperClass的信息</span></div><div class="line">sub.showName();                 <span class="comment">//sub.showName is not a function</span></div></pre></td></tr></table></figure></p>
<p>点评：上面的方法可以可以继承超类型中的原型属性和原型方法，但是无法继承实例属性和实例方法</p>
<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>实现思想：利用原型（链）让一个对象继承另一个对象的属性和方法<br>实现本质：重写原型对象</p>
<p><strong>原型链</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">① 每个构造函数都有原型对象</div><div class="line">② 每个对象都有自己的构造函数</div><div class="line">③ 每个构造函数的原型都是一个对象</div><div class="line">④ 那么这个构造函数的原型对象也有自己的构造函数</div><div class="line">⑤ 那么这个构造函数的原型对象的构造函数也有自己的原型对象</div><div class="line">以上形成一个链式的结构,称之为原型链</div></pre></td></tr></table></figure></p>
<p><strong>原型链中的属性搜索原则</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">当访问某个对象的成员的时候,会先在自身中查找,如果找到则直接使用</div><div class="line">如果在自身中没有找到,则去当前创建当前对象的构造函数的原型对象中查找,如果找到了则直接使用</div><div class="line">如果在该原型对象中没有找到,则继续查找原型对象的原型对象(创建该原型对象的构造函数所对应的原型对象),如果找到则直接使用</div><div class="line">如果在原型对象的原型对象中也没有找到,则继续向上搜索....</div><div class="line">直到Object的原型对象,若还是没有,则返回undefined(属性)或报错(方法)。</div></pre></td></tr></table></figure></p>
<p><strong>基本写法·代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提供超类型|父类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'SuperClass的名称'</span>;</div><div class="line">    <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//02 设置父类型的原型属性和原型方法</span></div><div class="line">SuperClass.prototype.info = <span class="string">'SuperClass的信息'</span>;</div><div class="line">SuperClass.prototype.showInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.info);</div><div class="line">&#125;;</div><div class="line"><span class="comment">//03 提供子类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="comment">//04 设置继承(原型对象继承)</span></div><div class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass();</div><div class="line">SubClass.prototype.constructor = SubClass;</div><div class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> SubClass();</div><div class="line"><span class="built_in">console</span>.log(sub.name);          <span class="comment">//SuperClass的名称</span></div><div class="line"><span class="built_in">console</span>.log(sub.info);          <span class="comment">//SuperClass的信息</span></div><div class="line">sub.showInfo();                 <span class="comment">//SuperClass的信息</span></div><div class="line">sub.showName();                 <span class="comment">//SuperClass的名称</span></div></pre></td></tr></table></figure></p>
<p>点评：可以继承父类型中的原型属性|原型方法,以及实例属性和实例方法</p>
<p><strong>注意点</strong><br>① 确定原型和实例的关系 instanceof + isPrototypeOf()<br>② 注意重写原型对象的位置，必须先实现原型继承，然后再设置子对象的原型属性和原型方法<br>③ 完成继承之后，不能使用字面量的方式来创建原型[因为会切断原型]</p>
<p><strong>问题</strong><br>① 父对象的实例属性会转换为子类型原型的原型属性，而如果父类型是实例属性是引用类型则会存在共享问题<br>② 在创建子类型的实例时，不能向父类型的构造函数中传递参数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提供父对象的构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//02 在构造函数中中设置实例属性,该属性为引用类型</span></div><div class="line">    <span class="keyword">this</span>.family = [<span class="string">'哥哥'</span>,<span class="string">'姐姐'</span>,<span class="string">'爸爸'</span>,<span class="string">'妈妈'</span>];</div><div class="line">&#125;;</div><div class="line"><span class="comment">//03 提供子对象的构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="comment">//04 设置原型继承</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"><span class="comment">//05 创建父对象构造函数的实例对象,并对内部的实例化属性进行修改</span></div><div class="line"><span class="keyword">var</span> subDemo1 = <span class="keyword">new</span> SubType();</div><div class="line"><span class="keyword">var</span> subDemo2 = <span class="keyword">new</span> SubType();</div><div class="line">alert(subDemo1.family);      <span class="comment">//哥哥,姐姐,爸爸,妈妈</span></div><div class="line">alert(subDemo2.family);      <span class="comment">//哥哥,姐姐,爸爸,妈妈</span></div><div class="line">subDemo1.family.push(<span class="string">'爷爷'</span>,<span class="string">'奶奶'</span>);</div><div class="line">alert(subDemo1.family);    <span class="comment">//哥哥,姐姐,爸爸,妈妈,爷爷,奶奶</span></div><div class="line">alert(subDemo2.family);    <span class="comment">//哥哥,姐姐,爸爸,妈妈,爷爷,奶奶</span></div></pre></td></tr></table></figure></p>
<h3 id="经典继承（借用构造函数）"><a href="#经典继承（借用构造函数）" class="headerlink" title="经典继承（借用构造函数）"></a>经典继承（借用构造函数）</h3><p>经典继承又称为借用构造函数|伪造继承</p>
<p><strong>基本思想</strong><br>在子类型构造函数的内部调用超类型|父类型构造函数<br>说明：需要借助call|apply方法<br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提供父类型(对象)的构造函数</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">      <span class="comment">//02 在构造函数中中设置实例属性,该属性为引用类型</span></div><div class="line">      <span class="keyword">this</span>.family = [<span class="string">'哥哥'</span>,<span class="string">'姐姐'</span>,<span class="string">'爸爸'</span>,<span class="string">'妈妈'</span>];</div><div class="line">      <span class="comment">//实例属性</span></div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;;</div><div class="line">  SuperType.prototype.info = <span class="string">'父类型的原型属性'</span>;</div><div class="line">  <span class="comment">//03 提供子类型（对象）的构造函数</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">//经典继承|借用构造函数|伪造对象继承</span></div><div class="line">      <span class="comment">//SuperType.call(this);</span></div><div class="line">      <span class="comment">//构造参数传递参数</span></div><div class="line">      SuperType.call(<span class="keyword">this</span>,<span class="string">'张老汉'</span>);</div><div class="line">  &#125;;</div><div class="line">  <span class="comment">//04 创建父类型的实例对象,并对内部的实例化属性进行修改</span></div><div class="line">  <span class="keyword">var</span> subDemo1 = <span class="keyword">new</span> SubType();</div><div class="line">  <span class="keyword">var</span> subDemo2 = <span class="keyword">new</span> SubType();</div><div class="line">  alert(subDemo1.info);        <span class="comment">//undefined</span></div><div class="line">  alert(subDemo1.family);      <span class="comment">//哥哥,姐姐,爸爸,妈妈</span></div><div class="line">  alert(subDemo2.family);      <span class="comment">//哥哥,姐姐,爸爸,妈妈</span></div><div class="line">  subDemo1.family.push(<span class="string">'爷爷'</span>,<span class="string">'奶奶'</span>);</div><div class="line">  alert(subDemo1.family);    <span class="comment">//哥哥,姐姐,爸爸,妈妈,爷爷,奶奶</span></div><div class="line">  alert(subDemo2.family);    <span class="comment">//哥哥,姐姐,爸爸,妈妈</span></div><div class="line">  <span class="comment">//测试构造函数传递参数</span></div><div class="line">  alert(subDemo1.name);</div></pre></td></tr></table></figure></p>
<p>点评：能够继承父类型的实例属性,但是无法继承父类型的原型属性和原型方法</p>
<p><strong>经典继承的优点</strong><br>① 解决实例对象共享问题，通过调用父对象的构造函数来实现每个子类型（对象）的实例对象均拥有一份父类型实例属性和方法的副本<br>② 可以在调用call方法的时候向构造函数传递参数</p>
<p><strong>经典继承的问题</strong><br>① 冒充继承的方法无法实现函数的重用<br>② 无法继承父对象的原型属性和原型方法</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承|伪经典继承</p>
<p><strong>基本思想</strong><br>① 使用原型链实现对原型属性和方法的继承<br>② 通过伪造(冒充)构造函数来实现对实例属性的继承<br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提供父类型的构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="comment">//在构造函数中中设置实例属性,该属性为引用类型</span></div><div class="line">    <span class="keyword">this</span>.family = [<span class="string">'哥哥'</span>,<span class="string">'姐姐'</span>,<span class="string">'爸爸'</span>,<span class="string">'妈妈'</span>];</div><div class="line">    <span class="comment">//实例属性</span></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//原型方法</span></div><div class="line">SuperType.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="comment">//02 提供子类型的构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="comment">//冒充|伪造 构造参数传递参数</span></div><div class="line">    SuperType.call(<span class="keyword">this</span>,name);</div><div class="line">&#125;;</div><div class="line">SubType.prototype = SuperType.prototype;</div><div class="line"><span class="comment">//SubType.prototype = new SuperType();</span></div><div class="line"><span class="comment">//02 创建父类型的实例对象,并对内部的实例化属性进行修改</span></div><div class="line"><span class="keyword">var</span> subDemo1 = <span class="keyword">new</span> SubType(<span class="string">'张三'</span>);</div><div class="line"><span class="keyword">var</span> subDemo2 = <span class="keyword">new</span> SubType(<span class="string">'张四'</span>);</div><div class="line">alert(subDemo1.family);    <span class="comment">//哥哥,姐姐,爸爸,妈妈</span></div><div class="line">alert(subDemo2.family);      <span class="comment">//哥哥,姐姐,爸爸,妈妈</span></div><div class="line">subDemo1.family.push(<span class="string">'爷爷'</span>,<span class="string">'奶奶'</span>);</div><div class="line">alert(subDemo1.family);    <span class="comment">//哥哥,姐姐,爸爸,妈妈,爷爷,奶奶</span></div><div class="line">alert(subDemo2.family);    <span class="comment">//哥哥,姐姐,爸爸,妈妈</span></div><div class="line"><span class="comment">//测试构造函数传递参数</span></div><div class="line">subDemo1.showName();    <span class="comment">//张三</span></div><div class="line">subDemo2.showName();    <span class="comment">//张四</span></div></pre></td></tr></table></figure></p>
<h3 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><p>基本类型：字符串 + 数值 + null + undefined + 布尔值<br>为了便于操作基本类型，ECMAScript提供了三个特殊的引用类型：<code>Boolean + Number + String</code>。<br>上述类型和其他的引用类型类似，同时也具备与各自的基本类型相应的特殊行为，每当我们读取一个基本类型的值的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'测试字符串'</span>;</div><div class="line"><span class="built_in">console</span>.log(str.length);            <span class="comment">//5</span></div><div class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">2</span>));      <span class="comment">//字符串</span></div></pre></td></tr></table></figure></p>
<p><code>思考</code>：属性和方法本是对象的特征，字符串如何能够拥有length属性以及其他类似subString等方法，内部怎么实现的？<br>基本类型值并不是对象，因此从逻辑上讨论他们不应该有属性和方法。 内部的具体处理:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">（<span class="number">1</span>）创建<span class="built_in">String</span>类型的一个实例对象</div><div class="line">（<span class="number">2</span>）在实例对象上面读取指定的属性（length）,调用指定的方法（subString）</div><div class="line">（<span class="number">3</span>）销毁该对象</div></pre></td></tr></table></figure></p>
<p><strong>Number</strong><br>Number是与数字值相对应的引用类型。<br>创建Number类型的对象：var num = new Number(10);</p>
<p><strong> String </strong><br>String是字符串的对象包装类型。<br>创建字符串类型的对象：var str = new String(‘hello World’);</p>
<p><strong>Boolean</strong><br>Boolean是与布尔值对象的引用类型。<br>可以通过调用Boolean构造函数传递参数来创建boolean类型的对象。<br>var bool = new Boolean(true);</p>
<p><strong>基本包装类型的代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//001 String</span></div><div class="line"><span class="keyword">var</span> str = <span class="string">'测试字符串'</span>;</div><div class="line"><span class="built_in">console</span>.log(str.length);            <span class="comment">//5</span></div><div class="line"><span class="built_in">console</span>.log(str.substring(<span class="number">2</span>));      <span class="comment">//字符串</span></div><div class="line"><span class="comment">//002 Number</span></div><div class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);</div><div class="line"><span class="built_in">console</span>.log(num);                   <span class="comment">//Number &#123;[[PrimitiveValue]]: 10&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);            <span class="comment">//object</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">10</span>);             <span class="comment">//number</span></div><div class="line"><span class="comment">//003 Boolean</span></div><div class="line"><span class="keyword">var</span> bool = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</div><div class="line"><span class="built_in">console</span>.log(bool);                  <span class="comment">//Boolean &#123;[[PrimitiveValue]]: true&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bool);           <span class="comment">//object</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);           <span class="comment">//boolean</span></div></pre></td></tr></table></figure></p>
<p><strong>基本包装类型的注意点</strong><br>[1] 对象还是基本数据类型值？<br>对象：通过new 调用构造函数创建出来的是对象<br>基本数据类型值：直接通过字面量方式赋值|通过省略new关键字调用构造函数方式创建的是基本数据类型值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ex:</div><div class="line">    <span class="keyword">var</span> str1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello'</span>);</div><div class="line">    <span class="keyword">var</span> str2 = <span class="string">'hello'</span>;</div><div class="line">    <span class="keyword">var</span> str3 = <span class="built_in">String</span>(<span class="string">'hello'</span>);</div><div class="line">    说明：以上代码中，str1是对象，而str2和str3是字符串（基本数据类型值）</div></pre></td></tr></table></figure></p>
<p>[2] 相等问题<br>基本类型值判断相等=&gt;值相等<br>引用类型值判断相等=&gt;值相等且引用相等<br>对象是引用类型，因此在判断相等的时候有诸多的注意点和容易出错的地方<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ex</div><div class="line">    <span class="keyword">var</span> str1 = <span class="string">'这是一个字符串'</span>;           <span class="comment">//基本数据类型</span></div><div class="line">    <span class="keyword">var</span> str2 = <span class="built_in">String</span>(<span class="string">'这是一个字符串'</span>);   <span class="comment">//基本数据类型</span></div><div class="line">    <span class="built_in">console</span>.log(str1 == str2);        <span class="comment">//true 相等</span></div><div class="line">    <span class="keyword">var</span> str3 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'这是一个字符串'</span>);  <span class="comment">//引用类型-对象</span></div><div class="line">    <span class="built_in">console</span>.log(str1 == str3);    <span class="comment">//true    //值相等</span></div><div class="line">    <span class="built_in">console</span>.log(str2 == str3);    <span class="comment">//true    //值相等</span></div><div class="line">    <span class="built_in">console</span>.log(str1 === str3); <span class="comment">//false //值相等,但是引用不相等</span></div><div class="line">    <span class="built_in">console</span>.log(str2 === str3); <span class="comment">//false //值相等,但是引用不相等</span></div><div class="line">    <span class="comment">//判断下面的变量是否相等</span></div><div class="line">    <span class="keyword">var</span> num1 = <span class="number">10</span>;                  <span class="comment">//基本数据类型</span></div><div class="line">    <span class="keyword">var</span> num2 = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>);      <span class="comment">//对象</span></div><div class="line">    <span class="built_in">console</span>.log(num1 == num2);      <span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(num1 ===  num2);    <span class="comment">//false</span></div><div class="line">    <span class="keyword">var</span> bool1 = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">var</span> bool2 = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</div><div class="line">    <span class="built_in">console</span>.log(bool1 == bool2);    <span class="comment">//true</span></div><div class="line">    <span class="built_in">console</span>.log(bool1 === bool2);   <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> 简明教程 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[可能是最简单的js原型继承]]></title>
      <url>/2016/02/08/js%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<p>JavaScript是一门奇妙的弱类型语言，原型继承与其它语言的类继承有所区别，下面通过一个简单的例子展示js的原型继承。</p>
<h2 id="你有对象吗？"><a href="#你有对象吗？" class="headerlink" title="你有对象吗？"></a>你有对象吗？</h2><p>你有对象吗？没有，赶紧就new一个吧！<br>首先，创建构造函数Parent<br>然后，new出一个Parent的实例对象child<br>此时，构造函数Parent拥有以下属性aString、aNumber、anObject,构造函数Parent的原型对象有aFunction方法。<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.aString = <span class="string">'string'</span>;</div><div class="line">    <span class="keyword">this</span>.aNumber = <span class="string">'number'</span>;</div><div class="line">    <span class="keyword">this</span>.anObject = <span class="string">'object'</span></div><div class="line">&#125;</div><div class="line">Parent.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>: Parent,</div><div class="line">    <span class="attr">aFunction</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="string">'i am function'</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>然后，new出一个Parent的实例对象child<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Parent();</div></pre></td></tr></table></figure></p>
<p>简单的原型继承图如下：<br><img src="/assets/img/js原型.png" alt="js原型"></p>
<p>#~~~~# 实现继承<br>实例对象默认拥有构造函数本身的属性和方法。但是，要知道构造函数荷构造函数的原型对象是俩个不同的函数（对象），原型对象拥有的属性和方法可以被实例化对象所共享。<br>也就是说实例对象child此时拥有属性aString、aNumber、anObject，this指向实例对象。child本身并没有aFunction方法。但是你调用此方法时，却发现能调用，这是怎么回事呢？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">child.aFunction();</div></pre></td></tr></table></figure></p>
<p>这就是我们所说的原型对象原拥有的属性和方法可以被实例化对象所共享的原因。<br>通过简单的例子，希望能帮到你，如果想深入学习javascript，请深戳<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript" target="_blank" rel="external">MDZ开发者</a></p>
]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 原型继承机制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript简明教程（2）]]></title>
      <url>/2016/02/01/js-02/</url>
      <content type="html"><![CDATA[<p>面向对象方法被人谈论了二十多年了，直到今天，我们还一直在谈对象。</p>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h2 id="面向层过程和面向对象编程"><a href="#面向层过程和面向对象编程" class="headerlink" title="面向层过程和面向对象编程"></a>面向层过程和面向对象编程</h2><p>01 面向对象编程和面向过程编程是一种编程思想,和具体的语言关系不大。<br>02 面向过程编程和面向对象编程的主要区别<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">面向过程编程:</div><div class="line">     关注点在于解决问题需要的每一个详细的步骤</div><div class="line">     示例:</div><div class="line">         自己洗衣服的过程</div><div class="line">         ① 收集需要洗的脏衣服</div><div class="line">         ② 准备洗衣粉、洗衣液等</div><div class="line">         ③ 把衣服放到一个盆里</div><div class="line">         ④ 接水</div><div class="line">         ⑤ 把洗衣粉放到盆里</div><div class="line">         ⑥ 摩擦,摩擦,不断的摩擦</div><div class="line">         ⑦ 把洗好的衣服用清水冲洗干净</div><div class="line">         ⑧ 尽量把把洗好的衣服的水分拧干</div><div class="line">         ⑨ 晾晒</div><div class="line"> 面向对象编程:</div><div class="line">     关注点在于解决问题需要的对象身上</div><div class="line">     示例:</div><div class="line">         使用洗衣机洗衣服的过程</div><div class="line">         ① 收集需要洗的脏衣服</div><div class="line">         ② 找到合适的洗衣机</div><div class="line">         ③ 设定洗衣服和烘干的程序</div></pre></td></tr></table></figure></p>
<p>03 面向过程和面向对象他们的区别就类似于自己洗衣服和使用洗衣机洗衣服|自己做饭吃和去餐馆吃饭</p>
<h2 id="面向对象编程的相关概念"><a href="#面向对象编程的相关概念" class="headerlink" title="面向对象编程的相关概念"></a>面向对象编程的相关概念</h2><p>01 对象<br>    什么是对象? 所有的一切都是对象,在开发中有一项重要的工作就是对象的划分。一般来说,我们所指的对象是某个具体的事物,而非泛泛的类别。<br>02 对象的特征(静态描述信息)<br>    所谓特征就是一些特定的描述信息<br>    如:学生(性别、年龄、班级、专业、籍贯、家庭住址)<br>    如:汽车(颜色、车牌、品牌、价格等)<br>03 对象的行为(动态特性)<br>    如:人(吃饭、睡觉、玩游戏、奔跑、运动等)<br>    如:狗(吃、睡、咬人、叫、流口水)<br>04 js中的对象<br>    键-值对(key-value)的集合。<br>05 现实生活中的对象和js对象的对应关系<br>    静态的描述信息 - js对象中的属性(属性就是定义在对象内部的变量)<br>    动态的行为特征 - js对象中的方法(方法就是定义在对象内部的函数)<br>06 代码示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">var</span> zhangsan = &#123;</div><div class="line">            <span class="attr">name</span>:<span class="string">"张三"</span>,</div><div class="line">            <span class="attr">sex</span>:<span class="string">"男"</span>,</div><div class="line">            <span class="attr">age</span>:<span class="number">18</span>,</div><div class="line">            <span class="attr">address</span>:<span class="string">"天上人间1号公馆"</span>,</div><div class="line">            <span class="attr">eat</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'能吃'</span>);</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">sleep</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"能睡"</span>);</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">say</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"能说话"</span>);</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">run</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"能运动"</span>);</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">song</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"能唱歌"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//打印对象的属性并调用相关的方法</span></div><div class="line"><span class="built_in">console</span>.log(zhangsan.name,zhangsan.age,zhangsan.address);</div><div class="line">        zhangsan.say();</div><div class="line">        zhangsan.sleep();</div></pre></td></tr></table></figure></p>
<h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><p>面向对象的三大特性:封装、继承、多态<br>01 封装:复用|信息隐蔽<br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 封装的简单说明</span></div><div class="line"><span class="comment">//001 观察以下杂乱无关的语句,它们仅仅只是一堆无意义的全局变量</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"乘风波浪会有时"</span>;</div><div class="line"><span class="keyword">var</span> actors = [<span class="string">"彭于晏"</span>,<span class="string">"邓超"</span>];</div><div class="line"><span class="keyword">var</span> showTime = <span class="string">"2016-1-28 - 2016-2-28"</span>;</div><div class="line"><span class="keyword">var</span> director = <span class="string">"韩寒"</span>;</div><div class="line"><span class="keyword">var</span> type = <span class="string">"喜剧"</span>;</div><div class="line"><span class="keyword">var</span> play = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//播放......</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//002 把上面的变量封装到对象中(更具有意义)</span></div><div class="line"><span class="keyword">var</span> film  = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"乘风破浪会有时"</span>,</div><div class="line">    <span class="attr">actors</span>:[<span class="string">"彭于晏"</span>,<span class="string">"邓超"</span>],</div><div class="line">    <span class="attr">showTime</span>:<span class="string">"2016-1-28 - 2016-2-28"</span>,</div><div class="line">    <span class="attr">director</span>:<span class="string">"韩寒"</span>,</div><div class="line">    <span class="attr">type</span>:<span class="string">"喜剧"</span>,</div><div class="line">    <span class="attr">play</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//播放......</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>02 继承:获取已经存在的对象已有属性和方法的一种方式(获取他人已有财富和资源的一种方式)。<br>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//继承的简单示例</span></div><div class="line"><span class="comment">//001 创建一个空的对象</span></div><div class="line"><span class="keyword">var</span> nullObj = &#123;&#125;;</div><div class="line"><span class="comment">// 上面的对象film拥有了很多的属性和方法</span></div><div class="line"><span class="comment">//002 设法让nullObj拥有film中所有的属性和方法</span></div><div class="line"><span class="comment">//方法一:自己重新写一遍</span></div><div class="line"><span class="comment">//方法二:通过某种方式来获得,比如遍历该对象,然后完成赋值</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> film)</div><div class="line">&#123;</div><div class="line">    nullObj[k] = film[k];</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> nullObj)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">console</span>.log(nullObj[k]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>03 多态(polymorphism)<br>    多态:polymorphism = poly(复数) + morph(形态) + ism<br>    多用于强类型语言中，JavaScript具备与生俱来的多态特性。<br>    多态表现为:<br>        ① 同一操作,作用于不同的对象,会产生不同的解释和行为。<br>        ② 隐藏不同。</p>
<h1 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h1><h2 id="字面量方式创建对象"><a href="#字面量方式创建对象" class="headerlink" title="字面量方式创建对象"></a>字面量方式创建对象</h2><p>基本写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span>  book1 = &#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"声名狼藉者的生活"</span>,</div><div class="line">        <span class="attr">price</span>:<span class="number">42.00</span>,</div><div class="line">        <span class="attr">author</span>:<span class="string">"福柯"</span>,</div><div class="line">        <span class="attr">press</span>:<span class="string">"北京大学出版社"</span>,</div><div class="line">        <span class="attr">read</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"我的书名为:声名狼藉者的的生活,作者为福柯...."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>存在的问题<br>[01] 代码复用性差<br>[02] 如果要创建大量的同类型对象，则需要些大量重复性代码</p>
<h2 id="内置构造函数创建对象"><a href="#内置构造函数创建对象" class="headerlink" title="内置构造函数创建对象"></a>内置构造函数创建对象</h2><p>JS中的内置构造函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span></div><div class="line"><span class="built_in">Number</span></div><div class="line"><span class="built_in">Boolean</span></div><div class="line">    注意：(区别于string number boolean)</div><div class="line"><span class="built_in">Date</span></div><div class="line"><span class="built_in">Array</span></div><div class="line"><span class="built_in">Function</span></div><div class="line"><span class="built_in">Object</span></div><div class="line"><span class="built_in">RegExp</span></div></pre></td></tr></table></figure></p>
<p>基本写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">book1.name = <span class="string">"声名狼藉者的生活"</span>;</div><div class="line">book1.price = <span class="number">42.00</span>;</div><div class="line">book1.author = <span class="string">"福柯"</span>;</div><div class="line">book1.press = <span class="string">"北京大学出版社"</span>;</div><div class="line">book1.read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"我的书名为:声名狼藉者的的生活,作者为福柯...."</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>问题<br>01 创建的对象无法复用,复用性差<br>02 如果需要创建多个同类型的对象,如(书籍)则需要写大量重复的代码,代码的冗余度高</p>
<h2 id="工厂函数创建对象"><a href="#工厂函数创建对象" class="headerlink" title="工厂函数创建对象"></a>工厂函数创建对象</h2><p>基本写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBookNew</span> (<span class="params">name,price,author,press</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> book = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    book.name = name;</div><div class="line">    book.price = price;</div><div class="line">    book.author = author;</div><div class="line">    book.press = press;</div><div class="line">    book.read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"我的书名为:"</span>+book.name+<span class="string">",作者为"</span>+book.author+<span class="string">"...."</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> book;</div><div class="line">&#125;</div><div class="line"><span class="comment">//使用工厂函数来创建对象</span></div><div class="line"><span class="keyword">var</span> book1 = createBookNew(<span class="string">"声名狼藉者的的生活"</span>,<span class="string">"42.00"</span>,<span class="string">"福柯"</span>,<span class="string">"北京大学出版社"</span>);</div><div class="line"><span class="keyword">var</span> book2 = createBookNew(<span class="string">"人性的枷锁"</span>,<span class="string">"49.00"</span>,<span class="string">"毛姆"</span>,<span class="string">"华东师范大学出版社"</span>);</div><div class="line"><span class="keyword">var</span> book3 = createBookNew(<span class="string">"悟空传"</span>,<span class="string">"28.00"</span>,<span class="string">"今何在"</span>,<span class="string">"湖南文艺出版社"</span>);</div><div class="line"><span class="comment">//打印对象的属性,调用对象的方法</span></div><div class="line"><span class="built_in">console</span>.log(book1.name);</div><div class="line"><span class="built_in">console</span>.log(book2.name);</div><div class="line"><span class="built_in">console</span>.log(book3.name);</div><div class="line">book1.read();</div><div class="line">book2.read();</div><div class="line">book3.read();</div></pre></td></tr></table></figure></p>
<p><strong>工厂函数说明</strong>:<br>001 工厂函数方式创建对象其本质是对内置构造函数创建对象的过程进行了封装<br>002 适用于大规模“批量生产”同类型的对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBook</span> (<span class="params">name,price,author,press</span>) </span>&#123;</div><div class="line">    <span class="comment">//001 参数 = 原料</span></div><div class="line">    <span class="keyword">var</span> book = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    <span class="comment">//002 创建对象并设置对象的属性和方法 = 对原料进行加工</span></div><div class="line">    book.name = name;</div><div class="line">    book.price = price;</div><div class="line">    book.author = author;</div><div class="line">    book.press = press;</div><div class="line">    book.read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"我的书名为:"</span>+book.name+<span class="string">",作者为"</span>+book.author+<span class="string">"...."</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//003 把处理好的对象返回给我们 == 产品出厂</span></div><div class="line">    <span class="keyword">return</span> book;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>封装思路</strong>:<br>使用函数把固定不变的部分封装起来，变化的部分提取为函数的参数。<br><strong>工厂函数创建对象的实现过程</strong>:<br>① 提供一个创建对象的函数（参数）<br>② 在该函数内部使用new 关键字和Object构造器创建对象<br>③ 设置对象的属性<br>④ 设置对象的方法<br>⑤ 返回对象</p>
<h2 id="自定义构造函数创建对象"><a href="#自定义构造函数创建对象" class="headerlink" title="自定义构造函数创建对象"></a>自定义构造函数创建对象</h2><p>基本写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> 构造函数名(<span class="params">参数<span class="number">1</span>,参数<span class="number">2</span>,参数<span class="number">3.</span>..</span>) </span>&#123;</div><div class="line">    <span class="comment">//设置对象的属性</span></div><div class="line">    <span class="keyword">this</span>.属性<span class="number">01</span> = 参数<span class="number">1</span>;</div><div class="line">    <span class="keyword">this</span>.属性<span class="number">02</span> = 参数<span class="number">2</span>;</div><div class="line">    <span class="comment">//设置对象的方法</span></div><div class="line">    <span class="keyword">this</span>.方法<span class="number">01</span> = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//.....</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.方法<span class="number">02</span> = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//.....</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//自定义构造函数方式创建对象</span></div><div class="line"><span class="keyword">var</span> 对象<span class="number">01</span> = <span class="keyword">new</span> 构造函数名(实参<span class="number">01</span>,实参<span class="number">02</span>,实参<span class="number">03.</span>..);</div><div class="line"><span class="keyword">var</span> 对象<span class="number">02</span> = <span class="keyword">new</span> 构造函数名(实参<span class="number">01</span>,实参<span class="number">02</span>,实参<span class="number">03.</span>..);</div></pre></td></tr></table></figure></p>
<p>代码示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateBook</span> (<span class="params">name,price,author,press</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.price = price;</div><div class="line">    <span class="keyword">this</span>.author = author;</div><div class="line">    <span class="keyword">this</span>.press = press;</div><div class="line">    <span class="keyword">this</span>.read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"我的书名为:"</span>+<span class="keyword">this</span>.name+<span class="string">",作者为"</span>+<span class="keyword">this</span>.author+<span class="string">"...."</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> CreateBook(<span class="string">"声名狼藉者的的生活"</span>,<span class="string">"42.00"</span>,<span class="string">"福柯"</span>,<span class="string">"北京大学出版社"</span>);</div><div class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> CreateBook(<span class="string">"人性的枷锁"</span>,<span class="string">"49.00"</span>,<span class="string">"毛姆"</span>,<span class="string">"华东师范大学出版社"</span>);</div><div class="line"><span class="keyword">var</span> b3 = <span class="keyword">new</span> CreateBook(<span class="string">"悟空传"</span>,<span class="string">"28.00"</span>,<span class="string">"今何在"</span>,<span class="string">"湖南文艺出版社"</span>);</div><div class="line"><span class="comment">//打印对象的属性,并调用对象的方法测试</span></div><div class="line"><span class="built_in">console</span>.log(b1.author);</div><div class="line"><span class="built_in">console</span>.log(b2.author);</div><div class="line"><span class="built_in">console</span>.log(b3.author);</div><div class="line">b1.read();</div><div class="line">b2.read();</div><div class="line">b3.read();</div></pre></td></tr></table></figure></p>
<p><strong>构造函数与new关键字</strong>:<br>new关键字的作用：用于创建对象（Object类型）。<br>构造函数和普通函数的区别：函数的首字母大写。<br>构造函数的作用:用于完成对象的初始化。</p>
<p><strong>自定义构造函数和简单工厂函数的对比</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">① 函数的首字母大写(用于区别构造函数和普通函数)</div><div class="line">② 创建对象的过程是由new关键字实现</div><div class="line">③ 在构造函数内部会自动的创建新对象,并赋值给this指针</div><div class="line">④ 自动返回创建出来的对象</div></pre></td></tr></table></figure></p>
<p><strong>构造函数的执行过程</strong><br>① 使用new关键字创建对象<br>② 把新创建出来的对象赋值给this<br>③ 在构造函数内部,使用this为新创建出来的对象设置属性和方法<br>④ 默认返回新创建的对象(普通函数如果不显示的return则默认返回undefined)。</p>
<p><strong>构造函数的返回值</strong><br>01 如果在构造函数中没有显示的return,则默认返回的是新创建出来的对象<br>02 如果在构造函数中显示的return,则依照具体的情况处理</p>
<pre><code>[01] return 的是对象,则直接返回该对象,取而代之本该默认返回的新对象
[02] return 的是null或基本数据类型值,则返回新创建的对象
</code></pre><p><strong>构造函数方式创建对象存在的问题</strong><br>每次创建对象,都会重新创建函数，那么如果创建的对象数量很多,而对象方法内部的实现一模一样,则造成了资源浪费。</p>
<p><strong>构造函数的使用注意</strong><br>函数传值：可以把构造函数的对象方法抽取为参数。代码示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//001 创建一个构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,toDoSomeThing</span>) </span>&#123;</div><div class="line">    <span class="comment">//002 在构造函数内部设置对象的属性和方法</span></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.toDoSomeThing = toDoSomeThing;</div><div class="line">&#125;</div><div class="line"><span class="comment">//003 使用构造函数创建对象</span></div><div class="line"><span class="keyword">var</span> zhangsan = <span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">18</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"张三在读书"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> lisi = <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">20</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"李四在玩耍"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>对象类型</strong>:<br>01 检查对象的类型：<code>instanceOf</code><br>02 获取对象的类型：<code>Object.prototype.toString.call(dog)</code></p>
<p><strong>对象的构造器属性</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.color = <span class="string">"黄色"</span>;</div><div class="line">    &#125;</div><div class="line"><span class="built_in">console</span>.log(dog.constructor);</div></pre></td></tr></table></figure></p>
<p>属性的名称：<code>constructor</code><br>属性的作用：指向创建该对象的构造函数，类似于现实生活中所有的产品都标有生产厂家一样。</p>
<p><strong>构造函数的调用</strong><br>01 构造函数可以像普通函数一样不通过new关键字直接调用<br>02 在使用构造函数创建对象的时候，如果没有传递参数，则（）可以省略<br>代码示例:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 创建构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"张三"</span>;</div><div class="line">    <span class="keyword">this</span>.age = <span class="number">20</span>;</div><div class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//02 使用构造函数创建对象</span></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person;    <span class="comment">//说明:如果不需要传递参数,则在调用构造函数的时候()可以省略</span></div></pre></td></tr></table></figure></p>
<p><strong>this指向</strong><br>01 如果使用new 构造函数的方式调用，则this指向内部默认创建出来的空对象<br>02 如果像调用普通函数一样调用构造函数，则this指向全局对象window(<code>不要这样使用</code>)</p>
<h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><p><strong>原型对象概念</strong></p>
<pre><code>在构造函数创建出来的时候,系统会默认帮构造函数创建并关联的一个新对象
自定义构造函数的原型对象默认是一个空对象。  
</code></pre><p><strong>原型对象的作用</strong></p>
<pre><code>构造函数中的原型对象中的属性和方法可以被使用该构造函数创建出来的对象使用。
即以自定义构造函数方式创建出来的所有对象,自动拥有和共享该构造函数的原型对象中的所有属性和方法。
</code></pre><p><strong>如何访问构造函数的原型对象</strong><br>① <code>构造函数.protoType</code><br>② <code>对象.__proto__（不推荐）</code></p>
<p><strong>设置原型对象的属性和方法</strong><br>① <code>利用对象的动态特性来为构造函数的原型对象添加属性和方法</code><br>② <code>替换原型对象</code></p>
<p><strong>实例和实例化</strong>：<br><code>实例化</code>:通过构造函数创建具体对象的过程。<br><code>实例</code>:通过构造函数实例化出来的对象,我们称之为该构造函数的一个实例。<br>注意:在说实例的时候,一定要指定是某个具体构造函数的实例。</p>
<p><strong>原型的使用方法</strong><br>① 利用对象的动态特性给原型添加属性|方法，如果要添加的方法过多,则有大量重复代码。<br>② 直接替换原型对象：<br>01 替换前后创建的对象所指向的原型对象不一致<br>02 替换原型对象会切断和之前的原型对象之间的关系</p>
<p><strong>原型对象的使用注意</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">① 访问属性:构造函数创建出来的对象在访问属性的时候,会先在实例内查找,如果没有找到则进一步到对应的原型对象中查找。</div><div class="line">② 设置属性:在使用点语法进行赋值的时候,无法操作到对应的原型对象,如果该属性在对象中已经存在，则修改该属性的值。如果该属性在对象中尚未存在,则新增该属性。</div><div class="line">③ 设置原型对象的属性:</div><div class="line">[<span class="number">01</span>] 设置原型对象的属性,只能通过构造函数.Prototype的方式替换原型对象的方式设置。</div><div class="line">[<span class="number">02</span>] 如果原型对象的属性是值类型，那么只能通过Person.prototype.属性的方式修改其值。如果原型对象的属性是引用类型,那么可以通过对象名.引用对象.属性名的方式设置修改：</div><div class="line">            (<span class="number">001</span>) 使用构造函数创建出来的多个对象的原型对象中的该属性指向的是同一块数据。</div><div class="line">            (<span class="number">002</span>) 某个对象对该原型对象属性进行了修改会影响到其他的对象。</div></pre></td></tr></table></figure></p>
<p><code>__proto__</code>属性说明：<code>__proto__</code>是一个非标准属性,即ECMAScript中并不包含该属性,这只是某些浏览器为了方便开发人员开发和调试而提供的一个属性,不具备通用性。建议:在调试的时候可以使用该属性,但不能出现在正式的代码中。</p>
]]></content>
      
        
        <tags>
            
            <tag> 简明教程 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript简明教程（1）]]></title>
      <url>/2016/01/15/01/</url>
      <content type="html"><![CDATA[<p>JavaScript与Java没有半毛钱关系，网景公司员工Brendan Eich用了10天时间设计了JavaScript语言。</p>
<h1 id="JavaScript的范围"><a href="#JavaScript的范围" class="headerlink" title="JavaScript的范围"></a>JavaScript的范围</h1><p><strong>JavaScript的范围：BOM + DOM + ECMAScript</strong></p>
<h2 id="BOM简单说明"><a href="#BOM简单说明" class="headerlink" title="BOM简单说明"></a>BOM简单说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">BOM即Browser Object Mode,浏览器对象模型。</div><div class="line">BOM提供了独立于内容而与浏览器窗口进行交互的对象。</div><div class="line">BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。</div><div class="line">因为BOM主要用于管理窗口与窗口之间的通信，因此其核心对象是window。</div><div class="line">BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是W3C。</div><div class="line">BOM结构体系</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="DOM简单说明"><a href="#DOM简单说明" class="headerlink" title="DOM简单说明"></a>DOM简单说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">DOM即Document Object Model，文档对象模型。</div><div class="line">当网页被加载时，浏览器会创建页面的文档对象模型，即DOM。</div><div class="line">DOM(文档对象模型)被构造为对象的树。</div><div class="line">DOM由一系列相关的对象构成，引申为Document对象。</div><div class="line">DOM的标准化组织是W3C。</div></pre></td></tr></table></figure>
<h2 id="ECMAScript简单说明"><a href="#ECMAScript简单说明" class="headerlink" title="ECMAScript简单说明"></a>ECMAScript简单说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ECMAScript指代JavaScript的核心语法。</div><div class="line">JavaScript 由 Brendan Eich 发明。</div><div class="line">JavaScript于1995 年出现在 Netscape 中于 1997 年被 ECMA（一个标准协会）采纳。</div><div class="line">语法核心：</div><div class="line">变量</div><div class="line">基本数据类型</div><div class="line">对象类型</div><div class="line">结构(循环|条件|判断)</div><div class="line">面向对象</div></pre></td></tr></table></figure>
<h1 id="javascript语法"><a href="#javascript语法" class="headerlink" title="javascript语法"></a>javascript语法</h1><h2 id="javascript数据类型"><a href="#javascript数据类型" class="headerlink" title="javascript数据类型"></a>javascript数据类型</h2><p>基本类型（简单数据类型）</p>
<pre><code>* string
* number
* boolean
* undefined
* null
</code></pre><p>复杂类型（复杂数据类型）</p>
<pre><code>* Object
* Array
* Date
* RegExp
* Function
* String
* Number
* Boolean
* null
* Math
</code></pre><h2 id="javascript部分操作符的说明"><a href="#javascript部分操作符的说明" class="headerlink" title="javascript部分操作符的说明"></a>javascript部分操作符的说明</h2><h3 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h3><p>只能够操作一个值的操作符叫做一元操作符。<br>① 递增和递减操作符:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[<span class="number">01</span>] 前置型,递增和递减操作在包含他们的语句被求值之前就执行。</div><div class="line">[<span class="number">02</span>] 后置型,递增和递减操作在包含他们的语句被求值之后才执行。</div><div class="line"><span class="keyword">var</span> num1  = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> num2  = <span class="number">20</span>;</div><div class="line"><span class="keyword">var</span> num3 = --num1 + num2;	<span class="comment">//21</span></div><div class="line"><span class="keyword">var</span> num4 = num1 + num2;		<span class="comment">//21</span></div><div class="line"><span class="keyword">var</span> num1  = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> num2  = <span class="number">20</span>;</div><div class="line"><span class="keyword">var</span> num3 = num1-- + num2;	<span class="comment">//22</span></div><div class="line"><span class="keyword">var</span> num4 = num1 + num2;		<span class="comment">//21</span></div></pre></td></tr></table></figure></p>
<p>② 一元加和减操作符:<br>一元加操作符对结果不会有任何的影响。<br>一元减操作符主要用于表示负数。</p>
<h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><p>01 按位非(NOT):使用 ~ 表示，执行按位非的结果就是返回数值的反码。<strong>操作数的负值减去1</strong>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="number">25</span>;</div><div class="line"><span class="keyword">var</span> num2 = -num1 - <span class="number">1</span>;	<span class="comment">//-26</span></div><div class="line">consol.log(~num1)		<span class="comment">//-26</span></div></pre></td></tr></table></figure></p>
<p>02 按位与(AND):使用&amp;表示，操作两个操作数。<strong>只要有0就为0</strong>。<br>03 按位或(OR):使用|表示，操作两个操作数。<strong>只要有1就为1</strong>。<br>04 按位异或(XOR):使用 ^ 表示，操作两个操作数。<strong>相同则为0，不同则为1</strong>。<br>05 左移|右移(|有符号|无符号)。</p>
<h3 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h3><p> 布尔操作符一共有三个，分别是：非、与、或。<br> 01 逻辑非，符号：！<br> 说明：取反，可应用于任何值，！！相当于没有操作。<br>02 逻辑与，符号：&amp;&amp;<br> 说明：两个值都为真的时候，结果为真。属于短路操作，如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。<br>03 逻辑或，符号：||<br>说明：两个值只要有一个为真，那么结果为真。属于短路操作，如果第一个操作数为真，那么就不会再对第二个操作数求值了。<br>技巧：可以利用逻辑或短路操作的特点来避免为变量赋null或undefined值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObject = refObject || backupObject;</div><div class="line"><span class="comment">//如果refObject的值不是null,那么它的值将被赋值给myObject</span></div><div class="line"><span class="comment">//如果是null,那么就将backupObject的值赋值给myObject。</span></div></pre></td></tr></table></figure></p>
<h3 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h3><p>乘 *<br>除 /<br>模 %</p>
<h3 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h3><p>加 +<br>减 -<br> <strong>说明：上述五种操作符在操作数为非数值的时候内部会执行自动的类型转换。</strong></p>
<h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>大于 &gt;<br>小于 &lt;<br>小于等于 &lt;=<br>大于等于 &gt;=<br>说明：返回布尔类型的值，要么为false，要么为true。</p>
<h3 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h3><p>01 相等和不相等[先转换再比较]，符号是 == 和！=<br><strong>比较的规则</strong>:<br>[01] 如果操作数中有布尔值，则先转换为数值再比较。<br>[02] 如果是字符串和数值比较，则先将字符串转换为数值再比较。<br>[03] 如果是对象和其他类型的值比较，则先调用对象的valueOf方法，然后用得到的基本类型值去比较。<br>[04] null和undefined是相等的。<br>[05] NaN和NaN不相等。<br>[06] 如果两个操作符都是对象，则比较他们是不是同一个对象，如果指向的是同一个对象则返回true，否则返回false。<br>02 全等和不全等[仅比较不转换],符号是<code>===</code>和<code>!==</code><br><strong>比较的规则</strong>:<br>[01] null和undefined是不全等的，因为它们是不同类型的值。<br>[02] 类型相同，且值相等，则返回true，否则返回false。</p>
<h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><p>符号：表达式1 ? 字面量1 ：字面量2<br>说明：如果表达式1的结果为true，则使用字面量1，否则使用字面量2。</p>
<h3 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h3><p>符号：=、+=、-=、*=、&lt;&lt;=等等<br>说明：使用赋值操作符对性能而言，没有任何的提升，只是简化了赋值操作而已。</p>
<h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><p><strong>01 值类型和引用类型简单说明</strong><br>值类型主要有：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">数值</div><div class="line">字符串</div><div class="line">布尔类型</div><div class="line"><span class="literal">undefined</span></div><div class="line"><span class="literal">null</span></div></pre></td></tr></table></figure></p>
<p>引用类型主要有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">对象（Object类型）</div><div class="line">数组（Array）</div><div class="line">函数 (Function)</div></pre></td></tr></table></figure></p>
<p><strong>值类型</strong>：保存为简单的数据值，赋值只是简单的数据值的复制<br><strong>引用类型</strong>:保存为对象，其本质是指向内存位置的引用(地址)，赋值是对地址的复制<br><strong>值类型代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> num2 = num1;    <span class="comment">//把num1的值复制一份给num2,num1和num2的值相等,除此之外没有任何其他关系</span></div><div class="line"><span class="built_in">console</span>.log(num1,num2);     <span class="comment">//10,10</span></div><div class="line"><span class="built_in">console</span>.log(num1 == num2);  <span class="comment">//true</span></div><div class="line">num2 = <span class="number">20</span>;          <span class="comment">//修改num2的值为20,不会对num1产生任何的影响</span></div><div class="line"><span class="built_in">console</span>.log(num1,num2);     <span class="comment">//10,20</span></div><div class="line"><span class="built_in">console</span>.log(num1 == num2);  <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p><strong>引用类型代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> arr2 = arr1;</div><div class="line"><span class="built_in">console</span>.log(arr1,arr2);             <span class="comment">//[1,2,3],[1,2,3]</span></div><div class="line"><span class="built_in">console</span>.log(arr1 == arr2);          <span class="comment">//true</span></div><div class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="built_in">console</span>.log(arr3);                  <span class="comment">//[1,2,3]</span></div><div class="line"><span class="built_in">console</span>.log(arr1 == arr3,arr2 == arr3); <span class="comment">//false,false</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 代码说明:</div><div class="line"> * arr1和arr2在比较的时候,值相等(都是[1,2,3]),且引用相等(都指向堆中同一块数据),因此arr1和arr2相等</div><div class="line"> * arr3和arr1以及arr2比较的时候,值相等([1,2,3]),但是引用不相等(arr3指向的是堆中另外一块数据),因此不等</div><div class="line"> * 总结:引用类型在比较相等的时候,只有值和引用都相等才相等</div><div class="line"> * */</div></pre></td></tr></table></figure></p>
<p><strong>02 值类型和引用类型的赋值</strong><br>赋值操作(=):把当前变量存储的值复制一份给接收的变量。<br>值类型的赋值:把当前变量存储的值(具体的数据)复制一份给接收的变量。<br>引用类型的赋值:把当前变量存储的值(具体数据的引用即地址)复制一份给接收的变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//引用类型使用注意</span></div><div class="line">  <span class="built_in">console</span>.log(arr1,arr2);         <span class="comment">//[1,2,3],[1,2,3];</span></div><div class="line">  <span class="built_in">console</span>.log(arr1 == arr2);      <span class="comment">//true</span></div><div class="line">  arr1.push(<span class="number">4</span>);</div><div class="line">  <span class="built_in">console</span>.log(arr1,arr2);         <span class="comment">//[1,2,3,4],[1,2,3,4]</span></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 代码说明:因为arr1和arr2内部的引用指向的是同一块数据,所以修改了arr1会对arr2也产生影响</div><div class="line">   * */</div></pre></td></tr></table></figure></p>
<p><strong>03 值类型和引用类型作为函数参数处理</strong><br><code>形参</code>:占位用的参数,用来接收数据的参数而已。<br><code>实参</code>:实际传递的参数。<br><code>函数的调用</code>:在函数调用的时候,函数默认会把实参的值赋值给形参。<br><strong>值类型作为参数</strong>：在函数内部对形参变量进行修改不会影响到实参的值。<br><strong>引用类型作为参数</strong>：在函数内部对形参变量进行修改会影响到实参的值，因为他们的引用指向同一个对象。<br><strong>04 值类型和引用类型的相关图示</strong><br><strong>基本类型的赋值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str1 = <span class="string">"hello zhangsan"</span>;</div><div class="line"><span class="keyword">var</span> str2 = str1;</div></pre></td></tr></table></figure></p>
<p><img src="/assets/img/03.png" alt="p1对象的存储结构图"><br><strong>引用类型的结构和赋值</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> car = &#123;</div><div class="line">    <span class="attr">color</span>:<span class="string">"黑色"</span>,</div><div class="line">    <span class="attr">number</span>:<span class="string">"B99"</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> p1 = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"王宝宝"</span>,</div><div class="line">    <span class="attr">age</span>:<span class="number">30</span>,</div><div class="line">    <span class="attr">car</span>:car</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><img src="/assets/img/01.png" alt="p1对象的存储结构图"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">       <span class="attr">name</span>:<span class="string">"lisi"</span>,</div><div class="line">       <span class="attr">age</span>:<span class="number">18</span></div><div class="line">   &#125;;</div><div class="line">   <span class="keyword">var</span> obj2 = obj1;</div></pre></td></tr></table></figure></p>
<p><img src="/assets/img/02.png" alt="obj1和obj2的存储结构图"></p>
<h2 id="对象的动态特性"><a href="#对象的动态特性" class="headerlink" title="对象的动态特性"></a>对象的动态特性</h2><p>在js中可以动态的对对象属性进行增加、修改和删除；<br><strong>代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 创建对象</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"刘德华"</span>,</div><div class="line">    <span class="attr">age</span>:<span class="number">60</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//02 动态的为对象添加属性</span></div><div class="line">obj.height = <span class="string">"180cm"</span>;</div><div class="line"><span class="built_in">console</span>.log(obj.height);</div><div class="line"><span class="comment">//03 动态的为对象添加方法</span></div><div class="line">obj.maiMeng = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"华仔会卖萌噢"</span>);</div><div class="line">&#125;;</div><div class="line">obj.maiMeng();</div><div class="line"><span class="comment">//04 修改属性的值:如果设置的属性以前不存在,那么就是添加,如果设置的属性已经存在了,那么就是修改</span></div><div class="line">obj.name = <span class="string">"王宝强"</span>;</div><div class="line"><span class="built_in">console</span>.log(obj.name)</div><div class="line"><span class="comment">//05 删除属性</span></div><div class="line"><span class="keyword">delete</span> obj.name;</div><div class="line"><span class="built_in">console</span>.log(obj.name);  <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p><strong>访问对象的方法</strong><br>01 可以使用点语法访问<br>02 可以使用[]语法访问，注意对象的属性必须是字符串</p>
<h2 id="关键字in和delete的使用"><a href="#关键字in和delete的使用" class="headerlink" title="关键字in和delete的使用"></a>关键字in和delete的使用</h2><p><strong>01 in关键字</strong><br>01 判断属性是否存在于对象中，注意所有的key都是字符串<br>02 for in循环中  遍历对象的 键<br><strong>代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">"张三"</span>,</div><div class="line">    <span class="attr">age</span>:<span class="number">18</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">for</span>(k <span class="keyword">in</span> obj)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">console</span>.log(k,obj[k]);</div><div class="line">&#125;</div><div class="line"><span class="comment">//检测obj对象中是否存在name这个属性</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> obj);</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：in关键字操作数组的时候检测的是索引值并非数组元素<br><strong>02 delete关键字</strong><br>01 删除对象的属性<br>02 删除未使用var声明的变量<br>03 返回值为boolean类型，true则表示是否删除成功<br><strong>注意</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">01 删除的属性如果不存在，返回true</div><div class="line">02 删除的如果是原型中的属性，返回true 但是删除不成功</div></pre></td></tr></table></figure></p>
<h2 id="循环和分支"><a href="#循环和分支" class="headerlink" title="循环和分支"></a>循环和分支</h2><p><strong>循环结构</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span></div><div class="line"><span class="keyword">while</span></div><div class="line"><span class="keyword">do</span>...while</div><div class="line"><span class="keyword">for</span>..in</div></pre></td></tr></table></figure></p>
<p><strong>分支结构</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>...else..</div><div class="line">swith..case</div></pre></td></tr></table></figure></p>
<p><strong>break和continue对比</strong><br>break:终止循环，循环中后面的代码不再执行<br>continue:结束当前循环，循环后面的代码不再执行，继续下一次循环</p>
<h2 id="调试工具的使用"><a href="#调试工具的使用" class="headerlink" title="调试工具的使用"></a>调试工具的使用</h2><p><strong>开启调试窗口</strong><br>    windows 平台: f12; Mac: option+command+i;<br><strong>调试窗口介绍</strong><br>    指针: 选择页面中的元素<br>    手机: 使用移动端界面调试<br>    Elements: 查看页面 DOM 树<br>    Console: 控制台(注意, 控制台与该页面是一个整体, 在控制台中的任何操作, 会影响到页面)<br>    Source: 代码调试<br><strong>调试工具的使用</strong><br>    逐过程运行, 一次运行一个函数<br>    单步运行(逐步运行), 一次运行一句, 如果是函数, 进入函数体内运行<br>    继续运行. 从当前状态运行下去, 直到出现断点, 如果没有断点则运行结束<br><strong>设置断点技巧</strong><br>    逐步与逐过程混合<br>    断点加继续运行<br>    条件断点(右键添加 add contitional breakpoint)<br><strong>利用 watch 监视窗口可以查看对象成员</strong></p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><strong>常见的异常分类</strong><br>运行环境的多样性导致的异常（浏览器）<br>语法错误，代码错误<br>异常的特征:一旦代码出现异常，后面的代码就不会再执行<br><strong>异常捕获</strong><br>使用try-catch语句捕获异常<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="comment">//这里写可能出现异常的代码</span></div><div class="line">&#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">    <span class="comment">//这里的e就是捕获的异常对象</span></div><div class="line">    <span class="comment">//可以在这里写，出现异常后的处理代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>异常捕获语句执行的过程为：<br>01 代码正常运行, 如果在try中出现了错误, try 里面出现错误的语句后面的代码都不再执行, 直接跳转到 catch 中<br>02 在catch中处理错误信息<br>03 继续执行后面的代码<br>04 如果 try 中没有出现错误, 那么不走 catch 直接执行后面的代码<br>捕获异常的优点：通过try-catch语句进行异常捕获之后，代码将会继续执行，而不会中断。<br>注意：语法错误异常用try-catch语句无法捕获，因为在预解析阶段，语法错误会直接检测出来，而不会等到运行的时候才报错。<br><strong>try..catch使用示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 try ... catch结构的使用</span></div><div class="line"><span class="comment">//a();  若直接调用则爆出:Uncaught ReferenceError: a is not defined错误</span></div><div class="line"><span class="comment">//在开发中,我们对于可能会报错或者是发生异常的代码用try结构进行处理</span></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    a();    <span class="comment">//如果发生异常,那么至少不会到正程序中断</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(e)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//如果try语句中发生了异常,那么会执行此处的代码块</span></div><div class="line">    <span class="comment">//参数e.为具体的异常信息,可以打印进行查看</span></div><div class="line">    <span class="built_in">console</span>.log(e);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionTest</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"functionTest"</span>);</div><div class="line">&#125;;</div><div class="line">functionTest();</div><div class="line"><span class="comment">//结论:使用try...catch结构,如果发生了异常,那么不会影响后面代码的执行,且我们可以在发生异常信息之后做出具体的处理</span></div></pre></td></tr></table></figure></p>
<p><strong>手动抛出异常</strong><br>案例：自己写的一个函数，需要一个参数，如果用户不传参数，此时想直接给用户抛出异常，就需要了解如何抛出异常。<br>抛出异常使用throw关键字，语法如下：<br>手动抛出异常信息（字符串）:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="comment">//a();    //如果发生异常,那么至少不会到正程序中断</span></div><div class="line">    <span class="comment">//不使用系统默认的异常信息,尝试手动抛出</span></div><div class="line">    <span class="keyword">throw</span> <span class="string">"对不起,您调用了尚未定义的方法"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(e)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//如果try语句中发生了异常,那么会执行此处的代码块</span></div><div class="line">    <span class="comment">//参数e.为具体的异常信息,可以打印进行查看</span></div><div class="line">    <span class="built_in">console</span>.log(e);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionTest</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"functionTest"</span>);</div><div class="line">&#125;;</div><div class="line">functionTest();</div></pre></td></tr></table></figure></p>
<p>手动抛出异常信息（对象）:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="comment">//a();    //如果发生异常,那么至少不会到正程序中断</span></div><div class="line">    <span class="comment">//不使用系统默认的异常信息,尝试手动抛出</span></div><div class="line">    <span class="keyword">throw</span> &#123;</div><div class="line">        <span class="attr">errMsg</span>:<span class="string">"具体的错误信息提示"</span>,</div><div class="line">        <span class="attr">errCode</span>:<span class="string">"指定错误类型的代号,如1001等"</span></div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span>(e)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//如果try语句中发生了异常,那么会执行此处的代码块</span></div><div class="line">    <span class="comment">//参数e.为具体的异常信息,可以打印进行查看</span></div><div class="line">    <span class="built_in">console</span>.log(e);</div><div class="line">    <span class="comment">//在try语句中抛出的错误信息是什么,那么得到的异常信息就是什么</span></div><div class="line">    <span class="comment">//如果抛出的是字符串,那么得到的就是字符串</span></div><div class="line">    <span class="comment">//如果抛出的是对象,那么此处得到的就是对象</span></div><div class="line">    <span class="built_in">console</span>.log(e.errMsg);</div><div class="line">    <span class="built_in">console</span>.log(e.errCode);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionTest</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"functionTest"</span>);</div><div class="line">&#125;;</div><div class="line">functionTest();</div></pre></td></tr></table></figure></p>
<p><strong>异常捕获语句的完整模式</strong><br>异常捕获语句的完整模式为try-catch-finally<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="comment">//在执行的时候可能发生异常的代码</span></div><div class="line">    b();</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (e)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//如果try代码块中的代码在执行中发生了异常,那么就会执行该代码块的代码</span></div><div class="line">    <span class="comment">//通过打印e对象可以查看具体的异常信息</span></div><div class="line">    <span class="built_in">console</span>.log(e); <span class="comment">//打印异常信息</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">//不论try语句中的代码是否会发生异常,都一定会执行此处的代码块</span></div><div class="line">    <span class="comment">//一般在前端开发中很少使用,常用语后台开发的资源释放工作</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"无论如何总要执行的代码"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>finally中的代码，不管是否发生异常，都会执行。一般用在后端语言中，用来释放资源，JavaScript中很少会用到。</p>
<h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><p>获取元素操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getElementById</div><div class="line">getElementsByTagName</div><div class="line">getElementsByClassName</div></pre></td></tr></table></figure></p>
<p>元素节点操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">appendChild</div><div class="line">insertBefore</div><div class="line">removeChild</div><div class="line">replaceChild</div><div class="line">cloneNode</div><div class="line">createElement</div><div class="line">createTextNode（创建文本节点）</div></pre></td></tr></table></figure></p>
<p>属性节点操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getAttribute</div><div class="line">setAttribute</div><div class="line">removeAttribute</div></pre></td></tr></table></figure></p>
<p>常用DOM属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">className</div><div class="line">innerHTML</div><div class="line">innerText/textContent value</div><div class="line">children</div></pre></td></tr></table></figure></p>
<p><strong>代码示例</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//0 获取页面中指定的标签,并设置其样式</span></div><div class="line">    <span class="keyword">var</span> divID = <span class="built_in">document</span>.getElementById(<span class="string">"divId"</span>);</div><div class="line">    divID.style.backgroundColor = <span class="string">"pink"</span>;</div><div class="line">    divID.style.height = <span class="string">"40px"</span>;</div><div class="line">    divID.style.width = <span class="string">"200px"</span>;</div><div class="line">    <span class="comment">//01 创建新的标签</span></div><div class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">    <span class="comment">//02 设置标签的样式</span></div><div class="line">    div.style.backgroundColor = <span class="string">"red"</span>;</div><div class="line">    div.style.height = <span class="string">"100px"</span>;</div><div class="line">    div.style.width = <span class="string">"300px"</span>;</div><div class="line">    div.style.fontSize = <span class="string">"20"</span>;</div><div class="line">    <span class="comment">//03 设置标签的内容</span></div><div class="line">    div.innerText = <span class="string">"这是一个自己创建的标签"</span>;</div><div class="line">    <span class="comment">//04 把标签插入到页面中</span></div><div class="line">    <span class="built_in">document</span>.body.appendChild(div);</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> 简明教程 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[12年逗比如我]]></title>
      <url>/2016/01/08/12%E5%B9%B4%E6%80%80%E6%97%A7/</url>
      <content type="html"><![CDATA[<p>12年写的乱七八遭，拿出来怀旧，权当笑话，笑笑更开心！</p>
<h2 id="一周大一秀"><a href="#一周大一秀" class="headerlink" title="一周大一秀"></a>一周大一秀</h2><p>欢迎收听一周大一秀，观众朋友们大家好。好学生就是我，我就是曾大贤。欢迎收听本节目，请大家用热烈的掌声欢迎我们今天的主角出场。他就是人见人爱，花见花开，俗称一朵海棠压梨花的帅哥。没错，你猜对了，好学生就是我，我就是曾大贤。接下来请大家千万把耳屎勾干净了，洗耳恭听嘛，哈哈。<br><a id="more"></a><br>大学就是围墙啊，在外面的人都想跳进来，在里面的人都想跳出去。曾哥我真的是深深的有感触啊！此事从五百年前说起，曾哥在一个夜黑风高的晚上，血腥的风放肆嘲笑满街的横尸遍野。曾哥右持AK_47，左携一篮子地雷，嘴叼雪茄【此音乐响起上海滩】，在千军万马中杀了出来。就这样，千军万马来相见，曾哥突破了大学这道围墙，杀进了大学【此时音乐响起天空之城】。进了大学这道墙，曾哥欣喜若狂，因为按照传说，就可以不费吹灰之力拥有一切，以后开宝马，住洋房，娶洋妞都不用愁了。以为到了世外桃源，曾哥很高兴地把AK_47丢进了河里，把一篮子地雷也扔了进去【此时音乐响起乌鸦的惨叫声】，只留下嘴刁着的那根雪茄，用来扮酷讨女孩子欢心。</p>
<p>故事到这里，相信大家都能猜到后果了，很遗憾广告时间到了，请大家不要走开，广告之后更精彩【好敌真好，广州好敌】。欢迎大家继续收听一周大一秀，好学生就是我，我就是曾大贤。曾大贤接下来何去何从，精彩不容错过。<br>曾大贤被传说给传说了，接下来的日子里，他就只能做这些事了，哎【MUSIC阿里路亚】</p>
<p>摸黑起床，叫兽整队，准备抗战。有的时候还没来得及刷牙洗脸，就匆匆忙忙赶去与英语口语决一死战。战罢方休，一个馒头一个大饼是战利品。军纪如律令，又赶忙去找营地，生怕触犯律令，有时不得不一边啃着个窝窝头一边找赶上军队去扎营。<br>糊糊涂涂的坐在营里，听叫兽讲那些讲那些似懂非懂的军事理论知识，时间很快到了中午。战友总在催，不走快点，就要吃剩饭，呜呜，排队打饭订餐，弄得曾哥连吃饭的心情都没有了。好不容易吃完了午饭，曾哥本想舒舒服服睡上一觉，怎知社团活动来风急。曾哥可怜的午休时间那，就这么被无情的摧残了。</p>
<p>俗话说，中午不睡，下午崩溃。果不其然，曾哥整个下午都崩溃掉了【音乐伤不起啊伤不起】。顶着乏意，毫无生机。曾哥恹恹欲睡，却又不敢入睡。闭着眼睛也能跟着叫兽打军体拳，曾哥实在是太强大了！</p>
<p>时间一晃而过，本来打算美美的洗个澡的，可是时间急迫啊。七点就要站岗放哨，又是军纪如律令，所以洗澡这事给挂了。一来省些水资源，二来嘛省钱，你懂的，哈哈。<br>终于曾哥下岗了，夜生活真正开始了。手机上网畅无线，莺歌电影嗨翻天十一二点不算晚，就看你的肾好不好，额滴肾啊，哈哈。</p>
<p>大学生活就是沙场点兵，而曾哥却总还能打怪兽。一部手机可以有几多个怪兽，曾哥说菲尔普斯专用山寨机，就是牛。曾哥追师姐也真是牛，来一个杀一个，来两个杀一双。可是你懂的，曾哥最终还是情伤了【音乐响起我是个容易受伤的男人】，因为长得太帅了没办法，不知道选那一个啊。【音乐响起请你不要迷恋哥，嫂子会打你的】</p>
<p>曾哥受伤了，曾哥想家了。【音乐响起常回家看看】曾哥哭了【音乐男人哭吧哭吧不是罪】，曾哥想到了AK_47，想到了地雷，但只剩嘴里那根烟了，杀不回去了。</p>
<p>还好，周末给了曾哥继续下去的理由。叫兽说，睡觉是对周末的最起码的尊重。曾哥一向是守法的孩子，所以周末有事没事要找曾哥的孩子，请留言，曾哥已睡死，哈哈。</p>
<p>当然这是不可能的事，因为叫兽还说过，来到洛阳，你不去外面转转，就可惜了。河山大好，洛阳正好。老师说到曾哥就做到，所以周末成了曾哥的旅游时间。一个地方总会有一个地方的好，洛阳正是个好地方。大学你所在的城市，你对他有了解多少呢？嘿嘿，趁周末完，像曾哥一样，出去转转吧，别待在宿舍当懒虫。音乐响起许嵩的【河山大好：电脑看太久了脖子也会酸，数字时代貌似把生活节奏加快，也让人变得行动迟缓起来。忙忙忙，忙不出个所以然，地球就算累了它照样会公转自转。叹叹叹，弹指一挥人生苦短，终点不明沿途风景要好好看。你可以隐隐的期待，途中佳缘的带来，保持一个浪漫的心态，活着就不算坏】。</p>
<p>感谢大家一路相伴，本期节目到此结束。曾哥究竟会在大学有何作为呢？</p>
]]></content>
      
        
        <tags>
            
            <tag> 娱乐 </tag>
            
            <tag> 怀旧 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[五分钟学会简单使用git]]></title>
      <url>/2016/01/03/%E4%BA%94%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8git/</url>
      <content type="html"><![CDATA[<p>五分钟，简单入门。学会之后可以愉快的管理你的文件啦。</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><pre><code>git 其实很简单，有多简单呢？
    1. git init 初始化一个仓库；
    2. git add . 添加文件到暂存区；
    3. git commit -m&apos;messeage&apos;  提交至版本库；
    4. git push origin master 推送至远程仓库；
</code></pre><a id="more"></a>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><pre><code>什么是平衡分支？实际工作中一般新建平衡分支用于开发调试等，然后再合并到主分支。
    1.git checkout -b dev 新建dev分支并切换到dev分支。
    相当于：git branch dev  创建dev分支；  
    git checkout dev 切换到dev分支；
    2. 开发或者调试结束后  
    git add * 添加所有文件到暂存区； 
    git commit -m&apos;messeage&apos; 提交至版本库；  
    3.git checkout master 切换到主分支；  
    git merge dev 合并分支；
    git branch -d dev   删除分支；  
</code></pre><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><pre><code>什么是冲突？同一份文件同一个地方被不同的协作者修改了，最后一个推送至远程的会产生冲突。  
解决冲突：git pull 更新本地仓库
打开冲突文件，找到冲突部分，协调修改。
   1 TODO
   2 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
   3 我修改的
   4 =======
   5 协作者修改的
   6 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 
经过协调，修改为       
   1 TODO
   2 经过协调修改的
</code></pre><p>到这里，你已经基本上掌握了git的使用了，想再深入了解，请点击<a href="http://git.oschina.net/progit/1-起步.html#1.1-关于版本控制" target="_blank" rel="external">git Pro中文</a></p>
]]></content>
      
        
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本控制 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的世界，如果少了一个你]]></title>
      <url>/2016/01/01/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%96%E7%95%8C/</url>
      <content type="html"><![CDATA[<p>如果说人的一生都有规律可以追寻，那是不是可以按照规律活下去，我的世界从此也就不会少一个你。</p>
<h1 id="这一天生日"><a href="#这一天生日" class="headerlink" title="这一天生日"></a>这一天生日</h1><p>在遥远的海洋上，夕阳无限好。摇摇曳曳，余光随着波浪，尽情摇摆。海面像往常一样平静。这是这座小城第824年历史的纪念日，历史悠久，耐人探索。吃完晚饭六点多，一家人来到海边散步。女儿已经5岁了，扎着小尾辫子。一手牵着妈妈，一手牵着爸爸，唱着上课老师教的歌曲。忽然，不知道那里逃出来的狗，灰棕灰，气势汹汹.这可不得了，这冲着人去咬。猝不及防，小女孩被狗咬伤了。没想到，意外总是这么意外。今天是小女孩的五岁生日。<br><a id="more"></a></p>
<h2 id="恶狗来袭"><a href="#恶狗来袭" class="headerlink" title="恶狗来袭"></a>恶狗来袭</h2><p>就这样，小女孩的生日那天是在医院度过的。小女孩的爸爸–冯孔，在一家国企上班，刚到而立之年。小女孩的妈妈–翁玲，是一名教师。而这个小女孩，叫冯孔玲。刚才那狗，明显是冲着小女孩去的。冯孔和翁玲明显疏忽了。只见那狗一个纵身飞跃，咬着小女孩的大腿不放。这可得了，冯孔先是一愣，眼眉一紧，使出吃奶力气撩开那狗。可是那狗也是凶残，一个转身，又一个飞跃，獠牙再现，冯孔也中招了。在医院，翁玲余惊未去。要不是刚才在路上恰巧有消防队路过，恐怕今天是在劫难逃。翁玲陷入了深深的沉思，想起了7年前发生的事情。</p>
<p>时光回到十年前。</p>
<p>那时候冯孔还在上大学，而翁玲刚考上大学。翁玲认识冯孔是汉语言学院的迎新晚会上。在那时候发生了很多事，翁玲和冯孔能够走到一起，很多事情就显得不可思议。往事历历在目，宛如昨日。那时候的天还很蓝，水也比较清澈。人们都过着自认为比较舒服的日子。翁玲是独生女，从小比较娇惯些。如果能够回到十年前，翁玲恐怕做梦都想改变这一切吧！可是如果改变这一切，可能她就再也见不到她的先生了。也许生活就是这么安排的，让人苦笑不得。回到迎新晚回上，翁玲是女子舞蹈团体的领队，那时候在男生多，女生少的学校，不知道有多少人在追求着翁玲。为了这一场迎新晚回的表演，翁玲已经连续排练了一个多月。队里的一个女生，叫秦岚。是河南驻马店的一个小村庄，能够得到这个机会，一方面是翁琳的帮助，一方面是自己确实热爱舞蹈。没有人知道为什么这次晚回为什么学校这么看重，按照以前的规矩，提取一个星期排练就可以说是相当重视了。可是这一次不同，在老早的时候，就提取预知舞蹈队选拔，准备晚回演出。可以看出，这是晚回最重要的节目，没有之一。那个时候能当上舞蹈队队长，与翁琳队爸爸不无关系，论实际能力，队里大三的魏若筠才是不二人选。说起翁玲的老爸，是这学校的教学主任，当初选拔队长的时候，魏若筠可是持主流声音。毕竟在队里是最有资历的，也是最有实力的。而且在社团的历史上，还没有出现大一就当选队长团长这样的先例。为什么翁玲在大一的时候就能够当选舞蹈队的队长呢？其实说来也是巧，当初在竞选的时候，由于都知道魏若筠会当选，所有基本上没有人去竞选，因为大家打从心底里佩服魏若筠。舞蹈队的事情她可是无论细巨，都很上心很负责。所以，最后竞选的名单只有翁琳和魏若筠。为什么翁玲会去竞选这个舞蹈队的队长呢？这个说来也巧。在她刚入学的那一天，各大社团都有迎接新生的活动，因为翁玲的爸爸是这个学校的教学主任，所以对这个学校的一切，一切貌似都了如指掌。当初会报名舞蹈队，完全是她老爸的安排。管社团的团委老师与翁玲老爸是校友，所以就算翁玲没有报名加入舞蹈队，她也是队里的一名队员了。翁玲是十分不愿意被安排的，从小到大，都是这样，每一次父母都没有征询过自己的意见，每一次都像个乖乖女。</p>
<p>正所谓初生牛犊不怕虎，</p>
<p>“您好，请问事13号病人的家属吗？”一旁的护士小姐端着记录板，轻声细语般：“请跟我到这边来办理相关手续，谢谢！”。翁玲收回思绪，赶紧随着护士去处理相关事宜。</p>
]]></content>
      
        
        <tags>
            
            <tag> sad story </tag>
            
            <tag> updating </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
